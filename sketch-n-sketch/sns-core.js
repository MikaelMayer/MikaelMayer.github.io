if(typeof document === "undefined" || document === null)
  document = {}; // So that the evaluation of sns.js does not throw exceptions.
if(typeof location === "undefined" || location === null)
  location = { hash : ""}; // so that the evaluation does not throw exceptions.


(function() {
'use strict';

function F2(fun)
{
  function wrapper(a) { return function(b) { return fun(a,b); }; }
  wrapper.arity = 2;
  wrapper.func = fun;
  return wrapper;
}

function F3(fun)
{
  function wrapper(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  }
  wrapper.arity = 3;
  wrapper.func = fun;
  return wrapper;
}

function F4(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  }
  wrapper.arity = 4;
  wrapper.func = fun;
  return wrapper;
}

function F5(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  }
  wrapper.arity = 5;
  wrapper.func = fun;
  return wrapper;
}

function F6(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  }
  wrapper.arity = 6;
  wrapper.func = fun;
  return wrapper;
}

function F7(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  }
  wrapper.arity = 7;
  wrapper.func = fun;
  return wrapper;
}

function F8(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  }
  wrapper.arity = 8;
  wrapper.func = fun;
  return wrapper;
}

function F9(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  }
  wrapper.arity = 9;
  wrapper.func = fun;
  return wrapper;
}

function A2(fun, a, b)
{
  return fun.arity === 2
    ? fun.func(a, b)
    : fun(a)(b);
}
function A3(fun, a, b, c)
{
  return fun.arity === 3
    ? fun.func(a, b, c)
    : fun(a)(b)(c);
}
function A4(fun, a, b, c, d)
{
  return fun.arity === 4
    ? fun.func(a, b, c, d)
    : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e)
{
  return fun.arity === 5
    ? fun.func(a, b, c, d, e)
    : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f)
{
  return fun.arity === 6
    ? fun.func(a, b, c, d, e, f)
    : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g)
{
  return fun.arity === 7
    ? fun.func(a, b, c, d, e, f, g)
    : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h)
{
  return fun.arity === 8
    ? fun.func(a, b, c, d, e, f, g, h)
    : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i)
{
  return fun.arity === 9
    ? fun.func(a, b, c, d, e, f, g, h, i)
    : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}

//import Native.Utils //

var _elm_lang$core$Native_Char = function() {

return {
	fromCode: function(c) { return _elm_lang$core$Native_Utils.chr(String.fromCharCode(c)); },
	toCode: function(c) { return c.charCodeAt(0); },
	toUpper: function(c) { return _elm_lang$core$Native_Utils.chr(c.toUpperCase()); },
	toLower: function(c) { return _elm_lang$core$Native_Utils.chr(c.toLowerCase()); },
	toLocaleUpper: function(c) { return _elm_lang$core$Native_Utils.chr(c.toLocaleUpperCase()); },
	toLocaleLower: function(c) { return _elm_lang$core$Native_Utils.chr(c.toLocaleLowerCase()); }
};

}();
//import Native.Utils //

var _elm_lang$core$Native_Basics = function() {

function div(a, b)
{
	return (a / b) | 0;
}
function rem(a, b)
{
	return a % b;
}
function mod(a, b)
{
	if (b === 0)
	{
		throw new Error('Cannot perform mod 0. Division by zero error.');
	}
	var r = a % b;
	var m = a === 0 ? 0 : (b > 0 ? (a >= 0 ? r : r + b) : -mod(-a, -b));

	return m === b ? 0 : m;
}
function logBase(base, n)
{
	return Math.log(n) / Math.log(base);
}
function negate(n)
{
	return -n;
}
function abs(n)
{
	return n < 0 ? -n : n;
}

function min(a, b)
{
	return _elm_lang$core$Native_Utils.cmp(a, b) < 0 ? a : b;
}
function max(a, b)
{
	return _elm_lang$core$Native_Utils.cmp(a, b) > 0 ? a : b;
}
function clamp(lo, hi, n)
{
	return _elm_lang$core$Native_Utils.cmp(n, lo) < 0
		? lo
		: _elm_lang$core$Native_Utils.cmp(n, hi) > 0
			? hi
			: n;
}

var ord = ['LT', 'EQ', 'GT'];

function compare(x, y)
{
	return { ctor: ord[_elm_lang$core$Native_Utils.cmp(x, y) + 1] };
}

function xor(a, b)
{
	return a !== b;
}
function not(b)
{
	return !b;
}
function isInfinite(n)
{
	return n === Infinity || n === -Infinity;
}

function truncate(n)
{
	return n | 0;
}

function degrees(d)
{
	return d * Math.PI / 180;
}
function turns(t)
{
	return 2 * Math.PI * t;
}
function fromPolar(point)
{
	var r = point._0;
	var t = point._1;
	return _elm_lang$core$Native_Utils.Tuple2(r * Math.cos(t), r * Math.sin(t));
}
function toPolar(point)
{
	var x = point._0;
	var y = point._1;
	return _elm_lang$core$Native_Utils.Tuple2(Math.sqrt(x * x + y * y), Math.atan2(y, x));
}

return {
	div: F2(div),
	rem: F2(rem),
	mod: F2(mod),

	pi: Math.PI,
	e: Math.E,
	cos: Math.cos,
	sin: Math.sin,
	tan: Math.tan,
	acos: Math.acos,
	asin: Math.asin,
	atan: Math.atan,
	atan2: F2(Math.atan2),

	degrees: degrees,
	turns: turns,
	fromPolar: fromPolar,
	toPolar: toPolar,

	sqrt: Math.sqrt,
	logBase: F2(logBase),
	negate: negate,
	abs: abs,
	min: F2(min),
	max: F2(max),
	clamp: F3(clamp),
	compare: F2(compare),

	xor: F2(xor),
	not: not,

	truncate: truncate,
	ceiling: Math.ceil,
	floor: Math.floor,
	round: Math.round,
	toFloat: function(x) { return x; },
	isNaN: isNaN,
	isInfinite: isInfinite
};

}();
//import //

var _elm_lang$core$Native_Utils = function() {

// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
// the particular integer values assigned to LT, EQ, and GT.

var LT = -1, EQ = 0, GT = 1;

function cmp(x, y)
{
	return cmp_(x, y, []);
}

function eq(x, y)
{
	return cmp_(x, y, []) === EQ;
}

// Guaranteed to terminate if object graph we are traversiving is finite.
// Proof: number of [x,y] pairs is therefore finite so eventually we will
// hit a pair we've seen before and terminate.
function cmp_(x, y, priorPairs)
{
	if (x === y)
	{
		return EQ;
	}

	// This avoids looping forever if someone hacked cycles into the object graph.
	// If we get the same x,y as before, that means we will loop for ever.
	// Return EQ --- they are equal as far as this branch of comparison is concerned.
	for (var i in priorPairs)
	{
		if (x === priorPairs[i][0] && y === priorPairs[i][1])
		{
			return EQ;
		}
	}
	var seenPairs = priorPairs.concat([[x, y]]);

	var type = typeof x;

	if (type !== 'object' && type !== 'function')
	{
		return x < y ? LT : GT;
	}

	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? EQ : a < b ? LT : GT;
	}

	if (type === 'function') {
		throw new Error(
			'Comparison error: There is no way to compare functions. '
			+ 'Comparison is only defined on ints, '
			+ 'floats, times, chars, strings, lists of comparable values, '
			+ 'and tuples of comparable values.'
		);
	}

	// Only Javascript objects past this point.

	if ('ctor' in x && typeof x.ctor === 'string')
	{
		if (x.ctor === '::' || x.ctor === '[]')
		{
			while (x.ctor === '::' && y.ctor === '::')
			{
				var ord = cmp_(x._0, y._0, seenPairs);
				if (ord !== EQ)
				{
					return ord;
				}
				x = x._1;
				y = y._1;
			}
			return x.ctor === y.ctor ? EQ : x.ctor === '[]' ? LT : GT;
		}

		if (x.ctor.slice(0, 6) === '_Tuple')
		{
			var ord;
			var n = x.ctor.slice(6) - 0;
			var err = 'cannot compare tuples with more than 16 elements.';
			if (n === 0) return EQ;
			if (n >= 1)  { ord = cmp_(x._0,  y._0,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 2)  { ord = cmp_(x._1,  y._1,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 3)  { ord = cmp_(x._2,  y._2,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 4)  { ord = cmp_(x._3,  y._3,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 5)  { ord = cmp_(x._4,  y._4,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 6)  { ord = cmp_(x._5,  y._5,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 7)  { ord = cmp_(x._6,  y._6,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 8)  { ord = cmp_(x._7,  y._7,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 9)  { ord = cmp_(x._8,  y._8,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 10) { ord = cmp_(x._9,  y._9,  seenPairs); if (ord !== EQ) return ord;
			if (n >= 11) { ord = cmp_(x._10, y._10, seenPairs); if (ord !== EQ) return ord;
			if (n >= 12) { ord = cmp_(x._11, y._11, seenPairs); if (ord !== EQ) return ord;
			if (n >= 13) { ord = cmp_(x._12, y._12, seenPairs); if (ord !== EQ) return ord;
			if (n >= 14) { ord = cmp_(x._13, y._13, seenPairs); if (ord !== EQ) return ord;
			if (n >= 15) { ord = cmp_(x._14, y._14, seenPairs); if (ord !== EQ) return ord;
			if (n >= 16) { ord = cmp_(x._15, y._15, seenPairs); if (ord !== EQ) return ord;
			if (n >= 17) throw new Error('Comparison error: ' + err); } } } } } } } } } } } } } } } }
			return EQ;
		}

		// Non-comparable types below, for use in sets and as dictionary keys.
		//
		// Type checker prevents these being used with < > <= >=.

		// convert Dicts and Sets to lists
		if (x.ctor === 'RBNode_elm_builtin' || x.ctor === 'RBEmpty_elm_builtin')
		{
			x = _elm_lang$core$Dict$toList(x);
			y = _elm_lang$core$Dict$toList(y);

			return cmp_(x, y, seenPairs);
		}
		if (x.ctor === 'Set_elm_builtin')
		{
			x = _elm_lang$core$Set$toList(x);
			y = _elm_lang$core$Set$toList(y);

			return cmp_(x, y, seenPairs);
		}

		// Other ADTs
		if (x.ctor < y.ctor) { return LT; }
		if (x.ctor > y.ctor) { return GT; }

		// If you made a record with a string ctor field, you will use
		// these comparison semenantics which don't sort they keys as
		// happens in regular record comparison. Just don't make
		// records with a "ctor " field.
		var ord;
		for (var i in x)
		{
			if (i === 'ctor') continue;

			ord = cmp_(x[i], y[i], seenPairs);

			if (ord !== EQ) { return ord; }
		}

		return EQ;
	}

	if (x instanceof Date)
	{
		var xt = x.getTime();
		var yt = y.getTime();
		return xt === yt ? EQ : xt < yt ? LT : GT;
	}

	if (x === null || x.elm_web_socket)
	{
		throw new Error(
			'Comparison error: comparison is only defined on ints, '
			+ 'floats, times, chars, strings, lists of comparable values, '
			+ 'and tuples of comparable values.'
		);
	}

	// Two records.
	var keys = Object.keys(x).sort();

	for (var i in keys)
	{
		var k = keys[i];
		ord = cmp_(x[k], y[k], seenPairs);

		if (ord !== EQ) { return ord; }
	}

	return EQ;
}


// COMMON VALUES

var Tuple0 = {
	ctor: '_Tuple0'
};

function Tuple2(x, y)
{
	return {
		ctor: '_Tuple2',
		_0: x,
		_1: y
	};
}

function chr(c)
{
	return new String(c);
}


// GUID

var count = 0;
function guid(_)
{
	return count++;
}


// RECORDS

function update(oldRecord, updatedFields)
{
	var newRecord = {};

	for (var key in oldRecord)
	{
		newRecord[key] = oldRecord[key];
	}

	for (var key in updatedFields)
	{
		newRecord[key] = updatedFields[key];
	}

	return newRecord;
}


//// LIST STUFF ////

var Nil = { ctor: '[]' };

function Cons(hd, tl)
{
	return {
		ctor: '::',
		_0: hd,
		_1: tl
	};
}

function append(xs, ys)
{
	// append Strings
	if (typeof xs === 'string')
	{
		return xs + ys;
	}

	// append Lists
	if (xs.ctor === '[]')
	{
		return ys;
	}
	var root = Cons(xs._0, Nil);
	var curr = root;
	xs = xs._1;
	while (xs.ctor !== '[]')
	{
		curr._1 = Cons(xs._0, Nil);
		xs = xs._1;
		curr = curr._1;
	}
	curr._1 = ys;
	return root;
}


// CRASHES

function crash(moduleName, region)
{
	return function(message) {
		throw new Error(
			'Ran into a `Debug.crash` in module `' + moduleName + '` ' + regionToString(region) + '\n'
			+ 'The message provided by the code author is:\n\n    '
			+ message
		);
	};
}

function crashCase(moduleName, region, value)
{
	return function(message) {
		throw new Error(
			'Ran into a `Debug.crash` in module `' + moduleName + '`\n\n'
			+ 'This was caused by the `case` expression ' + regionToString(region) + '.\n'
			+ 'One of the branches ended with a crash and the following value got through:\n\n    ' + toString(value) + '\n\n'
			+ 'The message provided by the code author is:\n\n    '
			+ message
		);
	};
}

function regionToString(region)
{
	if (region.start.line == region.end.line)
	{
		return 'on line ' + region.start.line;
	}
	return 'between lines ' + region.start.line + ' and ' + region.end.line;
}


// TO STRING

function toString(v)
{
  return toString_(v, 7);
}

function toString_(v, maxDepth)
{
  if (maxDepth <= 0)
  {
    return 'â€¦';
  } else {
    maxDepth -= 1;
  }

	var type = typeof v;
	if (type === 'function')
	{
		return '<function>';
	}

	if (type === 'boolean')
	{
		return v ? 'True' : 'False';
	}

	if (type === 'number')
	{
		return v + '';
	}

	if (v instanceof String)
	{
		return '\'' + addSlashes(v, true) + '\'';
	}

	if (type === 'string')
	{
		return '"' + addSlashes(v, false) + '"';
	}

	if (v === null)
	{
		return 'null';
	}

	if (type === 'object' && 'ctor' in v)
	{
		var ctorStarter = v.ctor.substring(0, 5);

		if (ctorStarter === '_Tupl')
		{
			var output = [];
			for (var k in v)
			{
				if (k === 'ctor') continue;
				output.push(toString_(v[k], maxDepth));
			}
			return '(' + output.join(',') + ')';
		}

		if (ctorStarter === '_Task')
		{
			return '<task>'
		}

		if (v.ctor === '_Array')
		{
			var list = _elm_lang$core$Array$toList(v);
			return 'Array.fromList ' + toString_(list, maxDepth);
		}

		if (v.ctor === '<decoder>')
		{
			return '<decoder>';
		}

		if (v.ctor === '_Process')
		{
			return '<process:' + v.id + '>';
		}

		if (v.ctor === '::')
		{
			var output = '[' + toString_(v._0, maxDepth);
			v = v._1;
			while (v.ctor === '::')
			{
				output += ',' + toString_(v._0, maxDepth);
				v = v._1;
			}
			return output + ']';
		}

		if (v.ctor === '[]')
		{
			return '[]';
		}

		if (v.ctor === 'Set_elm_builtin')
		{
			return 'Set.fromList ' + toString_(_elm_lang$core$Set$toList(v), maxDepth);
		}

		if (v.ctor === 'RBNode_elm_builtin' || v.ctor === 'RBEmpty_elm_builtin')
		{
			return 'Dict.fromList ' + toString_(_elm_lang$core$Dict$toList(v), maxDepth);
		}

		var output = '';
		for (var i in v)
		{
			if (i === 'ctor') continue;
			var str = toString_(v[i], maxDepth);
			var c0 = str[0];
			var parenless = c0 === '{' || c0 === '(' || c0 === '<' || c0 === '"' || str.indexOf(' ') < 0;
			output += ' ' + (parenless ? str : '(' + str + ')');
		}
		return v.ctor + output;
	}

	if (type === 'object')
	{
		if (v instanceof Date)
		{
			return '<' + v.toString() + '>';
		}

		if (v.elm_web_socket)
		{
			return '<websocket>';
		}

		var output = [];
		var keys = Object.keys(v).sort();

		for (var i in keys)
		{
			var k = keys[i];
			output.push(k + ' = ' + toString_(v[k], maxDepth));
		}
		if (output.length === 0)
		{
			return '{}';
		}
		return '{ ' + output.join(', ') + ' }';
	}

	return '<internal structure>';
}

function addSlashes(str, isChar)
{
	var s = str.replace(/\\/g, '\\\\')
			  .replace(/\n/g, '\\n')
			  .replace(/\t/g, '\\t')
			  .replace(/\r/g, '\\r')
			  .replace(/\v/g, '\\v')
			  .replace(/\0/g, '\\0');
	if (isChar)
	{
		return s.replace(/\'/g, '\\\'');
	}
	else
	{
		return s.replace(/\"/g, '\\"');
	}
}


return {
	eq: eq,
	cmp: cmp,
	Tuple0: Tuple0,
	Tuple2: Tuple2,
	chr: chr,
	update: update,
	guid: guid,

	append: F2(append),

	crash: crash,
	crashCase: crashCase,

	toString: toString
};

}();
var _elm_lang$core$Basics$never = function (_p0) {
	never:
	while (true) {
		var _p1 = _p0;
		var _v1 = _p1._0;
		_p0 = _v1;
		continue never;
	}
};
var _elm_lang$core$Basics$uncurry = F2(
	function (f, _p2) {
		var _p3 = _p2;
		return A2(f, _p3._0, _p3._1);
	});
var _elm_lang$core$Basics$curry = F3(
	function (f, a, b) {
		return f(
			{ctor: '_Tuple2', _0: a, _1: b});
	});
var _elm_lang$core$Basics$flip = F3(
	function (f, b, a) {
		return A2(f, a, b);
	});
var _elm_lang$core$Basics$always = F2(
	function (a, _p4) {
		return a;
	});
var _elm_lang$core$Basics$identity = function (x) {
	return x;
};
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<|'] = F2(
	function (f, x) {
		return f(x);
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['|>'] = F2(
	function (x, f) {
		return f(x);
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>>'] = F3(
	function (f, g, x) {
		return g(
			f(x));
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<<'] = F3(
	function (g, f, x) {
		return g(
			f(x));
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['++'] = _elm_lang$core$Native_Utils.append;
var _elm_lang$core$Basics$toString = _elm_lang$core$Native_Utils.toString;
var _elm_lang$core$Basics$isInfinite = _elm_lang$core$Native_Basics.isInfinite;
var _elm_lang$core$Basics$isNaN = _elm_lang$core$Native_Basics.isNaN;
var _elm_lang$core$Basics$toFloat = _elm_lang$core$Native_Basics.toFloat;
var _elm_lang$core$Basics$ceiling = _elm_lang$core$Native_Basics.ceiling;
var _elm_lang$core$Basics$floor = _elm_lang$core$Native_Basics.floor;
var _elm_lang$core$Basics$truncate = _elm_lang$core$Native_Basics.truncate;
var _elm_lang$core$Basics$round = _elm_lang$core$Native_Basics.round;
var _elm_lang$core$Basics$not = _elm_lang$core$Native_Basics.not;
var _elm_lang$core$Basics$xor = _elm_lang$core$Native_Basics.xor;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['||'] = _elm_lang$core$Native_Basics.or;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['&&'] = _elm_lang$core$Native_Basics.and;
var _elm_lang$core$Basics$max = _elm_lang$core$Native_Basics.max;
var _elm_lang$core$Basics$min = _elm_lang$core$Native_Basics.min;
var _elm_lang$core$Basics$compare = _elm_lang$core$Native_Basics.compare;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>='] = _elm_lang$core$Native_Basics.ge;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<='] = _elm_lang$core$Native_Basics.le;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>'] = _elm_lang$core$Native_Basics.gt;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<'] = _elm_lang$core$Native_Basics.lt;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['/='] = _elm_lang$core$Native_Basics.neq;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['=='] = _elm_lang$core$Native_Basics.eq;
var _elm_lang$core$Basics$e = _elm_lang$core$Native_Basics.e;
var _elm_lang$core$Basics$pi = _elm_lang$core$Native_Basics.pi;
var _elm_lang$core$Basics$clamp = _elm_lang$core$Native_Basics.clamp;
var _elm_lang$core$Basics$logBase = _elm_lang$core$Native_Basics.logBase;
var _elm_lang$core$Basics$abs = _elm_lang$core$Native_Basics.abs;
var _elm_lang$core$Basics$negate = _elm_lang$core$Native_Basics.negate;
var _elm_lang$core$Basics$sqrt = _elm_lang$core$Native_Basics.sqrt;
var _elm_lang$core$Basics$atan2 = _elm_lang$core$Native_Basics.atan2;
var _elm_lang$core$Basics$atan = _elm_lang$core$Native_Basics.atan;
var _elm_lang$core$Basics$asin = _elm_lang$core$Native_Basics.asin;
var _elm_lang$core$Basics$acos = _elm_lang$core$Native_Basics.acos;
var _elm_lang$core$Basics$tan = _elm_lang$core$Native_Basics.tan;
var _elm_lang$core$Basics$sin = _elm_lang$core$Native_Basics.sin;
var _elm_lang$core$Basics$cos = _elm_lang$core$Native_Basics.cos;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['^'] = _elm_lang$core$Native_Basics.exp;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['%'] = _elm_lang$core$Native_Basics.mod;
var _elm_lang$core$Basics$rem = _elm_lang$core$Native_Basics.rem;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['//'] = _elm_lang$core$Native_Basics.div;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['/'] = _elm_lang$core$Native_Basics.floatDiv;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['*'] = _elm_lang$core$Native_Basics.mul;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['-'] = _elm_lang$core$Native_Basics.sub;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['+'] = _elm_lang$core$Native_Basics.add;
var _elm_lang$core$Basics$toPolar = _elm_lang$core$Native_Basics.toPolar;
var _elm_lang$core$Basics$fromPolar = _elm_lang$core$Native_Basics.fromPolar;
var _elm_lang$core$Basics$turns = _elm_lang$core$Native_Basics.turns;
var _elm_lang$core$Basics$degrees = _elm_lang$core$Native_Basics.degrees;
var _elm_lang$core$Basics$radians = function (t) {
	return t;
};
var _elm_lang$core$Basics$GT = {ctor: 'GT'};
var _elm_lang$core$Basics$EQ = {ctor: 'EQ'};
var _elm_lang$core$Basics$LT = {ctor: 'LT'};
var _elm_lang$core$Basics$JustOneMore = function (a) {
	return {ctor: 'JustOneMore', _0: a};
};

var _elm_lang$core$Char$fromCode = _elm_lang$core$Native_Char.fromCode;
var _elm_lang$core$Char$toCode = _elm_lang$core$Native_Char.toCode;
var _elm_lang$core$Char$toLocaleLower = _elm_lang$core$Native_Char.toLocaleLower;
var _elm_lang$core$Char$toLocaleUpper = _elm_lang$core$Native_Char.toLocaleUpper;
var _elm_lang$core$Char$toLower = _elm_lang$core$Native_Char.toLower;
var _elm_lang$core$Char$toUpper = _elm_lang$core$Native_Char.toUpper;
var _elm_lang$core$Char$isBetween = F3(
	function (low, high, $char) {
		var code = _elm_lang$core$Char$toCode($char);
		return (_elm_lang$core$Native_Utils.cmp(
			code,
			_elm_lang$core$Char$toCode(low)) > -1) && (_elm_lang$core$Native_Utils.cmp(
			code,
			_elm_lang$core$Char$toCode(high)) < 1);
	});
var _elm_lang$core$Char$isUpper = A2(
	_elm_lang$core$Char$isBetween,
	_elm_lang$core$Native_Utils.chr('A'),
	_elm_lang$core$Native_Utils.chr('Z'));
var _elm_lang$core$Char$isLower = A2(
	_elm_lang$core$Char$isBetween,
	_elm_lang$core$Native_Utils.chr('a'),
	_elm_lang$core$Native_Utils.chr('z'));
var _elm_lang$core$Char$isDigit = A2(
	_elm_lang$core$Char$isBetween,
	_elm_lang$core$Native_Utils.chr('0'),
	_elm_lang$core$Native_Utils.chr('9'));
var _elm_lang$core$Char$isOctDigit = A2(
	_elm_lang$core$Char$isBetween,
	_elm_lang$core$Native_Utils.chr('0'),
	_elm_lang$core$Native_Utils.chr('7'));
var _elm_lang$core$Char$isHexDigit = function ($char) {
	return _elm_lang$core$Char$isDigit($char) || (A3(
		_elm_lang$core$Char$isBetween,
		_elm_lang$core$Native_Utils.chr('a'),
		_elm_lang$core$Native_Utils.chr('f'),
		$char) || A3(
		_elm_lang$core$Char$isBetween,
		_elm_lang$core$Native_Utils.chr('A'),
		_elm_lang$core$Native_Utils.chr('F'),
		$char));
};

var _elm_tools$parser_primitives$Native_ParserPrimitives = function() {


// STRINGS

function isSubString(smallString, offset, row, col, bigString)
{
	var smallLength = smallString.length;
	var bigLength = bigString.length - offset;

	if (bigLength < smallLength)
	{
		return tuple3(-1, row, col);
	}

	for (var i = 0; i < smallLength; i++)
	{
		var char = smallString[i];

		if (char !== bigString[offset + i])
		{
			return tuple3(-1, row, col);
		}

		// if it is a two word character
		if ((bigString.charCodeAt(offset) & 0xF800) === 0xD800)
		{
			i++
			if (smallString[i] !== bigString[offset + i])
			{
				return tuple3(-1, row, col);
			}
			col++;
			continue;
		}

		// if it is a newline
		if (char === '\n')
		{
			row++;
			col = 1;
			continue;
		}

		// if it is a one word character
		col++
	}

	return tuple3(offset + smallLength, row, col);
}

function tuple3(a, b, c)
{
	return { ctor: '_Tuple3', _0: a, _1: b, _2: c };
}


// CHARS

var mkChar = _elm_lang$core$Native_Utils.chr;

function isSubChar(predicate, offset, string)
{
	if (offset >= string.length)
	{
		return -1;
	}

	if ((string.charCodeAt(offset) & 0xF800) === 0xD800)
	{
		return predicate(mkChar(string.substr(offset, 2)))
			? offset + 2
			: -1;
	}

	var char = string[offset];

	return predicate(mkChar(char))
		? ((char === '\n') ? -2 : (offset + 1))
		: -1;
}


// FIND STRING

function findSubString(before, smallString, offset, row, col, bigString)
{
	var newOffset = bigString.indexOf(smallString, offset);

	if (newOffset === -1)
	{
		return tuple3(-1, row, col);
	}

	var scanTarget = before ? newOffset	: newOffset + smallString.length;

	while (offset < scanTarget)
	{
		var char = bigString[offset];

		if (char === '\n')
		{
			offset++;
			row++;
			col = 1;
			continue;
		}

		if ((bigString.charCodeAt(offset) & 0xF800) === 0xD800)
		{
			offset += 2;
			col++;
			continue;
		}

		offset++;
		col++;
	}

	return tuple3(offset, row, col);
}


return {
	isSubString: F5(isSubString),
	isSubChar: F3(isSubChar),
	findSubString: F6(findSubString)
};

}();

//import Native.Utils //

var _elm_lang$core$Native_Debug = function() {

function log(tag, value)
{
	var msg = tag + ': ' + _elm_lang$core$Native_Utils.toString(value);
	var process = process || {};
	if (process.stdout)
	{
		process.stdout.write(msg);
	}
	else
	{
		console.log(msg);
	}
	return value;
}

function crash(message)
{
	throw new Error(message);
}

return {
	crash: crash,
	log: F2(log)
};

}();
var _elm_lang$core$Debug$crash = _elm_lang$core$Native_Debug.crash;
var _elm_lang$core$Debug$log = _elm_lang$core$Native_Debug.log;

var _elm_lang$core$Maybe$withDefault = F2(
	function ($default, maybe) {
		var _p0 = maybe;
		if (_p0.ctor === 'Just') {
			return _p0._0;
		} else {
			return $default;
		}
	});
var _elm_lang$core$Maybe$Nothing = {ctor: 'Nothing'};
var _elm_lang$core$Maybe$andThen = F2(
	function (callback, maybeValue) {
		var _p1 = maybeValue;
		if (_p1.ctor === 'Just') {
			return callback(_p1._0);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$Just = function (a) {
	return {ctor: 'Just', _0: a};
};
var _elm_lang$core$Maybe$map = F2(
	function (f, maybe) {
		var _p2 = maybe;
		if (_p2.ctor === 'Just') {
			return _elm_lang$core$Maybe$Just(
				f(_p2._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map2 = F3(
	function (func, ma, mb) {
		var _p3 = {ctor: '_Tuple2', _0: ma, _1: mb};
		if (((_p3.ctor === '_Tuple2') && (_p3._0.ctor === 'Just')) && (_p3._1.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A2(func, _p3._0._0, _p3._1._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map3 = F4(
	function (func, ma, mb, mc) {
		var _p4 = {ctor: '_Tuple3', _0: ma, _1: mb, _2: mc};
		if ((((_p4.ctor === '_Tuple3') && (_p4._0.ctor === 'Just')) && (_p4._1.ctor === 'Just')) && (_p4._2.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A3(func, _p4._0._0, _p4._1._0, _p4._2._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map4 = F5(
	function (func, ma, mb, mc, md) {
		var _p5 = {ctor: '_Tuple4', _0: ma, _1: mb, _2: mc, _3: md};
		if (((((_p5.ctor === '_Tuple4') && (_p5._0.ctor === 'Just')) && (_p5._1.ctor === 'Just')) && (_p5._2.ctor === 'Just')) && (_p5._3.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A4(func, _p5._0._0, _p5._1._0, _p5._2._0, _p5._3._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map5 = F6(
	function (func, ma, mb, mc, md, me) {
		var _p6 = {ctor: '_Tuple5', _0: ma, _1: mb, _2: mc, _3: md, _4: me};
		if ((((((_p6.ctor === '_Tuple5') && (_p6._0.ctor === 'Just')) && (_p6._1.ctor === 'Just')) && (_p6._2.ctor === 'Just')) && (_p6._3.ctor === 'Just')) && (_p6._4.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A5(func, _p6._0._0, _p6._1._0, _p6._2._0, _p6._3._0, _p6._4._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});

//import Native.Utils //

var _elm_lang$core$Native_List = function() {

var Nil = { ctor: '[]' };

function Cons(hd, tl)
{
	return { ctor: '::', _0: hd, _1: tl };
}

function fromArray(arr)
{
	var out = Nil;
	for (var i = arr.length; i--; )
	{
		out = Cons(arr[i], out);
	}
	return out;
}

function toArray(xs)
{
	var out = [];
	while (xs.ctor !== '[]')
	{
		out.push(xs._0);
		xs = xs._1;
	}
	return out;
}

function foldr(f, b, xs)
{
	var arr = toArray(xs);
	var acc = b;
	for (var i = arr.length; i--; )
	{
		acc = A2(f, arr[i], acc);
	}
	return acc;
}

function map2(f, xs, ys)
{
	var arr = [];
	while (xs.ctor !== '[]' && ys.ctor !== '[]')
	{
		arr.push(A2(f, xs._0, ys._0));
		xs = xs._1;
		ys = ys._1;
	}
	return fromArray(arr);
}

function map3(f, xs, ys, zs)
{
	var arr = [];
	while (xs.ctor !== '[]' && ys.ctor !== '[]' && zs.ctor !== '[]')
	{
		arr.push(A3(f, xs._0, ys._0, zs._0));
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function map4(f, ws, xs, ys, zs)
{
	var arr = [];
	while (   ws.ctor !== '[]'
		   && xs.ctor !== '[]'
		   && ys.ctor !== '[]'
		   && zs.ctor !== '[]')
	{
		arr.push(A4(f, ws._0, xs._0, ys._0, zs._0));
		ws = ws._1;
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function map5(f, vs, ws, xs, ys, zs)
{
	var arr = [];
	while (   vs.ctor !== '[]'
		   && ws.ctor !== '[]'
		   && xs.ctor !== '[]'
		   && ys.ctor !== '[]'
		   && zs.ctor !== '[]')
	{
		arr.push(A5(f, vs._0, ws._0, xs._0, ys._0, zs._0));
		vs = vs._1;
		ws = ws._1;
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function sortBy(f, xs)
{
	return fromArray(toArray(xs).sort(function(a, b) {
		return _elm_lang$core$Native_Utils.cmp(f(a), f(b));
	}));
}

function sortWith(f, xs)
{
	return fromArray(toArray(xs).sort(function(a, b) {
		var ord = f(a)(b).ctor;
		return ord === 'EQ' ? 0 : ord === 'LT' ? -1 : 1;
	}));
}

return {
	Nil: Nil,
	Cons: Cons,
	cons: F2(Cons),
	toArray: toArray,
	fromArray: fromArray,

	foldr: F3(foldr),

	map2: F3(map2),
	map3: F4(map3),
	map4: F5(map4),
	map5: F6(map5),
	sortBy: F2(sortBy),
	sortWith: F2(sortWith)
};

}();
var _elm_lang$core$List$sortWith = _elm_lang$core$Native_List.sortWith;
var _elm_lang$core$List$sortBy = _elm_lang$core$Native_List.sortBy;
var _elm_lang$core$List$sort = function (xs) {
	return A2(_elm_lang$core$List$sortBy, _elm_lang$core$Basics$identity, xs);
};
var _elm_lang$core$List$singleton = function (value) {
	return {
		ctor: '::',
		_0: value,
		_1: {ctor: '[]'}
	};
};
var _elm_lang$core$List$drop = F2(
	function (n, list) {
		drop:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return list;
			} else {
				var _p0 = list;
				if (_p0.ctor === '[]') {
					return list;
				} else {
					var _v1 = n - 1,
						_v2 = _p0._1;
					n = _v1;
					list = _v2;
					continue drop;
				}
			}
		}
	});
var _elm_lang$core$List$map5 = _elm_lang$core$Native_List.map5;
var _elm_lang$core$List$map4 = _elm_lang$core$Native_List.map4;
var _elm_lang$core$List$map3 = _elm_lang$core$Native_List.map3;
var _elm_lang$core$List$map2 = _elm_lang$core$Native_List.map2;
var _elm_lang$core$List$any = F2(
	function (isOkay, list) {
		any:
		while (true) {
			var _p1 = list;
			if (_p1.ctor === '[]') {
				return false;
			} else {
				if (isOkay(_p1._0)) {
					return true;
				} else {
					var _v4 = isOkay,
						_v5 = _p1._1;
					isOkay = _v4;
					list = _v5;
					continue any;
				}
			}
		}
	});
var _elm_lang$core$List$all = F2(
	function (isOkay, list) {
		return !A2(
			_elm_lang$core$List$any,
			function (_p2) {
				return !isOkay(_p2);
			},
			list);
	});
var _elm_lang$core$List$foldr = _elm_lang$core$Native_List.foldr;
var _elm_lang$core$List$foldl = F3(
	function (func, acc, list) {
		foldl:
		while (true) {
			var _p3 = list;
			if (_p3.ctor === '[]') {
				return acc;
			} else {
				var _v7 = func,
					_v8 = A2(func, _p3._0, acc),
					_v9 = _p3._1;
				func = _v7;
				acc = _v8;
				list = _v9;
				continue foldl;
			}
		}
	});
var _elm_lang$core$List$length = function (xs) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (_p4, i) {
				return i + 1;
			}),
		0,
		xs);
};
var _elm_lang$core$List$sum = function (numbers) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return x + y;
			}),
		0,
		numbers);
};
var _elm_lang$core$List$product = function (numbers) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return x * y;
			}),
		1,
		numbers);
};
var _elm_lang$core$List$maximum = function (list) {
	var _p5 = list;
	if (_p5.ctor === '::') {
		return _elm_lang$core$Maybe$Just(
			A3(_elm_lang$core$List$foldl, _elm_lang$core$Basics$max, _p5._0, _p5._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$minimum = function (list) {
	var _p6 = list;
	if (_p6.ctor === '::') {
		return _elm_lang$core$Maybe$Just(
			A3(_elm_lang$core$List$foldl, _elm_lang$core$Basics$min, _p6._0, _p6._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$member = F2(
	function (x, xs) {
		return A2(
			_elm_lang$core$List$any,
			function (a) {
				return _elm_lang$core$Native_Utils.eq(a, x);
			},
			xs);
	});
var _elm_lang$core$List$isEmpty = function (xs) {
	var _p7 = xs;
	if (_p7.ctor === '[]') {
		return true;
	} else {
		return false;
	}
};
var _elm_lang$core$List$tail = function (list) {
	var _p8 = list;
	if (_p8.ctor === '::') {
		return _elm_lang$core$Maybe$Just(_p8._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$head = function (list) {
	var _p9 = list;
	if (_p9.ctor === '::') {
		return _elm_lang$core$Maybe$Just(_p9._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List_ops = _elm_lang$core$List_ops || {};
_elm_lang$core$List_ops['::'] = _elm_lang$core$Native_List.cons;
var _elm_lang$core$List$map = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$foldr,
			F2(
				function (x, acc) {
					return {
						ctor: '::',
						_0: f(x),
						_1: acc
					};
				}),
			{ctor: '[]'},
			xs);
	});
var _elm_lang$core$List$filter = F2(
	function (pred, xs) {
		var conditionalCons = F2(
			function (front, back) {
				return pred(front) ? {ctor: '::', _0: front, _1: back} : back;
			});
		return A3(
			_elm_lang$core$List$foldr,
			conditionalCons,
			{ctor: '[]'},
			xs);
	});
var _elm_lang$core$List$maybeCons = F3(
	function (f, mx, xs) {
		var _p10 = f(mx);
		if (_p10.ctor === 'Just') {
			return {ctor: '::', _0: _p10._0, _1: xs};
		} else {
			return xs;
		}
	});
var _elm_lang$core$List$filterMap = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$foldr,
			_elm_lang$core$List$maybeCons(f),
			{ctor: '[]'},
			xs);
	});
var _elm_lang$core$List$reverse = function (list) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return {ctor: '::', _0: x, _1: y};
			}),
		{ctor: '[]'},
		list);
};
var _elm_lang$core$List$scanl = F3(
	function (f, b, xs) {
		var scan1 = F2(
			function (x, accAcc) {
				var _p11 = accAcc;
				if (_p11.ctor === '::') {
					return {
						ctor: '::',
						_0: A2(f, x, _p11._0),
						_1: accAcc
					};
				} else {
					return {ctor: '[]'};
				}
			});
		return _elm_lang$core$List$reverse(
			A3(
				_elm_lang$core$List$foldl,
				scan1,
				{
					ctor: '::',
					_0: b,
					_1: {ctor: '[]'}
				},
				xs));
	});
var _elm_lang$core$List$append = F2(
	function (xs, ys) {
		var _p12 = ys;
		if (_p12.ctor === '[]') {
			return xs;
		} else {
			return A3(
				_elm_lang$core$List$foldr,
				F2(
					function (x, y) {
						return {ctor: '::', _0: x, _1: y};
					}),
				ys,
				xs);
		}
	});
var _elm_lang$core$List$concat = function (lists) {
	return A3(
		_elm_lang$core$List$foldr,
		_elm_lang$core$List$append,
		{ctor: '[]'},
		lists);
};
var _elm_lang$core$List$concatMap = F2(
	function (f, list) {
		return _elm_lang$core$List$concat(
			A2(_elm_lang$core$List$map, f, list));
	});
var _elm_lang$core$List$partition = F2(
	function (pred, list) {
		var step = F2(
			function (x, _p13) {
				var _p14 = _p13;
				var _p16 = _p14._0;
				var _p15 = _p14._1;
				return pred(x) ? {
					ctor: '_Tuple2',
					_0: {ctor: '::', _0: x, _1: _p16},
					_1: _p15
				} : {
					ctor: '_Tuple2',
					_0: _p16,
					_1: {ctor: '::', _0: x, _1: _p15}
				};
			});
		return A3(
			_elm_lang$core$List$foldr,
			step,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'}
			},
			list);
	});
var _elm_lang$core$List$unzip = function (pairs) {
	var step = F2(
		function (_p18, _p17) {
			var _p19 = _p18;
			var _p20 = _p17;
			return {
				ctor: '_Tuple2',
				_0: {ctor: '::', _0: _p19._0, _1: _p20._0},
				_1: {ctor: '::', _0: _p19._1, _1: _p20._1}
			};
		});
	return A3(
		_elm_lang$core$List$foldr,
		step,
		{
			ctor: '_Tuple2',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'}
		},
		pairs);
};
var _elm_lang$core$List$intersperse = F2(
	function (sep, xs) {
		var _p21 = xs;
		if (_p21.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var step = F2(
				function (x, rest) {
					return {
						ctor: '::',
						_0: sep,
						_1: {ctor: '::', _0: x, _1: rest}
					};
				});
			var spersed = A3(
				_elm_lang$core$List$foldr,
				step,
				{ctor: '[]'},
				_p21._1);
			return {ctor: '::', _0: _p21._0, _1: spersed};
		}
	});
var _elm_lang$core$List$takeReverse = F3(
	function (n, list, taken) {
		takeReverse:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return taken;
			} else {
				var _p22 = list;
				if (_p22.ctor === '[]') {
					return taken;
				} else {
					var _v23 = n - 1,
						_v24 = _p22._1,
						_v25 = {ctor: '::', _0: _p22._0, _1: taken};
					n = _v23;
					list = _v24;
					taken = _v25;
					continue takeReverse;
				}
			}
		}
	});
var _elm_lang$core$List$takeTailRec = F2(
	function (n, list) {
		return _elm_lang$core$List$reverse(
			A3(
				_elm_lang$core$List$takeReverse,
				n,
				list,
				{ctor: '[]'}));
	});
var _elm_lang$core$List$takeFast = F3(
	function (ctr, n, list) {
		if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
			return {ctor: '[]'};
		} else {
			var _p23 = {ctor: '_Tuple2', _0: n, _1: list};
			_v26_5:
			do {
				_v26_1:
				do {
					if (_p23.ctor === '_Tuple2') {
						if (_p23._1.ctor === '[]') {
							return list;
						} else {
							if (_p23._1._1.ctor === '::') {
								switch (_p23._0) {
									case 1:
										break _v26_1;
									case 2:
										return {
											ctor: '::',
											_0: _p23._1._0,
											_1: {
												ctor: '::',
												_0: _p23._1._1._0,
												_1: {ctor: '[]'}
											}
										};
									case 3:
										if (_p23._1._1._1.ctor === '::') {
											return {
												ctor: '::',
												_0: _p23._1._0,
												_1: {
													ctor: '::',
													_0: _p23._1._1._0,
													_1: {
														ctor: '::',
														_0: _p23._1._1._1._0,
														_1: {ctor: '[]'}
													}
												}
											};
										} else {
											break _v26_5;
										}
									default:
										if ((_p23._1._1._1.ctor === '::') && (_p23._1._1._1._1.ctor === '::')) {
											var _p28 = _p23._1._1._1._0;
											var _p27 = _p23._1._1._0;
											var _p26 = _p23._1._0;
											var _p25 = _p23._1._1._1._1._0;
											var _p24 = _p23._1._1._1._1._1;
											return (_elm_lang$core$Native_Utils.cmp(ctr, 1000) > 0) ? {
												ctor: '::',
												_0: _p26,
												_1: {
													ctor: '::',
													_0: _p27,
													_1: {
														ctor: '::',
														_0: _p28,
														_1: {
															ctor: '::',
															_0: _p25,
															_1: A2(_elm_lang$core$List$takeTailRec, n - 4, _p24)
														}
													}
												}
											} : {
												ctor: '::',
												_0: _p26,
												_1: {
													ctor: '::',
													_0: _p27,
													_1: {
														ctor: '::',
														_0: _p28,
														_1: {
															ctor: '::',
															_0: _p25,
															_1: A3(_elm_lang$core$List$takeFast, ctr + 1, n - 4, _p24)
														}
													}
												}
											};
										} else {
											break _v26_5;
										}
								}
							} else {
								if (_p23._0 === 1) {
									break _v26_1;
								} else {
									break _v26_5;
								}
							}
						}
					} else {
						break _v26_5;
					}
				} while(false);
				return {
					ctor: '::',
					_0: _p23._1._0,
					_1: {ctor: '[]'}
				};
			} while(false);
			return list;
		}
	});
var _elm_lang$core$List$take = F2(
	function (n, list) {
		return A3(_elm_lang$core$List$takeFast, 0, n, list);
	});
var _elm_lang$core$List$repeatHelp = F3(
	function (result, n, value) {
		repeatHelp:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return result;
			} else {
				var _v27 = {ctor: '::', _0: value, _1: result},
					_v28 = n - 1,
					_v29 = value;
				result = _v27;
				n = _v28;
				value = _v29;
				continue repeatHelp;
			}
		}
	});
var _elm_lang$core$List$repeat = F2(
	function (n, value) {
		return A3(
			_elm_lang$core$List$repeatHelp,
			{ctor: '[]'},
			n,
			value);
	});
var _elm_lang$core$List$rangeHelp = F3(
	function (lo, hi, list) {
		rangeHelp:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(lo, hi) < 1) {
				var _v30 = lo,
					_v31 = hi - 1,
					_v32 = {ctor: '::', _0: hi, _1: list};
				lo = _v30;
				hi = _v31;
				list = _v32;
				continue rangeHelp;
			} else {
				return list;
			}
		}
	});
var _elm_lang$core$List$range = F2(
	function (lo, hi) {
		return A3(
			_elm_lang$core$List$rangeHelp,
			lo,
			hi,
			{ctor: '[]'});
	});
var _elm_lang$core$List$indexedMap = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$map2,
			f,
			A2(
				_elm_lang$core$List$range,
				0,
				_elm_lang$core$List$length(xs) - 1),
			xs);
	});

var _elm_lang$core$Result$toMaybe = function (result) {
	var _p0 = result;
	if (_p0.ctor === 'Ok') {
		return _elm_lang$core$Maybe$Just(_p0._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$Result$withDefault = F2(
	function (def, result) {
		var _p1 = result;
		if (_p1.ctor === 'Ok') {
			return _p1._0;
		} else {
			return def;
		}
	});
var _elm_lang$core$Result$Err = function (a) {
	return {ctor: 'Err', _0: a};
};
var _elm_lang$core$Result$andThen = F2(
	function (callback, result) {
		var _p2 = result;
		if (_p2.ctor === 'Ok') {
			return callback(_p2._0);
		} else {
			return _elm_lang$core$Result$Err(_p2._0);
		}
	});
var _elm_lang$core$Result$Ok = function (a) {
	return {ctor: 'Ok', _0: a};
};
var _elm_lang$core$Result$map = F2(
	function (func, ra) {
		var _p3 = ra;
		if (_p3.ctor === 'Ok') {
			return _elm_lang$core$Result$Ok(
				func(_p3._0));
		} else {
			return _elm_lang$core$Result$Err(_p3._0);
		}
	});
var _elm_lang$core$Result$map2 = F3(
	function (func, ra, rb) {
		var _p4 = {ctor: '_Tuple2', _0: ra, _1: rb};
		if (_p4._0.ctor === 'Ok') {
			if (_p4._1.ctor === 'Ok') {
				return _elm_lang$core$Result$Ok(
					A2(func, _p4._0._0, _p4._1._0));
			} else {
				return _elm_lang$core$Result$Err(_p4._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p4._0._0);
		}
	});
var _elm_lang$core$Result$map3 = F4(
	function (func, ra, rb, rc) {
		var _p5 = {ctor: '_Tuple3', _0: ra, _1: rb, _2: rc};
		if (_p5._0.ctor === 'Ok') {
			if (_p5._1.ctor === 'Ok') {
				if (_p5._2.ctor === 'Ok') {
					return _elm_lang$core$Result$Ok(
						A3(func, _p5._0._0, _p5._1._0, _p5._2._0));
				} else {
					return _elm_lang$core$Result$Err(_p5._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p5._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p5._0._0);
		}
	});
var _elm_lang$core$Result$map4 = F5(
	function (func, ra, rb, rc, rd) {
		var _p6 = {ctor: '_Tuple4', _0: ra, _1: rb, _2: rc, _3: rd};
		if (_p6._0.ctor === 'Ok') {
			if (_p6._1.ctor === 'Ok') {
				if (_p6._2.ctor === 'Ok') {
					if (_p6._3.ctor === 'Ok') {
						return _elm_lang$core$Result$Ok(
							A4(func, _p6._0._0, _p6._1._0, _p6._2._0, _p6._3._0));
					} else {
						return _elm_lang$core$Result$Err(_p6._3._0);
					}
				} else {
					return _elm_lang$core$Result$Err(_p6._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p6._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p6._0._0);
		}
	});
var _elm_lang$core$Result$map5 = F6(
	function (func, ra, rb, rc, rd, re) {
		var _p7 = {ctor: '_Tuple5', _0: ra, _1: rb, _2: rc, _3: rd, _4: re};
		if (_p7._0.ctor === 'Ok') {
			if (_p7._1.ctor === 'Ok') {
				if (_p7._2.ctor === 'Ok') {
					if (_p7._3.ctor === 'Ok') {
						if (_p7._4.ctor === 'Ok') {
							return _elm_lang$core$Result$Ok(
								A5(func, _p7._0._0, _p7._1._0, _p7._2._0, _p7._3._0, _p7._4._0));
						} else {
							return _elm_lang$core$Result$Err(_p7._4._0);
						}
					} else {
						return _elm_lang$core$Result$Err(_p7._3._0);
					}
				} else {
					return _elm_lang$core$Result$Err(_p7._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p7._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p7._0._0);
		}
	});
var _elm_lang$core$Result$mapError = F2(
	function (f, result) {
		var _p8 = result;
		if (_p8.ctor === 'Ok') {
			return _elm_lang$core$Result$Ok(_p8._0);
		} else {
			return _elm_lang$core$Result$Err(
				f(_p8._0));
		}
	});
var _elm_lang$core$Result$fromMaybe = F2(
	function (err, maybe) {
		var _p9 = maybe;
		if (_p9.ctor === 'Just') {
			return _elm_lang$core$Result$Ok(_p9._0);
		} else {
			return _elm_lang$core$Result$Err(err);
		}
	});

//import Maybe, Native.List, Native.Utils, Result //

var _elm_lang$core$Native_String = function() {

function isEmpty(str)
{
	return str.length === 0;
}
function cons(chr, str)
{
	return chr + str;
}
function uncons(str)
{
	var hd = str[0];
	if (hd)
	{
		return _elm_lang$core$Maybe$Just(_elm_lang$core$Native_Utils.Tuple2(_elm_lang$core$Native_Utils.chr(hd), str.slice(1)));
	}
	return _elm_lang$core$Maybe$Nothing;
}
function append(a, b)
{
	return a + b;
}
function concat(strs)
{
	return _elm_lang$core$Native_List.toArray(strs).join('');
}
function length(str)
{
	return str.length;
}
function map(f, str)
{
	var out = str.split('');
	for (var i = out.length; i--; )
	{
		out[i] = f(_elm_lang$core$Native_Utils.chr(out[i]));
	}
	return out.join('');
}
function filter(pred, str)
{
	return str.split('').map(_elm_lang$core$Native_Utils.chr).filter(pred).join('');
}
function reverse(str)
{
	return str.split('').reverse().join('');
}
function foldl(f, b, str)
{
	var len = str.length;
	for (var i = 0; i < len; ++i)
	{
		b = A2(f, _elm_lang$core$Native_Utils.chr(str[i]), b);
	}
	return b;
}
function foldr(f, b, str)
{
	for (var i = str.length; i--; )
	{
		b = A2(f, _elm_lang$core$Native_Utils.chr(str[i]), b);
	}
	return b;
}
function split(sep, str)
{
	return _elm_lang$core$Native_List.fromArray(str.split(sep));
}
function join(sep, strs)
{
	return _elm_lang$core$Native_List.toArray(strs).join(sep);
}
function repeat(n, str)
{
	var result = '';
	while (n > 0)
	{
		if (n & 1)
		{
			result += str;
		}
		n >>= 1, str += str;
	}
	return result;
}
function slice(start, end, str)
{
	return str.slice(start, end);
}
function left(n, str)
{
	return n < 1 ? '' : str.slice(0, n);
}
function right(n, str)
{
	return n < 1 ? '' : str.slice(-n);
}
function dropLeft(n, str)
{
	return n < 1 ? str : str.slice(n);
}
function dropRight(n, str)
{
	return n < 1 ? str : str.slice(0, -n);
}
function pad(n, chr, str)
{
	var half = (n - str.length) / 2;
	return repeat(Math.ceil(half), chr) + str + repeat(half | 0, chr);
}
function padRight(n, chr, str)
{
	return str + repeat(n - str.length, chr);
}
function padLeft(n, chr, str)
{
	return repeat(n - str.length, chr) + str;
}

function trim(str)
{
	return str.trim();
}
function trimLeft(str)
{
	return str.replace(/^\s+/, '');
}
function trimRight(str)
{
	return str.replace(/\s+$/, '');
}

function words(str)
{
	return _elm_lang$core$Native_List.fromArray(str.trim().split(/\s+/g));
}
function lines(str)
{
	return _elm_lang$core$Native_List.fromArray(str.split(/\r\n|\r|\n/g));
}

function toUpper(str)
{
	return str.toUpperCase();
}
function toLower(str)
{
	return str.toLowerCase();
}

function any(pred, str)
{
	for (var i = str.length; i--; )
	{
		if (pred(_elm_lang$core$Native_Utils.chr(str[i])))
		{
			return true;
		}
	}
	return false;
}
function all(pred, str)
{
	for (var i = str.length; i--; )
	{
		if (!pred(_elm_lang$core$Native_Utils.chr(str[i])))
		{
			return false;
		}
	}
	return true;
}

function contains(sub, str)
{
	return str.indexOf(sub) > -1;
}
function startsWith(sub, str)
{
	return str.indexOf(sub) === 0;
}
function endsWith(sub, str)
{
	return str.length >= sub.length &&
		str.lastIndexOf(sub) === str.length - sub.length;
}
function indexes(sub, str)
{
	var subLen = sub.length;

	if (subLen < 1)
	{
		return _elm_lang$core$Native_List.Nil;
	}

	var i = 0;
	var is = [];

	while ((i = str.indexOf(sub, i)) > -1)
	{
		is.push(i);
		i = i + subLen;
	}

	return _elm_lang$core$Native_List.fromArray(is);
}


function toInt(s)
{
	var len = s.length;

	// if empty
	if (len === 0)
	{
		return intErr(s);
	}

	// if hex
	var c = s[0];
	if (c === '0' && s[1] === 'x')
	{
		for (var i = 2; i < len; ++i)
		{
			var c = s[i];
			if (('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f'))
			{
				continue;
			}
			return intErr(s);
		}
		return _elm_lang$core$Result$Ok(parseInt(s, 16));
	}

	// is decimal
	if (c > '9' || (c < '0' && c !== '-' && c !== '+'))
	{
		return intErr(s);
	}
	for (var i = 1; i < len; ++i)
	{
		var c = s[i];
		if (c < '0' || '9' < c)
		{
			return intErr(s);
		}
	}

	return _elm_lang$core$Result$Ok(parseInt(s, 10));
}

function intErr(s)
{
	return _elm_lang$core$Result$Err("could not convert string '" + s + "' to an Int");
}


function toFloat(s)
{
	// check if it is a hex, octal, or binary number
	if (s.length === 0 || /[\sxbo]/.test(s))
	{
		return floatErr(s);
	}
	var n = +s;
	// faster isNaN check
	return n === n ? _elm_lang$core$Result$Ok(n) : floatErr(s);
}

function floatErr(s)
{
	return _elm_lang$core$Result$Err("could not convert string '" + s + "' to a Float");
}


function toList(str)
{
	return _elm_lang$core$Native_List.fromArray(str.split('').map(_elm_lang$core$Native_Utils.chr));
}
function fromList(chars)
{
	return _elm_lang$core$Native_List.toArray(chars).join('');
}

return {
	isEmpty: isEmpty,
	cons: F2(cons),
	uncons: uncons,
	append: F2(append),
	concat: concat,
	length: length,
	map: F2(map),
	filter: F2(filter),
	reverse: reverse,
	foldl: F3(foldl),
	foldr: F3(foldr),

	split: F2(split),
	join: F2(join),
	repeat: F2(repeat),

	slice: F3(slice),
	left: F2(left),
	right: F2(right),
	dropLeft: F2(dropLeft),
	dropRight: F2(dropRight),

	pad: F3(pad),
	padLeft: F3(padLeft),
	padRight: F3(padRight),

	trim: trim,
	trimLeft: trimLeft,
	trimRight: trimRight,

	words: words,
	lines: lines,

	toUpper: toUpper,
	toLower: toLower,

	any: F2(any),
	all: F2(all),

	contains: F2(contains),
	startsWith: F2(startsWith),
	endsWith: F2(endsWith),
	indexes: F2(indexes),

	toInt: toInt,
	toFloat: toFloat,
	toList: toList,
	fromList: fromList
};

}();

var _elm_lang$core$String$fromList = _elm_lang$core$Native_String.fromList;
var _elm_lang$core$String$toList = _elm_lang$core$Native_String.toList;
var _elm_lang$core$String$toFloat = _elm_lang$core$Native_String.toFloat;
var _elm_lang$core$String$toInt = _elm_lang$core$Native_String.toInt;
var _elm_lang$core$String$indices = _elm_lang$core$Native_String.indexes;
var _elm_lang$core$String$indexes = _elm_lang$core$Native_String.indexes;
var _elm_lang$core$String$endsWith = _elm_lang$core$Native_String.endsWith;
var _elm_lang$core$String$startsWith = _elm_lang$core$Native_String.startsWith;
var _elm_lang$core$String$contains = _elm_lang$core$Native_String.contains;
var _elm_lang$core$String$all = _elm_lang$core$Native_String.all;
var _elm_lang$core$String$any = _elm_lang$core$Native_String.any;
var _elm_lang$core$String$toLower = _elm_lang$core$Native_String.toLower;
var _elm_lang$core$String$toUpper = _elm_lang$core$Native_String.toUpper;
var _elm_lang$core$String$lines = _elm_lang$core$Native_String.lines;
var _elm_lang$core$String$words = _elm_lang$core$Native_String.words;
var _elm_lang$core$String$trimRight = _elm_lang$core$Native_String.trimRight;
var _elm_lang$core$String$trimLeft = _elm_lang$core$Native_String.trimLeft;
var _elm_lang$core$String$trim = _elm_lang$core$Native_String.trim;
var _elm_lang$core$String$padRight = _elm_lang$core$Native_String.padRight;
var _elm_lang$core$String$padLeft = _elm_lang$core$Native_String.padLeft;
var _elm_lang$core$String$pad = _elm_lang$core$Native_String.pad;
var _elm_lang$core$String$dropRight = _elm_lang$core$Native_String.dropRight;
var _elm_lang$core$String$dropLeft = _elm_lang$core$Native_String.dropLeft;
var _elm_lang$core$String$right = _elm_lang$core$Native_String.right;
var _elm_lang$core$String$left = _elm_lang$core$Native_String.left;
var _elm_lang$core$String$slice = _elm_lang$core$Native_String.slice;
var _elm_lang$core$String$repeat = _elm_lang$core$Native_String.repeat;
var _elm_lang$core$String$join = _elm_lang$core$Native_String.join;
var _elm_lang$core$String$split = _elm_lang$core$Native_String.split;
var _elm_lang$core$String$foldr = _elm_lang$core$Native_String.foldr;
var _elm_lang$core$String$foldl = _elm_lang$core$Native_String.foldl;
var _elm_lang$core$String$reverse = _elm_lang$core$Native_String.reverse;
var _elm_lang$core$String$filter = _elm_lang$core$Native_String.filter;
var _elm_lang$core$String$map = _elm_lang$core$Native_String.map;
var _elm_lang$core$String$length = _elm_lang$core$Native_String.length;
var _elm_lang$core$String$concat = _elm_lang$core$Native_String.concat;
var _elm_lang$core$String$append = _elm_lang$core$Native_String.append;
var _elm_lang$core$String$uncons = _elm_lang$core$Native_String.uncons;
var _elm_lang$core$String$cons = _elm_lang$core$Native_String.cons;
var _elm_lang$core$String$fromChar = function ($char) {
	return A2(_elm_lang$core$String$cons, $char, '');
};
var _elm_lang$core$String$isEmpty = _elm_lang$core$Native_String.isEmpty;

var _elm_lang$core$Tuple$mapSecond = F2(
	function (func, _p0) {
		var _p1 = _p0;
		return {
			ctor: '_Tuple2',
			_0: _p1._0,
			_1: func(_p1._1)
		};
	});
var _elm_lang$core$Tuple$mapFirst = F2(
	function (func, _p2) {
		var _p3 = _p2;
		return {
			ctor: '_Tuple2',
			_0: func(_p3._0),
			_1: _p3._1
		};
	});
var _elm_lang$core$Tuple$second = function (_p4) {
	var _p5 = _p4;
	return _p5._1;
};
var _elm_lang$core$Tuple$first = function (_p6) {
	var _p7 = _p6;
	return _p7._0;
};

//import //

var _elm_lang$core$Native_Platform = function() {


// PROGRAMS

function program(impl)
{
	return function(flagDecoder)
	{
		return function(object, moduleName)
		{
			object['worker'] = function worker(flags)
			{
				if (typeof flags !== 'undefined')
				{
					throw new Error(
						'The `' + moduleName + '` module does not need flags.\n'
						+ 'Call ' + moduleName + '.worker() with no arguments and you should be all set!'
					);
				}

				return initialize(
					impl.init,
					impl.update,
					impl.subscriptions,
					renderer
				);
			};
		};
	};
}

function programWithFlags(impl)
{
	return function(flagDecoder)
	{
		return function(object, moduleName)
		{
			object['worker'] = function worker(flags)
			{
				if (typeof flagDecoder === 'undefined')
				{
					throw new Error(
						'Are you trying to sneak a Never value into Elm? Trickster!\n'
						+ 'It looks like ' + moduleName + '.main is defined with `programWithFlags` but has type `Program Never`.\n'
						+ 'Use `program` instead if you do not want flags.'
					);
				}

				var result = A2(_elm_lang$core$Native_Json.run, flagDecoder, flags);
				if (result.ctor === 'Err')
				{
					throw new Error(
						moduleName + '.worker(...) was called with an unexpected argument.\n'
						+ 'I tried to convert it to an Elm value, but ran into this problem:\n\n'
						+ result._0
					);
				}

				return initialize(
					impl.init(result._0),
					impl.update,
					impl.subscriptions,
					renderer
				);
			};
		};
	};
}

function renderer(enqueue, _)
{
	return function(_) {};
}


// HTML TO PROGRAM

function htmlToProgram(vnode)
{
	var emptyBag = batch(_elm_lang$core$Native_List.Nil);
	var noChange = _elm_lang$core$Native_Utils.Tuple2(
		_elm_lang$core$Native_Utils.Tuple0,
		emptyBag
	);

	return _elm_lang$virtual_dom$VirtualDom$program({
		init: noChange,
		view: function(model) { return main; },
		update: F2(function(msg, model) { return noChange; }),
		subscriptions: function (model) { return emptyBag; }
	});
}


// INITIALIZE A PROGRAM

function initialize(init, update, subscriptions, renderer)
{
	// ambient state
	var managers = {};
	var updateView;

	// init and update state in main process
	var initApp = _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
		var model = init._0;
		updateView = renderer(enqueue, model);
		var cmds = init._1;
		var subs = subscriptions(model);
		dispatchEffects(managers, cmds, subs);
		callback(_elm_lang$core$Native_Scheduler.succeed(model));
	});

	function onMessage(msg, model)
	{
		return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
			var results = A2(update, msg, model);
			model = results._0;
			updateView(model);
			var cmds = results._1;
			var subs = subscriptions(model);
			dispatchEffects(managers, cmds, subs);
			callback(_elm_lang$core$Native_Scheduler.succeed(model));
		});
	}

	var mainProcess = spawnLoop(initApp, onMessage);

	function enqueue(msg)
	{
		_elm_lang$core$Native_Scheduler.rawSend(mainProcess, msg);
	}

	var ports = setupEffects(managers, enqueue);

	return ports ? { ports: ports } : {};
}


// EFFECT MANAGERS

var effectManagers = {};

function setupEffects(managers, callback)
{
	var ports;

	// setup all necessary effect managers
	for (var key in effectManagers)
	{
		var manager = effectManagers[key];

		if (manager.isForeign)
		{
			ports = ports || {};
			ports[key] = manager.tag === 'cmd'
				? setupOutgoingPort(key)
				: setupIncomingPort(key, callback);
		}

		managers[key] = makeManager(manager, callback);
	}

	return ports;
}

function makeManager(info, callback)
{
	var router = {
		main: callback,
		self: undefined
	};

	var tag = info.tag;
	var onEffects = info.onEffects;
	var onSelfMsg = info.onSelfMsg;

	function onMessage(msg, state)
	{
		if (msg.ctor === 'self')
		{
			return A3(onSelfMsg, router, msg._0, state);
		}

		var fx = msg._0;
		switch (tag)
		{
			case 'cmd':
				return A3(onEffects, router, fx.cmds, state);

			case 'sub':
				return A3(onEffects, router, fx.subs, state);

			case 'fx':
				return A4(onEffects, router, fx.cmds, fx.subs, state);
		}
	}

	var process = spawnLoop(info.init, onMessage);
	router.self = process;
	return process;
}

function sendToApp(router, msg)
{
	return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback)
	{
		router.main(msg);
		callback(_elm_lang$core$Native_Scheduler.succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function sendToSelf(router, msg)
{
	return A2(_elm_lang$core$Native_Scheduler.send, router.self, {
		ctor: 'self',
		_0: msg
	});
}


// HELPER for STATEFUL LOOPS

function spawnLoop(init, onMessage)
{
	var andThen = _elm_lang$core$Native_Scheduler.andThen;

	function loop(state)
	{
		var handleMsg = _elm_lang$core$Native_Scheduler.receive(function(msg) {
			return onMessage(msg, state);
		});
		return A2(andThen, loop, handleMsg);
	}

	var task = A2(andThen, loop, init);

	return _elm_lang$core$Native_Scheduler.rawSpawn(task);
}


// BAGS

function leaf(home)
{
	return function(value)
	{
		return {
			type: 'leaf',
			home: home,
			value: value
		};
	};
}

function batch(list)
{
	return {
		type: 'node',
		branches: list
	};
}

function map(tagger, bag)
{
	return {
		type: 'map',
		tagger: tagger,
		tree: bag
	}
}


// PIPE BAGS INTO EFFECT MANAGERS

function dispatchEffects(managers, cmdBag, subBag)
{
	var effectsDict = {};
	gatherEffects(true, cmdBag, effectsDict, null);
	gatherEffects(false, subBag, effectsDict, null);

	for (var home in managers)
	{
		var fx = home in effectsDict
			? effectsDict[home]
			: {
				cmds: _elm_lang$core$Native_List.Nil,
				subs: _elm_lang$core$Native_List.Nil
			};

		_elm_lang$core$Native_Scheduler.rawSend(managers[home], { ctor: 'fx', _0: fx });
	}
}

function gatherEffects(isCmd, bag, effectsDict, taggers)
{
	switch (bag.type)
	{
		case 'leaf':
			var home = bag.home;
			var effect = toEffect(isCmd, home, taggers, bag.value);
			effectsDict[home] = insert(isCmd, effect, effectsDict[home]);
			return;

		case 'node':
			var list = bag.branches;
			while (list.ctor !== '[]')
			{
				gatherEffects(isCmd, list._0, effectsDict, taggers);
				list = list._1;
			}
			return;

		case 'map':
			gatherEffects(isCmd, bag.tree, effectsDict, {
				tagger: bag.tagger,
				rest: taggers
			});
			return;
	}
}

function toEffect(isCmd, home, taggers, value)
{
	function applyTaggers(x)
	{
		var temp = taggers;
		while (temp)
		{
			x = temp.tagger(x);
			temp = temp.rest;
		}
		return x;
	}

	var map = isCmd
		? effectManagers[home].cmdMap
		: effectManagers[home].subMap;

	return A2(map, applyTaggers, value)
}

function insert(isCmd, newEffect, effects)
{
	effects = effects || {
		cmds: _elm_lang$core$Native_List.Nil,
		subs: _elm_lang$core$Native_List.Nil
	};
	if (isCmd)
	{
		effects.cmds = _elm_lang$core$Native_List.Cons(newEffect, effects.cmds);
		return effects;
	}
	effects.subs = _elm_lang$core$Native_List.Cons(newEffect, effects.subs);
	return effects;
}


// PORTS

function checkPortName(name)
{
	if (name in effectManagers)
	{
		throw new Error('There can only be one port named `' + name + '`, but your program has multiple.');
	}
}


// OUTGOING PORTS

function outgoingPort(name, converter)
{
	checkPortName(name);
	effectManagers[name] = {
		tag: 'cmd',
		cmdMap: outgoingPortMap,
		converter: converter,
		isForeign: true
	};
	return leaf(name);
}

var outgoingPortMap = F2(function cmdMap(tagger, value) {
	return value;
});

function setupOutgoingPort(name)
{
	var subs = [];
	var converter = effectManagers[name].converter;

	// CREATE MANAGER

	var init = _elm_lang$core$Native_Scheduler.succeed(null);

	function onEffects(router, cmdList, state)
	{
		while (cmdList.ctor !== '[]')
		{
			// grab a separate reference to subs in case unsubscribe is called
			var currentSubs = subs;
			var value = converter(cmdList._0);
			for (var i = 0; i < currentSubs.length; i++)
			{
				currentSubs[i](value);
			}
			cmdList = cmdList._1;
		}
		return init;
	}

	effectManagers[name].init = init;
	effectManagers[name].onEffects = F3(onEffects);

	// PUBLIC API

	function subscribe(callback)
	{
		subs.push(callback);
	}

	function unsubscribe(callback)
	{
		// copy subs into a new array in case unsubscribe is called within a
		// subscribed callback
		subs = subs.slice();
		var index = subs.indexOf(callback);
		if (index >= 0)
		{
			subs.splice(index, 1);
		}
	}

	return {
		subscribe: subscribe,
		unsubscribe: unsubscribe
	};
}


// INCOMING PORTS

function incomingPort(name, converter)
{
	checkPortName(name);
	effectManagers[name] = {
		tag: 'sub',
		subMap: incomingPortMap,
		converter: converter,
		isForeign: true
	};
	return leaf(name);
}

var incomingPortMap = F2(function subMap(tagger, finalTagger)
{
	return function(value)
	{
		return tagger(finalTagger(value));
	};
});

function setupIncomingPort(name, callback)
{
	var sentBeforeInit = [];
	var subs = _elm_lang$core$Native_List.Nil;
	var converter = effectManagers[name].converter;
	var currentOnEffects = preInitOnEffects;
	var currentSend = preInitSend;

	// CREATE MANAGER

	var init = _elm_lang$core$Native_Scheduler.succeed(null);

	function preInitOnEffects(router, subList, state)
	{
		var postInitResult = postInitOnEffects(router, subList, state);

		for(var i = 0; i < sentBeforeInit.length; i++)
		{
			postInitSend(sentBeforeInit[i]);
		}

		sentBeforeInit = null; // to release objects held in queue
		currentSend = postInitSend;
		currentOnEffects = postInitOnEffects;
		return postInitResult;
	}

	function postInitOnEffects(router, subList, state)
	{
		subs = subList;
		return init;
	}

	function onEffects(router, subList, state)
	{
		return currentOnEffects(router, subList, state);
	}

	effectManagers[name].init = init;
	effectManagers[name].onEffects = F3(onEffects);

	// PUBLIC API

	function preInitSend(value)
	{
		sentBeforeInit.push(value);
	}

	function postInitSend(value)
	{
		var temp = subs;
		while (temp.ctor !== '[]')
		{
			callback(temp._0(value));
			temp = temp._1;
		}
	}

	function send(incomingValue)
	{
		var result = A2(_elm_lang$core$Json_Decode$decodeValue, converter, incomingValue);
		if (result.ctor === 'Err')
		{
			throw new Error('Trying to send an unexpected type of value through port `' + name + '`:\n' + result._0);
		}

		currentSend(result._0);
	}

	return { send: send };
}

return {
	// routers
	sendToApp: F2(sendToApp),
	sendToSelf: F2(sendToSelf),

	// global setup
	effectManagers: effectManagers,
	outgoingPort: outgoingPort,
	incomingPort: incomingPort,

	htmlToProgram: htmlToProgram,
	program: program,
	programWithFlags: programWithFlags,
	initialize: initialize,

	// effect bags
	leaf: leaf,
	batch: batch,
	map: F2(map)
};

}();

//import Native.Utils //

var _elm_lang$core$Native_Scheduler = function() {

var MAX_STEPS = 10000;


// TASKS

function succeed(value)
{
	return {
		ctor: '_Task_succeed',
		value: value
	};
}

function fail(error)
{
	return {
		ctor: '_Task_fail',
		value: error
	};
}

function nativeBinding(callback)
{
	return {
		ctor: '_Task_nativeBinding',
		callback: callback,
		cancel: null
	};
}

function andThen(callback, task)
{
	return {
		ctor: '_Task_andThen',
		callback: callback,
		task: task
	};
}

function onError(callback, task)
{
	return {
		ctor: '_Task_onError',
		callback: callback,
		task: task
	};
}

function receive(callback)
{
	return {
		ctor: '_Task_receive',
		callback: callback
	};
}


// PROCESSES

function rawSpawn(task)
{
	var process = {
		ctor: '_Process',
		id: _elm_lang$core$Native_Utils.guid(),
		root: task,
		stack: null,
		mailbox: []
	};

	enqueue(process);

	return process;
}

function spawn(task)
{
	return nativeBinding(function(callback) {
		var process = rawSpawn(task);
		callback(succeed(process));
	});
}

function rawSend(process, msg)
{
	process.mailbox.push(msg);
	enqueue(process);
}

function send(process, msg)
{
	return nativeBinding(function(callback) {
		rawSend(process, msg);
		callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function kill(process)
{
	return nativeBinding(function(callback) {
		var root = process.root;
		if (root.ctor === '_Task_nativeBinding' && root.cancel)
		{
			root.cancel();
		}

		process.root = null;

		callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function sleep(time)
{
	return nativeBinding(function(callback) {
		var id = setTimeout(function() {
			callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
		}, time);

		return function() { clearTimeout(id); };
	});
}


// STEP PROCESSES

function step(numSteps, process)
{
	while (numSteps < MAX_STEPS)
	{
		var ctor = process.root.ctor;

		if (ctor === '_Task_succeed')
		{
			while (process.stack && process.stack.ctor === '_Task_onError')
			{
				process.stack = process.stack.rest;
			}
			if (process.stack === null)
			{
				break;
			}
			process.root = process.stack.callback(process.root.value);
			process.stack = process.stack.rest;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_fail')
		{
			while (process.stack && process.stack.ctor === '_Task_andThen')
			{
				process.stack = process.stack.rest;
			}
			if (process.stack === null)
			{
				break;
			}
			process.root = process.stack.callback(process.root.value);
			process.stack = process.stack.rest;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_andThen')
		{
			process.stack = {
				ctor: '_Task_andThen',
				callback: process.root.callback,
				rest: process.stack
			};
			process.root = process.root.task;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_onError')
		{
			process.stack = {
				ctor: '_Task_onError',
				callback: process.root.callback,
				rest: process.stack
			};
			process.root = process.root.task;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_nativeBinding')
		{
			process.root.cancel = process.root.callback(function(newRoot) {
				process.root = newRoot;
				enqueue(process);
			});

			break;
		}

		if (ctor === '_Task_receive')
		{
			var mailbox = process.mailbox;
			if (mailbox.length === 0)
			{
				break;
			}

			process.root = process.root.callback(mailbox.shift());
			++numSteps;
			continue;
		}

		throw new Error(ctor);
	}

	if (numSteps < MAX_STEPS)
	{
		return numSteps + 1;
	}
	enqueue(process);

	return numSteps;
}


// WORK QUEUE

var working = false;
var workQueue = [];

function enqueue(process)
{
	workQueue.push(process);

	if (!working)
	{
		setTimeout(work, 0);
		working = true;
	}
}

function work()
{
	var numSteps = 0;
	var process;
	while (numSteps < MAX_STEPS && (process = workQueue.shift()))
	{
		if (process.root)
		{
			numSteps = step(numSteps, process);
		}
	}
	if (!process)
	{
		working = false;
		return;
	}
	setTimeout(work, 0);
}


return {
	succeed: succeed,
	fail: fail,
	nativeBinding: nativeBinding,
	andThen: F2(andThen),
	onError: F2(onError),
	receive: receive,

	spawn: spawn,
	kill: kill,
	sleep: sleep,
	send: F2(send),

	rawSpawn: rawSpawn,
	rawSend: rawSend
};

}();
var _elm_lang$core$Platform_Cmd$batch = _elm_lang$core$Native_Platform.batch;
var _elm_lang$core$Platform_Cmd$none = _elm_lang$core$Platform_Cmd$batch(
	{ctor: '[]'});
var _elm_lang$core$Platform_Cmd_ops = _elm_lang$core$Platform_Cmd_ops || {};
_elm_lang$core$Platform_Cmd_ops['!'] = F2(
	function (model, commands) {
		return {
			ctor: '_Tuple2',
			_0: model,
			_1: _elm_lang$core$Platform_Cmd$batch(commands)
		};
	});
var _elm_lang$core$Platform_Cmd$map = _elm_lang$core$Native_Platform.map;
var _elm_lang$core$Platform_Cmd$Cmd = {ctor: 'Cmd'};

var _elm_lang$core$Platform_Sub$batch = _elm_lang$core$Native_Platform.batch;
var _elm_lang$core$Platform_Sub$none = _elm_lang$core$Platform_Sub$batch(
	{ctor: '[]'});
var _elm_lang$core$Platform_Sub$map = _elm_lang$core$Native_Platform.map;
var _elm_lang$core$Platform_Sub$Sub = {ctor: 'Sub'};

var _elm_lang$core$Platform$hack = _elm_lang$core$Native_Scheduler.succeed;
var _elm_lang$core$Platform$sendToSelf = _elm_lang$core$Native_Platform.sendToSelf;
var _elm_lang$core$Platform$sendToApp = _elm_lang$core$Native_Platform.sendToApp;
var _elm_lang$core$Platform$programWithFlags = _elm_lang$core$Native_Platform.programWithFlags;
var _elm_lang$core$Platform$program = _elm_lang$core$Native_Platform.program;
var _elm_lang$core$Platform$Program = {ctor: 'Program'};
var _elm_lang$core$Platform$Task = {ctor: 'Task'};
var _elm_lang$core$Platform$ProcessId = {ctor: 'ProcessId'};
var _elm_lang$core$Platform$Router = {ctor: 'Router'};

var _elm_tools$parser_primitives$ParserPrimitives$findSubString = _elm_tools$parser_primitives$Native_ParserPrimitives.findSubString;
var _elm_tools$parser_primitives$ParserPrimitives$isSubChar = _elm_tools$parser_primitives$Native_ParserPrimitives.isSubChar;
var _elm_tools$parser_primitives$ParserPrimitives$isSubString = _elm_tools$parser_primitives$Native_ParserPrimitives.isSubString;

var _MikaelMayer$parser$Parser_Internal$isPlusOrMinus = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('+')) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('-'));
};
var _MikaelMayer$parser$Parser_Internal$isZero = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('0'));
};
var _MikaelMayer$parser$Parser_Internal$isE = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('e')) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('E'));
};
var _MikaelMayer$parser$Parser_Internal$isDot = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('.'));
};
var _MikaelMayer$parser$Parser_Internal$isBadIntEnd = function ($char) {
	return _elm_lang$core$Char$isDigit($char) || (_elm_lang$core$Char$isUpper($char) || (_elm_lang$core$Char$isLower($char) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('.'))));
};
var _MikaelMayer$parser$Parser_Internal$chomp = F3(
	function (isGood, offset, source) {
		chomp:
		while (true) {
			var newOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, isGood, offset, source);
			if (_elm_lang$core$Native_Utils.cmp(newOffset, 0) < 0) {
				return offset;
			} else {
				var _v0 = isGood,
					_v1 = newOffset,
					_v2 = source;
				isGood = _v0;
				offset = _v1;
				source = _v2;
				continue chomp;
			}
		}
	});
var _MikaelMayer$parser$Parser_Internal$chompDigits = F3(
	function (isValidDigit, offset, source) {
		var newOffset = A3(_MikaelMayer$parser$Parser_Internal$chomp, isValidDigit, offset, source);
		return _elm_lang$core$Native_Utils.eq(newOffset, offset) ? _elm_lang$core$Result$Err(newOffset) : ((!_elm_lang$core$Native_Utils.eq(
			A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isBadIntEnd, newOffset, source),
			-1)) ? _elm_lang$core$Result$Err(newOffset) : _elm_lang$core$Result$Ok(newOffset));
	});
var _MikaelMayer$parser$Parser_Internal$chompExp = F2(
	function (offset, source) {
		var eOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isE, offset, source);
		if (_elm_lang$core$Native_Utils.eq(eOffset, -1)) {
			return _elm_lang$core$Result$Ok(offset);
		} else {
			var opOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isPlusOrMinus, eOffset, source);
			var expOffset = _elm_lang$core$Native_Utils.eq(opOffset, -1) ? eOffset : opOffset;
			return (!_elm_lang$core$Native_Utils.eq(
				A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isZero, expOffset, source),
				-1)) ? _elm_lang$core$Result$Err(expOffset) : (_elm_lang$core$Native_Utils.eq(
				A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _elm_lang$core$Char$isDigit, expOffset, source),
				-1) ? _elm_lang$core$Result$Err(expOffset) : A3(_MikaelMayer$parser$Parser_Internal$chompDigits, _elm_lang$core$Char$isDigit, expOffset, source));
		}
	});
var _MikaelMayer$parser$Parser_Internal$chompDotAndExp = F2(
	function (offset, source) {
		var dotOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isDot, offset, source);
		return _elm_lang$core$Native_Utils.eq(dotOffset, -1) ? A2(_MikaelMayer$parser$Parser_Internal$chompExp, offset, source) : A2(
			_MikaelMayer$parser$Parser_Internal$chompExp,
			A3(_MikaelMayer$parser$Parser_Internal$chomp, _elm_lang$core$Char$isDigit, dotOffset, source),
			source);
	});
var _MikaelMayer$parser$Parser_Internal$State = F6(
	function (a, b, c, d, e, f) {
		return {source: a, offset: b, indent: c, context: d, row: e, col: f};
	});
var _MikaelMayer$parser$Parser_Internal$Parser = function (a) {
	return {ctor: 'Parser', _0: a};
};
var _MikaelMayer$parser$Parser_Internal$Bad = F2(
	function (a, b) {
		return {ctor: 'Bad', _0: a, _1: b};
	});
var _MikaelMayer$parser$Parser_Internal$Good = F2(
	function (a, b) {
		return {ctor: 'Good', _0: a, _1: b};
	});

var _MikaelMayer$parser$Parser$changeContext = F2(
	function (newContext, _p0) {
		var _p1 = _p0;
		return {source: _p1.source, offset: _p1.offset, indent: _p1.indent, context: newContext, row: _p1.row, col: _p1.col};
	});
var _MikaelMayer$parser$Parser$sourceMap = F2(
	function (func, _p2) {
		var _p3 = _p2;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (_p4) {
				var _p5 = _p4;
				var _p6 = _p3._0(_p5);
				if (_p6.ctor === 'Bad') {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p6._0, _p6._1);
				} else {
					var _p7 = _p6._1;
					var subString = A3(_elm_lang$core$String$slice, _p5.offset, _p7.offset, _p5.source);
					return A2(
						_MikaelMayer$parser$Parser_Internal$Good,
						A2(func, subString, _p6._0),
						_p7);
				}
			});
	});
var _MikaelMayer$parser$Parser$source = function (parser) {
	return A2(_MikaelMayer$parser$Parser$sourceMap, _elm_lang$core$Basics$always, parser);
};
var _MikaelMayer$parser$Parser$badFloatMsg = 'The `Parser.float` parser seems to have a bug.\nPlease report an SSCCE to <https://github.com/elm-tools/parser/issues>.';
var _MikaelMayer$parser$Parser$isE = function (c) {
	return _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('e')) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('E'));
};
var _MikaelMayer$parser$Parser$floatHelp = F2(
	function (offset, source) {
		var eOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser$isE, offset, source);
		if (_elm_lang$core$Native_Utils.cmp(eOffset, 0) > -1) {
			return _elm_lang$core$Result$Err(eOffset);
		} else {
			var dotOffset = A3(_MikaelMayer$parser$Parser_Internal$chomp, _elm_lang$core$Char$isDigit, offset, source);
			var result = A2(_MikaelMayer$parser$Parser_Internal$chompDotAndExp, dotOffset, source);
			var _p8 = result;
			if (_p8.ctor === 'Err') {
				return result;
			} else {
				var _p9 = _p8._0;
				return (_elm_lang$core$Native_Utils.eq(_p9, offset) || ((_elm_lang$core$Native_Utils.eq(dotOffset, offset) && (_elm_lang$core$Native_Utils.eq(_p9, dotOffset + 1) || (_elm_lang$core$Native_Utils.cmp(
					A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser$isE, dotOffset + 1, source),
					0) > -1))) || (_elm_lang$core$Native_Utils.cmp(
					A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser$isE, _p9 - 1, source),
					0) > -1))) ? _elm_lang$core$Result$Err(_p9) : result;
			}
		}
	});
var _MikaelMayer$parser$Parser$badIntMsg = 'The `Parser.int` parser seems to have a bug.\nPlease report an SSCCE to <https://github.com/elm-tools/parser/issues>.';
var _MikaelMayer$parser$Parser$isX = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('x'));
};
var _MikaelMayer$parser$Parser$isO = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('o'));
};
var _MikaelMayer$parser$Parser$isZero = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('0'));
};
var _MikaelMayer$parser$Parser$intHelp = F3(
	function (offset, zeroOffset, source) {
		return _elm_lang$core$Native_Utils.eq(zeroOffset, -1) ? A3(_MikaelMayer$parser$Parser_Internal$chompDigits, _elm_lang$core$Char$isDigit, offset, source) : ((!_elm_lang$core$Native_Utils.eq(
			A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser$isX, zeroOffset, source),
			-1)) ? A3(_MikaelMayer$parser$Parser_Internal$chompDigits, _elm_lang$core$Char$isHexDigit, offset + 2, source) : (_elm_lang$core$Native_Utils.eq(
			A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser_Internal$isBadIntEnd, zeroOffset, source),
			-1) ? _elm_lang$core$Result$Ok(zeroOffset) : _elm_lang$core$Result$Err(zeroOffset)));
	});
var _MikaelMayer$parser$Parser$token = F2(
	function (makeProblem, str) {
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (_p10) {
				var _p11 = _p10;
				var _p13 = _p11.source;
				var _p12 = A5(_elm_tools$parser_primitives$ParserPrimitives$isSubString, str, _p11.offset, _p11.row, _p11.col, _p13);
				var newOffset = _p12._0;
				var newRow = _p12._1;
				var newCol = _p12._2;
				return _elm_lang$core$Native_Utils.eq(newOffset, -1) ? A2(
					_MikaelMayer$parser$Parser_Internal$Bad,
					makeProblem(str),
					_p11) : A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					{ctor: '_Tuple0'},
					{source: _p13, offset: newOffset, indent: _p11.indent, context: _p11.context, row: newRow, col: newCol});
			});
	});
var _MikaelMayer$parser$Parser$delayedCommitAndThen = F3(
	function (func, _p14, aToParserB) {
		var _p15 = _p14;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p16 = _p15._0(state1);
				if (_p16.ctor === 'Bad') {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p16._0, state1);
				} else {
					var _p22 = _p16._1;
					var _p21 = _p16._0;
					var _p17 = aToParserB(_p21);
					var parseB = _p17._0;
					var _p18 = parseB(_p22);
					if (_p18.ctor === 'Good') {
						return A2(
							_MikaelMayer$parser$Parser_Internal$Good,
							A2(func, _p21, _p18._0),
							_p18._1);
					} else {
						var _p20 = _p18._0;
						var _p19 = _p18._1;
						return (_elm_lang$core$Native_Utils.eq(_p22.row, _p19.row) && _elm_lang$core$Native_Utils.eq(_p22.col, _p19.col)) ? A2(_MikaelMayer$parser$Parser_Internal$Bad, _p20, state1) : A2(_MikaelMayer$parser$Parser_Internal$Bad, _p20, _p19);
					}
				}
			});
	});
var _MikaelMayer$parser$Parser$delayedCommitMap = F3(
	function (func, _p24, _p23) {
		var _p25 = _p24;
		var _p26 = _p23;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p27 = _p25._0(state1);
				if (_p27.ctor === 'Bad') {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p27._0, state1);
				} else {
					var _p31 = _p27._1;
					var _p28 = _p26._0(_p31);
					if (_p28.ctor === 'Good') {
						return A2(
							_MikaelMayer$parser$Parser_Internal$Good,
							A2(func, _p27._0, _p28._0),
							_p28._1);
					} else {
						var _p30 = _p28._0;
						var _p29 = _p28._1;
						return (_elm_lang$core$Native_Utils.eq(_p31.row, _p29.row) && _elm_lang$core$Native_Utils.eq(_p31.col, _p29.col)) ? A2(_MikaelMayer$parser$Parser_Internal$Bad, _p30, state1) : A2(_MikaelMayer$parser$Parser_Internal$Bad, _p30, _p29);
					}
				}
			});
	});
var _MikaelMayer$parser$Parser$delayedCommit = F2(
	function (filler, realStuff) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (_p32, v) {
					return v;
				}),
			filler,
			realStuff);
	});
var _MikaelMayer$parser$Parser$lazy = function (thunk) {
	return _MikaelMayer$parser$Parser_Internal$Parser(
		function (state) {
			var _p33 = thunk(
				{ctor: '_Tuple0'});
			var parse = _p33._0;
			return parse(state);
		});
};
var _MikaelMayer$parser$Parser$andThen = F2(
	function (callback, _p34) {
		var _p35 = _p34;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p36 = _p35._0(state1);
				if (_p36.ctor === 'Bad') {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p36._0, _p36._1);
				} else {
					var _p37 = callback(_p36._0);
					var parseB = _p37._0;
					return parseB(_p36._1);
				}
			});
	});
var _MikaelMayer$parser$Parser$apply = F2(
	function (f, a) {
		return f(a);
	});
var _MikaelMayer$parser$Parser$map2 = F3(
	function (func, _p39, _p38) {
		var _p40 = _p39;
		var _p41 = _p38;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p42 = _p40._0(state1);
				if (_p42.ctor === 'Bad') {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p42._0, _p42._1);
				} else {
					var _p43 = _p41._0(_p42._1);
					if (_p43.ctor === 'Bad') {
						return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p43._0, _p43._1);
					} else {
						return A2(
							_MikaelMayer$parser$Parser_Internal$Good,
							A2(func, _p42._0, _p43._0),
							_p43._1);
					}
				}
			});
	});
var _MikaelMayer$parser$Parser_ops = _MikaelMayer$parser$Parser_ops || {};
_MikaelMayer$parser$Parser_ops['|='] = F2(
	function (parseFunc, parseArg) {
		return A3(_MikaelMayer$parser$Parser$map2, _MikaelMayer$parser$Parser$apply, parseFunc, parseArg);
	});
var _MikaelMayer$parser$Parser_ops = _MikaelMayer$parser$Parser_ops || {};
_MikaelMayer$parser$Parser_ops['|.'] = F2(
	function (keepParser, ignoreParser) {
		return A3(_MikaelMayer$parser$Parser$map2, _elm_lang$core$Basics$always, keepParser, ignoreParser);
	});
var _MikaelMayer$parser$Parser$map = F2(
	function (func, _p44) {
		var _p45 = _p44;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p46 = _p45._0(state1);
				if (_p46.ctor === 'Good') {
					return A2(
						_MikaelMayer$parser$Parser_Internal$Good,
						func(_p46._0),
						_p46._1);
				} else {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p46._0, _p46._1);
				}
			});
	});
var _MikaelMayer$parser$Parser$succeed = function (a) {
	return _MikaelMayer$parser$Parser_Internal$Parser(
		function (state) {
			return A2(_MikaelMayer$parser$Parser_Internal$Good, a, state);
		});
};
var _MikaelMayer$parser$Parser$run = F2(
	function (_p47, source) {
		var _p48 = _p47;
		var initialState = {
			source: source,
			offset: 0,
			indent: 1,
			context: {ctor: '[]'},
			row: 1,
			col: 1
		};
		var _p49 = _p48._0(initialState);
		if (_p49.ctor === 'Good') {
			return _elm_lang$core$Result$Ok(_p49._0);
		} else {
			return _elm_lang$core$Result$Err(
				{row: _p49._1.row, col: _p49._1.col, source: source, problem: _p49._0, context: _p49._1.context});
		}
	});
var _MikaelMayer$parser$Parser$Error = F5(
	function (a, b, c, d, e) {
		return {row: a, col: b, source: c, problem: d, context: e};
	});
var _MikaelMayer$parser$Parser$Context = F3(
	function (a, b, c) {
		return {row: a, col: b, description: c};
	});
var _MikaelMayer$parser$Parser$inContext = F2(
	function (ctx, _p50) {
		var _p51 = _p50;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (_p52) {
				var _p53 = _p52;
				var _p55 = _p53.context;
				var state1 = A2(
					_MikaelMayer$parser$Parser$changeContext,
					{
						ctor: '::',
						_0: A3(_MikaelMayer$parser$Parser$Context, _p53.row, _p53.col, ctx),
						_1: _p55
					},
					_p53);
				var _p54 = _p51._0(state1);
				if (_p54.ctor === 'Good') {
					return A2(
						_MikaelMayer$parser$Parser_Internal$Good,
						_p54._0,
						A2(_MikaelMayer$parser$Parser$changeContext, _p55, _p54._1));
				} else {
					return _p54;
				}
			});
	});
var _MikaelMayer$parser$Parser$Fail = function (a) {
	return {ctor: 'Fail', _0: a};
};
var _MikaelMayer$parser$Parser$fail = function (message) {
	return _MikaelMayer$parser$Parser_Internal$Parser(
		function (state) {
			return A2(
				_MikaelMayer$parser$Parser_Internal$Bad,
				_MikaelMayer$parser$Parser$Fail(message),
				state);
		});
};
var _MikaelMayer$parser$Parser$ExpectingClosing = function (a) {
	return {ctor: 'ExpectingClosing', _0: a};
};
var _MikaelMayer$parser$Parser$ignoreUntil = function (str) {
	return _MikaelMayer$parser$Parser_Internal$Parser(
		function (_p56) {
			var _p57 = _p56;
			var _p59 = _p57.source;
			var _p58 = A6(_elm_tools$parser_primitives$ParserPrimitives$findSubString, false, str, _p57.offset, _p57.row, _p57.col, _p59);
			var newOffset = _p58._0;
			var newRow = _p58._1;
			var newCol = _p58._2;
			return _elm_lang$core$Native_Utils.eq(newOffset, -1) ? A2(
				_MikaelMayer$parser$Parser_Internal$Bad,
				_MikaelMayer$parser$Parser$ExpectingClosing(str),
				_p57) : A2(
				_MikaelMayer$parser$Parser_Internal$Good,
				{ctor: '_Tuple0'},
				{source: _p59, offset: newOffset, indent: _p57.indent, context: _p57.context, row: newRow, col: newCol});
		});
};
var _MikaelMayer$parser$Parser$ExpectingVariable = {ctor: 'ExpectingVariable'};
var _MikaelMayer$parser$Parser$ExpectingKeyword = function (a) {
	return {ctor: 'ExpectingKeyword', _0: a};
};
var _MikaelMayer$parser$Parser$keyword = function (str) {
	return A2(_MikaelMayer$parser$Parser$token, _MikaelMayer$parser$Parser$ExpectingKeyword, str);
};
var _MikaelMayer$parser$Parser$ExpectingSymbol = function (a) {
	return {ctor: 'ExpectingSymbol', _0: a};
};
var _MikaelMayer$parser$Parser$symbol = function (str) {
	return A2(_MikaelMayer$parser$Parser$token, _MikaelMayer$parser$Parser$ExpectingSymbol, str);
};
var _MikaelMayer$parser$Parser$ExpectingEnd = {ctor: 'ExpectingEnd'};
var _MikaelMayer$parser$Parser$end = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return _elm_lang$core$Native_Utils.eq(
			_elm_lang$core$String$length(state.source),
			state.offset) ? A2(
			_MikaelMayer$parser$Parser_Internal$Good,
			{ctor: '_Tuple0'},
			state) : A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$ExpectingEnd, state);
	});
var _MikaelMayer$parser$Parser$BadRepeat = {ctor: 'BadRepeat'};
var _MikaelMayer$parser$Parser$repeatExactly = F4(
	function (n, parse, revList, state1) {
		repeatExactly:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					_elm_lang$core$List$reverse(revList),
					state1);
			} else {
				var _p60 = parse(state1);
				if (_p60.ctor === 'Good') {
					var _p61 = _p60._1;
					if (_elm_lang$core$Native_Utils.eq(state1.row, _p61.row) && _elm_lang$core$Native_Utils.eq(state1.col, _p61.col)) {
						return A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$BadRepeat, _p61);
					} else {
						var _v28 = n - 1,
							_v29 = parse,
							_v30 = {ctor: '::', _0: _p60._0, _1: revList},
							_v31 = _p61;
						n = _v28;
						parse = _v29;
						revList = _v30;
						state1 = _v31;
						continue repeatExactly;
					}
				} else {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _p60._0, _p60._1);
				}
			}
		}
	});
var _MikaelMayer$parser$Parser$repeatAtLeast = F4(
	function (n, parse, revList, state1) {
		repeatAtLeast:
		while (true) {
			var _p62 = parse(state1);
			if (_p62.ctor === 'Good') {
				var _p63 = _p62._1;
				if (_elm_lang$core$Native_Utils.eq(state1.row, _p63.row) && _elm_lang$core$Native_Utils.eq(state1.col, _p63.col)) {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$BadRepeat, _p63);
				} else {
					var _v33 = n - 1,
						_v34 = parse,
						_v35 = {ctor: '::', _0: _p62._0, _1: revList},
						_v36 = _p63;
					n = _v33;
					parse = _v34;
					revList = _v35;
					state1 = _v36;
					continue repeatAtLeast;
				}
			} else {
				var _p64 = _p62._1;
				return (_elm_lang$core$Native_Utils.eq(state1.row, _p64.row) && (_elm_lang$core$Native_Utils.eq(state1.col, _p64.col) && (_elm_lang$core$Native_Utils.cmp(n, 0) < 1))) ? A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					_elm_lang$core$List$reverse(revList),
					state1) : A2(_MikaelMayer$parser$Parser_Internal$Bad, _p62._0, _p64);
			}
		}
	});
var _MikaelMayer$parser$Parser$repeat = F2(
	function (count, _p65) {
		var _p66 = _p65;
		var _p68 = _p66._0;
		var _p67 = count;
		if (_p67.ctor === 'Exactly') {
			return _MikaelMayer$parser$Parser_Internal$Parser(
				function (state) {
					return A4(
						_MikaelMayer$parser$Parser$repeatExactly,
						_p67._0,
						_p68,
						{ctor: '[]'},
						state);
				});
		} else {
			return _MikaelMayer$parser$Parser_Internal$Parser(
				function (state) {
					return A4(
						_MikaelMayer$parser$Parser$repeatAtLeast,
						_p67._0,
						_p68,
						{ctor: '[]'},
						state);
				});
		}
	});
var _MikaelMayer$parser$Parser$ignoreExactly = F8(
	function (n, predicate, source, offset, indent, context, row, col) {
		ignoreExactly:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					{ctor: '_Tuple0'},
					{source: source, offset: offset, indent: indent, context: context, row: row, col: col});
			} else {
				var newOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, predicate, offset, source);
				if (_elm_lang$core$Native_Utils.eq(newOffset, -1)) {
					return A2(
						_MikaelMayer$parser$Parser_Internal$Bad,
						_MikaelMayer$parser$Parser$BadRepeat,
						{source: source, offset: offset, indent: indent, context: context, row: row, col: col});
				} else {
					if (_elm_lang$core$Native_Utils.eq(newOffset, -2)) {
						var _v39 = n - 1,
							_v40 = predicate,
							_v41 = source,
							_v42 = offset + 1,
							_v43 = indent,
							_v44 = context,
							_v45 = row + 1,
							_v46 = 1;
						n = _v39;
						predicate = _v40;
						source = _v41;
						offset = _v42;
						indent = _v43;
						context = _v44;
						row = _v45;
						col = _v46;
						continue ignoreExactly;
					} else {
						var _v47 = n - 1,
							_v48 = predicate,
							_v49 = source,
							_v50 = newOffset,
							_v51 = indent,
							_v52 = context,
							_v53 = row,
							_v54 = col + 1;
						n = _v47;
						predicate = _v48;
						source = _v49;
						offset = _v50;
						indent = _v51;
						context = _v52;
						row = _v53;
						col = _v54;
						continue ignoreExactly;
					}
				}
			}
		}
	});
var _MikaelMayer$parser$Parser$ignoreAtLeast = F8(
	function (n, predicate, source, offset, indent, context, row, col) {
		ignoreAtLeast:
		while (true) {
			var newOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, predicate, offset, source);
			if (_elm_lang$core$Native_Utils.eq(newOffset, -1)) {
				var state = {source: source, offset: offset, indent: indent, context: context, row: row, col: col};
				return (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) ? A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					{ctor: '_Tuple0'},
					state) : A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$BadRepeat, state);
			} else {
				if (_elm_lang$core$Native_Utils.eq(newOffset, -2)) {
					var _v55 = n - 1,
						_v56 = predicate,
						_v57 = source,
						_v58 = offset + 1,
						_v59 = indent,
						_v60 = context,
						_v61 = row + 1,
						_v62 = 1;
					n = _v55;
					predicate = _v56;
					source = _v57;
					offset = _v58;
					indent = _v59;
					context = _v60;
					row = _v61;
					col = _v62;
					continue ignoreAtLeast;
				} else {
					var _v63 = n - 1,
						_v64 = predicate,
						_v65 = source,
						_v66 = newOffset,
						_v67 = indent,
						_v68 = context,
						_v69 = row,
						_v70 = col + 1;
					n = _v63;
					predicate = _v64;
					source = _v65;
					offset = _v66;
					indent = _v67;
					context = _v68;
					row = _v69;
					col = _v70;
					continue ignoreAtLeast;
				}
			}
		}
	});
var _MikaelMayer$parser$Parser$ignore = F2(
	function (count, predicate) {
		var _p69 = count;
		if (_p69.ctor === 'Exactly') {
			return _MikaelMayer$parser$Parser_Internal$Parser(
				function (_p70) {
					var _p71 = _p70;
					return A8(_MikaelMayer$parser$Parser$ignoreExactly, _p69._0, predicate, _p71.source, _p71.offset, _p71.indent, _p71.context, _p71.row, _p71.col);
				});
		} else {
			return _MikaelMayer$parser$Parser_Internal$Parser(
				function (_p72) {
					var _p73 = _p72;
					return A8(_MikaelMayer$parser$Parser$ignoreAtLeast, _p69._0, predicate, _p73.source, _p73.offset, _p73.indent, _p73.context, _p73.row, _p73.col);
				});
		}
	});
var _MikaelMayer$parser$Parser$keep = F2(
	function (count, predicate) {
		return _MikaelMayer$parser$Parser$source(
			A2(_MikaelMayer$parser$Parser$ignore, count, predicate));
	});
var _MikaelMayer$parser$Parser$BadFloat = {ctor: 'BadFloat'};
var _MikaelMayer$parser$Parser$float = _MikaelMayer$parser$Parser_Internal$Parser(
	function (_p74) {
		var _p75 = _p74;
		var _p86 = _p75.source;
		var _p85 = _p75.row;
		var _p84 = _p75.offset;
		var _p83 = _p75.indent;
		var _p82 = _p75.context;
		var _p81 = _p75.col;
		var _p76 = A2(_MikaelMayer$parser$Parser$floatHelp, _p84, _p86);
		if (_p76.ctor === 'Err') {
			var _p77 = _p76._0;
			return A2(
				_MikaelMayer$parser$Parser_Internal$Bad,
				_MikaelMayer$parser$Parser$BadFloat,
				{source: _p86, offset: _p77, indent: _p83, context: _p82, row: _p85, col: _p81 + (_p77 - _p84)});
		} else {
			var _p80 = _p76._0;
			var _p78 = _elm_lang$core$String$toFloat(
				A3(_elm_lang$core$String$slice, _p84, _p80, _p86));
			if (_p78.ctor === 'Err') {
				return _elm_lang$core$Native_Utils.crashCase(
					'Parser',
					{
						start: {line: 758, column: 9},
						end: {line: 770, column: 16}
					},
					_p78)(_MikaelMayer$parser$Parser$badFloatMsg);
			} else {
				return A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					_p78._0,
					{source: _p86, offset: _p80, indent: _p83, context: _p82, row: _p85, col: _p81 + (_p80 - _p84)});
			}
		}
	});
var _MikaelMayer$parser$Parser$BadInt = {ctor: 'BadInt'};
var _MikaelMayer$parser$Parser$int = _MikaelMayer$parser$Parser_Internal$Parser(
	function (_p87) {
		var _p88 = _p87;
		var _p99 = _p88.source;
		var _p98 = _p88.row;
		var _p97 = _p88.offset;
		var _p96 = _p88.indent;
		var _p95 = _p88.context;
		var _p94 = _p88.col;
		var _p89 = A3(
			_MikaelMayer$parser$Parser$intHelp,
			_p97,
			A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, _MikaelMayer$parser$Parser$isZero, _p97, _p99),
			_p99);
		if (_p89.ctor === 'Err') {
			var _p90 = _p89._0;
			return A2(
				_MikaelMayer$parser$Parser_Internal$Bad,
				_MikaelMayer$parser$Parser$BadInt,
				{source: _p99, offset: _p90, indent: _p96, context: _p95, row: _p98, col: _p94 + (_p90 - _p97)});
		} else {
			var _p93 = _p89._0;
			var _p91 = _elm_lang$core$String$toInt(
				A3(_elm_lang$core$String$slice, _p97, _p93, _p99));
			if (_p91.ctor === 'Err') {
				return _elm_lang$core$Native_Utils.crashCase(
					'Parser',
					{
						start: {line: 657, column: 9},
						end: {line: 669, column: 16}
					},
					_p91)(_MikaelMayer$parser$Parser$badIntMsg);
			} else {
				return A2(
					_MikaelMayer$parser$Parser_Internal$Good,
					_p91._0,
					{source: _p99, offset: _p93, indent: _p96, context: _p95, row: _p98, col: _p94 + (_p93 - _p97)});
			}
		}
	});
var _MikaelMayer$parser$Parser$BadOneOf = function (a) {
	return {ctor: 'BadOneOf', _0: a};
};
var _MikaelMayer$parser$Parser$oneOfHelp = F3(
	function (state, problems, parsers) {
		oneOfHelp:
		while (true) {
			var _p100 = parsers;
			if (_p100.ctor === '[]') {
				return A2(
					_MikaelMayer$parser$Parser_Internal$Bad,
					_MikaelMayer$parser$Parser$BadOneOf(
						_elm_lang$core$List$reverse(problems)),
					state);
			} else {
				var _p101 = _p100._0._0(state);
				if (_p101.ctor === 'Good') {
					return _p101;
				} else {
					if (_elm_lang$core$Native_Utils.eq(state.row, _p101._1.row) && _elm_lang$core$Native_Utils.eq(state.col, _p101._1.col)) {
						var _v82 = state,
							_v83 = {ctor: '::', _0: _p101._0, _1: problems},
							_v84 = _p100._1;
						state = _v82;
						problems = _v83;
						parsers = _v84;
						continue oneOfHelp;
					} else {
						return _p101;
					}
				}
			}
		}
	});
var _MikaelMayer$parser$Parser$oneOf = function (parsers) {
	return _MikaelMayer$parser$Parser_Internal$Parser(
		function (state) {
			return A3(
				_MikaelMayer$parser$Parser$oneOfHelp,
				state,
				{ctor: '[]'},
				parsers);
		});
};
var _MikaelMayer$parser$Parser$Exactly = function (a) {
	return {ctor: 'Exactly', _0: a};
};
var _MikaelMayer$parser$Parser$AtLeast = function (a) {
	return {ctor: 'AtLeast', _0: a};
};
var _MikaelMayer$parser$Parser$zeroOrMore = _MikaelMayer$parser$Parser$AtLeast(0);
var _MikaelMayer$parser$Parser$oneOrMore = _MikaelMayer$parser$Parser$AtLeast(1);

var _elm_lang$core$Dict$foldr = F3(
	function (f, acc, t) {
		foldr:
		while (true) {
			var _p0 = t;
			if (_p0.ctor === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var _v1 = f,
					_v2 = A3(
					f,
					_p0._1,
					_p0._2,
					A3(_elm_lang$core$Dict$foldr, f, acc, _p0._4)),
					_v3 = _p0._3;
				f = _v1;
				acc = _v2;
				t = _v3;
				continue foldr;
			}
		}
	});
var _elm_lang$core$Dict$keys = function (dict) {
	return A3(
		_elm_lang$core$Dict$foldr,
		F3(
			function (key, value, keyList) {
				return {ctor: '::', _0: key, _1: keyList};
			}),
		{ctor: '[]'},
		dict);
};
var _elm_lang$core$Dict$values = function (dict) {
	return A3(
		_elm_lang$core$Dict$foldr,
		F3(
			function (key, value, valueList) {
				return {ctor: '::', _0: value, _1: valueList};
			}),
		{ctor: '[]'},
		dict);
};
var _elm_lang$core$Dict$toList = function (dict) {
	return A3(
		_elm_lang$core$Dict$foldr,
		F3(
			function (key, value, list) {
				return {
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: key, _1: value},
					_1: list
				};
			}),
		{ctor: '[]'},
		dict);
};
var _elm_lang$core$Dict$foldl = F3(
	function (f, acc, dict) {
		foldl:
		while (true) {
			var _p1 = dict;
			if (_p1.ctor === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var _v5 = f,
					_v6 = A3(
					f,
					_p1._1,
					_p1._2,
					A3(_elm_lang$core$Dict$foldl, f, acc, _p1._3)),
					_v7 = _p1._4;
				f = _v5;
				acc = _v6;
				dict = _v7;
				continue foldl;
			}
		}
	});
var _elm_lang$core$Dict$reportRemBug = F4(
	function (msg, c, lgot, rgot) {
		return _elm_lang$core$Native_Debug.crash(
			_elm_lang$core$String$concat(
				{
					ctor: '::',
					_0: 'Internal red-black tree invariant violated, expected ',
					_1: {
						ctor: '::',
						_0: msg,
						_1: {
							ctor: '::',
							_0: ' and got ',
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Basics$toString(c),
								_1: {
									ctor: '::',
									_0: '/',
									_1: {
										ctor: '::',
										_0: lgot,
										_1: {
											ctor: '::',
											_0: '/',
											_1: {
												ctor: '::',
												_0: rgot,
												_1: {
													ctor: '::',
													_0: '\nPlease report this bug to <https://github.com/elm-lang/core/issues>',
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							}
						}
					}
				}));
	});
var _elm_lang$core$Dict$isBBlack = function (dict) {
	var _p2 = dict;
	_v8_2:
	do {
		if (_p2.ctor === 'RBNode_elm_builtin') {
			if (_p2._0.ctor === 'BBlack') {
				return true;
			} else {
				break _v8_2;
			}
		} else {
			if (_p2._0.ctor === 'LBBlack') {
				return true;
			} else {
				break _v8_2;
			}
		}
	} while(false);
	return false;
};
var _elm_lang$core$Dict$keyCompare = _elm_lang$core$Native_Basics.compare;
var _elm_lang$core$Dict$merge = F6(
	function (leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
		var stepState = F3(
			function (rKey, rValue, _p3) {
				stepState:
				while (true) {
					var _p4 = _p3;
					var _p11 = _p4._1;
					var _p10 = _p4._0;
					var _p5 = _p10;
					if (_p5.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: _p10,
							_1: A3(rightStep, rKey, rValue, _p11)
						};
					} else {
						var _p9 = _p5._1;
						var _p8 = _p5._0._1;
						var _p7 = _p5._0._0;
						var _p6 = A2(_elm_lang$core$Dict$keyCompare, _p7, rKey);
						switch (_p6.ctor) {
							case 'LT':
								var _v12 = rKey,
									_v13 = rValue,
									_v14 = {
									ctor: '_Tuple2',
									_0: _p9,
									_1: A3(leftStep, _p7, _p8, _p11)
								};
								rKey = _v12;
								rValue = _v13;
								_p3 = _v14;
								continue stepState;
							case 'GT':
								return {
									ctor: '_Tuple2',
									_0: _p10,
									_1: A3(rightStep, rKey, rValue, _p11)
								};
							default:
								return {
									ctor: '_Tuple2',
									_0: _p9,
									_1: A4(bothStep, _p7, _p8, rValue, _p11)
								};
						}
					}
				}
			});
		var _p12 = A3(
			_elm_lang$core$Dict$foldl,
			stepState,
			{
				ctor: '_Tuple2',
				_0: _elm_lang$core$Dict$toList(leftDict),
				_1: initialResult
			},
			rightDict);
		var leftovers = _p12._0;
		var intermediateResult = _p12._1;
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p13, result) {
					var _p14 = _p13;
					return A3(leftStep, _p14._0, _p14._1, result);
				}),
			intermediateResult,
			leftovers);
	});
var _elm_lang$core$Dict$sizeHelp = F2(
	function (n, dict) {
		sizeHelp:
		while (true) {
			var _p15 = dict;
			if (_p15.ctor === 'RBEmpty_elm_builtin') {
				return n;
			} else {
				var _v17 = A2(_elm_lang$core$Dict$sizeHelp, n + 1, _p15._4),
					_v18 = _p15._3;
				n = _v17;
				dict = _v18;
				continue sizeHelp;
			}
		}
	});
var _elm_lang$core$Dict$size = function (dict) {
	return A2(_elm_lang$core$Dict$sizeHelp, 0, dict);
};
var _elm_lang$core$Dict$get = F2(
	function (targetKey, dict) {
		get:
		while (true) {
			var _p16 = dict;
			if (_p16.ctor === 'RBEmpty_elm_builtin') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p17 = A2(_elm_lang$core$Dict$keyCompare, targetKey, _p16._1);
				switch (_p17.ctor) {
					case 'LT':
						var _v21 = targetKey,
							_v22 = _p16._3;
						targetKey = _v21;
						dict = _v22;
						continue get;
					case 'EQ':
						return _elm_lang$core$Maybe$Just(_p16._2);
					default:
						var _v23 = targetKey,
							_v24 = _p16._4;
						targetKey = _v23;
						dict = _v24;
						continue get;
				}
			}
		}
	});
var _elm_lang$core$Dict$member = F2(
	function (key, dict) {
		var _p18 = A2(_elm_lang$core$Dict$get, key, dict);
		if (_p18.ctor === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var _elm_lang$core$Dict$maxWithDefault = F3(
	function (k, v, r) {
		maxWithDefault:
		while (true) {
			var _p19 = r;
			if (_p19.ctor === 'RBEmpty_elm_builtin') {
				return {ctor: '_Tuple2', _0: k, _1: v};
			} else {
				var _v27 = _p19._1,
					_v28 = _p19._2,
					_v29 = _p19._4;
				k = _v27;
				v = _v28;
				r = _v29;
				continue maxWithDefault;
			}
		}
	});
var _elm_lang$core$Dict$NBlack = {ctor: 'NBlack'};
var _elm_lang$core$Dict$BBlack = {ctor: 'BBlack'};
var _elm_lang$core$Dict$Black = {ctor: 'Black'};
var _elm_lang$core$Dict$blackish = function (t) {
	var _p20 = t;
	if (_p20.ctor === 'RBNode_elm_builtin') {
		var _p21 = _p20._0;
		return _elm_lang$core$Native_Utils.eq(_p21, _elm_lang$core$Dict$Black) || _elm_lang$core$Native_Utils.eq(_p21, _elm_lang$core$Dict$BBlack);
	} else {
		return true;
	}
};
var _elm_lang$core$Dict$Red = {ctor: 'Red'};
var _elm_lang$core$Dict$moreBlack = function (color) {
	var _p22 = color;
	switch (_p22.ctor) {
		case 'Black':
			return _elm_lang$core$Dict$BBlack;
		case 'Red':
			return _elm_lang$core$Dict$Black;
		case 'NBlack':
			return _elm_lang$core$Dict$Red;
		default:
			return _elm_lang$core$Native_Debug.crash('Can\'t make a double black node more black!');
	}
};
var _elm_lang$core$Dict$lessBlack = function (color) {
	var _p23 = color;
	switch (_p23.ctor) {
		case 'BBlack':
			return _elm_lang$core$Dict$Black;
		case 'Black':
			return _elm_lang$core$Dict$Red;
		case 'Red':
			return _elm_lang$core$Dict$NBlack;
		default:
			return _elm_lang$core$Native_Debug.crash('Can\'t make a negative black node less black!');
	}
};
var _elm_lang$core$Dict$LBBlack = {ctor: 'LBBlack'};
var _elm_lang$core$Dict$LBlack = {ctor: 'LBlack'};
var _elm_lang$core$Dict$RBEmpty_elm_builtin = function (a) {
	return {ctor: 'RBEmpty_elm_builtin', _0: a};
};
var _elm_lang$core$Dict$empty = _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBlack);
var _elm_lang$core$Dict$isEmpty = function (dict) {
	return _elm_lang$core$Native_Utils.eq(dict, _elm_lang$core$Dict$empty);
};
var _elm_lang$core$Dict$RBNode_elm_builtin = F5(
	function (a, b, c, d, e) {
		return {ctor: 'RBNode_elm_builtin', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _elm_lang$core$Dict$ensureBlackRoot = function (dict) {
	var _p24 = dict;
	if ((_p24.ctor === 'RBNode_elm_builtin') && (_p24._0.ctor === 'Red')) {
		return A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p24._1, _p24._2, _p24._3, _p24._4);
	} else {
		return dict;
	}
};
var _elm_lang$core$Dict$lessBlackTree = function (dict) {
	var _p25 = dict;
	if (_p25.ctor === 'RBNode_elm_builtin') {
		return A5(
			_elm_lang$core$Dict$RBNode_elm_builtin,
			_elm_lang$core$Dict$lessBlack(_p25._0),
			_p25._1,
			_p25._2,
			_p25._3,
			_p25._4);
	} else {
		return _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBlack);
	}
};
var _elm_lang$core$Dict$balancedTree = function (col) {
	return function (xk) {
		return function (xv) {
			return function (yk) {
				return function (yv) {
					return function (zk) {
						return function (zv) {
							return function (a) {
								return function (b) {
									return function (c) {
										return function (d) {
											return A5(
												_elm_lang$core$Dict$RBNode_elm_builtin,
												_elm_lang$core$Dict$lessBlack(col),
												yk,
												yv,
												A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, xk, xv, a, b),
												A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, zk, zv, c, d));
										};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var _elm_lang$core$Dict$blacken = function (t) {
	var _p26 = t;
	if (_p26.ctor === 'RBEmpty_elm_builtin') {
		return _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBlack);
	} else {
		return A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p26._1, _p26._2, _p26._3, _p26._4);
	}
};
var _elm_lang$core$Dict$redden = function (t) {
	var _p27 = t;
	if (_p27.ctor === 'RBEmpty_elm_builtin') {
		return _elm_lang$core$Native_Debug.crash('can\'t make a Leaf red');
	} else {
		return A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Red, _p27._1, _p27._2, _p27._3, _p27._4);
	}
};
var _elm_lang$core$Dict$balanceHelp = function (tree) {
	var _p28 = tree;
	_v37_6:
	do {
		_v37_5:
		do {
			_v37_4:
			do {
				_v37_3:
				do {
					_v37_2:
					do {
						_v37_1:
						do {
							_v37_0:
							do {
								if (_p28.ctor === 'RBNode_elm_builtin') {
									if (_p28._3.ctor === 'RBNode_elm_builtin') {
										if (_p28._4.ctor === 'RBNode_elm_builtin') {
											switch (_p28._3._0.ctor) {
												case 'Red':
													switch (_p28._4._0.ctor) {
														case 'Red':
															if ((_p28._3._3.ctor === 'RBNode_elm_builtin') && (_p28._3._3._0.ctor === 'Red')) {
																break _v37_0;
															} else {
																if ((_p28._3._4.ctor === 'RBNode_elm_builtin') && (_p28._3._4._0.ctor === 'Red')) {
																	break _v37_1;
																} else {
																	if ((_p28._4._3.ctor === 'RBNode_elm_builtin') && (_p28._4._3._0.ctor === 'Red')) {
																		break _v37_2;
																	} else {
																		if ((_p28._4._4.ctor === 'RBNode_elm_builtin') && (_p28._4._4._0.ctor === 'Red')) {
																			break _v37_3;
																		} else {
																			break _v37_6;
																		}
																	}
																}
															}
														case 'NBlack':
															if ((_p28._3._3.ctor === 'RBNode_elm_builtin') && (_p28._3._3._0.ctor === 'Red')) {
																break _v37_0;
															} else {
																if ((_p28._3._4.ctor === 'RBNode_elm_builtin') && (_p28._3._4._0.ctor === 'Red')) {
																	break _v37_1;
																} else {
																	if (((((_p28._0.ctor === 'BBlack') && (_p28._4._3.ctor === 'RBNode_elm_builtin')) && (_p28._4._3._0.ctor === 'Black')) && (_p28._4._4.ctor === 'RBNode_elm_builtin')) && (_p28._4._4._0.ctor === 'Black')) {
																		break _v37_4;
																	} else {
																		break _v37_6;
																	}
																}
															}
														default:
															if ((_p28._3._3.ctor === 'RBNode_elm_builtin') && (_p28._3._3._0.ctor === 'Red')) {
																break _v37_0;
															} else {
																if ((_p28._3._4.ctor === 'RBNode_elm_builtin') && (_p28._3._4._0.ctor === 'Red')) {
																	break _v37_1;
																} else {
																	break _v37_6;
																}
															}
													}
												case 'NBlack':
													switch (_p28._4._0.ctor) {
														case 'Red':
															if ((_p28._4._3.ctor === 'RBNode_elm_builtin') && (_p28._4._3._0.ctor === 'Red')) {
																break _v37_2;
															} else {
																if ((_p28._4._4.ctor === 'RBNode_elm_builtin') && (_p28._4._4._0.ctor === 'Red')) {
																	break _v37_3;
																} else {
																	if (((((_p28._0.ctor === 'BBlack') && (_p28._3._3.ctor === 'RBNode_elm_builtin')) && (_p28._3._3._0.ctor === 'Black')) && (_p28._3._4.ctor === 'RBNode_elm_builtin')) && (_p28._3._4._0.ctor === 'Black')) {
																		break _v37_5;
																	} else {
																		break _v37_6;
																	}
																}
															}
														case 'NBlack':
															if (_p28._0.ctor === 'BBlack') {
																if ((((_p28._4._3.ctor === 'RBNode_elm_builtin') && (_p28._4._3._0.ctor === 'Black')) && (_p28._4._4.ctor === 'RBNode_elm_builtin')) && (_p28._4._4._0.ctor === 'Black')) {
																	break _v37_4;
																} else {
																	if ((((_p28._3._3.ctor === 'RBNode_elm_builtin') && (_p28._3._3._0.ctor === 'Black')) && (_p28._3._4.ctor === 'RBNode_elm_builtin')) && (_p28._3._4._0.ctor === 'Black')) {
																		break _v37_5;
																	} else {
																		break _v37_6;
																	}
																}
															} else {
																break _v37_6;
															}
														default:
															if (((((_p28._0.ctor === 'BBlack') && (_p28._3._3.ctor === 'RBNode_elm_builtin')) && (_p28._3._3._0.ctor === 'Black')) && (_p28._3._4.ctor === 'RBNode_elm_builtin')) && (_p28._3._4._0.ctor === 'Black')) {
																break _v37_5;
															} else {
																break _v37_6;
															}
													}
												default:
													switch (_p28._4._0.ctor) {
														case 'Red':
															if ((_p28._4._3.ctor === 'RBNode_elm_builtin') && (_p28._4._3._0.ctor === 'Red')) {
																break _v37_2;
															} else {
																if ((_p28._4._4.ctor === 'RBNode_elm_builtin') && (_p28._4._4._0.ctor === 'Red')) {
																	break _v37_3;
																} else {
																	break _v37_6;
																}
															}
														case 'NBlack':
															if (((((_p28._0.ctor === 'BBlack') && (_p28._4._3.ctor === 'RBNode_elm_builtin')) && (_p28._4._3._0.ctor === 'Black')) && (_p28._4._4.ctor === 'RBNode_elm_builtin')) && (_p28._4._4._0.ctor === 'Black')) {
																break _v37_4;
															} else {
																break _v37_6;
															}
														default:
															break _v37_6;
													}
											}
										} else {
											switch (_p28._3._0.ctor) {
												case 'Red':
													if ((_p28._3._3.ctor === 'RBNode_elm_builtin') && (_p28._3._3._0.ctor === 'Red')) {
														break _v37_0;
													} else {
														if ((_p28._3._4.ctor === 'RBNode_elm_builtin') && (_p28._3._4._0.ctor === 'Red')) {
															break _v37_1;
														} else {
															break _v37_6;
														}
													}
												case 'NBlack':
													if (((((_p28._0.ctor === 'BBlack') && (_p28._3._3.ctor === 'RBNode_elm_builtin')) && (_p28._3._3._0.ctor === 'Black')) && (_p28._3._4.ctor === 'RBNode_elm_builtin')) && (_p28._3._4._0.ctor === 'Black')) {
														break _v37_5;
													} else {
														break _v37_6;
													}
												default:
													break _v37_6;
											}
										}
									} else {
										if (_p28._4.ctor === 'RBNode_elm_builtin') {
											switch (_p28._4._0.ctor) {
												case 'Red':
													if ((_p28._4._3.ctor === 'RBNode_elm_builtin') && (_p28._4._3._0.ctor === 'Red')) {
														break _v37_2;
													} else {
														if ((_p28._4._4.ctor === 'RBNode_elm_builtin') && (_p28._4._4._0.ctor === 'Red')) {
															break _v37_3;
														} else {
															break _v37_6;
														}
													}
												case 'NBlack':
													if (((((_p28._0.ctor === 'BBlack') && (_p28._4._3.ctor === 'RBNode_elm_builtin')) && (_p28._4._3._0.ctor === 'Black')) && (_p28._4._4.ctor === 'RBNode_elm_builtin')) && (_p28._4._4._0.ctor === 'Black')) {
														break _v37_4;
													} else {
														break _v37_6;
													}
												default:
													break _v37_6;
											}
										} else {
											break _v37_6;
										}
									}
								} else {
									break _v37_6;
								}
							} while(false);
							return _elm_lang$core$Dict$balancedTree(_p28._0)(_p28._3._3._1)(_p28._3._3._2)(_p28._3._1)(_p28._3._2)(_p28._1)(_p28._2)(_p28._3._3._3)(_p28._3._3._4)(_p28._3._4)(_p28._4);
						} while(false);
						return _elm_lang$core$Dict$balancedTree(_p28._0)(_p28._3._1)(_p28._3._2)(_p28._3._4._1)(_p28._3._4._2)(_p28._1)(_p28._2)(_p28._3._3)(_p28._3._4._3)(_p28._3._4._4)(_p28._4);
					} while(false);
					return _elm_lang$core$Dict$balancedTree(_p28._0)(_p28._1)(_p28._2)(_p28._4._3._1)(_p28._4._3._2)(_p28._4._1)(_p28._4._2)(_p28._3)(_p28._4._3._3)(_p28._4._3._4)(_p28._4._4);
				} while(false);
				return _elm_lang$core$Dict$balancedTree(_p28._0)(_p28._1)(_p28._2)(_p28._4._1)(_p28._4._2)(_p28._4._4._1)(_p28._4._4._2)(_p28._3)(_p28._4._3)(_p28._4._4._3)(_p28._4._4._4);
			} while(false);
			return A5(
				_elm_lang$core$Dict$RBNode_elm_builtin,
				_elm_lang$core$Dict$Black,
				_p28._4._3._1,
				_p28._4._3._2,
				A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p28._1, _p28._2, _p28._3, _p28._4._3._3),
				A5(
					_elm_lang$core$Dict$balance,
					_elm_lang$core$Dict$Black,
					_p28._4._1,
					_p28._4._2,
					_p28._4._3._4,
					_elm_lang$core$Dict$redden(_p28._4._4)));
		} while(false);
		return A5(
			_elm_lang$core$Dict$RBNode_elm_builtin,
			_elm_lang$core$Dict$Black,
			_p28._3._4._1,
			_p28._3._4._2,
			A5(
				_elm_lang$core$Dict$balance,
				_elm_lang$core$Dict$Black,
				_p28._3._1,
				_p28._3._2,
				_elm_lang$core$Dict$redden(_p28._3._3),
				_p28._3._4._3),
			A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p28._1, _p28._2, _p28._3._4._4, _p28._4));
	} while(false);
	return tree;
};
var _elm_lang$core$Dict$balance = F5(
	function (c, k, v, l, r) {
		var tree = A5(_elm_lang$core$Dict$RBNode_elm_builtin, c, k, v, l, r);
		return _elm_lang$core$Dict$blackish(tree) ? _elm_lang$core$Dict$balanceHelp(tree) : tree;
	});
var _elm_lang$core$Dict$bubble = F5(
	function (c, k, v, l, r) {
		return (_elm_lang$core$Dict$isBBlack(l) || _elm_lang$core$Dict$isBBlack(r)) ? A5(
			_elm_lang$core$Dict$balance,
			_elm_lang$core$Dict$moreBlack(c),
			k,
			v,
			_elm_lang$core$Dict$lessBlackTree(l),
			_elm_lang$core$Dict$lessBlackTree(r)) : A5(_elm_lang$core$Dict$RBNode_elm_builtin, c, k, v, l, r);
	});
var _elm_lang$core$Dict$removeMax = F5(
	function (c, k, v, l, r) {
		var _p29 = r;
		if (_p29.ctor === 'RBEmpty_elm_builtin') {
			return A3(_elm_lang$core$Dict$rem, c, l, r);
		} else {
			return A5(
				_elm_lang$core$Dict$bubble,
				c,
				k,
				v,
				l,
				A5(_elm_lang$core$Dict$removeMax, _p29._0, _p29._1, _p29._2, _p29._3, _p29._4));
		}
	});
var _elm_lang$core$Dict$rem = F3(
	function (color, left, right) {
		var _p30 = {ctor: '_Tuple2', _0: left, _1: right};
		if (_p30._0.ctor === 'RBEmpty_elm_builtin') {
			if (_p30._1.ctor === 'RBEmpty_elm_builtin') {
				var _p31 = color;
				switch (_p31.ctor) {
					case 'Red':
						return _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBlack);
					case 'Black':
						return _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBBlack);
					default:
						return _elm_lang$core$Native_Debug.crash('cannot have bblack or nblack nodes at this point');
				}
			} else {
				var _p34 = _p30._1._0;
				var _p33 = _p30._0._0;
				var _p32 = {ctor: '_Tuple3', _0: color, _1: _p33, _2: _p34};
				if ((((_p32.ctor === '_Tuple3') && (_p32._0.ctor === 'Black')) && (_p32._1.ctor === 'LBlack')) && (_p32._2.ctor === 'Red')) {
					return A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p30._1._1, _p30._1._2, _p30._1._3, _p30._1._4);
				} else {
					return A4(
						_elm_lang$core$Dict$reportRemBug,
						'Black/LBlack/Red',
						color,
						_elm_lang$core$Basics$toString(_p33),
						_elm_lang$core$Basics$toString(_p34));
				}
			}
		} else {
			if (_p30._1.ctor === 'RBEmpty_elm_builtin') {
				var _p37 = _p30._1._0;
				var _p36 = _p30._0._0;
				var _p35 = {ctor: '_Tuple3', _0: color, _1: _p36, _2: _p37};
				if ((((_p35.ctor === '_Tuple3') && (_p35._0.ctor === 'Black')) && (_p35._1.ctor === 'Red')) && (_p35._2.ctor === 'LBlack')) {
					return A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Black, _p30._0._1, _p30._0._2, _p30._0._3, _p30._0._4);
				} else {
					return A4(
						_elm_lang$core$Dict$reportRemBug,
						'Black/Red/LBlack',
						color,
						_elm_lang$core$Basics$toString(_p36),
						_elm_lang$core$Basics$toString(_p37));
				}
			} else {
				var _p41 = _p30._0._2;
				var _p40 = _p30._0._4;
				var _p39 = _p30._0._1;
				var newLeft = A5(_elm_lang$core$Dict$removeMax, _p30._0._0, _p39, _p41, _p30._0._3, _p40);
				var _p38 = A3(_elm_lang$core$Dict$maxWithDefault, _p39, _p41, _p40);
				var k = _p38._0;
				var v = _p38._1;
				return A5(_elm_lang$core$Dict$bubble, color, k, v, newLeft, right);
			}
		}
	});
var _elm_lang$core$Dict$map = F2(
	function (f, dict) {
		var _p42 = dict;
		if (_p42.ctor === 'RBEmpty_elm_builtin') {
			return _elm_lang$core$Dict$RBEmpty_elm_builtin(_elm_lang$core$Dict$LBlack);
		} else {
			var _p43 = _p42._1;
			return A5(
				_elm_lang$core$Dict$RBNode_elm_builtin,
				_p42._0,
				_p43,
				A2(f, _p43, _p42._2),
				A2(_elm_lang$core$Dict$map, f, _p42._3),
				A2(_elm_lang$core$Dict$map, f, _p42._4));
		}
	});
var _elm_lang$core$Dict$Same = {ctor: 'Same'};
var _elm_lang$core$Dict$Remove = {ctor: 'Remove'};
var _elm_lang$core$Dict$Insert = {ctor: 'Insert'};
var _elm_lang$core$Dict$update = F3(
	function (k, alter, dict) {
		var up = function (dict) {
			var _p44 = dict;
			if (_p44.ctor === 'RBEmpty_elm_builtin') {
				var _p45 = alter(_elm_lang$core$Maybe$Nothing);
				if (_p45.ctor === 'Nothing') {
					return {ctor: '_Tuple2', _0: _elm_lang$core$Dict$Same, _1: _elm_lang$core$Dict$empty};
				} else {
					return {
						ctor: '_Tuple2',
						_0: _elm_lang$core$Dict$Insert,
						_1: A5(_elm_lang$core$Dict$RBNode_elm_builtin, _elm_lang$core$Dict$Red, k, _p45._0, _elm_lang$core$Dict$empty, _elm_lang$core$Dict$empty)
					};
				}
			} else {
				var _p56 = _p44._2;
				var _p55 = _p44._4;
				var _p54 = _p44._3;
				var _p53 = _p44._1;
				var _p52 = _p44._0;
				var _p46 = A2(_elm_lang$core$Dict$keyCompare, k, _p53);
				switch (_p46.ctor) {
					case 'EQ':
						var _p47 = alter(
							_elm_lang$core$Maybe$Just(_p56));
						if (_p47.ctor === 'Nothing') {
							return {
								ctor: '_Tuple2',
								_0: _elm_lang$core$Dict$Remove,
								_1: A3(_elm_lang$core$Dict$rem, _p52, _p54, _p55)
							};
						} else {
							return {
								ctor: '_Tuple2',
								_0: _elm_lang$core$Dict$Same,
								_1: A5(_elm_lang$core$Dict$RBNode_elm_builtin, _p52, _p53, _p47._0, _p54, _p55)
							};
						}
					case 'LT':
						var _p48 = up(_p54);
						var flag = _p48._0;
						var newLeft = _p48._1;
						var _p49 = flag;
						switch (_p49.ctor) {
							case 'Same':
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Same,
									_1: A5(_elm_lang$core$Dict$RBNode_elm_builtin, _p52, _p53, _p56, newLeft, _p55)
								};
							case 'Insert':
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Insert,
									_1: A5(_elm_lang$core$Dict$balance, _p52, _p53, _p56, newLeft, _p55)
								};
							default:
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Remove,
									_1: A5(_elm_lang$core$Dict$bubble, _p52, _p53, _p56, newLeft, _p55)
								};
						}
					default:
						var _p50 = up(_p55);
						var flag = _p50._0;
						var newRight = _p50._1;
						var _p51 = flag;
						switch (_p51.ctor) {
							case 'Same':
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Same,
									_1: A5(_elm_lang$core$Dict$RBNode_elm_builtin, _p52, _p53, _p56, _p54, newRight)
								};
							case 'Insert':
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Insert,
									_1: A5(_elm_lang$core$Dict$balance, _p52, _p53, _p56, _p54, newRight)
								};
							default:
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Dict$Remove,
									_1: A5(_elm_lang$core$Dict$bubble, _p52, _p53, _p56, _p54, newRight)
								};
						}
				}
			}
		};
		var _p57 = up(dict);
		var flag = _p57._0;
		var updatedDict = _p57._1;
		var _p58 = flag;
		switch (_p58.ctor) {
			case 'Same':
				return updatedDict;
			case 'Insert':
				return _elm_lang$core$Dict$ensureBlackRoot(updatedDict);
			default:
				return _elm_lang$core$Dict$blacken(updatedDict);
		}
	});
var _elm_lang$core$Dict$insert = F3(
	function (key, value, dict) {
		return A3(
			_elm_lang$core$Dict$update,
			key,
			_elm_lang$core$Basics$always(
				_elm_lang$core$Maybe$Just(value)),
			dict);
	});
var _elm_lang$core$Dict$singleton = F2(
	function (key, value) {
		return A3(_elm_lang$core$Dict$insert, key, value, _elm_lang$core$Dict$empty);
	});
var _elm_lang$core$Dict$union = F2(
	function (t1, t2) {
		return A3(_elm_lang$core$Dict$foldl, _elm_lang$core$Dict$insert, t2, t1);
	});
var _elm_lang$core$Dict$filter = F2(
	function (predicate, dictionary) {
		var add = F3(
			function (key, value, dict) {
				return A2(predicate, key, value) ? A3(_elm_lang$core$Dict$insert, key, value, dict) : dict;
			});
		return A3(_elm_lang$core$Dict$foldl, add, _elm_lang$core$Dict$empty, dictionary);
	});
var _elm_lang$core$Dict$intersect = F2(
	function (t1, t2) {
		return A2(
			_elm_lang$core$Dict$filter,
			F2(
				function (k, _p59) {
					return A2(_elm_lang$core$Dict$member, k, t2);
				}),
			t1);
	});
var _elm_lang$core$Dict$partition = F2(
	function (predicate, dict) {
		var add = F3(
			function (key, value, _p60) {
				var _p61 = _p60;
				var _p63 = _p61._1;
				var _p62 = _p61._0;
				return A2(predicate, key, value) ? {
					ctor: '_Tuple2',
					_0: A3(_elm_lang$core$Dict$insert, key, value, _p62),
					_1: _p63
				} : {
					ctor: '_Tuple2',
					_0: _p62,
					_1: A3(_elm_lang$core$Dict$insert, key, value, _p63)
				};
			});
		return A3(
			_elm_lang$core$Dict$foldl,
			add,
			{ctor: '_Tuple2', _0: _elm_lang$core$Dict$empty, _1: _elm_lang$core$Dict$empty},
			dict);
	});
var _elm_lang$core$Dict$fromList = function (assocs) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (_p64, dict) {
				var _p65 = _p64;
				return A3(_elm_lang$core$Dict$insert, _p65._0, _p65._1, dict);
			}),
		_elm_lang$core$Dict$empty,
		assocs);
};
var _elm_lang$core$Dict$remove = F2(
	function (key, dict) {
		return A3(
			_elm_lang$core$Dict$update,
			key,
			_elm_lang$core$Basics$always(_elm_lang$core$Maybe$Nothing),
			dict);
	});
var _elm_lang$core$Dict$diff = F2(
	function (t1, t2) {
		return A3(
			_elm_lang$core$Dict$foldl,
			F3(
				function (k, v, t) {
					return A2(_elm_lang$core$Dict$remove, k, t);
				}),
			t1,
			t2);
	});

var _elm_lang$core$Set$foldr = F3(
	function (f, b, _p0) {
		var _p1 = _p0;
		return A3(
			_elm_lang$core$Dict$foldr,
			F3(
				function (k, _p2, b) {
					return A2(f, k, b);
				}),
			b,
			_p1._0);
	});
var _elm_lang$core$Set$foldl = F3(
	function (f, b, _p3) {
		var _p4 = _p3;
		return A3(
			_elm_lang$core$Dict$foldl,
			F3(
				function (k, _p5, b) {
					return A2(f, k, b);
				}),
			b,
			_p4._0);
	});
var _elm_lang$core$Set$toList = function (_p6) {
	var _p7 = _p6;
	return _elm_lang$core$Dict$keys(_p7._0);
};
var _elm_lang$core$Set$size = function (_p8) {
	var _p9 = _p8;
	return _elm_lang$core$Dict$size(_p9._0);
};
var _elm_lang$core$Set$member = F2(
	function (k, _p10) {
		var _p11 = _p10;
		return A2(_elm_lang$core$Dict$member, k, _p11._0);
	});
var _elm_lang$core$Set$isEmpty = function (_p12) {
	var _p13 = _p12;
	return _elm_lang$core$Dict$isEmpty(_p13._0);
};
var _elm_lang$core$Set$Set_elm_builtin = function (a) {
	return {ctor: 'Set_elm_builtin', _0: a};
};
var _elm_lang$core$Set$empty = _elm_lang$core$Set$Set_elm_builtin(_elm_lang$core$Dict$empty);
var _elm_lang$core$Set$singleton = function (k) {
	return _elm_lang$core$Set$Set_elm_builtin(
		A2(
			_elm_lang$core$Dict$singleton,
			k,
			{ctor: '_Tuple0'}));
};
var _elm_lang$core$Set$insert = F2(
	function (k, _p14) {
		var _p15 = _p14;
		return _elm_lang$core$Set$Set_elm_builtin(
			A3(
				_elm_lang$core$Dict$insert,
				k,
				{ctor: '_Tuple0'},
				_p15._0));
	});
var _elm_lang$core$Set$fromList = function (xs) {
	return A3(_elm_lang$core$List$foldl, _elm_lang$core$Set$insert, _elm_lang$core$Set$empty, xs);
};
var _elm_lang$core$Set$map = F2(
	function (f, s) {
		return _elm_lang$core$Set$fromList(
			A2(
				_elm_lang$core$List$map,
				f,
				_elm_lang$core$Set$toList(s)));
	});
var _elm_lang$core$Set$remove = F2(
	function (k, _p16) {
		var _p17 = _p16;
		return _elm_lang$core$Set$Set_elm_builtin(
			A2(_elm_lang$core$Dict$remove, k, _p17._0));
	});
var _elm_lang$core$Set$union = F2(
	function (_p19, _p18) {
		var _p20 = _p19;
		var _p21 = _p18;
		return _elm_lang$core$Set$Set_elm_builtin(
			A2(_elm_lang$core$Dict$union, _p20._0, _p21._0));
	});
var _elm_lang$core$Set$intersect = F2(
	function (_p23, _p22) {
		var _p24 = _p23;
		var _p25 = _p22;
		return _elm_lang$core$Set$Set_elm_builtin(
			A2(_elm_lang$core$Dict$intersect, _p24._0, _p25._0));
	});
var _elm_lang$core$Set$diff = F2(
	function (_p27, _p26) {
		var _p28 = _p27;
		var _p29 = _p26;
		return _elm_lang$core$Set$Set_elm_builtin(
			A2(_elm_lang$core$Dict$diff, _p28._0, _p29._0));
	});
var _elm_lang$core$Set$filter = F2(
	function (p, _p30) {
		var _p31 = _p30;
		return _elm_lang$core$Set$Set_elm_builtin(
			A2(
				_elm_lang$core$Dict$filter,
				F2(
					function (k, _p32) {
						return p(k);
					}),
				_p31._0));
	});
var _elm_lang$core$Set$partition = F2(
	function (p, _p33) {
		var _p34 = _p33;
		var _p35 = A2(
			_elm_lang$core$Dict$partition,
			F2(
				function (k, _p36) {
					return p(k);
				}),
			_p34._0);
		var p1 = _p35._0;
		var p2 = _p35._1;
		return {
			ctor: '_Tuple2',
			_0: _elm_lang$core$Set$Set_elm_builtin(p1),
			_1: _elm_lang$core$Set$Set_elm_builtin(p2)
		};
	});

var _MikaelMayer$parser$Parser_LanguageKit$isChar = function ($char) {
	return true;
};
var _MikaelMayer$parser$Parser_LanguageKit$isTab = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('\t'));
};
var _MikaelMayer$parser$Parser_LanguageKit$isSpace = function ($char) {
	return _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr(' ')) || (_elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('\n')) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('\r')));
};
var _MikaelMayer$parser$Parser_LanguageKit$chompSpaces = A2(_MikaelMayer$parser$Parser$ignore, _MikaelMayer$parser$Parser$zeroOrMore, _MikaelMayer$parser$Parser_LanguageKit$isSpace);
var _MikaelMayer$parser$Parser_LanguageKit$revAlways = F2(
	function (_p0, keep) {
		return keep;
	});
var _MikaelMayer$parser$Parser_LanguageKit$ignore = F2(
	function (ignoreParser, keepParser) {
		return A3(_MikaelMayer$parser$Parser$map2, _MikaelMayer$parser$Parser_LanguageKit$revAlways, ignoreParser, keepParser);
	});
var _MikaelMayer$parser$Parser_LanguageKit_ops = _MikaelMayer$parser$Parser_LanguageKit_ops || {};
_MikaelMayer$parser$Parser_LanguageKit_ops['|-'] = _MikaelMayer$parser$Parser_LanguageKit$ignore;
var _MikaelMayer$parser$Parser_LanguageKit$sequenceEndMandatory = F5(
	function (end, spaces, parseItem, sep, revItems) {
		var chompRest = function (item) {
			return A5(
				_MikaelMayer$parser$Parser_LanguageKit$sequenceEndMandatory,
				end,
				spaces,
				parseItem,
				sep,
				{ctor: '::', _0: item, _1: revItems});
		};
		return _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser$andThen,
					chompRest,
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(_MikaelMayer$parser$Parser_ops['|.'], parseItem, spaces),
							_MikaelMayer$parser$Parser$symbol(sep)),
						spaces)),
				_1: {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
						_MikaelMayer$parser$Parser$symbol(end),
						_MikaelMayer$parser$Parser$succeed(
							_elm_lang$core$List$reverse(revItems))),
					_1: {ctor: '[]'}
				}
			});
	});
var _MikaelMayer$parser$Parser_LanguageKit$sequenceEndForbidden = F5(
	function (end, spaces, parseItem, sep, revItems) {
		var chompRest = function (item) {
			return A5(
				_MikaelMayer$parser$Parser_LanguageKit$sequenceEndForbidden,
				end,
				spaces,
				parseItem,
				sep,
				{ctor: '::', _0: item, _1: revItems});
		};
		return A2(
			_MikaelMayer$parser$Parser_LanguageKit$ignore,
			spaces,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
						A2(
							_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
							_MikaelMayer$parser$Parser$symbol(sep),
							spaces),
						A2(_MikaelMayer$parser$Parser$andThen, chompRest, parseItem)),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
							_MikaelMayer$parser$Parser$symbol(end),
							_MikaelMayer$parser$Parser$succeed(
								_elm_lang$core$List$reverse(revItems))),
						_1: {ctor: '[]'}
					}
				}));
	});
var _MikaelMayer$parser$Parser_LanguageKit$sequenceEndOptional = F5(
	function (end, spaces, parseItem, sep, revItems) {
		var chompRest = function (item) {
			return A5(
				_MikaelMayer$parser$Parser_LanguageKit$sequenceEndOptional,
				end,
				spaces,
				parseItem,
				sep,
				{ctor: '::', _0: item, _1: revItems});
		};
		var parseEnd = A2(
			_MikaelMayer$parser$Parser$andThen,
			function (_p1) {
				return _MikaelMayer$parser$Parser$succeed(
					_elm_lang$core$List$reverse(revItems));
			},
			_MikaelMayer$parser$Parser$symbol(end));
		return A2(
			_MikaelMayer$parser$Parser_LanguageKit$ignore,
			spaces,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
						A2(
							_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
							_MikaelMayer$parser$Parser$symbol(sep),
							spaces),
						_MikaelMayer$parser$Parser$oneOf(
							{
								ctor: '::',
								_0: A2(_MikaelMayer$parser$Parser$andThen, chompRest, parseItem),
								_1: {
									ctor: '::',
									_0: parseEnd,
									_1: {ctor: '[]'}
								}
							})),
					_1: {
						ctor: '::',
						_0: parseEnd,
						_1: {ctor: '[]'}
					}
				}));
	});
var _MikaelMayer$parser$Parser_LanguageKit$sequenceEnd = F5(
	function (end, spaces, parseItem, sep, trailing) {
		var chompRest = function (item) {
			var _p2 = trailing;
			switch (_p2.ctor) {
				case 'Forbidden':
					return A5(
						_MikaelMayer$parser$Parser_LanguageKit$sequenceEndForbidden,
						end,
						spaces,
						parseItem,
						sep,
						{
							ctor: '::',
							_0: item,
							_1: {ctor: '[]'}
						});
				case 'Optional':
					return A5(
						_MikaelMayer$parser$Parser_LanguageKit$sequenceEndOptional,
						end,
						spaces,
						parseItem,
						sep,
						{
							ctor: '::',
							_0: item,
							_1: {ctor: '[]'}
						});
				default:
					return A2(
						_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
						A2(
							_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
							A2(
								_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
								spaces,
								_MikaelMayer$parser$Parser$symbol(sep)),
							spaces),
						A5(
							_MikaelMayer$parser$Parser_LanguageKit$sequenceEndMandatory,
							end,
							spaces,
							parseItem,
							sep,
							{
								ctor: '::',
								_0: item,
								_1: {ctor: '[]'}
							}));
			}
		};
		return _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A2(_MikaelMayer$parser$Parser$andThen, chompRest, parseItem),
				_1: {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
						_MikaelMayer$parser$Parser$symbol(end),
						_MikaelMayer$parser$Parser$succeed(
							{ctor: '[]'})),
					_1: {ctor: '[]'}
				}
			});
	});
var _MikaelMayer$parser$Parser_LanguageKit$whitespaceHelp = function (parser) {
	return A2(
		_MikaelMayer$parser$Parser_LanguageKit$ignore,
		_MikaelMayer$parser$Parser_LanguageKit$chompSpaces,
		_MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser$andThen,
					function (_p3) {
						return _MikaelMayer$parser$Parser_LanguageKit$whitespaceHelp(parser);
					},
					parser),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$succeed(
						{ctor: '_Tuple0'}),
					_1: {ctor: '[]'}
				}
			}));
};
var _MikaelMayer$parser$Parser_LanguageKit$nestableCommentHelp = F4(
	function (isNotRelevant, start, end, nestLevel) {
		return _MikaelMayer$parser$Parser$lazy(
			function (_p4) {
				return A2(
					_MikaelMayer$parser$Parser_LanguageKit$ignore,
					A2(_MikaelMayer$parser$Parser$ignore, _MikaelMayer$parser$Parser$zeroOrMore, isNotRelevant),
					_MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_LanguageKit$ignore,
								_MikaelMayer$parser$Parser$symbol(end),
								_elm_lang$core$Native_Utils.eq(nestLevel, 1) ? _MikaelMayer$parser$Parser$succeed(
									{ctor: '_Tuple0'}) : A4(_MikaelMayer$parser$Parser_LanguageKit$nestableCommentHelp, isNotRelevant, start, end, nestLevel - 1)),
							_1: {
								ctor: '::',
								_0: A2(
									_MikaelMayer$parser$Parser_LanguageKit$ignore,
									_MikaelMayer$parser$Parser$symbol(start),
									A4(_MikaelMayer$parser$Parser_LanguageKit$nestableCommentHelp, isNotRelevant, start, end, nestLevel + 1)),
								_1: {
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser_LanguageKit$ignore,
										A2(
											_MikaelMayer$parser$Parser$ignore,
											_MikaelMayer$parser$Parser$Exactly(1),
											_MikaelMayer$parser$Parser_LanguageKit$isChar),
										A4(_MikaelMayer$parser$Parser_LanguageKit$nestableCommentHelp, isNotRelevant, start, end, nestLevel)),
									_1: {ctor: '[]'}
								}
							}
						}));
			});
	});
var _MikaelMayer$parser$Parser_LanguageKit$nestableComment = F2(
	function (start, end) {
		var _p5 = {
			ctor: '_Tuple2',
			_0: _elm_lang$core$String$uncons(start),
			_1: _elm_lang$core$String$uncons(end)
		};
		if (_p5._0.ctor === 'Nothing') {
			return _MikaelMayer$parser$Parser$fail('Trying to parse a multi-line comment, but the start token cannot be the empty string!');
		} else {
			if (_p5._1.ctor === 'Nothing') {
				return _MikaelMayer$parser$Parser$fail('Trying to parse a multi-line comment, but the end token cannot be the empty string!');
			} else {
				var isNotRelevant = function ($char) {
					return (!_elm_lang$core$Native_Utils.eq($char, _p5._0._0._0)) && (!_elm_lang$core$Native_Utils.eq($char, _p5._1._0._0));
				};
				return A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$symbol(start),
					A4(_MikaelMayer$parser$Parser_LanguageKit$nestableCommentHelp, isNotRelevant, start, end, 1));
			}
		}
	});
var _MikaelMayer$parser$Parser_LanguageKit$whitespace = function (_p6) {
	var _p7 = _p6;
	var multiParser = function () {
		var _p8 = _p7.multiComment;
		switch (_p8.ctor) {
			case 'NoMultiComment':
				return {ctor: '[]'};
			case 'UnnestableComment':
				return {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$symbol(_p8._0),
						_MikaelMayer$parser$Parser$ignoreUntil(_p8._1)),
					_1: {ctor: '[]'}
				};
			default:
				return {
					ctor: '::',
					_0: A2(_MikaelMayer$parser$Parser_LanguageKit$nestableComment, _p8._0, _p8._1),
					_1: {ctor: '[]'}
				};
		}
	}();
	var lineParser = function () {
		var _p9 = _p7.lineComment;
		if (_p9.ctor === 'NoLineComment') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$symbol(_p9._0),
					_MikaelMayer$parser$Parser$ignoreUntil('\n')),
				_1: {ctor: '[]'}
			};
		}
	}();
	var tabParser = _p7.allowTabs ? {
		ctor: '::',
		_0: A2(_MikaelMayer$parser$Parser$ignore, _MikaelMayer$parser$Parser$zeroOrMore, _MikaelMayer$parser$Parser_LanguageKit$isTab),
		_1: {ctor: '[]'}
	} : {ctor: '[]'};
	return _MikaelMayer$parser$Parser_LanguageKit$whitespaceHelp(
		_MikaelMayer$parser$Parser$oneOf(
			A2(
				_elm_lang$core$Basics_ops['++'],
				tabParser,
				A2(_elm_lang$core$Basics_ops['++'], lineParser, multiParser))));
};
var _MikaelMayer$parser$Parser_LanguageKit$sequence = function (_p10) {
	var _p11 = _p10;
	var _p12 = _p11.spaces;
	return A2(
		_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
		A2(
			_MikaelMayer$parser$Parser_LanguageKit_ops['|-'],
			_MikaelMayer$parser$Parser$symbol(_p11.start),
			_p12),
		A5(_MikaelMayer$parser$Parser_LanguageKit$sequenceEnd, _p11.end, _p12, _p11.item, _p11.separator, _p11.trailing));
};
var _MikaelMayer$parser$Parser_LanguageKit$varHelp = F7(
	function (isGood, offset, row, col, source, indent, context) {
		varHelp:
		while (true) {
			var newOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, isGood, offset, source);
			if (_elm_lang$core$Native_Utils.eq(newOffset, -1)) {
				return {source: source, offset: offset, indent: indent, context: context, row: row, col: col};
			} else {
				if (_elm_lang$core$Native_Utils.eq(newOffset, -2)) {
					var _v6 = isGood,
						_v7 = offset + 1,
						_v8 = row + 1,
						_v9 = 1,
						_v10 = source,
						_v11 = indent,
						_v12 = context;
					isGood = _v6;
					offset = _v7;
					row = _v8;
					col = _v9;
					source = _v10;
					indent = _v11;
					context = _v12;
					continue varHelp;
				} else {
					var _v13 = isGood,
						_v14 = newOffset,
						_v15 = row,
						_v16 = col + 1,
						_v17 = source,
						_v18 = indent,
						_v19 = context;
					isGood = _v13;
					offset = _v14;
					row = _v15;
					col = _v16;
					source = _v17;
					indent = _v18;
					context = _v19;
					continue varHelp;
				}
			}
		}
	});
var _MikaelMayer$parser$Parser_LanguageKit$variable = F3(
	function (isFirst, isOther, keywords) {
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (_p13) {
				var _p14 = _p13;
				var _p20 = _p14;
				var _p19 = _p14.source;
				var _p18 = _p14.row;
				var _p17 = _p14.offset;
				var _p16 = _p14.indent;
				var _p15 = _p14.context;
				var firstOffset = A3(_elm_tools$parser_primitives$ParserPrimitives$isSubChar, isFirst, _p17, _p19);
				if (_elm_lang$core$Native_Utils.eq(firstOffset, -1)) {
					return A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$ExpectingVariable, _p20);
				} else {
					var state2 = _elm_lang$core$Native_Utils.eq(firstOffset, -2) ? A7(_MikaelMayer$parser$Parser_LanguageKit$varHelp, isOther, _p17 + 1, _p18 + 1, 1, _p19, _p16, _p15) : A7(_MikaelMayer$parser$Parser_LanguageKit$varHelp, isOther, firstOffset, _p18, _p14.col + 1, _p19, _p16, _p15);
					var name = A3(_elm_lang$core$String$slice, _p17, state2.offset, _p19);
					return A2(_elm_lang$core$Set$member, name, keywords) ? A2(_MikaelMayer$parser$Parser_Internal$Bad, _MikaelMayer$parser$Parser$ExpectingVariable, _p20) : A2(_MikaelMayer$parser$Parser_Internal$Good, name, state2);
				}
			});
	});
var _MikaelMayer$parser$Parser_LanguageKit$Mandatory = {ctor: 'Mandatory'};
var _MikaelMayer$parser$Parser_LanguageKit$Optional = {ctor: 'Optional'};
var _MikaelMayer$parser$Parser_LanguageKit$Forbidden = {ctor: 'Forbidden'};
var _MikaelMayer$parser$Parser_LanguageKit$list = F2(
	function (spaces, item) {
		return _MikaelMayer$parser$Parser_LanguageKit$sequence(
			{start: '[', separator: ',', end: ']', spaces: spaces, item: item, trailing: _MikaelMayer$parser$Parser_LanguageKit$Forbidden});
	});
var _MikaelMayer$parser$Parser_LanguageKit$record = F2(
	function (spaces, item) {
		return _MikaelMayer$parser$Parser_LanguageKit$sequence(
			{start: '{', separator: ',', end: '}', spaces: spaces, item: item, trailing: _MikaelMayer$parser$Parser_LanguageKit$Forbidden});
	});
var _MikaelMayer$parser$Parser_LanguageKit$tuple = F2(
	function (spaces, item) {
		return _MikaelMayer$parser$Parser_LanguageKit$sequence(
			{start: '(', separator: ',', end: ')', spaces: spaces, item: item, trailing: _MikaelMayer$parser$Parser_LanguageKit$Forbidden});
	});
var _MikaelMayer$parser$Parser_LanguageKit$LineComment = function (a) {
	return {ctor: 'LineComment', _0: a};
};
var _MikaelMayer$parser$Parser_LanguageKit$NoLineComment = {ctor: 'NoLineComment'};
var _MikaelMayer$parser$Parser_LanguageKit$UnnestableComment = F2(
	function (a, b) {
		return {ctor: 'UnnestableComment', _0: a, _1: b};
	});
var _MikaelMayer$parser$Parser_LanguageKit$NestableComment = F2(
	function (a, b) {
		return {ctor: 'NestableComment', _0: a, _1: b};
	});
var _MikaelMayer$parser$Parser_LanguageKit$NoMultiComment = {ctor: 'NoMultiComment'};

var _MikaelMayer$parser$Parser_LowLevel$getSource = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(_MikaelMayer$parser$Parser_Internal$Good, state.source, state);
	});
var _MikaelMayer$parser$Parser_LowLevel$getOffset = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(_MikaelMayer$parser$Parser_Internal$Good, state.offset, state);
	});
var _MikaelMayer$parser$Parser_LowLevel$getCol = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(_MikaelMayer$parser$Parser_Internal$Good, state.col, state);
	});
var _MikaelMayer$parser$Parser_LowLevel$getRow = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(_MikaelMayer$parser$Parser_Internal$Good, state.row, state);
	});
var _MikaelMayer$parser$Parser_LowLevel$getPosition = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(
			_MikaelMayer$parser$Parser_Internal$Good,
			{ctor: '_Tuple2', _0: state.row, _1: state.col},
			state);
	});
var _MikaelMayer$parser$Parser_LowLevel$changeIndent = F2(
	function (newIndent, _p0) {
		var _p1 = _p0;
		return {source: _p1.source, offset: _p1.offset, indent: newIndent, context: _p1.context, row: _p1.row, col: _p1.col};
	});
var _MikaelMayer$parser$Parser_LowLevel$withIndentLevel = F2(
	function (newIndent, _p2) {
		var _p3 = _p2;
		return _MikaelMayer$parser$Parser_Internal$Parser(
			function (state1) {
				var _p4 = _p3._0(
					A2(_MikaelMayer$parser$Parser_LowLevel$changeIndent, newIndent, state1));
				if (_p4.ctor === 'Good') {
					return A2(
						_MikaelMayer$parser$Parser_Internal$Good,
						_p4._0,
						A2(_MikaelMayer$parser$Parser_LowLevel$changeIndent, state1.indent, _p4._1));
				} else {
					return A2(
						_MikaelMayer$parser$Parser_Internal$Bad,
						_p4._0,
						A2(_MikaelMayer$parser$Parser_LowLevel$changeIndent, state1.indent, _p4._1));
				}
			});
	});
var _MikaelMayer$parser$Parser_LowLevel$getIndentLevel = _MikaelMayer$parser$Parser_Internal$Parser(
	function (state) {
		return A2(_MikaelMayer$parser$Parser_Internal$Good, state.indent, state);
	});

//import Native.List //

var _elm_lang$core$Native_Array = function() {

// A RRB-Tree has two distinct data types.
// Leaf -> "height"  is always 0
//         "table"   is an array of elements
// Node -> "height"  is always greater than 0
//         "table"   is an array of child nodes
//         "lengths" is an array of accumulated lengths of the child nodes

// M is the maximal table size. 32 seems fast. E is the allowed increase
// of search steps when concatting to find an index. Lower values will
// decrease balancing, but will increase search steps.
var M = 32;
var E = 2;

// An empty array.
var empty = {
	ctor: '_Array',
	height: 0,
	table: []
};


function get(i, array)
{
	if (i < 0 || i >= length(array))
	{
		throw new Error(
			'Index ' + i + ' is out of range. Check the length of ' +
			'your array first or use getMaybe or getWithDefault.');
	}
	return unsafeGet(i, array);
}


function unsafeGet(i, array)
{
	for (var x = array.height; x > 0; x--)
	{
		var slot = i >> (x * 5);
		while (array.lengths[slot] <= i)
		{
			slot++;
		}
		if (slot > 0)
		{
			i -= array.lengths[slot - 1];
		}
		array = array.table[slot];
	}
	return array.table[i];
}


// Sets the value at the index i. Only the nodes leading to i will get
// copied and updated.
function set(i, item, array)
{
	if (i < 0 || length(array) <= i)
	{
		return array;
	}
	return unsafeSet(i, item, array);
}


function unsafeSet(i, item, array)
{
	array = nodeCopy(array);

	if (array.height === 0)
	{
		array.table[i] = item;
	}
	else
	{
		var slot = getSlot(i, array);
		if (slot > 0)
		{
			i -= array.lengths[slot - 1];
		}
		array.table[slot] = unsafeSet(i, item, array.table[slot]);
	}
	return array;
}


function initialize(len, f)
{
	if (len <= 0)
	{
		return empty;
	}
	var h = Math.floor( Math.log(len) / Math.log(M) );
	return initialize_(f, h, 0, len);
}

function initialize_(f, h, from, to)
{
	if (h === 0)
	{
		var table = new Array((to - from) % (M + 1));
		for (var i = 0; i < table.length; i++)
		{
		  table[i] = f(from + i);
		}
		return {
			ctor: '_Array',
			height: 0,
			table: table
		};
	}

	var step = Math.pow(M, h);
	var table = new Array(Math.ceil((to - from) / step));
	var lengths = new Array(table.length);
	for (var i = 0; i < table.length; i++)
	{
		table[i] = initialize_(f, h - 1, from + (i * step), Math.min(from + ((i + 1) * step), to));
		lengths[i] = length(table[i]) + (i > 0 ? lengths[i-1] : 0);
	}
	return {
		ctor: '_Array',
		height: h,
		table: table,
		lengths: lengths
	};
}

function fromList(list)
{
	if (list.ctor === '[]')
	{
		return empty;
	}

	// Allocate M sized blocks (table) and write list elements to it.
	var table = new Array(M);
	var nodes = [];
	var i = 0;

	while (list.ctor !== '[]')
	{
		table[i] = list._0;
		list = list._1;
		i++;

		// table is full, so we can push a leaf containing it into the
		// next node.
		if (i === M)
		{
			var leaf = {
				ctor: '_Array',
				height: 0,
				table: table
			};
			fromListPush(leaf, nodes);
			table = new Array(M);
			i = 0;
		}
	}

	// Maybe there is something left on the table.
	if (i > 0)
	{
		var leaf = {
			ctor: '_Array',
			height: 0,
			table: table.splice(0, i)
		};
		fromListPush(leaf, nodes);
	}

	// Go through all of the nodes and eventually push them into higher nodes.
	for (var h = 0; h < nodes.length - 1; h++)
	{
		if (nodes[h].table.length > 0)
		{
			fromListPush(nodes[h], nodes);
		}
	}

	var head = nodes[nodes.length - 1];
	if (head.height > 0 && head.table.length === 1)
	{
		return head.table[0];
	}
	else
	{
		return head;
	}
}

// Push a node into a higher node as a child.
function fromListPush(toPush, nodes)
{
	var h = toPush.height;

	// Maybe the node on this height does not exist.
	if (nodes.length === h)
	{
		var node = {
			ctor: '_Array',
			height: h + 1,
			table: [],
			lengths: []
		};
		nodes.push(node);
	}

	nodes[h].table.push(toPush);
	var len = length(toPush);
	if (nodes[h].lengths.length > 0)
	{
		len += nodes[h].lengths[nodes[h].lengths.length - 1];
	}
	nodes[h].lengths.push(len);

	if (nodes[h].table.length === M)
	{
		fromListPush(nodes[h], nodes);
		nodes[h] = {
			ctor: '_Array',
			height: h + 1,
			table: [],
			lengths: []
		};
	}
}

// Pushes an item via push_ to the bottom right of a tree.
function push(item, a)
{
	var pushed = push_(item, a);
	if (pushed !== null)
	{
		return pushed;
	}

	var newTree = create(item, a.height);
	return siblise(a, newTree);
}

// Recursively tries to push an item to the bottom-right most
// tree possible. If there is no space left for the item,
// null will be returned.
function push_(item, a)
{
	// Handle resursion stop at leaf level.
	if (a.height === 0)
	{
		if (a.table.length < M)
		{
			var newA = {
				ctor: '_Array',
				height: 0,
				table: a.table.slice()
			};
			newA.table.push(item);
			return newA;
		}
		else
		{
		  return null;
		}
	}

	// Recursively push
	var pushed = push_(item, botRight(a));

	// There was space in the bottom right tree, so the slot will
	// be updated.
	if (pushed !== null)
	{
		var newA = nodeCopy(a);
		newA.table[newA.table.length - 1] = pushed;
		newA.lengths[newA.lengths.length - 1]++;
		return newA;
	}

	// When there was no space left, check if there is space left
	// for a new slot with a tree which contains only the item
	// at the bottom.
	if (a.table.length < M)
	{
		var newSlot = create(item, a.height - 1);
		var newA = nodeCopy(a);
		newA.table.push(newSlot);
		newA.lengths.push(newA.lengths[newA.lengths.length - 1] + length(newSlot));
		return newA;
	}
	else
	{
		return null;
	}
}

// Converts an array into a list of elements.
function toList(a)
{
	return toList_(_elm_lang$core$Native_List.Nil, a);
}

function toList_(list, a)
{
	for (var i = a.table.length - 1; i >= 0; i--)
	{
		list =
			a.height === 0
				? _elm_lang$core$Native_List.Cons(a.table[i], list)
				: toList_(list, a.table[i]);
	}
	return list;
}

// Maps a function over the elements of an array.
function map(f, a)
{
	var newA = {
		ctor: '_Array',
		height: a.height,
		table: new Array(a.table.length)
	};
	if (a.height > 0)
	{
		newA.lengths = a.lengths;
	}
	for (var i = 0; i < a.table.length; i++)
	{
		newA.table[i] =
			a.height === 0
				? f(a.table[i])
				: map(f, a.table[i]);
	}
	return newA;
}

// Maps a function over the elements with their index as first argument.
function indexedMap(f, a)
{
	return indexedMap_(f, a, 0);
}

function indexedMap_(f, a, from)
{
	var newA = {
		ctor: '_Array',
		height: a.height,
		table: new Array(a.table.length)
	};
	if (a.height > 0)
	{
		newA.lengths = a.lengths;
	}
	for (var i = 0; i < a.table.length; i++)
	{
		newA.table[i] =
			a.height === 0
				? A2(f, from + i, a.table[i])
				: indexedMap_(f, a.table[i], i == 0 ? from : from + a.lengths[i - 1]);
	}
	return newA;
}

function foldl(f, b, a)
{
	if (a.height === 0)
	{
		for (var i = 0; i < a.table.length; i++)
		{
			b = A2(f, a.table[i], b);
		}
	}
	else
	{
		for (var i = 0; i < a.table.length; i++)
		{
			b = foldl(f, b, a.table[i]);
		}
	}
	return b;
}

function foldr(f, b, a)
{
	if (a.height === 0)
	{
		for (var i = a.table.length; i--; )
		{
			b = A2(f, a.table[i], b);
		}
	}
	else
	{
		for (var i = a.table.length; i--; )
		{
			b = foldr(f, b, a.table[i]);
		}
	}
	return b;
}

// TODO: currently, it slices the right, then the left. This can be
// optimized.
function slice(from, to, a)
{
	if (from < 0)
	{
		from += length(a);
	}
	if (to < 0)
	{
		to += length(a);
	}
	return sliceLeft(from, sliceRight(to, a));
}

function sliceRight(to, a)
{
	if (to === length(a))
	{
		return a;
	}

	// Handle leaf level.
	if (a.height === 0)
	{
		var newA = { ctor:'_Array', height:0 };
		newA.table = a.table.slice(0, to);
		return newA;
	}

	// Slice the right recursively.
	var right = getSlot(to, a);
	var sliced = sliceRight(to - (right > 0 ? a.lengths[right - 1] : 0), a.table[right]);

	// Maybe the a node is not even needed, as sliced contains the whole slice.
	if (right === 0)
	{
		return sliced;
	}

	// Create new node.
	var newA = {
		ctor: '_Array',
		height: a.height,
		table: a.table.slice(0, right),
		lengths: a.lengths.slice(0, right)
	};
	if (sliced.table.length > 0)
	{
		newA.table[right] = sliced;
		newA.lengths[right] = length(sliced) + (right > 0 ? newA.lengths[right - 1] : 0);
	}
	return newA;
}

function sliceLeft(from, a)
{
	if (from === 0)
	{
		return a;
	}

	// Handle leaf level.
	if (a.height === 0)
	{
		var newA = { ctor:'_Array', height:0 };
		newA.table = a.table.slice(from, a.table.length + 1);
		return newA;
	}

	// Slice the left recursively.
	var left = getSlot(from, a);
	var sliced = sliceLeft(from - (left > 0 ? a.lengths[left - 1] : 0), a.table[left]);

	// Maybe the a node is not even needed, as sliced contains the whole slice.
	if (left === a.table.length - 1)
	{
		return sliced;
	}

	// Create new node.
	var newA = {
		ctor: '_Array',
		height: a.height,
		table: a.table.slice(left, a.table.length + 1),
		lengths: new Array(a.table.length - left)
	};
	newA.table[0] = sliced;
	var len = 0;
	for (var i = 0; i < newA.table.length; i++)
	{
		len += length(newA.table[i]);
		newA.lengths[i] = len;
	}

	return newA;
}

// Appends two trees.
function append(a,b)
{
	if (a.table.length === 0)
	{
		return b;
	}
	if (b.table.length === 0)
	{
		return a;
	}

	var c = append_(a, b);

	// Check if both nodes can be crunshed together.
	if (c[0].table.length + c[1].table.length <= M)
	{
		if (c[0].table.length === 0)
		{
			return c[1];
		}
		if (c[1].table.length === 0)
		{
			return c[0];
		}

		// Adjust .table and .lengths
		c[0].table = c[0].table.concat(c[1].table);
		if (c[0].height > 0)
		{
			var len = length(c[0]);
			for (var i = 0; i < c[1].lengths.length; i++)
			{
				c[1].lengths[i] += len;
			}
			c[0].lengths = c[0].lengths.concat(c[1].lengths);
		}

		return c[0];
	}

	if (c[0].height > 0)
	{
		var toRemove = calcToRemove(a, b);
		if (toRemove > E)
		{
			c = shuffle(c[0], c[1], toRemove);
		}
	}

	return siblise(c[0], c[1]);
}

// Returns an array of two nodes; right and left. One node _may_ be empty.
function append_(a, b)
{
	if (a.height === 0 && b.height === 0)
	{
		return [a, b];
	}

	if (a.height !== 1 || b.height !== 1)
	{
		if (a.height === b.height)
		{
			a = nodeCopy(a);
			b = nodeCopy(b);
			var appended = append_(botRight(a), botLeft(b));

			insertRight(a, appended[1]);
			insertLeft(b, appended[0]);
		}
		else if (a.height > b.height)
		{
			a = nodeCopy(a);
			var appended = append_(botRight(a), b);

			insertRight(a, appended[0]);
			b = parentise(appended[1], appended[1].height + 1);
		}
		else
		{
			b = nodeCopy(b);
			var appended = append_(a, botLeft(b));

			var left = appended[0].table.length === 0 ? 0 : 1;
			var right = left === 0 ? 1 : 0;
			insertLeft(b, appended[left]);
			a = parentise(appended[right], appended[right].height + 1);
		}
	}

	// Check if balancing is needed and return based on that.
	if (a.table.length === 0 || b.table.length === 0)
	{
		return [a, b];
	}

	var toRemove = calcToRemove(a, b);
	if (toRemove <= E)
	{
		return [a, b];
	}
	return shuffle(a, b, toRemove);
}

// Helperfunctions for append_. Replaces a child node at the side of the parent.
function insertRight(parent, node)
{
	var index = parent.table.length - 1;
	parent.table[index] = node;
	parent.lengths[index] = length(node);
	parent.lengths[index] += index > 0 ? parent.lengths[index - 1] : 0;
}

function insertLeft(parent, node)
{
	if (node.table.length > 0)
	{
		parent.table[0] = node;
		parent.lengths[0] = length(node);

		var len = length(parent.table[0]);
		for (var i = 1; i < parent.lengths.length; i++)
		{
			len += length(parent.table[i]);
			parent.lengths[i] = len;
		}
	}
	else
	{
		parent.table.shift();
		for (var i = 1; i < parent.lengths.length; i++)
		{
			parent.lengths[i] = parent.lengths[i] - parent.lengths[0];
		}
		parent.lengths.shift();
	}
}

// Returns the extra search steps for E. Refer to the paper.
function calcToRemove(a, b)
{
	var subLengths = 0;
	for (var i = 0; i < a.table.length; i++)
	{
		subLengths += a.table[i].table.length;
	}
	for (var i = 0; i < b.table.length; i++)
	{
		subLengths += b.table[i].table.length;
	}

	var toRemove = a.table.length + b.table.length;
	return toRemove - (Math.floor((subLengths - 1) / M) + 1);
}

// get2, set2 and saveSlot are helpers for accessing elements over two arrays.
function get2(a, b, index)
{
	return index < a.length
		? a[index]
		: b[index - a.length];
}

function set2(a, b, index, value)
{
	if (index < a.length)
	{
		a[index] = value;
	}
	else
	{
		b[index - a.length] = value;
	}
}

function saveSlot(a, b, index, slot)
{
	set2(a.table, b.table, index, slot);

	var l = (index === 0 || index === a.lengths.length)
		? 0
		: get2(a.lengths, a.lengths, index - 1);

	set2(a.lengths, b.lengths, index, l + length(slot));
}

// Creates a node or leaf with a given length at their arrays for perfomance.
// Is only used by shuffle.
function createNode(h, length)
{
	if (length < 0)
	{
		length = 0;
	}
	var a = {
		ctor: '_Array',
		height: h,
		table: new Array(length)
	};
	if (h > 0)
	{
		a.lengths = new Array(length);
	}
	return a;
}

// Returns an array of two balanced nodes.
function shuffle(a, b, toRemove)
{
	var newA = createNode(a.height, Math.min(M, a.table.length + b.table.length - toRemove));
	var newB = createNode(a.height, newA.table.length - (a.table.length + b.table.length - toRemove));

	// Skip the slots with size M. More precise: copy the slot references
	// to the new node
	var read = 0;
	while (get2(a.table, b.table, read).table.length % M === 0)
	{
		set2(newA.table, newB.table, read, get2(a.table, b.table, read));
		set2(newA.lengths, newB.lengths, read, get2(a.lengths, b.lengths, read));
		read++;
	}

	// Pulling items from left to right, caching in a slot before writing
	// it into the new nodes.
	var write = read;
	var slot = new createNode(a.height - 1, 0);
	var from = 0;

	// If the current slot is still containing data, then there will be at
	// least one more write, so we do not break this loop yet.
	while (read - write - (slot.table.length > 0 ? 1 : 0) < toRemove)
	{
		// Find out the max possible items for copying.
		var source = get2(a.table, b.table, read);
		var to = Math.min(M - slot.table.length, source.table.length);

		// Copy and adjust size table.
		slot.table = slot.table.concat(source.table.slice(from, to));
		if (slot.height > 0)
		{
			var len = slot.lengths.length;
			for (var i = len; i < len + to - from; i++)
			{
				slot.lengths[i] = length(slot.table[i]);
				slot.lengths[i] += (i > 0 ? slot.lengths[i - 1] : 0);
			}
		}

		from += to;

		// Only proceed to next slots[i] if the current one was
		// fully copied.
		if (source.table.length <= to)
		{
			read++; from = 0;
		}

		// Only create a new slot if the current one is filled up.
		if (slot.table.length === M)
		{
			saveSlot(newA, newB, write, slot);
			slot = createNode(a.height - 1, 0);
			write++;
		}
	}

	// Cleanup after the loop. Copy the last slot into the new nodes.
	if (slot.table.length > 0)
	{
		saveSlot(newA, newB, write, slot);
		write++;
	}

	// Shift the untouched slots to the left
	while (read < a.table.length + b.table.length )
	{
		saveSlot(newA, newB, write, get2(a.table, b.table, read));
		read++;
		write++;
	}

	return [newA, newB];
}

// Navigation functions
function botRight(a)
{
	return a.table[a.table.length - 1];
}
function botLeft(a)
{
	return a.table[0];
}

// Copies a node for updating. Note that you should not use this if
// only updating only one of "table" or "lengths" for performance reasons.
function nodeCopy(a)
{
	var newA = {
		ctor: '_Array',
		height: a.height,
		table: a.table.slice()
	};
	if (a.height > 0)
	{
		newA.lengths = a.lengths.slice();
	}
	return newA;
}

// Returns how many items are in the tree.
function length(array)
{
	if (array.height === 0)
	{
		return array.table.length;
	}
	else
	{
		return array.lengths[array.lengths.length - 1];
	}
}

// Calculates in which slot of "table" the item probably is, then
// find the exact slot via forward searching in  "lengths". Returns the index.
function getSlot(i, a)
{
	var slot = i >> (5 * a.height);
	while (a.lengths[slot] <= i)
	{
		slot++;
	}
	return slot;
}

// Recursively creates a tree with a given height containing
// only the given item.
function create(item, h)
{
	if (h === 0)
	{
		return {
			ctor: '_Array',
			height: 0,
			table: [item]
		};
	}
	return {
		ctor: '_Array',
		height: h,
		table: [create(item, h - 1)],
		lengths: [1]
	};
}

// Recursively creates a tree that contains the given tree.
function parentise(tree, h)
{
	if (h === tree.height)
	{
		return tree;
	}

	return {
		ctor: '_Array',
		height: h,
		table: [parentise(tree, h - 1)],
		lengths: [length(tree)]
	};
}

// Emphasizes blood brotherhood beneath two trees.
function siblise(a, b)
{
	return {
		ctor: '_Array',
		height: a.height + 1,
		table: [a, b],
		lengths: [length(a), length(a) + length(b)]
	};
}

function toJSArray(a)
{
	var jsArray = new Array(length(a));
	toJSArray_(jsArray, 0, a);
	return jsArray;
}

function toJSArray_(jsArray, i, a)
{
	for (var t = 0; t < a.table.length; t++)
	{
		if (a.height === 0)
		{
			jsArray[i + t] = a.table[t];
		}
		else
		{
			var inc = t === 0 ? 0 : a.lengths[t - 1];
			toJSArray_(jsArray, i + inc, a.table[t]);
		}
	}
}

function fromJSArray(jsArray)
{
	if (jsArray.length === 0)
	{
		return empty;
	}
	var h = Math.floor(Math.log(jsArray.length) / Math.log(M));
	return fromJSArray_(jsArray, h, 0, jsArray.length);
}

function fromJSArray_(jsArray, h, from, to)
{
	if (h === 0)
	{
		return {
			ctor: '_Array',
			height: 0,
			table: jsArray.slice(from, to)
		};
	}

	var step = Math.pow(M, h);
	var table = new Array(Math.ceil((to - from) / step));
	var lengths = new Array(table.length);
	for (var i = 0; i < table.length; i++)
	{
		table[i] = fromJSArray_(jsArray, h - 1, from + (i * step), Math.min(from + ((i + 1) * step), to));
		lengths[i] = length(table[i]) + (i > 0 ? lengths[i - 1] : 0);
	}
	return {
		ctor: '_Array',
		height: h,
		table: table,
		lengths: lengths
	};
}

return {
	empty: empty,
	fromList: fromList,
	toList: toList,
	initialize: F2(initialize),
	append: F2(append),
	push: F2(push),
	slice: F3(slice),
	get: F2(get),
	set: F3(set),
	map: F2(map),
	indexedMap: F2(indexedMap),
	foldl: F3(foldl),
	foldr: F3(foldr),
	length: length,

	toJSArray: toJSArray,
	fromJSArray: fromJSArray
};

}();
var _elm_lang$core$Array$append = _elm_lang$core$Native_Array.append;
var _elm_lang$core$Array$length = _elm_lang$core$Native_Array.length;
var _elm_lang$core$Array$isEmpty = function (array) {
	return _elm_lang$core$Native_Utils.eq(
		_elm_lang$core$Array$length(array),
		0);
};
var _elm_lang$core$Array$slice = _elm_lang$core$Native_Array.slice;
var _elm_lang$core$Array$set = _elm_lang$core$Native_Array.set;
var _elm_lang$core$Array$get = F2(
	function (i, array) {
		return ((_elm_lang$core$Native_Utils.cmp(0, i) < 1) && (_elm_lang$core$Native_Utils.cmp(
			i,
			_elm_lang$core$Native_Array.length(array)) < 0)) ? _elm_lang$core$Maybe$Just(
			A2(_elm_lang$core$Native_Array.get, i, array)) : _elm_lang$core$Maybe$Nothing;
	});
var _elm_lang$core$Array$push = _elm_lang$core$Native_Array.push;
var _elm_lang$core$Array$empty = _elm_lang$core$Native_Array.empty;
var _elm_lang$core$Array$filter = F2(
	function (isOkay, arr) {
		var update = F2(
			function (x, xs) {
				return isOkay(x) ? A2(_elm_lang$core$Native_Array.push, x, xs) : xs;
			});
		return A3(_elm_lang$core$Native_Array.foldl, update, _elm_lang$core$Native_Array.empty, arr);
	});
var _elm_lang$core$Array$foldr = _elm_lang$core$Native_Array.foldr;
var _elm_lang$core$Array$foldl = _elm_lang$core$Native_Array.foldl;
var _elm_lang$core$Array$indexedMap = _elm_lang$core$Native_Array.indexedMap;
var _elm_lang$core$Array$map = _elm_lang$core$Native_Array.map;
var _elm_lang$core$Array$toIndexedList = function (array) {
	return A3(
		_elm_lang$core$List$map2,
		F2(
			function (v0, v1) {
				return {ctor: '_Tuple2', _0: v0, _1: v1};
			}),
		A2(
			_elm_lang$core$List$range,
			0,
			_elm_lang$core$Native_Array.length(array) - 1),
		_elm_lang$core$Native_Array.toList(array));
};
var _elm_lang$core$Array$toList = _elm_lang$core$Native_Array.toList;
var _elm_lang$core$Array$fromList = _elm_lang$core$Native_Array.fromList;
var _elm_lang$core$Array$initialize = _elm_lang$core$Native_Array.initialize;
var _elm_lang$core$Array$repeat = F2(
	function (n, e) {
		return A2(
			_elm_lang$core$Array$initialize,
			n,
			_elm_lang$core$Basics$always(e));
	});
var _elm_lang$core$Array$Array = {ctor: 'Array'};

//import Maybe, Native.Array, Native.List, Native.Utils, Result //

var _elm_lang$core$Native_Json = function() {


// CORE DECODERS

function succeed(msg)
{
	return {
		ctor: '<decoder>',
		tag: 'succeed',
		msg: msg
	};
}

function fail(msg)
{
	return {
		ctor: '<decoder>',
		tag: 'fail',
		msg: msg
	};
}

function decodePrimitive(tag)
{
	return {
		ctor: '<decoder>',
		tag: tag
	};
}

function decodeContainer(tag, decoder)
{
	return {
		ctor: '<decoder>',
		tag: tag,
		decoder: decoder
	};
}

function decodeNull(value)
{
	return {
		ctor: '<decoder>',
		tag: 'null',
		value: value
	};
}

function decodeField(field, decoder)
{
	return {
		ctor: '<decoder>',
		tag: 'field',
		field: field,
		decoder: decoder
	};
}

function decodeIndex(index, decoder)
{
	return {
		ctor: '<decoder>',
		tag: 'index',
		index: index,
		decoder: decoder
	};
}

function decodeKeyValuePairs(decoder)
{
	return {
		ctor: '<decoder>',
		tag: 'key-value',
		decoder: decoder
	};
}

function mapMany(f, decoders)
{
	return {
		ctor: '<decoder>',
		tag: 'map-many',
		func: f,
		decoders: decoders
	};
}

function andThen(callback, decoder)
{
	return {
		ctor: '<decoder>',
		tag: 'andThen',
		decoder: decoder,
		callback: callback
	};
}

function oneOf(decoders)
{
	return {
		ctor: '<decoder>',
		tag: 'oneOf',
		decoders: decoders
	};
}


// DECODING OBJECTS

function map1(f, d1)
{
	return mapMany(f, [d1]);
}

function map2(f, d1, d2)
{
	return mapMany(f, [d1, d2]);
}

function map3(f, d1, d2, d3)
{
	return mapMany(f, [d1, d2, d3]);
}

function map4(f, d1, d2, d3, d4)
{
	return mapMany(f, [d1, d2, d3, d4]);
}

function map5(f, d1, d2, d3, d4, d5)
{
	return mapMany(f, [d1, d2, d3, d4, d5]);
}

function map6(f, d1, d2, d3, d4, d5, d6)
{
	return mapMany(f, [d1, d2, d3, d4, d5, d6]);
}

function map7(f, d1, d2, d3, d4, d5, d6, d7)
{
	return mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
}

function map8(f, d1, d2, d3, d4, d5, d6, d7, d8)
{
	return mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
}


// DECODE HELPERS

function ok(value)
{
	return { tag: 'ok', value: value };
}

function badPrimitive(type, value)
{
	return { tag: 'primitive', type: type, value: value };
}

function badIndex(index, nestedProblems)
{
	return { tag: 'index', index: index, rest: nestedProblems };
}

function badField(field, nestedProblems)
{
	return { tag: 'field', field: field, rest: nestedProblems };
}

function badIndex(index, nestedProblems)
{
	return { tag: 'index', index: index, rest: nestedProblems };
}

function badOneOf(problems)
{
	return { tag: 'oneOf', problems: problems };
}

function bad(msg)
{
	return { tag: 'fail', msg: msg };
}

function badToString(problem)
{
	var context = '_';
	while (problem)
	{
		switch (problem.tag)
		{
			case 'primitive':
				return 'Expecting ' + problem.type
					+ (context === '_' ? '' : ' at ' + context)
					+ ' but instead got: ' + jsToString(problem.value);

			case 'index':
				context += '[' + problem.index + ']';
				problem = problem.rest;
				break;

			case 'field':
				context += '.' + problem.field;
				problem = problem.rest;
				break;

			case 'oneOf':
				var problems = problem.problems;
				for (var i = 0; i < problems.length; i++)
				{
					problems[i] = badToString(problems[i]);
				}
				return 'I ran into the following problems'
					+ (context === '_' ? '' : ' at ' + context)
					+ ':\n\n' + problems.join('\n');

			case 'fail':
				return 'I ran into a `fail` decoder'
					+ (context === '_' ? '' : ' at ' + context)
					+ ': ' + problem.msg;
		}
	}
}

function jsToString(value)
{
	return value === undefined
		? 'undefined'
		: JSON.stringify(value);
}


// DECODE

function runOnString(decoder, string)
{
	var json;
	try
	{
		json = JSON.parse(string);
	}
	catch (e)
	{
		return _elm_lang$core$Result$Err('Given an invalid JSON: ' + e.message);
	}
	return run(decoder, json);
}

function run(decoder, value)
{
	var result = runHelp(decoder, value);
	return (result.tag === 'ok')
		? _elm_lang$core$Result$Ok(result.value)
		: _elm_lang$core$Result$Err(badToString(result));
}

function runHelp(decoder, value)
{
	switch (decoder.tag)
	{
		case 'bool':
			return (typeof value === 'boolean')
				? ok(value)
				: badPrimitive('a Bool', value);

		case 'int':
			if (typeof value !== 'number') {
				return badPrimitive('an Int', value);
			}

			if (-2147483647 < value && value < 2147483647 && (value | 0) === value) {
				return ok(value);
			}

			if (isFinite(value) && !(value % 1)) {
				return ok(value);
			}

			return badPrimitive('an Int', value);

		case 'float':
			return (typeof value === 'number')
				? ok(value)
				: badPrimitive('a Float', value);

		case 'string':
			return (typeof value === 'string')
				? ok(value)
				: (value instanceof String)
					? ok(value + '')
					: badPrimitive('a String', value);

		case 'null':
			return (value === null)
				? ok(decoder.value)
				: badPrimitive('null', value);

		case 'value':
			return ok(value);

		case 'list':
			if (!(value instanceof Array))
			{
				return badPrimitive('a List', value);
			}

			var list = _elm_lang$core$Native_List.Nil;
			for (var i = value.length; i--; )
			{
				var result = runHelp(decoder.decoder, value[i]);
				if (result.tag !== 'ok')
				{
					return badIndex(i, result)
				}
				list = _elm_lang$core$Native_List.Cons(result.value, list);
			}
			return ok(list);

		case 'array':
			if (!(value instanceof Array))
			{
				return badPrimitive('an Array', value);
			}

			var len = value.length;
			var array = new Array(len);
			for (var i = len; i--; )
			{
				var result = runHelp(decoder.decoder, value[i]);
				if (result.tag !== 'ok')
				{
					return badIndex(i, result);
				}
				array[i] = result.value;
			}
			return ok(_elm_lang$core$Native_Array.fromJSArray(array));

		case 'maybe':
			var result = runHelp(decoder.decoder, value);
			return (result.tag === 'ok')
				? ok(_elm_lang$core$Maybe$Just(result.value))
				: ok(_elm_lang$core$Maybe$Nothing);

		case 'field':
			var field = decoder.field;
			if (typeof value !== 'object' || value === null || !(field in value))
			{
				return badPrimitive('an object with a field named `' + field + '`', value);
			}

			var result = runHelp(decoder.decoder, value[field]);
			return (result.tag === 'ok') ? result : badField(field, result);

		case 'index':
			var index = decoder.index;
			if (!(value instanceof Array))
			{
				return badPrimitive('an array', value);
			}
			if (index >= value.length)
			{
				return badPrimitive('a longer array. Need index ' + index + ' but there are only ' + value.length + ' entries', value);
			}

			var result = runHelp(decoder.decoder, value[index]);
			return (result.tag === 'ok') ? result : badIndex(index, result);

		case 'key-value':
			if (typeof value !== 'object' || value === null || value instanceof Array)
			{
				return badPrimitive('an object', value);
			}

			var keyValuePairs = _elm_lang$core$Native_List.Nil;
			for (var key in value)
			{
				var result = runHelp(decoder.decoder, value[key]);
				if (result.tag !== 'ok')
				{
					return badField(key, result);
				}
				var pair = _elm_lang$core$Native_Utils.Tuple2(key, result.value);
				keyValuePairs = _elm_lang$core$Native_List.Cons(pair, keyValuePairs);
			}
			return ok(keyValuePairs);

		case 'map-many':
			var answer = decoder.func;
			var decoders = decoder.decoders;
			for (var i = 0; i < decoders.length; i++)
			{
				var result = runHelp(decoders[i], value);
				if (result.tag !== 'ok')
				{
					return result;
				}
				answer = answer(result.value);
			}
			return ok(answer);

		case 'andThen':
			var result = runHelp(decoder.decoder, value);
			return (result.tag !== 'ok')
				? result
				: runHelp(decoder.callback(result.value), value);

		case 'oneOf':
			var errors = [];
			var temp = decoder.decoders;
			while (temp.ctor !== '[]')
			{
				var result = runHelp(temp._0, value);

				if (result.tag === 'ok')
				{
					return result;
				}

				errors.push(result);

				temp = temp._1;
			}
			return badOneOf(errors);

		case 'fail':
			return bad(decoder.msg);

		case 'succeed':
			return ok(decoder.msg);
	}
}


// EQUALITY

function equality(a, b)
{
	if (a === b)
	{
		return true;
	}

	if (a.tag !== b.tag)
	{
		return false;
	}

	switch (a.tag)
	{
		case 'succeed':
		case 'fail':
			return a.msg === b.msg;

		case 'bool':
		case 'int':
		case 'float':
		case 'string':
		case 'value':
			return true;

		case 'null':
			return a.value === b.value;

		case 'list':
		case 'array':
		case 'maybe':
		case 'key-value':
			return equality(a.decoder, b.decoder);

		case 'field':
			return a.field === b.field && equality(a.decoder, b.decoder);

		case 'index':
			return a.index === b.index && equality(a.decoder, b.decoder);

		case 'map-many':
			if (a.func !== b.func)
			{
				return false;
			}
			return listEquality(a.decoders, b.decoders);

		case 'andThen':
			return a.callback === b.callback && equality(a.decoder, b.decoder);

		case 'oneOf':
			return listEquality(a.decoders, b.decoders);
	}
}

function listEquality(aDecoders, bDecoders)
{
	var len = aDecoders.length;
	if (len !== bDecoders.length)
	{
		return false;
	}
	for (var i = 0; i < len; i++)
	{
		if (!equality(aDecoders[i], bDecoders[i]))
		{
			return false;
		}
	}
	return true;
}


// ENCODE

function encode(indentLevel, value)
{
	return JSON.stringify(value, null, indentLevel);
}

function identity(value)
{
	return value;
}

function encodeObject(keyValuePairs)
{
	var obj = {};
	while (keyValuePairs.ctor !== '[]')
	{
		var pair = keyValuePairs._0;
		obj[pair._0] = pair._1;
		keyValuePairs = keyValuePairs._1;
	}
	return obj;
}

return {
	encode: F2(encode),
	runOnString: F2(runOnString),
	run: F2(run),

	decodeNull: decodeNull,
	decodePrimitive: decodePrimitive,
	decodeContainer: F2(decodeContainer),

	decodeField: F2(decodeField),
	decodeIndex: F2(decodeIndex),

	map1: F2(map1),
	map2: F3(map2),
	map3: F4(map3),
	map4: F5(map4),
	map5: F6(map5),
	map6: F7(map6),
	map7: F8(map7),
	map8: F9(map8),
	decodeKeyValuePairs: decodeKeyValuePairs,

	andThen: F2(andThen),
	fail: fail,
	succeed: succeed,
	oneOf: oneOf,

	identity: identity,
	encodeNull: null,
	encodeArray: _elm_lang$core$Native_Array.toJSArray,
	encodeList: _elm_lang$core$Native_List.toArray,
	encodeObject: encodeObject,

	equality: equality
};

}();

var _elm_lang$core$Json_Encode$list = _elm_lang$core$Native_Json.encodeList;
var _elm_lang$core$Json_Encode$array = _elm_lang$core$Native_Json.encodeArray;
var _elm_lang$core$Json_Encode$object = _elm_lang$core$Native_Json.encodeObject;
var _elm_lang$core$Json_Encode$null = _elm_lang$core$Native_Json.encodeNull;
var _elm_lang$core$Json_Encode$bool = _elm_lang$core$Native_Json.identity;
var _elm_lang$core$Json_Encode$float = _elm_lang$core$Native_Json.identity;
var _elm_lang$core$Json_Encode$int = _elm_lang$core$Native_Json.identity;
var _elm_lang$core$Json_Encode$string = _elm_lang$core$Native_Json.identity;
var _elm_lang$core$Json_Encode$encode = _elm_lang$core$Native_Json.encode;
var _elm_lang$core$Json_Encode$Value = {ctor: 'Value'};

var _elm_lang$core$Json_Decode$null = _elm_lang$core$Native_Json.decodeNull;
var _elm_lang$core$Json_Decode$value = _elm_lang$core$Native_Json.decodePrimitive('value');
var _elm_lang$core$Json_Decode$andThen = _elm_lang$core$Native_Json.andThen;
var _elm_lang$core$Json_Decode$fail = _elm_lang$core$Native_Json.fail;
var _elm_lang$core$Json_Decode$succeed = _elm_lang$core$Native_Json.succeed;
var _elm_lang$core$Json_Decode$lazy = function (thunk) {
	return A2(
		_elm_lang$core$Json_Decode$andThen,
		thunk,
		_elm_lang$core$Json_Decode$succeed(
			{ctor: '_Tuple0'}));
};
var _elm_lang$core$Json_Decode$decodeValue = _elm_lang$core$Native_Json.run;
var _elm_lang$core$Json_Decode$decodeString = _elm_lang$core$Native_Json.runOnString;
var _elm_lang$core$Json_Decode$map8 = _elm_lang$core$Native_Json.map8;
var _elm_lang$core$Json_Decode$map7 = _elm_lang$core$Native_Json.map7;
var _elm_lang$core$Json_Decode$map6 = _elm_lang$core$Native_Json.map6;
var _elm_lang$core$Json_Decode$map5 = _elm_lang$core$Native_Json.map5;
var _elm_lang$core$Json_Decode$map4 = _elm_lang$core$Native_Json.map4;
var _elm_lang$core$Json_Decode$map3 = _elm_lang$core$Native_Json.map3;
var _elm_lang$core$Json_Decode$map2 = _elm_lang$core$Native_Json.map2;
var _elm_lang$core$Json_Decode$map = _elm_lang$core$Native_Json.map1;
var _elm_lang$core$Json_Decode$oneOf = _elm_lang$core$Native_Json.oneOf;
var _elm_lang$core$Json_Decode$maybe = function (decoder) {
	return A2(_elm_lang$core$Native_Json.decodeContainer, 'maybe', decoder);
};
var _elm_lang$core$Json_Decode$index = _elm_lang$core$Native_Json.decodeIndex;
var _elm_lang$core$Json_Decode$field = _elm_lang$core$Native_Json.decodeField;
var _elm_lang$core$Json_Decode$at = F2(
	function (fields, decoder) {
		return A3(_elm_lang$core$List$foldr, _elm_lang$core$Json_Decode$field, decoder, fields);
	});
var _elm_lang$core$Json_Decode$keyValuePairs = _elm_lang$core$Native_Json.decodeKeyValuePairs;
var _elm_lang$core$Json_Decode$dict = function (decoder) {
	return A2(
		_elm_lang$core$Json_Decode$map,
		_elm_lang$core$Dict$fromList,
		_elm_lang$core$Json_Decode$keyValuePairs(decoder));
};
var _elm_lang$core$Json_Decode$array = function (decoder) {
	return A2(_elm_lang$core$Native_Json.decodeContainer, 'array', decoder);
};
var _elm_lang$core$Json_Decode$list = function (decoder) {
	return A2(_elm_lang$core$Native_Json.decodeContainer, 'list', decoder);
};
var _elm_lang$core$Json_Decode$nullable = function (decoder) {
	return _elm_lang$core$Json_Decode$oneOf(
		{
			ctor: '::',
			_0: _elm_lang$core$Json_Decode$null(_elm_lang$core$Maybe$Nothing),
			_1: {
				ctor: '::',
				_0: A2(_elm_lang$core$Json_Decode$map, _elm_lang$core$Maybe$Just, decoder),
				_1: {ctor: '[]'}
			}
		});
};
var _elm_lang$core$Json_Decode$float = _elm_lang$core$Native_Json.decodePrimitive('float');
var _elm_lang$core$Json_Decode$int = _elm_lang$core$Native_Json.decodePrimitive('int');
var _elm_lang$core$Json_Decode$bool = _elm_lang$core$Native_Json.decodePrimitive('bool');
var _elm_lang$core$Json_Decode$string = _elm_lang$core$Native_Json.decodePrimitive('string');
var _elm_lang$core$Json_Decode$Decoder = {ctor: 'Decoder'};

//import Maybe, Native.List //

var _elm_lang$core$Native_Regex = function() {

function escape(str)
{
	return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function caseInsensitive(re)
{
	return new RegExp(re.source, 'gi');
}
function regex(raw)
{
	return new RegExp(raw, 'g');
}

function contains(re, string)
{
	return string.match(re) !== null;
}

function find(n, re, str)
{
	n = n.ctor === 'All' ? Infinity : n._0;
	var out = [];
	var number = 0;
	var string = str;
	var lastIndex = re.lastIndex;
	var prevLastIndex = -1;
	var result;
	while (number++ < n && (result = re.exec(string)))
	{
		if (prevLastIndex === re.lastIndex) break;
		var i = result.length - 1;
		var subs = new Array(i);
		while (i > 0)
		{
			var submatch = result[i];
			subs[--i] = submatch === undefined
				? _elm_lang$core$Maybe$Nothing
				: _elm_lang$core$Maybe$Just(submatch);
		}
		out.push({
			match: result[0],
			submatches: _elm_lang$core$Native_List.fromArray(subs),
			index: result.index,
			number: number
		});
		prevLastIndex = re.lastIndex;
	}
	re.lastIndex = lastIndex;
	return _elm_lang$core$Native_List.fromArray(out);
}

function replace(n, re, replacer, string)
{
	n = n.ctor === 'All' ? Infinity : n._0;
	var count = 0;
	function jsReplacer(match)
	{
		if (count++ >= n)
		{
			return match;
		}
		var i = arguments.length - 3;
		var submatches = new Array(i);
		while (i > 0)
		{
			var submatch = arguments[i];
			submatches[--i] = submatch === undefined
				? _elm_lang$core$Maybe$Nothing
				: _elm_lang$core$Maybe$Just(submatch);
		}
		return replacer({
			match: match,
			submatches: _elm_lang$core$Native_List.fromArray(submatches),
			index: arguments[arguments.length - 2],
			number: count
		});
	}
	return string.replace(re, jsReplacer);
}

function split(n, re, str)
{
	n = n.ctor === 'All' ? Infinity : n._0;
	if (n === Infinity)
	{
		return _elm_lang$core$Native_List.fromArray(str.split(re));
	}
	var string = str;
	var result;
	var out = [];
	var start = re.lastIndex;
	var restoreLastIndex = re.lastIndex;
	while (n--)
	{
		if (!(result = re.exec(string))) break;
		out.push(string.slice(start, result.index));
		start = re.lastIndex;
	}
	out.push(string.slice(start));
	re.lastIndex = restoreLastIndex;
	return _elm_lang$core$Native_List.fromArray(out);
}

return {
	regex: regex,
	caseInsensitive: caseInsensitive,
	escape: escape,

	contains: F2(contains),
	find: F3(find),
	replace: F4(replace),
	split: F3(split)
};

}();

var _elm_lang$core$Regex$split = _elm_lang$core$Native_Regex.split;
var _elm_lang$core$Regex$replace = _elm_lang$core$Native_Regex.replace;
var _elm_lang$core$Regex$find = _elm_lang$core$Native_Regex.find;
var _elm_lang$core$Regex$contains = _elm_lang$core$Native_Regex.contains;
var _elm_lang$core$Regex$caseInsensitive = _elm_lang$core$Native_Regex.caseInsensitive;
var _elm_lang$core$Regex$regex = _elm_lang$core$Native_Regex.regex;
var _elm_lang$core$Regex$escape = _elm_lang$core$Native_Regex.escape;
var _elm_lang$core$Regex$Match = F4(
	function (a, b, c, d) {
		return {match: a, submatches: b, index: c, number: d};
	});
var _elm_lang$core$Regex$Regex = {ctor: 'Regex'};
var _elm_lang$core$Regex$AtMost = function (a) {
	return {ctor: 'AtMost', _0: a};
};
var _elm_lang$core$Regex$All = {ctor: 'All'};

var _elm_lang$virtual_dom$VirtualDom_Debug$wrap;
var _elm_lang$virtual_dom$VirtualDom_Debug$wrapWithFlags;

var _elm_lang$virtual_dom$Native_VirtualDom = function() {

var STYLE_KEY = 'STYLE';
var EVENT_KEY = 'EVENT';
var ATTR_KEY = 'ATTR';
var ATTR_NS_KEY = 'ATTR_NS';

var localDoc = typeof document !== 'undefined' ? document : {};


////////////  VIRTUAL DOM NODES  ////////////


function text(string)
{
	return {
		type: 'text',
		text: string
	};
}


function node(tag)
{
	return F2(function(factList, kidList) {
		return nodeHelp(tag, factList, kidList);
	});
}


function nodeHelp(tag, factList, kidList)
{
	var organized = organizeFacts(factList);
	var namespace = organized.namespace;
	var facts = organized.facts;

	var children = [];
	var descendantsCount = 0;
	while (kidList.ctor !== '[]')
	{
		var kid = kidList._0;
		descendantsCount += (kid.descendantsCount || 0);
		children.push(kid);
		kidList = kidList._1;
	}
	descendantsCount += children.length;

	return {
		type: 'node',
		tag: tag,
		facts: facts,
		children: children,
		namespace: namespace,
		descendantsCount: descendantsCount
	};
}


function keyedNode(tag, factList, kidList)
{
	var organized = organizeFacts(factList);
	var namespace = organized.namespace;
	var facts = organized.facts;

	var children = [];
	var descendantsCount = 0;
	while (kidList.ctor !== '[]')
	{
		var kid = kidList._0;
		descendantsCount += (kid._1.descendantsCount || 0);
		children.push(kid);
		kidList = kidList._1;
	}
	descendantsCount += children.length;

	return {
		type: 'keyed-node',
		tag: tag,
		facts: facts,
		children: children,
		namespace: namespace,
		descendantsCount: descendantsCount
	};
}


function custom(factList, model, impl)
{
	var facts = organizeFacts(factList).facts;

	return {
		type: 'custom',
		facts: facts,
		model: model,
		impl: impl
	};
}


function map(tagger, node)
{
	return {
		type: 'tagger',
		tagger: tagger,
		node: node,
		descendantsCount: 1 + (node.descendantsCount || 0)
	};
}


function thunk(func, args, thunk)
{
	return {
		type: 'thunk',
		func: func,
		args: args,
		thunk: thunk,
		node: undefined
	};
}

function lazy(fn, a)
{
	return thunk(fn, [a], function() {
		return fn(a);
	});
}

function lazy2(fn, a, b)
{
	return thunk(fn, [a,b], function() {
		return A2(fn, a, b);
	});
}

function lazy3(fn, a, b, c)
{
	return thunk(fn, [a,b,c], function() {
		return A3(fn, a, b, c);
	});
}



// FACTS


function organizeFacts(factList)
{
	var namespace, facts = {};

	while (factList.ctor !== '[]')
	{
		var entry = factList._0;
		var key = entry.key;

		if (key === ATTR_KEY || key === ATTR_NS_KEY || key === EVENT_KEY)
		{
			var subFacts = facts[key] || {};
			subFacts[entry.realKey] = entry.value;
			facts[key] = subFacts;
		}
		else if (key === STYLE_KEY)
		{
			var styles = facts[key] || {};
			var styleList = entry.value;
			while (styleList.ctor !== '[]')
			{
				var style = styleList._0;
				styles[style._0] = style._1;
				styleList = styleList._1;
			}
			facts[key] = styles;
		}
		else if (key === 'namespace')
		{
			namespace = entry.value;
		}
		else if (key === 'className')
		{
			var classes = facts[key];
			facts[key] = typeof classes === 'undefined'
				? entry.value
				: classes + ' ' + entry.value;
		}
 		else
		{
			facts[key] = entry.value;
		}
		factList = factList._1;
	}

	return {
		facts: facts,
		namespace: namespace
	};
}



////////////  PROPERTIES AND ATTRIBUTES  ////////////


function style(value)
{
	return {
		key: STYLE_KEY,
		value: value
	};
}


function property(key, value)
{
	return {
		key: key,
		value: value
	};
}


function attribute(key, value)
{
	return {
		key: ATTR_KEY,
		realKey: key,
		value: value
	};
}


function attributeNS(namespace, key, value)
{
	return {
		key: ATTR_NS_KEY,
		realKey: key,
		value: {
			value: value,
			namespace: namespace
		}
	};
}


function on(name, options, decoder)
{
	return {
		key: EVENT_KEY,
		realKey: name,
		value: {
			options: options,
			decoder: decoder
		}
	};
}


function equalEvents(a, b)
{
	if (a.options !== b.options)
	{
		if (a.options.stopPropagation !== b.options.stopPropagation || a.options.preventDefault !== b.options.preventDefault)
		{
			return false;
		}
	}
	return _elm_lang$core$Native_Json.equality(a.decoder, b.decoder);
}


function mapProperty(func, property)
{
	if (property.key !== EVENT_KEY)
	{
		return property;
	}
	return on(
		property.realKey,
		property.value.options,
		A2(_elm_lang$core$Json_Decode$map, func, property.value.decoder)
	);
}


////////////  RENDER  ////////////


function render(vNode, eventNode)
{
	switch (vNode.type)
	{
		case 'thunk':
			if (!vNode.node)
			{
				vNode.node = vNode.thunk();
			}
			return render(vNode.node, eventNode);

		case 'tagger':
			var subNode = vNode.node;
			var tagger = vNode.tagger;

			while (subNode.type === 'tagger')
			{
				typeof tagger !== 'object'
					? tagger = [tagger, subNode.tagger]
					: tagger.push(subNode.tagger);

				subNode = subNode.node;
			}

			var subEventRoot = { tagger: tagger, parent: eventNode };
			var domNode = render(subNode, subEventRoot);
			domNode.elm_event_node_ref = subEventRoot;
			return domNode;

		case 'text':
			return localDoc.createTextNode(vNode.text);

		case 'node':
			var domNode = vNode.namespace
				? localDoc.createElementNS(vNode.namespace, vNode.tag)
				: localDoc.createElement(vNode.tag);

			applyFacts(domNode, eventNode, vNode.facts);

			var children = vNode.children;

			for (var i = 0; i < children.length; i++)
			{
				domNode.appendChild(render(children[i], eventNode));
			}

			return domNode;

		case 'keyed-node':
			var domNode = vNode.namespace
				? localDoc.createElementNS(vNode.namespace, vNode.tag)
				: localDoc.createElement(vNode.tag);

			applyFacts(domNode, eventNode, vNode.facts);

			var children = vNode.children;

			for (var i = 0; i < children.length; i++)
			{
				domNode.appendChild(render(children[i]._1, eventNode));
			}

			return domNode;

		case 'custom':
			var domNode = vNode.impl.render(vNode.model);
			applyFacts(domNode, eventNode, vNode.facts);
			return domNode;
	}
}



////////////  APPLY FACTS  ////////////


function applyFacts(domNode, eventNode, facts)
{
	for (var key in facts)
	{
		var value = facts[key];

		switch (key)
		{
			case STYLE_KEY:
				applyStyles(domNode, value);
				break;

			case EVENT_KEY:
				applyEvents(domNode, eventNode, value);
				break;

			case ATTR_KEY:
				applyAttrs(domNode, value);
				break;

			case ATTR_NS_KEY:
				applyAttrsNS(domNode, value);
				break;

			case 'value':
				if (domNode[key] !== value)
				{
					domNode[key] = value;
				}
				break;

			default:
				domNode[key] = value;
				break;
		}
	}
}

function applyStyles(domNode, styles)
{
	var domNodeStyle = domNode.style;

	for (var key in styles)
	{
		domNodeStyle[key] = styles[key];
	}
}

function applyEvents(domNode, eventNode, events)
{
	var allHandlers = domNode.elm_handlers || {};

	for (var key in events)
	{
		var handler = allHandlers[key];
		var value = events[key];

		if (typeof value === 'undefined')
		{
			domNode.removeEventListener(key, handler);
			allHandlers[key] = undefined;
		}
		else if (typeof handler === 'undefined')
		{
			var handler = makeEventHandler(eventNode, value);
			domNode.addEventListener(key, handler);
			allHandlers[key] = handler;
		}
		else
		{
			handler.info = value;
		}
	}

	domNode.elm_handlers = allHandlers;
}

function makeEventHandler(eventNode, info)
{
	function eventHandler(event)
	{
		var info = eventHandler.info;

		var value = A2(_elm_lang$core$Native_Json.run, info.decoder, event);

		if (value.ctor === 'Ok')
		{
			var options = info.options;
			if (options.stopPropagation)
			{
				event.stopPropagation();
			}
			if (options.preventDefault)
			{
				event.preventDefault();
			}

			var message = value._0;

			var currentEventNode = eventNode;
			while (currentEventNode)
			{
				var tagger = currentEventNode.tagger;
				if (typeof tagger === 'function')
				{
					message = tagger(message);
				}
				else
				{
					for (var i = tagger.length; i--; )
					{
						message = tagger[i](message);
					}
				}
				currentEventNode = currentEventNode.parent;
			}
		}
	};

	eventHandler.info = info;

	return eventHandler;
}

function applyAttrs(domNode, attrs)
{
	for (var key in attrs)
	{
		var value = attrs[key];
		if (typeof value === 'undefined')
		{
			domNode.removeAttribute(key);
		}
		else
		{
			domNode.setAttribute(key, value);
		}
	}
}

function applyAttrsNS(domNode, nsAttrs)
{
	for (var key in nsAttrs)
	{
		var pair = nsAttrs[key];
		var namespace = pair.namespace;
		var value = pair.value;

		if (typeof value === 'undefined')
		{
			domNode.removeAttributeNS(namespace, key);
		}
		else
		{
			domNode.setAttributeNS(namespace, key, value);
		}
	}
}



////////////  DIFF  ////////////


function diff(a, b)
{
	var patches = [];
	diffHelp(a, b, patches, 0);
	return patches;
}


function makePatch(type, index, data)
{
	return {
		index: index,
		type: type,
		data: data,
		domNode: undefined,
		eventNode: undefined
	};
}


function diffHelp(a, b, patches, index)
{
	if (a === b)
	{
		return;
	}

	var aType = a.type;
	var bType = b.type;

	// Bail if you run into different types of nodes. Implies that the
	// structure has changed significantly and it's not worth a diff.
	if (aType !== bType)
	{
		patches.push(makePatch('p-redraw', index, b));
		return;
	}

	// Now we know that both nodes are the same type.
	switch (bType)
	{
		case 'thunk':
			var aArgs = a.args;
			var bArgs = b.args;
			var i = aArgs.length;
			var same = a.func === b.func && i === bArgs.length;
			while (same && i--)
			{
				same = aArgs[i] === bArgs[i];
			}
			if (same)
			{
				b.node = a.node;
				return;
			}
			b.node = b.thunk();
			var subPatches = [];
			diffHelp(a.node, b.node, subPatches, 0);
			if (subPatches.length > 0)
			{
				patches.push(makePatch('p-thunk', index, subPatches));
			}
			return;

		case 'tagger':
			// gather nested taggers
			var aTaggers = a.tagger;
			var bTaggers = b.tagger;
			var nesting = false;

			var aSubNode = a.node;
			while (aSubNode.type === 'tagger')
			{
				nesting = true;

				typeof aTaggers !== 'object'
					? aTaggers = [aTaggers, aSubNode.tagger]
					: aTaggers.push(aSubNode.tagger);

				aSubNode = aSubNode.node;
			}

			var bSubNode = b.node;
			while (bSubNode.type === 'tagger')
			{
				nesting = true;

				typeof bTaggers !== 'object'
					? bTaggers = [bTaggers, bSubNode.tagger]
					: bTaggers.push(bSubNode.tagger);

				bSubNode = bSubNode.node;
			}

			// Just bail if different numbers of taggers. This implies the
			// structure of the virtual DOM has changed.
			if (nesting && aTaggers.length !== bTaggers.length)
			{
				patches.push(makePatch('p-redraw', index, b));
				return;
			}

			// check if taggers are "the same"
			if (nesting ? !pairwiseRefEqual(aTaggers, bTaggers) : aTaggers !== bTaggers)
			{
				patches.push(makePatch('p-tagger', index, bTaggers));
			}

			// diff everything below the taggers
			diffHelp(aSubNode, bSubNode, patches, index + 1);
			return;

		case 'text':
			if (a.text !== b.text)
			{
				patches.push(makePatch('p-text', index, b.text));
				return;
			}

			return;

		case 'node':
			// Bail if obvious indicators have changed. Implies more serious
			// structural changes such that it's not worth it to diff.
			if (a.tag !== b.tag || a.namespace !== b.namespace)
			{
				patches.push(makePatch('p-redraw', index, b));
				return;
			}

			var factsDiff = diffFacts(a.facts, b.facts);

			if (typeof factsDiff !== 'undefined')
			{
				patches.push(makePatch('p-facts', index, factsDiff));
			}

			diffChildren(a, b, patches, index);
			return;

		case 'keyed-node':
			// Bail if obvious indicators have changed. Implies more serious
			// structural changes such that it's not worth it to diff.
			if (a.tag !== b.tag || a.namespace !== b.namespace)
			{
				patches.push(makePatch('p-redraw', index, b));
				return;
			}

			var factsDiff = diffFacts(a.facts, b.facts);

			if (typeof factsDiff !== 'undefined')
			{
				patches.push(makePatch('p-facts', index, factsDiff));
			}

			diffKeyedChildren(a, b, patches, index);
			return;

		case 'custom':
			if (a.impl !== b.impl)
			{
				patches.push(makePatch('p-redraw', index, b));
				return;
			}

			var factsDiff = diffFacts(a.facts, b.facts);
			if (typeof factsDiff !== 'undefined')
			{
				patches.push(makePatch('p-facts', index, factsDiff));
			}

			var patch = b.impl.diff(a,b);
			if (patch)
			{
				patches.push(makePatch('p-custom', index, patch));
				return;
			}

			return;
	}
}


// assumes the incoming arrays are the same length
function pairwiseRefEqual(as, bs)
{
	for (var i = 0; i < as.length; i++)
	{
		if (as[i] !== bs[i])
		{
			return false;
		}
	}

	return true;
}


// TODO Instead of creating a new diff object, it's possible to just test if
// there *is* a diff. During the actual patch, do the diff again and make the
// modifications directly. This way, there's no new allocations. Worth it?
function diffFacts(a, b, category)
{
	var diff;

	// look for changes and removals
	for (var aKey in a)
	{
		if (aKey === STYLE_KEY || aKey === EVENT_KEY || aKey === ATTR_KEY || aKey === ATTR_NS_KEY)
		{
			var subDiff = diffFacts(a[aKey], b[aKey] || {}, aKey);
			if (subDiff)
			{
				diff = diff || {};
				diff[aKey] = subDiff;
			}
			continue;
		}

		// remove if not in the new facts
		if (!(aKey in b))
		{
			diff = diff || {};
			diff[aKey] =
				(typeof category === 'undefined')
					? (typeof a[aKey] === 'string' ? '' : null)
					:
				(category === STYLE_KEY)
					? ''
					:
				(category === EVENT_KEY || category === ATTR_KEY)
					? undefined
					:
				{ namespace: a[aKey].namespace, value: undefined };

			continue;
		}

		var aValue = a[aKey];
		var bValue = b[aKey];

		// reference equal, so don't worry about it
		if (aValue === bValue && aKey !== 'value'
			|| category === EVENT_KEY && equalEvents(aValue, bValue))
		{
			continue;
		}

		diff = diff || {};
		diff[aKey] = bValue;
	}

	// add new stuff
	for (var bKey in b)
	{
		if (!(bKey in a))
		{
			diff = diff || {};
			diff[bKey] = b[bKey];
		}
	}

	return diff;
}


function diffChildren(aParent, bParent, patches, rootIndex)
{
	var aChildren = aParent.children;
	var bChildren = bParent.children;

	var aLen = aChildren.length;
	var bLen = bChildren.length;

	// FIGURE OUT IF THERE ARE INSERTS OR REMOVALS

	if (aLen > bLen)
	{
		patches.push(makePatch('p-remove-last', rootIndex, aLen - bLen));
	}
	else if (aLen < bLen)
	{
		patches.push(makePatch('p-append', rootIndex, bChildren.slice(aLen)));
	}

	// PAIRWISE DIFF EVERYTHING ELSE

	var index = rootIndex;
	var minLen = aLen < bLen ? aLen : bLen;
	for (var i = 0; i < minLen; i++)
	{
		index++;
		var aChild = aChildren[i];
		diffHelp(aChild, bChildren[i], patches, index);
		index += aChild.descendantsCount || 0;
	}
}



////////////  KEYED DIFF  ////////////


function diffKeyedChildren(aParent, bParent, patches, rootIndex)
{
	var localPatches = [];

	var changes = {}; // Dict String Entry
	var inserts = []; // Array { index : Int, entry : Entry }
	// type Entry = { tag : String, vnode : VNode, index : Int, data : _ }

	var aChildren = aParent.children;
	var bChildren = bParent.children;
	var aLen = aChildren.length;
	var bLen = bChildren.length;
	var aIndex = 0;
	var bIndex = 0;

	var index = rootIndex;

	while (aIndex < aLen && bIndex < bLen)
	{
		var a = aChildren[aIndex];
		var b = bChildren[bIndex];

		var aKey = a._0;
		var bKey = b._0;
		var aNode = a._1;
		var bNode = b._1;

		// check if keys match

		if (aKey === bKey)
		{
			index++;
			diffHelp(aNode, bNode, localPatches, index);
			index += aNode.descendantsCount || 0;

			aIndex++;
			bIndex++;
			continue;
		}

		// look ahead 1 to detect insertions and removals.

		var aLookAhead = aIndex + 1 < aLen;
		var bLookAhead = bIndex + 1 < bLen;

		if (aLookAhead)
		{
			var aNext = aChildren[aIndex + 1];
			var aNextKey = aNext._0;
			var aNextNode = aNext._1;
			var oldMatch = bKey === aNextKey;
		}

		if (bLookAhead)
		{
			var bNext = bChildren[bIndex + 1];
			var bNextKey = bNext._0;
			var bNextNode = bNext._1;
			var newMatch = aKey === bNextKey;
		}


		// swap a and b
		if (aLookAhead && bLookAhead && newMatch && oldMatch)
		{
			index++;
			diffHelp(aNode, bNextNode, localPatches, index);
			insertNode(changes, localPatches, aKey, bNode, bIndex, inserts);
			index += aNode.descendantsCount || 0;

			index++;
			removeNode(changes, localPatches, aKey, aNextNode, index);
			index += aNextNode.descendantsCount || 0;

			aIndex += 2;
			bIndex += 2;
			continue;
		}

		// insert b
		if (bLookAhead && newMatch)
		{
			index++;
			insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
			diffHelp(aNode, bNextNode, localPatches, index);
			index += aNode.descendantsCount || 0;

			aIndex += 1;
			bIndex += 2;
			continue;
		}

		// remove a
		if (aLookAhead && oldMatch)
		{
			index++;
			removeNode(changes, localPatches, aKey, aNode, index);
			index += aNode.descendantsCount || 0;

			index++;
			diffHelp(aNextNode, bNode, localPatches, index);
			index += aNextNode.descendantsCount || 0;

			aIndex += 2;
			bIndex += 1;
			continue;
		}

		// remove a, insert b
		if (aLookAhead && bLookAhead && aNextKey === bNextKey)
		{
			index++;
			removeNode(changes, localPatches, aKey, aNode, index);
			insertNode(changes, localPatches, bKey, bNode, bIndex, inserts);
			index += aNode.descendantsCount || 0;

			index++;
			diffHelp(aNextNode, bNextNode, localPatches, index);
			index += aNextNode.descendantsCount || 0;

			aIndex += 2;
			bIndex += 2;
			continue;
		}

		break;
	}

	// eat up any remaining nodes with removeNode and insertNode

	while (aIndex < aLen)
	{
		index++;
		var a = aChildren[aIndex];
		var aNode = a._1;
		removeNode(changes, localPatches, a._0, aNode, index);
		index += aNode.descendantsCount || 0;
		aIndex++;
	}

	var endInserts;
	while (bIndex < bLen)
	{
		endInserts = endInserts || [];
		var b = bChildren[bIndex];
		insertNode(changes, localPatches, b._0, b._1, undefined, endInserts);
		bIndex++;
	}

	if (localPatches.length > 0 || inserts.length > 0 || typeof endInserts !== 'undefined')
	{
		patches.push(makePatch('p-reorder', rootIndex, {
			patches: localPatches,
			inserts: inserts,
			endInserts: endInserts
		}));
	}
}



////////////  CHANGES FROM KEYED DIFF  ////////////


var POSTFIX = '_elmW6BL';


function insertNode(changes, localPatches, key, vnode, bIndex, inserts)
{
	var entry = changes[key];

	// never seen this key before
	if (typeof entry === 'undefined')
	{
		entry = {
			tag: 'insert',
			vnode: vnode,
			index: bIndex,
			data: undefined
		};

		inserts.push({ index: bIndex, entry: entry });
		changes[key] = entry;

		return;
	}

	// this key was removed earlier, a match!
	if (entry.tag === 'remove')
	{
		inserts.push({ index: bIndex, entry: entry });

		entry.tag = 'move';
		var subPatches = [];
		diffHelp(entry.vnode, vnode, subPatches, entry.index);
		entry.index = bIndex;
		entry.data.data = {
			patches: subPatches,
			entry: entry
		};

		return;
	}

	// this key has already been inserted or moved, a duplicate!
	insertNode(changes, localPatches, key + POSTFIX, vnode, bIndex, inserts);
}


function removeNode(changes, localPatches, key, vnode, index)
{
	var entry = changes[key];

	// never seen this key before
	if (typeof entry === 'undefined')
	{
		var patch = makePatch('p-remove', index, undefined);
		localPatches.push(patch);

		changes[key] = {
			tag: 'remove',
			vnode: vnode,
			index: index,
			data: patch
		};

		return;
	}

	// this key was inserted earlier, a match!
	if (entry.tag === 'insert')
	{
		entry.tag = 'move';
		var subPatches = [];
		diffHelp(vnode, entry.vnode, subPatches, index);

		var patch = makePatch('p-remove', index, {
			patches: subPatches,
			entry: entry
		});
		localPatches.push(patch);

		return;
	}

	// this key has already been removed or moved, a duplicate!
	removeNode(changes, localPatches, key + POSTFIX, vnode, index);
}



////////////  ADD DOM NODES  ////////////
//
// Each DOM node has an "index" assigned in order of traversal. It is important
// to minimize our crawl over the actual DOM, so these indexes (along with the
// descendantsCount of virtual nodes) let us skip touching entire subtrees of
// the DOM if we know there are no patches there.


function addDomNodes(domNode, vNode, patches, eventNode)
{
	addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.descendantsCount, eventNode);
}


// assumes `patches` is non-empty and indexes increase monotonically.
function addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode)
{
	var patch = patches[i];
	var index = patch.index;

	while (index === low)
	{
		var patchType = patch.type;

		if (patchType === 'p-thunk')
		{
			addDomNodes(domNode, vNode.node, patch.data, eventNode);
		}
		else if (patchType === 'p-reorder')
		{
			patch.domNode = domNode;
			patch.eventNode = eventNode;

			var subPatches = patch.data.patches;
			if (subPatches.length > 0)
			{
				addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
			}
		}
		else if (patchType === 'p-remove')
		{
			patch.domNode = domNode;
			patch.eventNode = eventNode;

			var data = patch.data;
			if (typeof data !== 'undefined')
			{
				data.entry.data = domNode;
				var subPatches = data.patches;
				if (subPatches.length > 0)
				{
					addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
				}
			}
		}
		else
		{
			patch.domNode = domNode;
			patch.eventNode = eventNode;
		}

		i++;

		if (!(patch = patches[i]) || (index = patch.index) > high)
		{
			return i;
		}
	}

	switch (vNode.type)
	{
		case 'tagger':
			var subNode = vNode.node;

			while (subNode.type === "tagger")
			{
				subNode = subNode.node;
			}

			return addDomNodesHelp(domNode, subNode, patches, i, low + 1, high, domNode.elm_event_node_ref);

		case 'node':
			var vChildren = vNode.children;
			var childNodes = domNode.childNodes;
			for (var j = 0; j < vChildren.length; j++)
			{
				low++;
				var vChild = vChildren[j];
				var nextLow = low + (vChild.descendantsCount || 0);
				if (low <= index && index <= nextLow)
				{
					i = addDomNodesHelp(childNodes[j], vChild, patches, i, low, nextLow, eventNode);
					if (!(patch = patches[i]) || (index = patch.index) > high)
					{
						return i;
					}
				}
				low = nextLow;
			}
			return i;

		case 'keyed-node':
			var vChildren = vNode.children;
			var childNodes = domNode.childNodes;
			for (var j = 0; j < vChildren.length; j++)
			{
				low++;
				var vChild = vChildren[j]._1;
				var nextLow = low + (vChild.descendantsCount || 0);
				if (low <= index && index <= nextLow)
				{
					i = addDomNodesHelp(childNodes[j], vChild, patches, i, low, nextLow, eventNode);
					if (!(patch = patches[i]) || (index = patch.index) > high)
					{
						return i;
					}
				}
				low = nextLow;
			}
			return i;

		case 'text':
		case 'thunk':
			throw new Error('should never traverse `text` or `thunk` nodes like this');
	}
}



////////////  APPLY PATCHES  ////////////


function applyPatches(rootDomNode, oldVirtualNode, patches, eventNode)
{
	if (patches.length === 0)
	{
		return rootDomNode;
	}

	addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
	return applyPatchesHelp(rootDomNode, patches);
}

function applyPatchesHelp(rootDomNode, patches)
{
	for (var i = 0; i < patches.length; i++)
	{
		var patch = patches[i];
		var localDomNode = patch.domNode
		var newNode = applyPatch(localDomNode, patch);
		if (localDomNode === rootDomNode)
		{
			rootDomNode = newNode;
		}
	}
	return rootDomNode;
}

function applyPatch(domNode, patch)
{
	switch (patch.type)
	{
		case 'p-redraw':
			return applyPatchRedraw(domNode, patch.data, patch.eventNode);

		case 'p-facts':
			applyFacts(domNode, patch.eventNode, patch.data);
			return domNode;

		case 'p-text':
			domNode.replaceData(0, domNode.length, patch.data);
			return domNode;

		case 'p-thunk':
			return applyPatchesHelp(domNode, patch.data);

		case 'p-tagger':
			if (typeof domNode.elm_event_node_ref !== 'undefined')
			{
				domNode.elm_event_node_ref.tagger = patch.data;
			}
			else
			{
				domNode.elm_event_node_ref = { tagger: patch.data, parent: patch.eventNode };
			}
			return domNode;

		case 'p-remove-last':
			var i = patch.data;
			while (i--)
			{
				domNode.removeChild(domNode.lastChild);
			}
			return domNode;

		case 'p-append':
			var newNodes = patch.data;
			for (var i = 0; i < newNodes.length; i++)
			{
				domNode.appendChild(render(newNodes[i], patch.eventNode));
			}
			return domNode;

		case 'p-remove':
			var data = patch.data;
			if (typeof data === 'undefined')
			{
				domNode.parentNode.removeChild(domNode);
				return domNode;
			}
			var entry = data.entry;
			if (typeof entry.index !== 'undefined')
			{
				domNode.parentNode.removeChild(domNode);
			}
			entry.data = applyPatchesHelp(domNode, data.patches);
			return domNode;

		case 'p-reorder':
			return applyPatchReorder(domNode, patch);

		case 'p-custom':
			var impl = patch.data;
			return impl.applyPatch(domNode, impl.data);

		default:
			throw new Error('Ran into an unknown patch!');
	}
}


function applyPatchRedraw(domNode, vNode, eventNode)
{
	var parentNode = domNode.parentNode;
	var newNode = render(vNode, eventNode);

	if (typeof newNode.elm_event_node_ref === 'undefined')
	{
		newNode.elm_event_node_ref = domNode.elm_event_node_ref;
	}

	if (parentNode && newNode !== domNode)
	{
		parentNode.replaceChild(newNode, domNode);
	}
	return newNode;
}


function applyPatchReorder(domNode, patch)
{
	var data = patch.data;

	// remove end inserts
	var frag = applyPatchReorderEndInsertsHelp(data.endInserts, patch);

	// removals
	domNode = applyPatchesHelp(domNode, data.patches);

	// inserts
	var inserts = data.inserts;
	for (var i = 0; i < inserts.length; i++)
	{
		var insert = inserts[i];
		var entry = insert.entry;
		var node = entry.tag === 'move'
			? entry.data
			: render(entry.vnode, patch.eventNode);
		domNode.insertBefore(node, domNode.childNodes[insert.index]);
	}

	// add end inserts
	if (typeof frag !== 'undefined')
	{
		domNode.appendChild(frag);
	}

	return domNode;
}


function applyPatchReorderEndInsertsHelp(endInserts, patch)
{
	if (typeof endInserts === 'undefined')
	{
		return;
	}

	var frag = localDoc.createDocumentFragment();
	for (var i = 0; i < endInserts.length; i++)
	{
		var insert = endInserts[i];
		var entry = insert.entry;
		frag.appendChild(entry.tag === 'move'
			? entry.data
			: render(entry.vnode, patch.eventNode)
		);
	}
	return frag;
}


// PROGRAMS

var program = makeProgram(checkNoFlags);
var programWithFlags = makeProgram(checkYesFlags);

function makeProgram(flagChecker)
{
	return F2(function(debugWrap, impl)
	{
		return function(flagDecoder)
		{
			return function(object, moduleName, debugMetadata)
			{
				var checker = flagChecker(flagDecoder, moduleName);
				if (typeof debugMetadata === 'undefined')
				{
					normalSetup(impl, object, moduleName, checker);
				}
				else
				{
					debugSetup(A2(debugWrap, debugMetadata, impl), object, moduleName, checker);
				}
			};
		};
	});
}

function staticProgram(vNode)
{
	var nothing = _elm_lang$core$Native_Utils.Tuple2(
		_elm_lang$core$Native_Utils.Tuple0,
		_elm_lang$core$Platform_Cmd$none
	);
	return A2(program, _elm_lang$virtual_dom$VirtualDom_Debug$wrap, {
		init: nothing,
		view: function() { return vNode; },
		update: F2(function() { return nothing; }),
		subscriptions: function() { return _elm_lang$core$Platform_Sub$none; }
	})();
}


// FLAG CHECKERS

function checkNoFlags(flagDecoder, moduleName)
{
	return function(init, flags, domNode)
	{
		if (typeof flags === 'undefined')
		{
			return init;
		}

		var errorMessage =
			'The `' + moduleName + '` module does not need flags.\n'
			+ 'Initialize it with no arguments and you should be all set!';

		crash(errorMessage, domNode);
	};
}

function checkYesFlags(flagDecoder, moduleName)
{
	return function(init, flags, domNode)
	{
		if (typeof flagDecoder === 'undefined')
		{
			var errorMessage =
				'Are you trying to sneak a Never value into Elm? Trickster!\n'
				+ 'It looks like ' + moduleName + '.main is defined with `programWithFlags` but has type `Program Never`.\n'
				+ 'Use `program` instead if you do not want flags.'

			crash(errorMessage, domNode);
		}

		var result = A2(_elm_lang$core$Native_Json.run, flagDecoder, flags);
		if (result.ctor === 'Ok')
		{
			return init(result._0);
		}

		var errorMessage =
			'Trying to initialize the `' + moduleName + '` module with an unexpected flag.\n'
			+ 'I tried to convert it to an Elm value, but ran into this problem:\n\n'
			+ result._0;

		crash(errorMessage, domNode);
	};
}

function crash(errorMessage, domNode)
{
	if (domNode)
	{
		domNode.innerHTML =
			'<div style="padding-left:1em;">'
			+ '<h2 style="font-weight:normal;"><b>Oops!</b> Something went wrong when starting your Elm program.</h2>'
			+ '<pre style="padding-left:1em;">' + errorMessage + '</pre>'
			+ '</div>';
	}

	throw new Error(errorMessage);
}


//  NORMAL SETUP

function normalSetup(impl, object, moduleName, flagChecker)
{
	object['embed'] = function embed(node, flags)
	{
		while (node.lastChild)
		{
			node.removeChild(node.lastChild);
		}

		return _elm_lang$core$Native_Platform.initialize(
			flagChecker(impl.init, flags, node),
			impl.update,
			impl.subscriptions,
			normalRenderer(node, impl.view)
		);
	};

	object['fullscreen'] = function fullscreen(flags)
	{
		return _elm_lang$core$Native_Platform.initialize(
			flagChecker(impl.init, flags, document.body),
			impl.update,
			impl.subscriptions,
			normalRenderer(document.body, impl.view)
		);
	};
}

function normalRenderer(parentNode, view)
{
	return function(tagger, initialModel)
	{
		var eventNode = { tagger: tagger, parent: undefined };
		var initialVirtualNode = view(initialModel);
		var domNode = render(initialVirtualNode, eventNode);
		parentNode.appendChild(domNode);
		return makeStepper(domNode, view, initialVirtualNode, eventNode);
	};
}


// STEPPER

var rAF =
	typeof requestAnimationFrame !== 'undefined'
		? requestAnimationFrame
		: function(callback) { setTimeout(callback, 1000 / 60); };

function makeStepper(domNode, view, initialVirtualNode, eventNode)
{
	var state = 'NO_REQUEST';
	var currNode = initialVirtualNode;
	var nextModel;

	function updateIfNeeded()
	{
		switch (state)
		{
			case 'NO_REQUEST':
				throw new Error(
					'Unexpected draw callback.\n' +
					'Please report this to <https://github.com/elm-lang/virtual-dom/issues>.'
				);

			case 'PENDING_REQUEST':
				rAF(updateIfNeeded);
				state = 'EXTRA_REQUEST';

				var nextNode = view(nextModel);
				var patches = diff(currNode, nextNode);
				domNode = applyPatches(domNode, currNode, patches, eventNode);
				currNode = nextNode;

				return;

			case 'EXTRA_REQUEST':
				state = 'NO_REQUEST';
				return;
		}
	}

	return function stepper(model)
	{
		if (state === 'NO_REQUEST')
		{
			rAF(updateIfNeeded);
		}
		state = 'PENDING_REQUEST';
		nextModel = model;
	};
}


// DEBUG SETUP

function debugSetup(impl, object, moduleName, flagChecker)
{
	object['fullscreen'] = function fullscreen(flags)
	{
		var popoutRef = { doc: undefined };
		return _elm_lang$core$Native_Platform.initialize(
			flagChecker(impl.init, flags, document.body),
			impl.update(scrollTask(popoutRef)),
			impl.subscriptions,
			debugRenderer(moduleName, document.body, popoutRef, impl.view, impl.viewIn, impl.viewOut)
		);
	};

	object['embed'] = function fullscreen(node, flags)
	{
		var popoutRef = { doc: undefined };
		return _elm_lang$core$Native_Platform.initialize(
			flagChecker(impl.init, flags, node),
			impl.update(scrollTask(popoutRef)),
			impl.subscriptions,
			debugRenderer(moduleName, node, popoutRef, impl.view, impl.viewIn, impl.viewOut)
		);
	};
}

function scrollTask(popoutRef)
{
	return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback)
	{
		var doc = popoutRef.doc;
		if (doc)
		{
			var msgs = doc.getElementsByClassName('debugger-sidebar-messages')[0];
			if (msgs)
			{
				msgs.scrollTop = msgs.scrollHeight;
			}
		}
		callback(_elm_lang$core$Native_Scheduler.succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}


function debugRenderer(moduleName, parentNode, popoutRef, view, viewIn, viewOut)
{
	return function(tagger, initialModel)
	{
		var appEventNode = { tagger: tagger, parent: undefined };
		var eventNode = { tagger: tagger, parent: undefined };

		// make normal stepper
		var appVirtualNode = view(initialModel);
		var appNode = render(appVirtualNode, appEventNode);
		parentNode.appendChild(appNode);
		var appStepper = makeStepper(appNode, view, appVirtualNode, appEventNode);

		// make overlay stepper
		var overVirtualNode = viewIn(initialModel)._1;
		var overNode = render(overVirtualNode, eventNode);
		parentNode.appendChild(overNode);
		var wrappedViewIn = wrapViewIn(appEventNode, overNode, viewIn);
		var overStepper = makeStepper(overNode, wrappedViewIn, overVirtualNode, eventNode);

		// make debugger stepper
		var debugStepper = makeDebugStepper(initialModel, viewOut, eventNode, parentNode, moduleName, popoutRef);

		return function stepper(model)
		{
			appStepper(model);
			overStepper(model);
			debugStepper(model);
		}
	};
}

function makeDebugStepper(initialModel, view, eventNode, parentNode, moduleName, popoutRef)
{
	var curr;
	var domNode;

	return function stepper(model)
	{
		if (!model.isDebuggerOpen)
		{
			return;
		}

		if (!popoutRef.doc)
		{
			curr = view(model);
			domNode = openDebugWindow(moduleName, popoutRef, curr, eventNode);
			return;
		}

		// switch to document of popout
		localDoc = popoutRef.doc;

		var next = view(model);
		var patches = diff(curr, next);
		domNode = applyPatches(domNode, curr, patches, eventNode);
		curr = next;

		// switch back to normal document
		localDoc = document;
	};
}

function openDebugWindow(moduleName, popoutRef, virtualNode, eventNode)
{
	var w = 900;
	var h = 360;
	var x = screen.width - w;
	var y = screen.height - h;
	var debugWindow = window.open('', '', 'width=' + w + ',height=' + h + ',left=' + x + ',top=' + y);

	// switch to window document
	localDoc = debugWindow.document;

	popoutRef.doc = localDoc;
	localDoc.title = 'Debugger - ' + moduleName;
	localDoc.body.style.margin = '0';
	localDoc.body.style.padding = '0';
	var domNode = render(virtualNode, eventNode);
	localDoc.body.appendChild(domNode);

	localDoc.addEventListener('keydown', function(event) {
		if (event.metaKey && event.which === 82)
		{
			window.location.reload();
		}
		if (event.which === 38)
		{
			eventNode.tagger({ ctor: 'Up' });
			event.preventDefault();
		}
		if (event.which === 40)
		{
			eventNode.tagger({ ctor: 'Down' });
			event.preventDefault();
		}
	});

	function close()
	{
		popoutRef.doc = undefined;
		debugWindow.close();
	}
	window.addEventListener('unload', close);
	debugWindow.addEventListener('unload', function() {
		popoutRef.doc = undefined;
		window.removeEventListener('unload', close);
		eventNode.tagger({ ctor: 'Close' });
	});

	// switch back to the normal document
	localDoc = document;

	return domNode;
}


// BLOCK EVENTS

function wrapViewIn(appEventNode, overlayNode, viewIn)
{
	var ignorer = makeIgnorer(overlayNode);
	var blocking = 'Normal';
	var overflow;

	var normalTagger = appEventNode.tagger;
	var blockTagger = function() {};

	return function(model)
	{
		var tuple = viewIn(model);
		var newBlocking = tuple._0.ctor;
		appEventNode.tagger = newBlocking === 'Normal' ? normalTagger : blockTagger;
		if (blocking !== newBlocking)
		{
			traverse('removeEventListener', ignorer, blocking);
			traverse('addEventListener', ignorer, newBlocking);

			if (blocking === 'Normal')
			{
				overflow = document.body.style.overflow;
				document.body.style.overflow = 'hidden';
			}

			if (newBlocking === 'Normal')
			{
				document.body.style.overflow = overflow;
			}

			blocking = newBlocking;
		}
		return tuple._1;
	}
}

function traverse(verbEventListener, ignorer, blocking)
{
	switch(blocking)
	{
		case 'Normal':
			return;

		case 'Pause':
			return traverseHelp(verbEventListener, ignorer, mostEvents);

		case 'Message':
			return traverseHelp(verbEventListener, ignorer, allEvents);
	}
}

function traverseHelp(verbEventListener, handler, eventNames)
{
	for (var i = 0; i < eventNames.length; i++)
	{
		document.body[verbEventListener](eventNames[i], handler, true);
	}
}

function makeIgnorer(overlayNode)
{
	return function(event)
	{
		if (event.type === 'keydown' && event.metaKey && event.which === 82)
		{
			return;
		}

		var isScroll = event.type === 'scroll' || event.type === 'wheel';

		var node = event.target;
		while (node !== null)
		{
			if (node.className === 'elm-overlay-message-details' && isScroll)
			{
				return;
			}

			if (node === overlayNode && !isScroll)
			{
				return;
			}
			node = node.parentNode;
		}

		event.stopPropagation();
		event.preventDefault();
	}
}

var mostEvents = [
	'click', 'dblclick', 'mousemove',
	'mouseup', 'mousedown', 'mouseenter', 'mouseleave',
	'touchstart', 'touchend', 'touchcancel', 'touchmove',
	'pointerdown', 'pointerup', 'pointerover', 'pointerout',
	'pointerenter', 'pointerleave', 'pointermove', 'pointercancel',
	'dragstart', 'drag', 'dragend', 'dragenter', 'dragover', 'dragleave', 'drop',
	'keyup', 'keydown', 'keypress',
	'input', 'change',
	'focus', 'blur'
];

var allEvents = mostEvents.concat('wheel', 'scroll');


return {
	node: node,
	text: text,
	custom: custom,
	map: F2(map),

	on: F3(on),
	style: style,
	property: F2(property),
	attribute: F2(attribute),
	attributeNS: F3(attributeNS),
	mapProperty: F2(mapProperty),

	lazy: F2(lazy),
	lazy2: F3(lazy2),
	lazy3: F4(lazy3),
	keyedNode: F3(keyedNode),

	program: program,
	programWithFlags: programWithFlags,
	staticProgram: staticProgram
};

}();

var _elm_lang$virtual_dom$VirtualDom$programWithFlags = function (impl) {
	return A2(_elm_lang$virtual_dom$Native_VirtualDom.programWithFlags, _elm_lang$virtual_dom$VirtualDom_Debug$wrapWithFlags, impl);
};
var _elm_lang$virtual_dom$VirtualDom$program = function (impl) {
	return A2(_elm_lang$virtual_dom$Native_VirtualDom.program, _elm_lang$virtual_dom$VirtualDom_Debug$wrap, impl);
};
var _elm_lang$virtual_dom$VirtualDom$keyedNode = _elm_lang$virtual_dom$Native_VirtualDom.keyedNode;
var _elm_lang$virtual_dom$VirtualDom$lazy3 = _elm_lang$virtual_dom$Native_VirtualDom.lazy3;
var _elm_lang$virtual_dom$VirtualDom$lazy2 = _elm_lang$virtual_dom$Native_VirtualDom.lazy2;
var _elm_lang$virtual_dom$VirtualDom$lazy = _elm_lang$virtual_dom$Native_VirtualDom.lazy;
var _elm_lang$virtual_dom$VirtualDom$defaultOptions = {stopPropagation: false, preventDefault: false};
var _elm_lang$virtual_dom$VirtualDom$onWithOptions = _elm_lang$virtual_dom$Native_VirtualDom.on;
var _elm_lang$virtual_dom$VirtualDom$on = F2(
	function (eventName, decoder) {
		return A3(_elm_lang$virtual_dom$VirtualDom$onWithOptions, eventName, _elm_lang$virtual_dom$VirtualDom$defaultOptions, decoder);
	});
var _elm_lang$virtual_dom$VirtualDom$style = _elm_lang$virtual_dom$Native_VirtualDom.style;
var _elm_lang$virtual_dom$VirtualDom$mapProperty = _elm_lang$virtual_dom$Native_VirtualDom.mapProperty;
var _elm_lang$virtual_dom$VirtualDom$attributeNS = _elm_lang$virtual_dom$Native_VirtualDom.attributeNS;
var _elm_lang$virtual_dom$VirtualDom$attribute = _elm_lang$virtual_dom$Native_VirtualDom.attribute;
var _elm_lang$virtual_dom$VirtualDom$property = _elm_lang$virtual_dom$Native_VirtualDom.property;
var _elm_lang$virtual_dom$VirtualDom$map = _elm_lang$virtual_dom$Native_VirtualDom.map;
var _elm_lang$virtual_dom$VirtualDom$text = _elm_lang$virtual_dom$Native_VirtualDom.text;
var _elm_lang$virtual_dom$VirtualDom$node = _elm_lang$virtual_dom$Native_VirtualDom.node;
var _elm_lang$virtual_dom$VirtualDom$Options = F2(
	function (a, b) {
		return {stopPropagation: a, preventDefault: b};
	});
var _elm_lang$virtual_dom$VirtualDom$Node = {ctor: 'Node'};
var _elm_lang$virtual_dom$VirtualDom$Property = {ctor: 'Property'};

var _elm_lang$html$Html$programWithFlags = _elm_lang$virtual_dom$VirtualDom$programWithFlags;
var _elm_lang$html$Html$program = _elm_lang$virtual_dom$VirtualDom$program;
var _elm_lang$html$Html$beginnerProgram = function (_p0) {
	var _p1 = _p0;
	return _elm_lang$html$Html$program(
		{
			init: A2(
				_elm_lang$core$Platform_Cmd_ops['!'],
				_p1.model,
				{ctor: '[]'}),
			update: F2(
				function (msg, model) {
					return A2(
						_elm_lang$core$Platform_Cmd_ops['!'],
						A2(_p1.update, msg, model),
						{ctor: '[]'});
				}),
			view: _p1.view,
			subscriptions: function (_p2) {
				return _elm_lang$core$Platform_Sub$none;
			}
		});
};
var _elm_lang$html$Html$map = _elm_lang$virtual_dom$VirtualDom$map;
var _elm_lang$html$Html$text = _elm_lang$virtual_dom$VirtualDom$text;
var _elm_lang$html$Html$node = _elm_lang$virtual_dom$VirtualDom$node;
var _elm_lang$html$Html$body = _elm_lang$html$Html$node('body');
var _elm_lang$html$Html$section = _elm_lang$html$Html$node('section');
var _elm_lang$html$Html$nav = _elm_lang$html$Html$node('nav');
var _elm_lang$html$Html$article = _elm_lang$html$Html$node('article');
var _elm_lang$html$Html$aside = _elm_lang$html$Html$node('aside');
var _elm_lang$html$Html$h1 = _elm_lang$html$Html$node('h1');
var _elm_lang$html$Html$h2 = _elm_lang$html$Html$node('h2');
var _elm_lang$html$Html$h3 = _elm_lang$html$Html$node('h3');
var _elm_lang$html$Html$h4 = _elm_lang$html$Html$node('h4');
var _elm_lang$html$Html$h5 = _elm_lang$html$Html$node('h5');
var _elm_lang$html$Html$h6 = _elm_lang$html$Html$node('h6');
var _elm_lang$html$Html$header = _elm_lang$html$Html$node('header');
var _elm_lang$html$Html$footer = _elm_lang$html$Html$node('footer');
var _elm_lang$html$Html$address = _elm_lang$html$Html$node('address');
var _elm_lang$html$Html$main_ = _elm_lang$html$Html$node('main');
var _elm_lang$html$Html$p = _elm_lang$html$Html$node('p');
var _elm_lang$html$Html$hr = _elm_lang$html$Html$node('hr');
var _elm_lang$html$Html$pre = _elm_lang$html$Html$node('pre');
var _elm_lang$html$Html$blockquote = _elm_lang$html$Html$node('blockquote');
var _elm_lang$html$Html$ol = _elm_lang$html$Html$node('ol');
var _elm_lang$html$Html$ul = _elm_lang$html$Html$node('ul');
var _elm_lang$html$Html$li = _elm_lang$html$Html$node('li');
var _elm_lang$html$Html$dl = _elm_lang$html$Html$node('dl');
var _elm_lang$html$Html$dt = _elm_lang$html$Html$node('dt');
var _elm_lang$html$Html$dd = _elm_lang$html$Html$node('dd');
var _elm_lang$html$Html$figure = _elm_lang$html$Html$node('figure');
var _elm_lang$html$Html$figcaption = _elm_lang$html$Html$node('figcaption');
var _elm_lang$html$Html$div = _elm_lang$html$Html$node('div');
var _elm_lang$html$Html$a = _elm_lang$html$Html$node('a');
var _elm_lang$html$Html$em = _elm_lang$html$Html$node('em');
var _elm_lang$html$Html$strong = _elm_lang$html$Html$node('strong');
var _elm_lang$html$Html$small = _elm_lang$html$Html$node('small');
var _elm_lang$html$Html$s = _elm_lang$html$Html$node('s');
var _elm_lang$html$Html$cite = _elm_lang$html$Html$node('cite');
var _elm_lang$html$Html$q = _elm_lang$html$Html$node('q');
var _elm_lang$html$Html$dfn = _elm_lang$html$Html$node('dfn');
var _elm_lang$html$Html$abbr = _elm_lang$html$Html$node('abbr');
var _elm_lang$html$Html$time = _elm_lang$html$Html$node('time');
var _elm_lang$html$Html$code = _elm_lang$html$Html$node('code');
var _elm_lang$html$Html$var = _elm_lang$html$Html$node('var');
var _elm_lang$html$Html$samp = _elm_lang$html$Html$node('samp');
var _elm_lang$html$Html$kbd = _elm_lang$html$Html$node('kbd');
var _elm_lang$html$Html$sub = _elm_lang$html$Html$node('sub');
var _elm_lang$html$Html$sup = _elm_lang$html$Html$node('sup');
var _elm_lang$html$Html$i = _elm_lang$html$Html$node('i');
var _elm_lang$html$Html$b = _elm_lang$html$Html$node('b');
var _elm_lang$html$Html$u = _elm_lang$html$Html$node('u');
var _elm_lang$html$Html$mark = _elm_lang$html$Html$node('mark');
var _elm_lang$html$Html$ruby = _elm_lang$html$Html$node('ruby');
var _elm_lang$html$Html$rt = _elm_lang$html$Html$node('rt');
var _elm_lang$html$Html$rp = _elm_lang$html$Html$node('rp');
var _elm_lang$html$Html$bdi = _elm_lang$html$Html$node('bdi');
var _elm_lang$html$Html$bdo = _elm_lang$html$Html$node('bdo');
var _elm_lang$html$Html$span = _elm_lang$html$Html$node('span');
var _elm_lang$html$Html$br = _elm_lang$html$Html$node('br');
var _elm_lang$html$Html$wbr = _elm_lang$html$Html$node('wbr');
var _elm_lang$html$Html$ins = _elm_lang$html$Html$node('ins');
var _elm_lang$html$Html$del = _elm_lang$html$Html$node('del');
var _elm_lang$html$Html$img = _elm_lang$html$Html$node('img');
var _elm_lang$html$Html$iframe = _elm_lang$html$Html$node('iframe');
var _elm_lang$html$Html$embed = _elm_lang$html$Html$node('embed');
var _elm_lang$html$Html$object = _elm_lang$html$Html$node('object');
var _elm_lang$html$Html$param = _elm_lang$html$Html$node('param');
var _elm_lang$html$Html$video = _elm_lang$html$Html$node('video');
var _elm_lang$html$Html$audio = _elm_lang$html$Html$node('audio');
var _elm_lang$html$Html$source = _elm_lang$html$Html$node('source');
var _elm_lang$html$Html$track = _elm_lang$html$Html$node('track');
var _elm_lang$html$Html$canvas = _elm_lang$html$Html$node('canvas');
var _elm_lang$html$Html$math = _elm_lang$html$Html$node('math');
var _elm_lang$html$Html$table = _elm_lang$html$Html$node('table');
var _elm_lang$html$Html$caption = _elm_lang$html$Html$node('caption');
var _elm_lang$html$Html$colgroup = _elm_lang$html$Html$node('colgroup');
var _elm_lang$html$Html$col = _elm_lang$html$Html$node('col');
var _elm_lang$html$Html$tbody = _elm_lang$html$Html$node('tbody');
var _elm_lang$html$Html$thead = _elm_lang$html$Html$node('thead');
var _elm_lang$html$Html$tfoot = _elm_lang$html$Html$node('tfoot');
var _elm_lang$html$Html$tr = _elm_lang$html$Html$node('tr');
var _elm_lang$html$Html$td = _elm_lang$html$Html$node('td');
var _elm_lang$html$Html$th = _elm_lang$html$Html$node('th');
var _elm_lang$html$Html$form = _elm_lang$html$Html$node('form');
var _elm_lang$html$Html$fieldset = _elm_lang$html$Html$node('fieldset');
var _elm_lang$html$Html$legend = _elm_lang$html$Html$node('legend');
var _elm_lang$html$Html$label = _elm_lang$html$Html$node('label');
var _elm_lang$html$Html$input = _elm_lang$html$Html$node('input');
var _elm_lang$html$Html$button = _elm_lang$html$Html$node('button');
var _elm_lang$html$Html$select = _elm_lang$html$Html$node('select');
var _elm_lang$html$Html$datalist = _elm_lang$html$Html$node('datalist');
var _elm_lang$html$Html$optgroup = _elm_lang$html$Html$node('optgroup');
var _elm_lang$html$Html$option = _elm_lang$html$Html$node('option');
var _elm_lang$html$Html$textarea = _elm_lang$html$Html$node('textarea');
var _elm_lang$html$Html$keygen = _elm_lang$html$Html$node('keygen');
var _elm_lang$html$Html$output = _elm_lang$html$Html$node('output');
var _elm_lang$html$Html$progress = _elm_lang$html$Html$node('progress');
var _elm_lang$html$Html$meter = _elm_lang$html$Html$node('meter');
var _elm_lang$html$Html$details = _elm_lang$html$Html$node('details');
var _elm_lang$html$Html$summary = _elm_lang$html$Html$node('summary');
var _elm_lang$html$Html$menuitem = _elm_lang$html$Html$node('menuitem');
var _elm_lang$html$Html$menu = _elm_lang$html$Html$node('menu');

var _elm_lang$html$Html_Attributes$map = _elm_lang$virtual_dom$VirtualDom$mapProperty;
var _elm_lang$html$Html_Attributes$attribute = _elm_lang$virtual_dom$VirtualDom$attribute;
var _elm_lang$html$Html_Attributes$contextmenu = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'contextmenu', value);
};
var _elm_lang$html$Html_Attributes$draggable = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'draggable', value);
};
var _elm_lang$html$Html_Attributes$itemprop = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'itemprop', value);
};
var _elm_lang$html$Html_Attributes$tabindex = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'tabIndex',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$charset = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'charset', value);
};
var _elm_lang$html$Html_Attributes$height = function (value) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'height',
		_elm_lang$core$Basics$toString(value));
};
var _elm_lang$html$Html_Attributes$width = function (value) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'width',
		_elm_lang$core$Basics$toString(value));
};
var _elm_lang$html$Html_Attributes$formaction = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'formAction', value);
};
var _elm_lang$html$Html_Attributes$list = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'list', value);
};
var _elm_lang$html$Html_Attributes$minlength = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'minLength',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$maxlength = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'maxlength',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$size = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'size',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$form = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'form', value);
};
var _elm_lang$html$Html_Attributes$cols = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'cols',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$rows = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'rows',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$challenge = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'challenge', value);
};
var _elm_lang$html$Html_Attributes$media = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'media', value);
};
var _elm_lang$html$Html_Attributes$rel = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'rel', value);
};
var _elm_lang$html$Html_Attributes$datetime = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'datetime', value);
};
var _elm_lang$html$Html_Attributes$pubdate = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'pubdate', value);
};
var _elm_lang$html$Html_Attributes$colspan = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'colspan',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$rowspan = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$attribute,
		'rowspan',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$manifest = function (value) {
	return A2(_elm_lang$html$Html_Attributes$attribute, 'manifest', value);
};
var _elm_lang$html$Html_Attributes$property = _elm_lang$virtual_dom$VirtualDom$property;
var _elm_lang$html$Html_Attributes$stringProperty = F2(
	function (name, string) {
		return A2(
			_elm_lang$html$Html_Attributes$property,
			name,
			_elm_lang$core$Json_Encode$string(string));
	});
var _elm_lang$html$Html_Attributes$class = function (name) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'className', name);
};
var _elm_lang$html$Html_Attributes$id = function (name) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'id', name);
};
var _elm_lang$html$Html_Attributes$title = function (name) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'title', name);
};
var _elm_lang$html$Html_Attributes$accesskey = function ($char) {
	return A2(
		_elm_lang$html$Html_Attributes$stringProperty,
		'accessKey',
		_elm_lang$core$String$fromChar($char));
};
var _elm_lang$html$Html_Attributes$dir = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'dir', value);
};
var _elm_lang$html$Html_Attributes$dropzone = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'dropzone', value);
};
var _elm_lang$html$Html_Attributes$lang = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'lang', value);
};
var _elm_lang$html$Html_Attributes$content = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'content', value);
};
var _elm_lang$html$Html_Attributes$httpEquiv = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'httpEquiv', value);
};
var _elm_lang$html$Html_Attributes$language = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'language', value);
};
var _elm_lang$html$Html_Attributes$src = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'src', value);
};
var _elm_lang$html$Html_Attributes$alt = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'alt', value);
};
var _elm_lang$html$Html_Attributes$preload = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'preload', value);
};
var _elm_lang$html$Html_Attributes$poster = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'poster', value);
};
var _elm_lang$html$Html_Attributes$kind = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'kind', value);
};
var _elm_lang$html$Html_Attributes$srclang = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'srclang', value);
};
var _elm_lang$html$Html_Attributes$sandbox = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'sandbox', value);
};
var _elm_lang$html$Html_Attributes$srcdoc = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'srcdoc', value);
};
var _elm_lang$html$Html_Attributes$type_ = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'type', value);
};
var _elm_lang$html$Html_Attributes$value = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'value', value);
};
var _elm_lang$html$Html_Attributes$defaultValue = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'defaultValue', value);
};
var _elm_lang$html$Html_Attributes$placeholder = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'placeholder', value);
};
var _elm_lang$html$Html_Attributes$accept = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'accept', value);
};
var _elm_lang$html$Html_Attributes$acceptCharset = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'acceptCharset', value);
};
var _elm_lang$html$Html_Attributes$action = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'action', value);
};
var _elm_lang$html$Html_Attributes$autocomplete = function (bool) {
	return A2(
		_elm_lang$html$Html_Attributes$stringProperty,
		'autocomplete',
		bool ? 'on' : 'off');
};
var _elm_lang$html$Html_Attributes$enctype = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'enctype', value);
};
var _elm_lang$html$Html_Attributes$method = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'method', value);
};
var _elm_lang$html$Html_Attributes$name = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'name', value);
};
var _elm_lang$html$Html_Attributes$pattern = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'pattern', value);
};
var _elm_lang$html$Html_Attributes$for = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'htmlFor', value);
};
var _elm_lang$html$Html_Attributes$max = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'max', value);
};
var _elm_lang$html$Html_Attributes$min = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'min', value);
};
var _elm_lang$html$Html_Attributes$step = function (n) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'step', n);
};
var _elm_lang$html$Html_Attributes$wrap = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'wrap', value);
};
var _elm_lang$html$Html_Attributes$usemap = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'useMap', value);
};
var _elm_lang$html$Html_Attributes$shape = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'shape', value);
};
var _elm_lang$html$Html_Attributes$coords = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'coords', value);
};
var _elm_lang$html$Html_Attributes$keytype = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'keytype', value);
};
var _elm_lang$html$Html_Attributes$align = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'align', value);
};
var _elm_lang$html$Html_Attributes$cite = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'cite', value);
};
var _elm_lang$html$Html_Attributes$href = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'href', value);
};
var _elm_lang$html$Html_Attributes$target = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'target', value);
};
var _elm_lang$html$Html_Attributes$downloadAs = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'download', value);
};
var _elm_lang$html$Html_Attributes$hreflang = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'hreflang', value);
};
var _elm_lang$html$Html_Attributes$ping = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'ping', value);
};
var _elm_lang$html$Html_Attributes$start = function (n) {
	return A2(
		_elm_lang$html$Html_Attributes$stringProperty,
		'start',
		_elm_lang$core$Basics$toString(n));
};
var _elm_lang$html$Html_Attributes$headers = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'headers', value);
};
var _elm_lang$html$Html_Attributes$scope = function (value) {
	return A2(_elm_lang$html$Html_Attributes$stringProperty, 'scope', value);
};
var _elm_lang$html$Html_Attributes$boolProperty = F2(
	function (name, bool) {
		return A2(
			_elm_lang$html$Html_Attributes$property,
			name,
			_elm_lang$core$Json_Encode$bool(bool));
	});
var _elm_lang$html$Html_Attributes$hidden = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'hidden', bool);
};
var _elm_lang$html$Html_Attributes$contenteditable = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'contentEditable', bool);
};
var _elm_lang$html$Html_Attributes$spellcheck = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'spellcheck', bool);
};
var _elm_lang$html$Html_Attributes$async = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'async', bool);
};
var _elm_lang$html$Html_Attributes$defer = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'defer', bool);
};
var _elm_lang$html$Html_Attributes$scoped = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'scoped', bool);
};
var _elm_lang$html$Html_Attributes$autoplay = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'autoplay', bool);
};
var _elm_lang$html$Html_Attributes$controls = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'controls', bool);
};
var _elm_lang$html$Html_Attributes$loop = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'loop', bool);
};
var _elm_lang$html$Html_Attributes$default = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'default', bool);
};
var _elm_lang$html$Html_Attributes$seamless = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'seamless', bool);
};
var _elm_lang$html$Html_Attributes$checked = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'checked', bool);
};
var _elm_lang$html$Html_Attributes$selected = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'selected', bool);
};
var _elm_lang$html$Html_Attributes$autofocus = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'autofocus', bool);
};
var _elm_lang$html$Html_Attributes$disabled = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'disabled', bool);
};
var _elm_lang$html$Html_Attributes$multiple = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'multiple', bool);
};
var _elm_lang$html$Html_Attributes$novalidate = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'noValidate', bool);
};
var _elm_lang$html$Html_Attributes$readonly = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'readOnly', bool);
};
var _elm_lang$html$Html_Attributes$required = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'required', bool);
};
var _elm_lang$html$Html_Attributes$ismap = function (value) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'isMap', value);
};
var _elm_lang$html$Html_Attributes$download = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'download', bool);
};
var _elm_lang$html$Html_Attributes$reversed = function (bool) {
	return A2(_elm_lang$html$Html_Attributes$boolProperty, 'reversed', bool);
};
var _elm_lang$html$Html_Attributes$classList = function (list) {
	return _elm_lang$html$Html_Attributes$class(
		A2(
			_elm_lang$core$String$join,
			' ',
			A2(
				_elm_lang$core$List$map,
				_elm_lang$core$Tuple$first,
				A2(_elm_lang$core$List$filter, _elm_lang$core$Tuple$second, list))));
};
var _elm_lang$html$Html_Attributes$style = _elm_lang$virtual_dom$VirtualDom$style;

var _elm_lang$lazy$Native_Lazy = function() {

function memoize(thunk)
{
    var value;
    var isForced = false;
    return function(tuple0) {
        if (!isForced) {
            value = thunk(tuple0);
            isForced = true;
        }
        return value;
    };
}

return {
    memoize: memoize
};

}();

var _elm_lang$lazy$Lazy$force = function (_p0) {
	var _p1 = _p0;
	return _p1._0(
		{ctor: '_Tuple0'});
};
var _elm_lang$lazy$Lazy$Lazy = function (a) {
	return {ctor: 'Lazy', _0: a};
};
var _elm_lang$lazy$Lazy$lazy = function (thunk) {
	return _elm_lang$lazy$Lazy$Lazy(
		_elm_lang$lazy$Native_Lazy.memoize(thunk));
};
var _elm_lang$lazy$Lazy$map = F2(
	function (f, a) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p2) {
				var _p3 = _p2;
				return f(
					_elm_lang$lazy$Lazy$force(a));
			});
	});
var _elm_lang$lazy$Lazy$map2 = F3(
	function (f, a, b) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p4) {
				var _p5 = _p4;
				return A2(
					f,
					_elm_lang$lazy$Lazy$force(a),
					_elm_lang$lazy$Lazy$force(b));
			});
	});
var _elm_lang$lazy$Lazy$map3 = F4(
	function (f, a, b, c) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p6) {
				var _p7 = _p6;
				return A3(
					f,
					_elm_lang$lazy$Lazy$force(a),
					_elm_lang$lazy$Lazy$force(b),
					_elm_lang$lazy$Lazy$force(c));
			});
	});
var _elm_lang$lazy$Lazy$map4 = F5(
	function (f, a, b, c, d) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p8) {
				var _p9 = _p8;
				return A4(
					f,
					_elm_lang$lazy$Lazy$force(a),
					_elm_lang$lazy$Lazy$force(b),
					_elm_lang$lazy$Lazy$force(c),
					_elm_lang$lazy$Lazy$force(d));
			});
	});
var _elm_lang$lazy$Lazy$map5 = F6(
	function (f, a, b, c, d, e) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p10) {
				var _p11 = _p10;
				return A5(
					f,
					_elm_lang$lazy$Lazy$force(a),
					_elm_lang$lazy$Lazy$force(b),
					_elm_lang$lazy$Lazy$force(c),
					_elm_lang$lazy$Lazy$force(d),
					_elm_lang$lazy$Lazy$force(e));
			});
	});
var _elm_lang$lazy$Lazy$apply = F2(
	function (f, x) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p12) {
				var _p13 = _p12;
				return A2(
					_elm_lang$lazy$Lazy$force,
					f,
					_elm_lang$lazy$Lazy$force(x));
			});
	});
var _elm_lang$lazy$Lazy$andThen = F2(
	function (callback, a) {
		return _elm_lang$lazy$Lazy$lazy(
			function (_p14) {
				var _p15 = _p14;
				return _elm_lang$lazy$Lazy$force(
					callback(
						_elm_lang$lazy$Lazy$force(a)));
			});
	});

var _elm_lang$svg$Svg$map = _elm_lang$virtual_dom$VirtualDom$map;
var _elm_lang$svg$Svg$text = _elm_lang$virtual_dom$VirtualDom$text;
var _elm_lang$svg$Svg$svgNamespace = A2(
	_elm_lang$virtual_dom$VirtualDom$property,
	'namespace',
	_elm_lang$core$Json_Encode$string('http://www.w3.org/2000/svg'));
var _elm_lang$svg$Svg$node = F3(
	function (name, attributes, children) {
		return A3(
			_elm_lang$virtual_dom$VirtualDom$node,
			name,
			{ctor: '::', _0: _elm_lang$svg$Svg$svgNamespace, _1: attributes},
			children);
	});
var _elm_lang$svg$Svg$svg = _elm_lang$svg$Svg$node('svg');
var _elm_lang$svg$Svg$foreignObject = _elm_lang$svg$Svg$node('foreignObject');
var _elm_lang$svg$Svg$animate = _elm_lang$svg$Svg$node('animate');
var _elm_lang$svg$Svg$animateColor = _elm_lang$svg$Svg$node('animateColor');
var _elm_lang$svg$Svg$animateMotion = _elm_lang$svg$Svg$node('animateMotion');
var _elm_lang$svg$Svg$animateTransform = _elm_lang$svg$Svg$node('animateTransform');
var _elm_lang$svg$Svg$mpath = _elm_lang$svg$Svg$node('mpath');
var _elm_lang$svg$Svg$set = _elm_lang$svg$Svg$node('set');
var _elm_lang$svg$Svg$a = _elm_lang$svg$Svg$node('a');
var _elm_lang$svg$Svg$defs = _elm_lang$svg$Svg$node('defs');
var _elm_lang$svg$Svg$g = _elm_lang$svg$Svg$node('g');
var _elm_lang$svg$Svg$marker = _elm_lang$svg$Svg$node('marker');
var _elm_lang$svg$Svg$mask = _elm_lang$svg$Svg$node('mask');
var _elm_lang$svg$Svg$pattern = _elm_lang$svg$Svg$node('pattern');
var _elm_lang$svg$Svg$switch = _elm_lang$svg$Svg$node('switch');
var _elm_lang$svg$Svg$symbol = _elm_lang$svg$Svg$node('symbol');
var _elm_lang$svg$Svg$desc = _elm_lang$svg$Svg$node('desc');
var _elm_lang$svg$Svg$metadata = _elm_lang$svg$Svg$node('metadata');
var _elm_lang$svg$Svg$title = _elm_lang$svg$Svg$node('title');
var _elm_lang$svg$Svg$feBlend = _elm_lang$svg$Svg$node('feBlend');
var _elm_lang$svg$Svg$feColorMatrix = _elm_lang$svg$Svg$node('feColorMatrix');
var _elm_lang$svg$Svg$feComponentTransfer = _elm_lang$svg$Svg$node('feComponentTransfer');
var _elm_lang$svg$Svg$feComposite = _elm_lang$svg$Svg$node('feComposite');
var _elm_lang$svg$Svg$feConvolveMatrix = _elm_lang$svg$Svg$node('feConvolveMatrix');
var _elm_lang$svg$Svg$feDiffuseLighting = _elm_lang$svg$Svg$node('feDiffuseLighting');
var _elm_lang$svg$Svg$feDisplacementMap = _elm_lang$svg$Svg$node('feDisplacementMap');
var _elm_lang$svg$Svg$feFlood = _elm_lang$svg$Svg$node('feFlood');
var _elm_lang$svg$Svg$feFuncA = _elm_lang$svg$Svg$node('feFuncA');
var _elm_lang$svg$Svg$feFuncB = _elm_lang$svg$Svg$node('feFuncB');
var _elm_lang$svg$Svg$feFuncG = _elm_lang$svg$Svg$node('feFuncG');
var _elm_lang$svg$Svg$feFuncR = _elm_lang$svg$Svg$node('feFuncR');
var _elm_lang$svg$Svg$feGaussianBlur = _elm_lang$svg$Svg$node('feGaussianBlur');
var _elm_lang$svg$Svg$feImage = _elm_lang$svg$Svg$node('feImage');
var _elm_lang$svg$Svg$feMerge = _elm_lang$svg$Svg$node('feMerge');
var _elm_lang$svg$Svg$feMergeNode = _elm_lang$svg$Svg$node('feMergeNode');
var _elm_lang$svg$Svg$feMorphology = _elm_lang$svg$Svg$node('feMorphology');
var _elm_lang$svg$Svg$feOffset = _elm_lang$svg$Svg$node('feOffset');
var _elm_lang$svg$Svg$feSpecularLighting = _elm_lang$svg$Svg$node('feSpecularLighting');
var _elm_lang$svg$Svg$feTile = _elm_lang$svg$Svg$node('feTile');
var _elm_lang$svg$Svg$feTurbulence = _elm_lang$svg$Svg$node('feTurbulence');
var _elm_lang$svg$Svg$font = _elm_lang$svg$Svg$node('font');
var _elm_lang$svg$Svg$linearGradient = _elm_lang$svg$Svg$node('linearGradient');
var _elm_lang$svg$Svg$radialGradient = _elm_lang$svg$Svg$node('radialGradient');
var _elm_lang$svg$Svg$stop = _elm_lang$svg$Svg$node('stop');
var _elm_lang$svg$Svg$circle = _elm_lang$svg$Svg$node('circle');
var _elm_lang$svg$Svg$ellipse = _elm_lang$svg$Svg$node('ellipse');
var _elm_lang$svg$Svg$image = _elm_lang$svg$Svg$node('image');
var _elm_lang$svg$Svg$line = _elm_lang$svg$Svg$node('line');
var _elm_lang$svg$Svg$path = _elm_lang$svg$Svg$node('path');
var _elm_lang$svg$Svg$polygon = _elm_lang$svg$Svg$node('polygon');
var _elm_lang$svg$Svg$polyline = _elm_lang$svg$Svg$node('polyline');
var _elm_lang$svg$Svg$rect = _elm_lang$svg$Svg$node('rect');
var _elm_lang$svg$Svg$use = _elm_lang$svg$Svg$node('use');
var _elm_lang$svg$Svg$feDistantLight = _elm_lang$svg$Svg$node('feDistantLight');
var _elm_lang$svg$Svg$fePointLight = _elm_lang$svg$Svg$node('fePointLight');
var _elm_lang$svg$Svg$feSpotLight = _elm_lang$svg$Svg$node('feSpotLight');
var _elm_lang$svg$Svg$altGlyph = _elm_lang$svg$Svg$node('altGlyph');
var _elm_lang$svg$Svg$altGlyphDef = _elm_lang$svg$Svg$node('altGlyphDef');
var _elm_lang$svg$Svg$altGlyphItem = _elm_lang$svg$Svg$node('altGlyphItem');
var _elm_lang$svg$Svg$glyph = _elm_lang$svg$Svg$node('glyph');
var _elm_lang$svg$Svg$glyphRef = _elm_lang$svg$Svg$node('glyphRef');
var _elm_lang$svg$Svg$textPath = _elm_lang$svg$Svg$node('textPath');
var _elm_lang$svg$Svg$text_ = _elm_lang$svg$Svg$node('text');
var _elm_lang$svg$Svg$tref = _elm_lang$svg$Svg$node('tref');
var _elm_lang$svg$Svg$tspan = _elm_lang$svg$Svg$node('tspan');
var _elm_lang$svg$Svg$clipPath = _elm_lang$svg$Svg$node('clipPath');
var _elm_lang$svg$Svg$colorProfile = _elm_lang$svg$Svg$node('colorProfile');
var _elm_lang$svg$Svg$cursor = _elm_lang$svg$Svg$node('cursor');
var _elm_lang$svg$Svg$filter = _elm_lang$svg$Svg$node('filter');
var _elm_lang$svg$Svg$script = _elm_lang$svg$Svg$node('script');
var _elm_lang$svg$Svg$style = _elm_lang$svg$Svg$node('style');
var _elm_lang$svg$Svg$view = _elm_lang$svg$Svg$node('view');

var _elm_lang$svg$Svg_Attributes$writingMode = _elm_lang$virtual_dom$VirtualDom$attribute('writing-mode');
var _elm_lang$svg$Svg_Attributes$wordSpacing = _elm_lang$virtual_dom$VirtualDom$attribute('word-spacing');
var _elm_lang$svg$Svg_Attributes$visibility = _elm_lang$virtual_dom$VirtualDom$attribute('visibility');
var _elm_lang$svg$Svg_Attributes$unicodeBidi = _elm_lang$virtual_dom$VirtualDom$attribute('unicode-bidi');
var _elm_lang$svg$Svg_Attributes$textRendering = _elm_lang$virtual_dom$VirtualDom$attribute('text-rendering');
var _elm_lang$svg$Svg_Attributes$textDecoration = _elm_lang$virtual_dom$VirtualDom$attribute('text-decoration');
var _elm_lang$svg$Svg_Attributes$textAnchor = _elm_lang$virtual_dom$VirtualDom$attribute('text-anchor');
var _elm_lang$svg$Svg_Attributes$stroke = _elm_lang$virtual_dom$VirtualDom$attribute('stroke');
var _elm_lang$svg$Svg_Attributes$strokeWidth = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-width');
var _elm_lang$svg$Svg_Attributes$strokeOpacity = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-opacity');
var _elm_lang$svg$Svg_Attributes$strokeMiterlimit = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-miterlimit');
var _elm_lang$svg$Svg_Attributes$strokeLinejoin = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-linejoin');
var _elm_lang$svg$Svg_Attributes$strokeLinecap = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-linecap');
var _elm_lang$svg$Svg_Attributes$strokeDashoffset = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-dashoffset');
var _elm_lang$svg$Svg_Attributes$strokeDasharray = _elm_lang$virtual_dom$VirtualDom$attribute('stroke-dasharray');
var _elm_lang$svg$Svg_Attributes$stopOpacity = _elm_lang$virtual_dom$VirtualDom$attribute('stop-opacity');
var _elm_lang$svg$Svg_Attributes$stopColor = _elm_lang$virtual_dom$VirtualDom$attribute('stop-color');
var _elm_lang$svg$Svg_Attributes$shapeRendering = _elm_lang$virtual_dom$VirtualDom$attribute('shape-rendering');
var _elm_lang$svg$Svg_Attributes$pointerEvents = _elm_lang$virtual_dom$VirtualDom$attribute('pointer-events');
var _elm_lang$svg$Svg_Attributes$overflow = _elm_lang$virtual_dom$VirtualDom$attribute('overflow');
var _elm_lang$svg$Svg_Attributes$opacity = _elm_lang$virtual_dom$VirtualDom$attribute('opacity');
var _elm_lang$svg$Svg_Attributes$mask = _elm_lang$virtual_dom$VirtualDom$attribute('mask');
var _elm_lang$svg$Svg_Attributes$markerStart = _elm_lang$virtual_dom$VirtualDom$attribute('marker-start');
var _elm_lang$svg$Svg_Attributes$markerMid = _elm_lang$virtual_dom$VirtualDom$attribute('marker-mid');
var _elm_lang$svg$Svg_Attributes$markerEnd = _elm_lang$virtual_dom$VirtualDom$attribute('marker-end');
var _elm_lang$svg$Svg_Attributes$lightingColor = _elm_lang$virtual_dom$VirtualDom$attribute('lighting-color');
var _elm_lang$svg$Svg_Attributes$letterSpacing = _elm_lang$virtual_dom$VirtualDom$attribute('letter-spacing');
var _elm_lang$svg$Svg_Attributes$kerning = _elm_lang$virtual_dom$VirtualDom$attribute('kerning');
var _elm_lang$svg$Svg_Attributes$imageRendering = _elm_lang$virtual_dom$VirtualDom$attribute('image-rendering');
var _elm_lang$svg$Svg_Attributes$glyphOrientationVertical = _elm_lang$virtual_dom$VirtualDom$attribute('glyph-orientation-vertical');
var _elm_lang$svg$Svg_Attributes$glyphOrientationHorizontal = _elm_lang$virtual_dom$VirtualDom$attribute('glyph-orientation-horizontal');
var _elm_lang$svg$Svg_Attributes$fontWeight = _elm_lang$virtual_dom$VirtualDom$attribute('font-weight');
var _elm_lang$svg$Svg_Attributes$fontVariant = _elm_lang$virtual_dom$VirtualDom$attribute('font-variant');
var _elm_lang$svg$Svg_Attributes$fontStyle = _elm_lang$virtual_dom$VirtualDom$attribute('font-style');
var _elm_lang$svg$Svg_Attributes$fontStretch = _elm_lang$virtual_dom$VirtualDom$attribute('font-stretch');
var _elm_lang$svg$Svg_Attributes$fontSize = _elm_lang$virtual_dom$VirtualDom$attribute('font-size');
var _elm_lang$svg$Svg_Attributes$fontSizeAdjust = _elm_lang$virtual_dom$VirtualDom$attribute('font-size-adjust');
var _elm_lang$svg$Svg_Attributes$fontFamily = _elm_lang$virtual_dom$VirtualDom$attribute('font-family');
var _elm_lang$svg$Svg_Attributes$floodOpacity = _elm_lang$virtual_dom$VirtualDom$attribute('flood-opacity');
var _elm_lang$svg$Svg_Attributes$floodColor = _elm_lang$virtual_dom$VirtualDom$attribute('flood-color');
var _elm_lang$svg$Svg_Attributes$filter = _elm_lang$virtual_dom$VirtualDom$attribute('filter');
var _elm_lang$svg$Svg_Attributes$fill = _elm_lang$virtual_dom$VirtualDom$attribute('fill');
var _elm_lang$svg$Svg_Attributes$fillRule = _elm_lang$virtual_dom$VirtualDom$attribute('fill-rule');
var _elm_lang$svg$Svg_Attributes$fillOpacity = _elm_lang$virtual_dom$VirtualDom$attribute('fill-opacity');
var _elm_lang$svg$Svg_Attributes$enableBackground = _elm_lang$virtual_dom$VirtualDom$attribute('enable-background');
var _elm_lang$svg$Svg_Attributes$dominantBaseline = _elm_lang$virtual_dom$VirtualDom$attribute('dominant-baseline');
var _elm_lang$svg$Svg_Attributes$display = _elm_lang$virtual_dom$VirtualDom$attribute('display');
var _elm_lang$svg$Svg_Attributes$direction = _elm_lang$virtual_dom$VirtualDom$attribute('direction');
var _elm_lang$svg$Svg_Attributes$cursor = _elm_lang$virtual_dom$VirtualDom$attribute('cursor');
var _elm_lang$svg$Svg_Attributes$color = _elm_lang$virtual_dom$VirtualDom$attribute('color');
var _elm_lang$svg$Svg_Attributes$colorRendering = _elm_lang$virtual_dom$VirtualDom$attribute('color-rendering');
var _elm_lang$svg$Svg_Attributes$colorProfile = _elm_lang$virtual_dom$VirtualDom$attribute('color-profile');
var _elm_lang$svg$Svg_Attributes$colorInterpolation = _elm_lang$virtual_dom$VirtualDom$attribute('color-interpolation');
var _elm_lang$svg$Svg_Attributes$colorInterpolationFilters = _elm_lang$virtual_dom$VirtualDom$attribute('color-interpolation-filters');
var _elm_lang$svg$Svg_Attributes$clip = _elm_lang$virtual_dom$VirtualDom$attribute('clip');
var _elm_lang$svg$Svg_Attributes$clipRule = _elm_lang$virtual_dom$VirtualDom$attribute('clip-rule');
var _elm_lang$svg$Svg_Attributes$clipPath = _elm_lang$virtual_dom$VirtualDom$attribute('clip-path');
var _elm_lang$svg$Svg_Attributes$baselineShift = _elm_lang$virtual_dom$VirtualDom$attribute('baseline-shift');
var _elm_lang$svg$Svg_Attributes$alignmentBaseline = _elm_lang$virtual_dom$VirtualDom$attribute('alignment-baseline');
var _elm_lang$svg$Svg_Attributes$zoomAndPan = _elm_lang$virtual_dom$VirtualDom$attribute('zoomAndPan');
var _elm_lang$svg$Svg_Attributes$z = _elm_lang$virtual_dom$VirtualDom$attribute('z');
var _elm_lang$svg$Svg_Attributes$yChannelSelector = _elm_lang$virtual_dom$VirtualDom$attribute('yChannelSelector');
var _elm_lang$svg$Svg_Attributes$y2 = _elm_lang$virtual_dom$VirtualDom$attribute('y2');
var _elm_lang$svg$Svg_Attributes$y1 = _elm_lang$virtual_dom$VirtualDom$attribute('y1');
var _elm_lang$svg$Svg_Attributes$y = _elm_lang$virtual_dom$VirtualDom$attribute('y');
var _elm_lang$svg$Svg_Attributes$xmlSpace = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/XML/1998/namespace', 'xml:space');
var _elm_lang$svg$Svg_Attributes$xmlLang = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/XML/1998/namespace', 'xml:lang');
var _elm_lang$svg$Svg_Attributes$xmlBase = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/XML/1998/namespace', 'xml:base');
var _elm_lang$svg$Svg_Attributes$xlinkType = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:type');
var _elm_lang$svg$Svg_Attributes$xlinkTitle = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:title');
var _elm_lang$svg$Svg_Attributes$xlinkShow = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:show');
var _elm_lang$svg$Svg_Attributes$xlinkRole = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:role');
var _elm_lang$svg$Svg_Attributes$xlinkHref = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:href');
var _elm_lang$svg$Svg_Attributes$xlinkArcrole = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:arcrole');
var _elm_lang$svg$Svg_Attributes$xlinkActuate = A2(_elm_lang$virtual_dom$VirtualDom$attributeNS, 'http://www.w3.org/1999/xlink', 'xlink:actuate');
var _elm_lang$svg$Svg_Attributes$xChannelSelector = _elm_lang$virtual_dom$VirtualDom$attribute('xChannelSelector');
var _elm_lang$svg$Svg_Attributes$x2 = _elm_lang$virtual_dom$VirtualDom$attribute('x2');
var _elm_lang$svg$Svg_Attributes$x1 = _elm_lang$virtual_dom$VirtualDom$attribute('x1');
var _elm_lang$svg$Svg_Attributes$xHeight = _elm_lang$virtual_dom$VirtualDom$attribute('x-height');
var _elm_lang$svg$Svg_Attributes$x = _elm_lang$virtual_dom$VirtualDom$attribute('x');
var _elm_lang$svg$Svg_Attributes$widths = _elm_lang$virtual_dom$VirtualDom$attribute('widths');
var _elm_lang$svg$Svg_Attributes$width = _elm_lang$virtual_dom$VirtualDom$attribute('width');
var _elm_lang$svg$Svg_Attributes$viewTarget = _elm_lang$virtual_dom$VirtualDom$attribute('viewTarget');
var _elm_lang$svg$Svg_Attributes$viewBox = _elm_lang$virtual_dom$VirtualDom$attribute('viewBox');
var _elm_lang$svg$Svg_Attributes$vertOriginY = _elm_lang$virtual_dom$VirtualDom$attribute('vert-origin-y');
var _elm_lang$svg$Svg_Attributes$vertOriginX = _elm_lang$virtual_dom$VirtualDom$attribute('vert-origin-x');
var _elm_lang$svg$Svg_Attributes$vertAdvY = _elm_lang$virtual_dom$VirtualDom$attribute('vert-adv-y');
var _elm_lang$svg$Svg_Attributes$version = _elm_lang$virtual_dom$VirtualDom$attribute('version');
var _elm_lang$svg$Svg_Attributes$values = _elm_lang$virtual_dom$VirtualDom$attribute('values');
var _elm_lang$svg$Svg_Attributes$vMathematical = _elm_lang$virtual_dom$VirtualDom$attribute('v-mathematical');
var _elm_lang$svg$Svg_Attributes$vIdeographic = _elm_lang$virtual_dom$VirtualDom$attribute('v-ideographic');
var _elm_lang$svg$Svg_Attributes$vHanging = _elm_lang$virtual_dom$VirtualDom$attribute('v-hanging');
var _elm_lang$svg$Svg_Attributes$vAlphabetic = _elm_lang$virtual_dom$VirtualDom$attribute('v-alphabetic');
var _elm_lang$svg$Svg_Attributes$unitsPerEm = _elm_lang$virtual_dom$VirtualDom$attribute('units-per-em');
var _elm_lang$svg$Svg_Attributes$unicodeRange = _elm_lang$virtual_dom$VirtualDom$attribute('unicode-range');
var _elm_lang$svg$Svg_Attributes$unicode = _elm_lang$virtual_dom$VirtualDom$attribute('unicode');
var _elm_lang$svg$Svg_Attributes$underlineThickness = _elm_lang$virtual_dom$VirtualDom$attribute('underline-thickness');
var _elm_lang$svg$Svg_Attributes$underlinePosition = _elm_lang$virtual_dom$VirtualDom$attribute('underline-position');
var _elm_lang$svg$Svg_Attributes$u2 = _elm_lang$virtual_dom$VirtualDom$attribute('u2');
var _elm_lang$svg$Svg_Attributes$u1 = _elm_lang$virtual_dom$VirtualDom$attribute('u1');
var _elm_lang$svg$Svg_Attributes$type_ = _elm_lang$virtual_dom$VirtualDom$attribute('type');
var _elm_lang$svg$Svg_Attributes$transform = _elm_lang$virtual_dom$VirtualDom$attribute('transform');
var _elm_lang$svg$Svg_Attributes$to = _elm_lang$virtual_dom$VirtualDom$attribute('to');
var _elm_lang$svg$Svg_Attributes$title = _elm_lang$virtual_dom$VirtualDom$attribute('title');
var _elm_lang$svg$Svg_Attributes$textLength = _elm_lang$virtual_dom$VirtualDom$attribute('textLength');
var _elm_lang$svg$Svg_Attributes$targetY = _elm_lang$virtual_dom$VirtualDom$attribute('targetY');
var _elm_lang$svg$Svg_Attributes$targetX = _elm_lang$virtual_dom$VirtualDom$attribute('targetX');
var _elm_lang$svg$Svg_Attributes$target = _elm_lang$virtual_dom$VirtualDom$attribute('target');
var _elm_lang$svg$Svg_Attributes$tableValues = _elm_lang$virtual_dom$VirtualDom$attribute('tableValues');
var _elm_lang$svg$Svg_Attributes$systemLanguage = _elm_lang$virtual_dom$VirtualDom$attribute('systemLanguage');
var _elm_lang$svg$Svg_Attributes$surfaceScale = _elm_lang$virtual_dom$VirtualDom$attribute('surfaceScale');
var _elm_lang$svg$Svg_Attributes$style = _elm_lang$virtual_dom$VirtualDom$attribute('style');
var _elm_lang$svg$Svg_Attributes$string = _elm_lang$virtual_dom$VirtualDom$attribute('string');
var _elm_lang$svg$Svg_Attributes$strikethroughThickness = _elm_lang$virtual_dom$VirtualDom$attribute('strikethrough-thickness');
var _elm_lang$svg$Svg_Attributes$strikethroughPosition = _elm_lang$virtual_dom$VirtualDom$attribute('strikethrough-position');
var _elm_lang$svg$Svg_Attributes$stitchTiles = _elm_lang$virtual_dom$VirtualDom$attribute('stitchTiles');
var _elm_lang$svg$Svg_Attributes$stemv = _elm_lang$virtual_dom$VirtualDom$attribute('stemv');
var _elm_lang$svg$Svg_Attributes$stemh = _elm_lang$virtual_dom$VirtualDom$attribute('stemh');
var _elm_lang$svg$Svg_Attributes$stdDeviation = _elm_lang$virtual_dom$VirtualDom$attribute('stdDeviation');
var _elm_lang$svg$Svg_Attributes$startOffset = _elm_lang$virtual_dom$VirtualDom$attribute('startOffset');
var _elm_lang$svg$Svg_Attributes$spreadMethod = _elm_lang$virtual_dom$VirtualDom$attribute('spreadMethod');
var _elm_lang$svg$Svg_Attributes$speed = _elm_lang$virtual_dom$VirtualDom$attribute('speed');
var _elm_lang$svg$Svg_Attributes$specularExponent = _elm_lang$virtual_dom$VirtualDom$attribute('specularExponent');
var _elm_lang$svg$Svg_Attributes$specularConstant = _elm_lang$virtual_dom$VirtualDom$attribute('specularConstant');
var _elm_lang$svg$Svg_Attributes$spacing = _elm_lang$virtual_dom$VirtualDom$attribute('spacing');
var _elm_lang$svg$Svg_Attributes$slope = _elm_lang$virtual_dom$VirtualDom$attribute('slope');
var _elm_lang$svg$Svg_Attributes$seed = _elm_lang$virtual_dom$VirtualDom$attribute('seed');
var _elm_lang$svg$Svg_Attributes$scale = _elm_lang$virtual_dom$VirtualDom$attribute('scale');
var _elm_lang$svg$Svg_Attributes$ry = _elm_lang$virtual_dom$VirtualDom$attribute('ry');
var _elm_lang$svg$Svg_Attributes$rx = _elm_lang$virtual_dom$VirtualDom$attribute('rx');
var _elm_lang$svg$Svg_Attributes$rotate = _elm_lang$virtual_dom$VirtualDom$attribute('rotate');
var _elm_lang$svg$Svg_Attributes$result = _elm_lang$virtual_dom$VirtualDom$attribute('result');
var _elm_lang$svg$Svg_Attributes$restart = _elm_lang$virtual_dom$VirtualDom$attribute('restart');
var _elm_lang$svg$Svg_Attributes$requiredFeatures = _elm_lang$virtual_dom$VirtualDom$attribute('requiredFeatures');
var _elm_lang$svg$Svg_Attributes$requiredExtensions = _elm_lang$virtual_dom$VirtualDom$attribute('requiredExtensions');
var _elm_lang$svg$Svg_Attributes$repeatDur = _elm_lang$virtual_dom$VirtualDom$attribute('repeatDur');
var _elm_lang$svg$Svg_Attributes$repeatCount = _elm_lang$virtual_dom$VirtualDom$attribute('repeatCount');
var _elm_lang$svg$Svg_Attributes$renderingIntent = _elm_lang$virtual_dom$VirtualDom$attribute('rendering-intent');
var _elm_lang$svg$Svg_Attributes$refY = _elm_lang$virtual_dom$VirtualDom$attribute('refY');
var _elm_lang$svg$Svg_Attributes$refX = _elm_lang$virtual_dom$VirtualDom$attribute('refX');
var _elm_lang$svg$Svg_Attributes$radius = _elm_lang$virtual_dom$VirtualDom$attribute('radius');
var _elm_lang$svg$Svg_Attributes$r = _elm_lang$virtual_dom$VirtualDom$attribute('r');
var _elm_lang$svg$Svg_Attributes$primitiveUnits = _elm_lang$virtual_dom$VirtualDom$attribute('primitiveUnits');
var _elm_lang$svg$Svg_Attributes$preserveAspectRatio = _elm_lang$virtual_dom$VirtualDom$attribute('preserveAspectRatio');
var _elm_lang$svg$Svg_Attributes$preserveAlpha = _elm_lang$virtual_dom$VirtualDom$attribute('preserveAlpha');
var _elm_lang$svg$Svg_Attributes$pointsAtZ = _elm_lang$virtual_dom$VirtualDom$attribute('pointsAtZ');
var _elm_lang$svg$Svg_Attributes$pointsAtY = _elm_lang$virtual_dom$VirtualDom$attribute('pointsAtY');
var _elm_lang$svg$Svg_Attributes$pointsAtX = _elm_lang$virtual_dom$VirtualDom$attribute('pointsAtX');
var _elm_lang$svg$Svg_Attributes$points = _elm_lang$virtual_dom$VirtualDom$attribute('points');
var _elm_lang$svg$Svg_Attributes$pointOrder = _elm_lang$virtual_dom$VirtualDom$attribute('point-order');
var _elm_lang$svg$Svg_Attributes$patternUnits = _elm_lang$virtual_dom$VirtualDom$attribute('patternUnits');
var _elm_lang$svg$Svg_Attributes$patternTransform = _elm_lang$virtual_dom$VirtualDom$attribute('patternTransform');
var _elm_lang$svg$Svg_Attributes$patternContentUnits = _elm_lang$virtual_dom$VirtualDom$attribute('patternContentUnits');
var _elm_lang$svg$Svg_Attributes$pathLength = _elm_lang$virtual_dom$VirtualDom$attribute('pathLength');
var _elm_lang$svg$Svg_Attributes$path = _elm_lang$virtual_dom$VirtualDom$attribute('path');
var _elm_lang$svg$Svg_Attributes$panose1 = _elm_lang$virtual_dom$VirtualDom$attribute('panose-1');
var _elm_lang$svg$Svg_Attributes$overlineThickness = _elm_lang$virtual_dom$VirtualDom$attribute('overline-thickness');
var _elm_lang$svg$Svg_Attributes$overlinePosition = _elm_lang$virtual_dom$VirtualDom$attribute('overline-position');
var _elm_lang$svg$Svg_Attributes$origin = _elm_lang$virtual_dom$VirtualDom$attribute('origin');
var _elm_lang$svg$Svg_Attributes$orientation = _elm_lang$virtual_dom$VirtualDom$attribute('orientation');
var _elm_lang$svg$Svg_Attributes$orient = _elm_lang$virtual_dom$VirtualDom$attribute('orient');
var _elm_lang$svg$Svg_Attributes$order = _elm_lang$virtual_dom$VirtualDom$attribute('order');
var _elm_lang$svg$Svg_Attributes$operator = _elm_lang$virtual_dom$VirtualDom$attribute('operator');
var _elm_lang$svg$Svg_Attributes$offset = _elm_lang$virtual_dom$VirtualDom$attribute('offset');
var _elm_lang$svg$Svg_Attributes$numOctaves = _elm_lang$virtual_dom$VirtualDom$attribute('numOctaves');
var _elm_lang$svg$Svg_Attributes$name = _elm_lang$virtual_dom$VirtualDom$attribute('name');
var _elm_lang$svg$Svg_Attributes$mode = _elm_lang$virtual_dom$VirtualDom$attribute('mode');
var _elm_lang$svg$Svg_Attributes$min = _elm_lang$virtual_dom$VirtualDom$attribute('min');
var _elm_lang$svg$Svg_Attributes$method = _elm_lang$virtual_dom$VirtualDom$attribute('method');
var _elm_lang$svg$Svg_Attributes$media = _elm_lang$virtual_dom$VirtualDom$attribute('media');
var _elm_lang$svg$Svg_Attributes$max = _elm_lang$virtual_dom$VirtualDom$attribute('max');
var _elm_lang$svg$Svg_Attributes$mathematical = _elm_lang$virtual_dom$VirtualDom$attribute('mathematical');
var _elm_lang$svg$Svg_Attributes$maskUnits = _elm_lang$virtual_dom$VirtualDom$attribute('maskUnits');
var _elm_lang$svg$Svg_Attributes$maskContentUnits = _elm_lang$virtual_dom$VirtualDom$attribute('maskContentUnits');
var _elm_lang$svg$Svg_Attributes$markerWidth = _elm_lang$virtual_dom$VirtualDom$attribute('markerWidth');
var _elm_lang$svg$Svg_Attributes$markerUnits = _elm_lang$virtual_dom$VirtualDom$attribute('markerUnits');
var _elm_lang$svg$Svg_Attributes$markerHeight = _elm_lang$virtual_dom$VirtualDom$attribute('markerHeight');
var _elm_lang$svg$Svg_Attributes$local = _elm_lang$virtual_dom$VirtualDom$attribute('local');
var _elm_lang$svg$Svg_Attributes$limitingConeAngle = _elm_lang$virtual_dom$VirtualDom$attribute('limitingConeAngle');
var _elm_lang$svg$Svg_Attributes$lengthAdjust = _elm_lang$virtual_dom$VirtualDom$attribute('lengthAdjust');
var _elm_lang$svg$Svg_Attributes$lang = _elm_lang$virtual_dom$VirtualDom$attribute('lang');
var _elm_lang$svg$Svg_Attributes$keyTimes = _elm_lang$virtual_dom$VirtualDom$attribute('keyTimes');
var _elm_lang$svg$Svg_Attributes$keySplines = _elm_lang$virtual_dom$VirtualDom$attribute('keySplines');
var _elm_lang$svg$Svg_Attributes$keyPoints = _elm_lang$virtual_dom$VirtualDom$attribute('keyPoints');
var _elm_lang$svg$Svg_Attributes$kernelUnitLength = _elm_lang$virtual_dom$VirtualDom$attribute('kernelUnitLength');
var _elm_lang$svg$Svg_Attributes$kernelMatrix = _elm_lang$virtual_dom$VirtualDom$attribute('kernelMatrix');
var _elm_lang$svg$Svg_Attributes$k4 = _elm_lang$virtual_dom$VirtualDom$attribute('k4');
var _elm_lang$svg$Svg_Attributes$k3 = _elm_lang$virtual_dom$VirtualDom$attribute('k3');
var _elm_lang$svg$Svg_Attributes$k2 = _elm_lang$virtual_dom$VirtualDom$attribute('k2');
var _elm_lang$svg$Svg_Attributes$k1 = _elm_lang$virtual_dom$VirtualDom$attribute('k1');
var _elm_lang$svg$Svg_Attributes$k = _elm_lang$virtual_dom$VirtualDom$attribute('k');
var _elm_lang$svg$Svg_Attributes$intercept = _elm_lang$virtual_dom$VirtualDom$attribute('intercept');
var _elm_lang$svg$Svg_Attributes$in2 = _elm_lang$virtual_dom$VirtualDom$attribute('in2');
var _elm_lang$svg$Svg_Attributes$in_ = _elm_lang$virtual_dom$VirtualDom$attribute('in');
var _elm_lang$svg$Svg_Attributes$ideographic = _elm_lang$virtual_dom$VirtualDom$attribute('ideographic');
var _elm_lang$svg$Svg_Attributes$id = _elm_lang$virtual_dom$VirtualDom$attribute('id');
var _elm_lang$svg$Svg_Attributes$horizOriginY = _elm_lang$virtual_dom$VirtualDom$attribute('horiz-origin-y');
var _elm_lang$svg$Svg_Attributes$horizOriginX = _elm_lang$virtual_dom$VirtualDom$attribute('horiz-origin-x');
var _elm_lang$svg$Svg_Attributes$horizAdvX = _elm_lang$virtual_dom$VirtualDom$attribute('horiz-adv-x');
var _elm_lang$svg$Svg_Attributes$height = _elm_lang$virtual_dom$VirtualDom$attribute('height');
var _elm_lang$svg$Svg_Attributes$hanging = _elm_lang$virtual_dom$VirtualDom$attribute('hanging');
var _elm_lang$svg$Svg_Attributes$gradientUnits = _elm_lang$virtual_dom$VirtualDom$attribute('gradientUnits');
var _elm_lang$svg$Svg_Attributes$gradientTransform = _elm_lang$virtual_dom$VirtualDom$attribute('gradientTransform');
var _elm_lang$svg$Svg_Attributes$glyphRef = _elm_lang$virtual_dom$VirtualDom$attribute('glyphRef');
var _elm_lang$svg$Svg_Attributes$glyphName = _elm_lang$virtual_dom$VirtualDom$attribute('glyph-name');
var _elm_lang$svg$Svg_Attributes$g2 = _elm_lang$virtual_dom$VirtualDom$attribute('g2');
var _elm_lang$svg$Svg_Attributes$g1 = _elm_lang$virtual_dom$VirtualDom$attribute('g1');
var _elm_lang$svg$Svg_Attributes$fy = _elm_lang$virtual_dom$VirtualDom$attribute('fy');
var _elm_lang$svg$Svg_Attributes$fx = _elm_lang$virtual_dom$VirtualDom$attribute('fx');
var _elm_lang$svg$Svg_Attributes$from = _elm_lang$virtual_dom$VirtualDom$attribute('from');
var _elm_lang$svg$Svg_Attributes$format = _elm_lang$virtual_dom$VirtualDom$attribute('format');
var _elm_lang$svg$Svg_Attributes$filterUnits = _elm_lang$virtual_dom$VirtualDom$attribute('filterUnits');
var _elm_lang$svg$Svg_Attributes$filterRes = _elm_lang$virtual_dom$VirtualDom$attribute('filterRes');
var _elm_lang$svg$Svg_Attributes$externalResourcesRequired = _elm_lang$virtual_dom$VirtualDom$attribute('externalResourcesRequired');
var _elm_lang$svg$Svg_Attributes$exponent = _elm_lang$virtual_dom$VirtualDom$attribute('exponent');
var _elm_lang$svg$Svg_Attributes$end = _elm_lang$virtual_dom$VirtualDom$attribute('end');
var _elm_lang$svg$Svg_Attributes$elevation = _elm_lang$virtual_dom$VirtualDom$attribute('elevation');
var _elm_lang$svg$Svg_Attributes$edgeMode = _elm_lang$virtual_dom$VirtualDom$attribute('edgeMode');
var _elm_lang$svg$Svg_Attributes$dy = _elm_lang$virtual_dom$VirtualDom$attribute('dy');
var _elm_lang$svg$Svg_Attributes$dx = _elm_lang$virtual_dom$VirtualDom$attribute('dx');
var _elm_lang$svg$Svg_Attributes$dur = _elm_lang$virtual_dom$VirtualDom$attribute('dur');
var _elm_lang$svg$Svg_Attributes$divisor = _elm_lang$virtual_dom$VirtualDom$attribute('divisor');
var _elm_lang$svg$Svg_Attributes$diffuseConstant = _elm_lang$virtual_dom$VirtualDom$attribute('diffuseConstant');
var _elm_lang$svg$Svg_Attributes$descent = _elm_lang$virtual_dom$VirtualDom$attribute('descent');
var _elm_lang$svg$Svg_Attributes$decelerate = _elm_lang$virtual_dom$VirtualDom$attribute('decelerate');
var _elm_lang$svg$Svg_Attributes$d = _elm_lang$virtual_dom$VirtualDom$attribute('d');
var _elm_lang$svg$Svg_Attributes$cy = _elm_lang$virtual_dom$VirtualDom$attribute('cy');
var _elm_lang$svg$Svg_Attributes$cx = _elm_lang$virtual_dom$VirtualDom$attribute('cx');
var _elm_lang$svg$Svg_Attributes$contentStyleType = _elm_lang$virtual_dom$VirtualDom$attribute('contentStyleType');
var _elm_lang$svg$Svg_Attributes$contentScriptType = _elm_lang$virtual_dom$VirtualDom$attribute('contentScriptType');
var _elm_lang$svg$Svg_Attributes$clipPathUnits = _elm_lang$virtual_dom$VirtualDom$attribute('clipPathUnits');
var _elm_lang$svg$Svg_Attributes$class = _elm_lang$virtual_dom$VirtualDom$attribute('class');
var _elm_lang$svg$Svg_Attributes$capHeight = _elm_lang$virtual_dom$VirtualDom$attribute('cap-height');
var _elm_lang$svg$Svg_Attributes$calcMode = _elm_lang$virtual_dom$VirtualDom$attribute('calcMode');
var _elm_lang$svg$Svg_Attributes$by = _elm_lang$virtual_dom$VirtualDom$attribute('by');
var _elm_lang$svg$Svg_Attributes$bias = _elm_lang$virtual_dom$VirtualDom$attribute('bias');
var _elm_lang$svg$Svg_Attributes$begin = _elm_lang$virtual_dom$VirtualDom$attribute('begin');
var _elm_lang$svg$Svg_Attributes$bbox = _elm_lang$virtual_dom$VirtualDom$attribute('bbox');
var _elm_lang$svg$Svg_Attributes$baseProfile = _elm_lang$virtual_dom$VirtualDom$attribute('baseProfile');
var _elm_lang$svg$Svg_Attributes$baseFrequency = _elm_lang$virtual_dom$VirtualDom$attribute('baseFrequency');
var _elm_lang$svg$Svg_Attributes$azimuth = _elm_lang$virtual_dom$VirtualDom$attribute('azimuth');
var _elm_lang$svg$Svg_Attributes$autoReverse = _elm_lang$virtual_dom$VirtualDom$attribute('autoReverse');
var _elm_lang$svg$Svg_Attributes$attributeType = _elm_lang$virtual_dom$VirtualDom$attribute('attributeType');
var _elm_lang$svg$Svg_Attributes$attributeName = _elm_lang$virtual_dom$VirtualDom$attribute('attributeName');
var _elm_lang$svg$Svg_Attributes$ascent = _elm_lang$virtual_dom$VirtualDom$attribute('ascent');
var _elm_lang$svg$Svg_Attributes$arabicForm = _elm_lang$virtual_dom$VirtualDom$attribute('arabic-form');
var _elm_lang$svg$Svg_Attributes$amplitude = _elm_lang$virtual_dom$VirtualDom$attribute('amplitude');
var _elm_lang$svg$Svg_Attributes$allowReorder = _elm_lang$virtual_dom$VirtualDom$attribute('allowReorder');
var _elm_lang$svg$Svg_Attributes$alphabetic = _elm_lang$virtual_dom$VirtualDom$attribute('alphabetic');
var _elm_lang$svg$Svg_Attributes$additive = _elm_lang$virtual_dom$VirtualDom$attribute('additive');
var _elm_lang$svg$Svg_Attributes$accumulate = _elm_lang$virtual_dom$VirtualDom$attribute('accumulate');
var _elm_lang$svg$Svg_Attributes$accelerate = _elm_lang$virtual_dom$VirtualDom$attribute('accelerate');
var _elm_lang$svg$Svg_Attributes$accentHeight = _elm_lang$virtual_dom$VirtualDom$attribute('accent-height');

var _user$project$Ace$Annotation = F3(
	function (a, b, c) {
		return {row: a, type_: b, text: c};
	});
var _user$project$Ace$Tooltip = F3(
	function (a, b, c) {
		return {row: a, col: b, text: c};
	});
var _user$project$Ace$Highlight = F2(
	function (a, b) {
		return {range: a, color: b};
	});
var _user$project$Ace$Pos = F2(
	function (a, b) {
		return {row: a, column: b};
	});
var _user$project$Ace$Range = F2(
	function (a, b) {
		return {start: a, end: b};
	});

var _user$project$Pos$posFromRowCol = function (_p0) {
	var _p1 = _p0;
	return {line: _p1._0, col: _p1._1};
};
var _user$project$Pos$dummyPos = {line: -1, col: -1};
var _user$project$Pos$startPos = {line: 1, col: 1};
var _user$project$Pos$Pos = F2(
	function (a, b) {
		return {line: a, col: b};
	});
var _user$project$Pos$WithPos = F2(
	function (a, b) {
		return {val: a, pos: b};
	});

var _user$project$Info$mapInfo = F2(
	function (f, wa) {
		return _elm_lang$core$Native_Utils.update(
			wa,
			{
				val: f(wa.val)
			});
	});
var _user$project$Info$hasDummyInfo = function (w) {
	return _elm_lang$core$Native_Utils.eq(
		{ctor: '_Tuple2', _0: w.start, _1: w.end},
		{ctor: '_Tuple2', _0: _user$project$Pos$dummyPos, _1: _user$project$Pos$dummyPos});
};
var _user$project$Info$withInfo = F3(
	function (x, start, end) {
		return {val: x, start: start, end: end};
	});
var _user$project$Info$withDummyInfo = function (x) {
	return A3(_user$project$Info$withInfo, x, _user$project$Pos$dummyPos, _user$project$Pos$dummyPos);
};
var _user$project$Info$mapInfoWS = F3(
	function (f, wca, c) {
		return A3(
			_user$project$Info$withInfo,
			f(
				wca.val(c)),
			wca.start,
			wca.end);
	});
var _user$project$Info$WithInfo = F3(
	function (a, b, c) {
		return {val: a, start: b, end: c};
	});
var _user$project$Info$replaceInfo = F2(
	function (wa, b) {
		return A3(_user$project$Info$WithInfo, b, wa.start, wa.end);
	});

var _user$project$ParserUtils$unparseStringContent = F2(
	function (quoteChar, text) {
		return A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'\\\\|',
					A2(_elm_lang$core$Basics_ops['++'], quoteChar, '|\r|\n|\t'))),
			function (_p0) {
				var _p1 = _p0;
				var _p2 = _p1.match;
				return _elm_lang$core$Native_Utils.eq(_p2, '\\') ? '\\\\' : (_elm_lang$core$Native_Utils.eq(_p2, '\n') ? '\\n' : (_elm_lang$core$Native_Utils.eq(_p2, '\r') ? '\\r' : (_elm_lang$core$Native_Utils.eq(_p2, '\t') ? '\\t' : A2(_elm_lang$core$Basics_ops['++'], '\\', quoteChar))));
			},
			text);
	});
var _user$project$ParserUtils$showIndentedProblem = F2(
	function (n, prob) {
		var indent = A2(_elm_lang$core$String$repeat, 2 * n, ' ');
		var _p3 = prob;
		switch (_p3.ctor) {
			case 'BadOneOf':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					indent,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'One of:\n',
						_elm_lang$core$String$concat(
							A2(
								_elm_lang$core$List$map,
								_user$project$ParserUtils$showIndentedProblem(n + 1),
								_p3._0))));
			case 'BadInt':
				return A2(_elm_lang$core$Basics_ops['++'], indent, 'Bad integer value\n');
			case 'BadFloat':
				return A2(_elm_lang$core$Basics_ops['++'], indent, 'Bad float value\n');
			case 'BadRepeat':
				return A2(_elm_lang$core$Basics_ops['++'], indent, 'Parse of zero-length input indefinitely\n');
			case 'ExpectingEnd':
				return A2(_elm_lang$core$Basics_ops['++'], indent, 'Expecting end\n');
			case 'ExpectingSymbol':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					indent,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expecting symbol \'',
						A2(_elm_lang$core$Basics_ops['++'], _p3._0, '\'\n')));
			case 'ExpectingKeyword':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					indent,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expecting keyword \'',
						A2(_elm_lang$core$Basics_ops['++'], _p3._0, '\'\n')));
			case 'ExpectingVariable':
				return A2(_elm_lang$core$Basics_ops['++'], indent, 'Expecting variable\n');
			case 'ExpectingClosing':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					indent,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expecting closing string \'',
						A2(_elm_lang$core$Basics_ops['++'], _p3._0, '\'\n')));
			default:
				return A2(
					_elm_lang$core$Basics_ops['++'],
					indent,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Parser failure: ',
						A2(_elm_lang$core$Basics_ops['++'], _p3._0, '\n')));
		}
	});
var _user$project$ParserUtils$showErrorReversible = function (err) {
	var deepestContext = function () {
		var _p4 = _elm_lang$core$List$head(err.context);
		if (_p4.ctor === 'Just') {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'Error while parsing \'',
				A2(_elm_lang$core$Basics_ops['++'], _p4._0.description, '\':\n'));
		} else {
			return '';
		}
	}();
	var showContext = function (c) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'  (row: ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$Basics$toString(c.row),
				A2(
					_elm_lang$core$Basics_ops['++'],
					', col: ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(c.col),
						A2(
							_elm_lang$core$Basics_ops['++'],
							') Error while parsing \'',
							A2(_elm_lang$core$Basics_ops['++'], c.description, '\'\n'))))));
	};
	var _p5 = function () {
		var arrow = A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$String$repeat, err.col - 1, ' '),
			'^');
		var sourceLines = _elm_lang$core$String$lines(err.source);
		var problemLine = _elm_lang$core$List$head(
			A2(_elm_lang$core$List$drop, err.row - 1, sourceLines));
		var _p6 = problemLine;
		if (_p6.ctor === 'Just') {
			var right = A2(
				_elm_lang$core$Basics_ops['++'],
				'\n',
				A2(_elm_lang$core$Basics_ops['++'], arrow, '\n\n'));
			return {
				ctor: '_Tuple2',
				_0: A2(_elm_lang$core$Basics_ops['++'], _p6._0, right),
				_1: function (newPrettyError) {
					if (A2(_elm_lang$core$String$endsWith, right, newPrettyError)) {
						var newLine = A2(
							_elm_lang$core$String$dropRight,
							_elm_lang$core$String$length(right),
							newPrettyError);
						var newSourceLines = A2(
							_elm_lang$core$Basics_ops['++'],
							A2(_elm_lang$core$List$take, err.row - 1, sourceLines),
							A2(
								_elm_lang$core$Basics_ops['++'],
								{
									ctor: '::',
									_0: newLine,
									_1: {ctor: '[]'}
								},
								A2(_elm_lang$core$List$drop, err.row, sourceLines)));
						return _elm_lang$core$Maybe$Just(
							A2(_elm_lang$core$String$join, '\n', newSourceLines));
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				}
			};
		} else {
			return {
				ctor: '_Tuple2',
				_0: '',
				_1: function (_p7) {
					return _elm_lang$core$Maybe$Nothing;
				}
			};
		}
	}();
	var prettyError = _p5._0;
	var putBackLine = _p5._1;
	var left = A2(
		_elm_lang$core$Basics_ops['++'],
		'[Parser Error]\n\n',
		A2(_elm_lang$core$Basics_ops['++'], deepestContext, '\n'));
	var middle = prettyError;
	var right = A2(
		_elm_lang$core$Basics_ops['++'],
		'Position\n',
		A2(
			_elm_lang$core$Basics_ops['++'],
			'========\n',
			A2(
				_elm_lang$core$Basics_ops['++'],
				'  Row: ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(err.row),
					A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'  Col: ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(err.col),
								A2(
									_elm_lang$core$Basics_ops['++'],
									'\n\n',
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Problem\n',
										A2(
											_elm_lang$core$Basics_ops['++'],
											'=======\n',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A2(_user$project$ParserUtils$showIndentedProblem, 1, err.problem),
												A2(
													_elm_lang$core$Basics_ops['++'],
													'\n',
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Context Stack\n',
														A2(
															_elm_lang$core$Basics_ops['++'],
															'=============\n',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_elm_lang$core$String$concat(
																	A2(_elm_lang$core$List$map, showContext, err.context)),
																'\n\n')))))))))))))));
	return {
		ctor: '_Tuple2',
		_0: A2(
			_elm_lang$core$Basics_ops['++'],
			left,
			A2(_elm_lang$core$Basics_ops['++'], middle, right)),
		_1: function (newError) {
			if (A2(_elm_lang$core$String$startsWith, left, newError)) {
				var newError2 = A2(
					_elm_lang$core$String$dropLeft,
					_elm_lang$core$String$length(left),
					newError);
				if (A2(_elm_lang$core$String$endsWith, right, newError2)) {
					var correctedLine = A2(
						_elm_lang$core$String$dropRight,
						_elm_lang$core$String$length(right),
						newError2);
					return putBackLine(correctedLine);
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		}
	};
};
var _user$project$ParserUtils$showError = function (err) {
	return _elm_lang$core$Tuple$first(
		_user$project$ParserUtils$showErrorReversible(err));
};
var _user$project$ParserUtils$setStartInfo = function (p) {
	return A2(
		_MikaelMayer$parser$Parser$map,
		F2(
			function (_p8, newStart) {
				var _p9 = _p8;
				return {val: _p9.val, start: newStart, end: _p9.end};
			}),
		p);
};
var _user$project$ParserUtils$untrackInfo = _MikaelMayer$parser$Parser$map(
	function (_) {
		return _.val;
	});
var _user$project$ParserUtils$getPos = A2(_MikaelMayer$parser$Parser$map, _user$project$Pos$posFromRowCol, _MikaelMayer$parser$Parser_LowLevel$getPosition);
var _user$project$ParserUtils$trackInfo = function (p) {
	return A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		F2(
			function (start, _p10) {
				var _p11 = _p10;
				return A3(_user$project$Info$withInfo, _p11._0, start, _p11._1);
			}),
		_user$project$ParserUtils$getPos,
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})),
				p),
			_user$project$ParserUtils$getPos));
};
var _user$project$ParserUtils$char = A2(
	_MikaelMayer$parser$Parser$map,
	function (_p12) {
		return _elm_lang$core$Tuple$first(
			A2(
				_elm_lang$core$Maybe$withDefault,
				{
					ctor: '_Tuple2',
					_0: _elm_lang$core$Native_Utils.chr('_'),
					_1: ''
				},
				_elm_lang$core$String$uncons(_p12)));
	},
	A2(
		_MikaelMayer$parser$Parser$keep,
		_MikaelMayer$parser$Parser$Exactly(1),
		_elm_lang$core$Basics$always(true)));
var _user$project$ParserUtils$ignoreRegex = function (reg) {
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		function (_p13) {
			var _p14 = _p13;
			var _p18 = _p14._1;
			var sourceFromOffset = A3(
				_elm_lang$core$String$slice,
				_p14._0,
				_elm_lang$core$String$length(_p18),
				_p18);
			var finding = A3(
				_elm_lang$core$Regex$find,
				_elm_lang$core$Regex$AtMost(1),
				reg,
				sourceFromOffset);
			var _p15 = finding;
			if (_p15.ctor === '::') {
				var _p17 = _p15._0.index;
				return _elm_lang$core$Native_Utils.eq(_p17, 0) ? A2(
					_MikaelMayer$parser$Parser$ignore,
					_MikaelMayer$parser$Parser$Exactly(
						_elm_lang$core$String$length(_p15._0.match)),
					function (_p16) {
						return true;
					}) : _MikaelMayer$parser$Parser$fail(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'expecting regex \'',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(reg),
							A2(
								_elm_lang$core$Basics_ops['++'],
								'\' immediately but appeared only after ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(_p17),
									' characters')))));
			} else {
				return _MikaelMayer$parser$Parser$fail(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'expecting regex \'',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(reg),
							'\'')));
			}
		},
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})),
				_MikaelMayer$parser$Parser_LowLevel$getOffset),
			_MikaelMayer$parser$Parser_LowLevel$getSource));
};
var _user$project$ParserUtils$keepRegex = function (reg) {
	return _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_user$project$ParserUtils$ignoreRegex(reg)),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$fail(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'\'',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(reg),
							'\' did not match'))),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$ParserUtils$ignoreUntilRegex = function (reg) {
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		function (_p19) {
			var _p20 = _p19;
			var _p24 = _p20._1;
			var sourceFromOffset = A3(
				_elm_lang$core$String$slice,
				_p20._0,
				_elm_lang$core$String$length(_p24),
				_p24);
			var regexMatches = A3(
				_elm_lang$core$Regex$find,
				_elm_lang$core$Regex$AtMost(1),
				reg,
				sourceFromOffset);
			var _p21 = regexMatches;
			if (_p21.ctor === '::') {
				return A2(
					_MikaelMayer$parser$Parser$ignore,
					_MikaelMayer$parser$Parser$Exactly(_p21._0.index),
					function (_p22) {
						return true;
					});
			} else {
				return A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						A2(
							_MikaelMayer$parser$Parser$keep,
							_MikaelMayer$parser$Parser$zeroOrMore,
							function (_p23) {
								return true;
							})),
					_MikaelMayer$parser$Parser$fail(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'expecting regex \'',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(reg),
								'\''))));
			}
		},
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})),
				_MikaelMayer$parser$Parser_LowLevel$getOffset),
			_MikaelMayer$parser$Parser_LowLevel$getSource));
};
var _user$project$ParserUtils$keepUntilRegex = function (reg) {
	return _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_user$project$ParserUtils$ignoreUntilRegex(reg)),
			_1: {
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						A2(
							_MikaelMayer$parser$Parser$keep,
							_MikaelMayer$parser$Parser$zeroOrMore,
							function (_p25) {
								return true;
							})),
					_MikaelMayer$parser$Parser$fail(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'expecting closing string \'',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(reg),
								'\'')))),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$ParserUtils$singleLineString = function () {
	var stringHelper = function (quoteChar) {
		var quoteString = _elm_lang$core$String$fromChar(quoteChar);
		var quoteEscapeRegex = _elm_lang$core$Regex$regex(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'\n|\r|\t|\\\\|\\',
				A2(
					_elm_lang$core$Basics_ops['++'],
					quoteString,
					A2(_elm_lang$core$Basics_ops['++'], '|', quoteString))));
		return A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$succeed(
						function (x) {
							return {ctor: '_Tuple2', _0: quoteString, _1: x};
						}),
					_MikaelMayer$parser$Parser$symbol(quoteString)),
				A2(
					_MikaelMayer$parser$Parser$map,
					_elm_lang$core$String$concat,
					A2(
						_MikaelMayer$parser$Parser$repeat,
						_MikaelMayer$parser$Parser$zeroOrMore,
						_MikaelMayer$parser$Parser$oneOf(
							{
								ctor: '::',
								_0: A2(
									_MikaelMayer$parser$Parser$map,
									function (_p26) {
										return quoteString;
									},
									_MikaelMayer$parser$Parser$symbol(
										A2(_elm_lang$core$Basics_ops['++'], '\\', quoteString))),
								_1: {
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser$map,
										function (_p27) {
											return '\n';
										},
										_MikaelMayer$parser$Parser$symbol('\\n')),
									_1: {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser$map,
											function (_p28) {
												return '\r';
											},
											_MikaelMayer$parser$Parser$symbol('\\r')),
										_1: {
											ctor: '::',
											_0: A2(
												_MikaelMayer$parser$Parser$map,
												function (_p29) {
													return '\t';
												},
												_MikaelMayer$parser$Parser$symbol('\\t')),
											_1: {
												ctor: '::',
												_0: A2(
													_MikaelMayer$parser$Parser$map,
													function (_p30) {
														return '\\';
													},
													_MikaelMayer$parser$Parser$symbol('\\\\')),
												_1: {
													ctor: '::',
													_0: A2(
														_MikaelMayer$parser$Parser_ops['|='],
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															_MikaelMayer$parser$Parser$succeed(
																F2(
																	function (a, b) {
																		return A2(_elm_lang$core$Basics_ops['++'], a, b);
																	})),
															A2(
																_MikaelMayer$parser$Parser$keep,
																_MikaelMayer$parser$Parser$Exactly(1),
																function (c) {
																	return (!_elm_lang$core$Native_Utils.eq(c, quoteChar)) && ((!_elm_lang$core$Native_Utils.eq(
																		c,
																		_elm_lang$core$Native_Utils.chr('\\'))) && (!_elm_lang$core$Native_Utils.eq(
																		c,
																		_elm_lang$core$Native_Utils.chr('\n'))));
																})),
														_user$project$ParserUtils$keepUntilRegex(quoteEscapeRegex)),
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							})))),
			_MikaelMayer$parser$Parser$symbol(quoteString));
	};
	return _MikaelMayer$parser$Parser$oneOf(
		A2(
			_elm_lang$core$List$map,
			stringHelper,
			{
				ctor: '::',
				_0: _elm_lang$core$Native_Utils.chr('\''),
				_1: {
					ctor: '::',
					_0: _elm_lang$core$Native_Utils.chr('\"'),
					_1: {ctor: '[]'}
				}
			}));
}();
var _user$project$ParserUtils$keepUntil = function (endString) {
	var endLength = _elm_lang$core$String$length(endString);
	return _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: A2(
				_MikaelMayer$parser$Parser$map,
				_elm_lang$core$String$dropRight(endLength),
				_MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$ignoreUntil(endString))),
			_1: {
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						A2(
							_MikaelMayer$parser$Parser$keep,
							_MikaelMayer$parser$Parser$zeroOrMore,
							function (_p31) {
								return true;
							})),
					_MikaelMayer$parser$Parser$fail(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'expecting closing string \'',
							A2(_elm_lang$core$Basics_ops['++'], endString, '\'')))),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$ParserUtils$inside = function (delimiter) {
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
			_MikaelMayer$parser$Parser$symbol(delimiter)),
		_user$project$ParserUtils$keepUntil(delimiter));
};
var _user$project$ParserUtils$token = F2(
	function (text, val) {
		return A2(
			_MikaelMayer$parser$Parser$map,
			function (_p32) {
				return val;
			},
			_MikaelMayer$parser$Parser$keyword(text));
	});
var _user$project$ParserUtils$guard = F2(
	function (failReason, pred) {
		return pred ? _MikaelMayer$parser$Parser$succeed(
			{ctor: '_Tuple0'}) : _MikaelMayer$parser$Parser$fail(failReason);
	});
var _user$project$ParserUtils$optional = function (parser) {
	return _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: A2(_MikaelMayer$parser$Parser$map, _elm_lang$core$Maybe$Just, parser),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$succeed(_elm_lang$core$Maybe$Nothing),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$ParserUtils$try = function (parser) {
	return A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		_elm_lang$core$Basics$always,
		parser,
		_MikaelMayer$parser$Parser$succeed(
			{ctor: '_Tuple0'}));
};
var _user$project$ParserUtils$separateBy = F3(
	function (count, sep, p) {
		var sepThenP = A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
				sep),
			p);
		var _p33 = count;
		if (_p33.ctor === 'AtLeast') {
			var _p34 = _p33._0;
			return (_elm_lang$core$Native_Utils.cmp(_p34, 0) < 1) ? _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A3(
						_user$project$ParserUtils$separateBy,
						_MikaelMayer$parser$Parser$AtLeast(1),
						sep,
						p),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$succeed(
							{ctor: '[]'}),
						_1: {ctor: '[]'}
					}
				}) : A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (x, xs1, xs2) {
									return {
										ctor: '::',
										_0: x,
										_1: A2(_elm_lang$core$Basics_ops['++'], xs1, xs2)
									};
								})),
						p),
					A2(
						_MikaelMayer$parser$Parser$repeat,
						_MikaelMayer$parser$Parser$Exactly(_p34 - 1),
						sepThenP)),
				A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, sepThenP));
		} else {
			var _p35 = _p33._0;
			return (_elm_lang$core$Native_Utils.cmp(_p35, 0) < 1) ? _MikaelMayer$parser$Parser$succeed(
				{ctor: '[]'}) : A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (x, y) {
								return {ctor: '::', _0: x, _1: y};
							})),
					p),
				A2(
					_MikaelMayer$parser$Parser$repeat,
					_MikaelMayer$parser$Parser$Exactly(_p35 - 1),
					sepThenP));
		}
	});
var _user$project$ParserUtils$negativeLookAhead = function (parser) {
	var getResult = A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F2(
					function (offset, source) {
						var remainingCode = A2(_elm_lang$core$String$dropLeft, offset, source);
						return A2(_MikaelMayer$parser$Parser$run, parser, remainingCode);
					})),
			_MikaelMayer$parser$Parser_LowLevel$getOffset),
		_MikaelMayer$parser$Parser_LowLevel$getSource);
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		function (result) {
			var _p36 = result;
			if (_p36.ctor === 'Ok') {
				return _MikaelMayer$parser$Parser$fail('Don\'t want to parse this.');
			} else {
				return _MikaelMayer$parser$Parser$succeed(
					{ctor: '_Tuple0'});
			}
		},
		getResult);
};
var _user$project$ParserUtils$lookAhead = function (parser) {
	var getResult = A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F2(
					function (offset, source) {
						var remainingCode = A2(_elm_lang$core$String$dropLeft, offset, source);
						return A2(_MikaelMayer$parser$Parser$run, parser, remainingCode);
					})),
			_MikaelMayer$parser$Parser_LowLevel$getOffset),
		_MikaelMayer$parser$Parser_LowLevel$getSource);
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		function (result) {
			var _p37 = result;
			if (_p37.ctor === 'Ok') {
				return _MikaelMayer$parser$Parser$succeed(_p37._0);
			} else {
				return parser;
			}
		},
		getResult);
};

var _user$project$BinaryOperatorParser$getOperatorInfo = F2(
	function (op, _p0) {
		var _p1 = _p0;
		return A2(_elm_lang$core$Dict$get, op, _p1._0);
	});
var _user$project$BinaryOperatorParser$binaryOperator = function (args) {
	var _p2 = args;
	var greedySpaceParser = _p2.greedySpaceParser;
	var precedenceTable = _p2.precedenceTable;
	var minimumPrecedence = _p2.minimumPrecedence;
	var expression = _p2.expression;
	var withZeroSpace = _p2.withZeroSpace;
	var operator = _p2.operator;
	var representation = _p2.representation;
	var combine = _p2.combine;
	var loop = function (resultWSExp) {
		return A3(
			_elm_lang$core$Basics$flip,
			_MikaelMayer$parser$Parser$andThen,
			_user$project$ParserUtils$lookAhead(
				_user$project$ParserUtils$optional(operator)),
			function (maybeOperator) {
				var _p3 = maybeOperator;
				if (_p3.ctor === 'Just') {
					var _p7 = _p3._0;
					var opRepresentation = representation(_p7);
					var _p4 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, opRepresentation, precedenceTable);
					if (_p4.ctor === 'Just') {
						var _p6 = _p4._0._1;
						if (_elm_lang$core$Native_Utils.cmp(_p6, minimumPrecedence) > -1) {
							var $continue = function (rightExp) {
								var newResult = function (wsBeforeAll) {
									return A4(
										combine,
										wsBeforeAll,
										withZeroSpace(resultWSExp),
										_p7,
										rightExp);
								};
								return loop(newResult);
							};
							var nextMinimumPrecedence = function () {
								var _p5 = _p4._0._0;
								if (_p5.ctor === 'Left') {
									return _p6 + 1;
								} else {
									return _p6;
								}
							}();
							var rightHandSide = A3(
								_MikaelMayer$parser$Parser$delayedCommitMap,
								F2(
									function (ws, r) {
										return r(ws);
									}),
								greedySpaceParser,
								_user$project$BinaryOperatorParser$binaryOperator(
									_elm_lang$core$Native_Utils.update(
										args,
										{minimumPrecedence: nextMinimumPrecedence})));
							return A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
									operator),
								A2(_MikaelMayer$parser$Parser$andThen, $continue, rightHandSide));
						} else {
							return _MikaelMayer$parser$Parser$succeed(resultWSExp);
						}
					} else {
						return _MikaelMayer$parser$Parser$fail(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'trying to parse operator \'',
								A2(
									_elm_lang$core$Basics_ops['++'],
									opRepresentation,
									A2(_elm_lang$core$Basics_ops['++'], '\' but no information for it was found in the', ' precedence table'))));
					}
				} else {
					return _MikaelMayer$parser$Parser$succeed(resultWSExp);
				}
			});
	};
	return A2(_MikaelMayer$parser$Parser$andThen, loop, expression);
};
var _user$project$BinaryOperatorParser$Right = {ctor: 'Right'};
var _user$project$BinaryOperatorParser$Left = {ctor: 'Left'};
var _user$project$BinaryOperatorParser$PT = function (a) {
	return {ctor: 'PT', _0: a};
};
var _user$project$BinaryOperatorParser$emptyPrecedenceTable = _user$project$BinaryOperatorParser$PT(_elm_lang$core$Dict$empty);
var _user$project$BinaryOperatorParser$addOperator = F2(
	function (_p9, _p8) {
		var _p10 = _p9;
		var _p11 = _p8;
		return _user$project$BinaryOperatorParser$PT(
			A3(
				_elm_lang$core$Dict$insert,
				_p10._0,
				{ctor: '_Tuple2', _0: _p10._1, _1: _p10._2},
				_p11._0));
	});
var _user$project$BinaryOperatorParser$buildPrecedenceTable = function () {
	var build = F4(
		function (associativity, precedence, operators, table) {
			return A3(
				_elm_lang$core$List$foldl,
				function (op) {
					return _user$project$BinaryOperatorParser$addOperator(
						{ctor: '_Tuple3', _0: op, _1: associativity, _2: precedence});
				},
				table,
				operators);
		});
	var buildPrecedenceLevel = F2(
		function (_p12, table) {
			var _p13 = _p12;
			var _p14 = _p13._0;
			return A4(
				build,
				_user$project$BinaryOperatorParser$Right,
				_p14,
				_p13._2,
				A4(build, _user$project$BinaryOperatorParser$Left, _p14, _p13._1, table));
		});
	return A2(_elm_lang$core$List$foldl, buildPrecedenceLevel, _user$project$BinaryOperatorParser$emptyPrecedenceTable);
}();

var _user$project$Utils$fixtailrec = F2(
	function (value, callback) {
		return callback(value);
	});
var _user$project$Utils$removeDuplicates = function () {
	var helper = F2(
		function (result, xs) {
			helper:
			while (true) {
				var _p0 = xs;
				if (_p0.ctor === '[]') {
					return result;
				} else {
					var _p2 = _p0._1;
					var _p1 = _p0._0;
					if (A2(_elm_lang$core$List$member, _p1, _p2)) {
						var _v1 = result,
							_v2 = _p2;
						result = _v1;
						xs = _v2;
						continue helper;
					} else {
						var _v3 = {ctor: '::', _0: _p1, _1: result},
							_v4 = _p2;
						result = _v3;
						xs = _v4;
						continue helper;
					}
				}
			}
		});
	return helper(
		{ctor: '[]'});
}();
var _user$project$Utils$reorder = F2(
	function (order, elements) {
		if (_elm_lang$core$List$isEmpty(order)) {
			return elements;
		} else {
			var elementArray = _elm_lang$core$Array$fromList(elements);
			var aux = F2(
				function (order, revAcc) {
					aux:
					while (true) {
						var _p3 = order;
						if (_p3.ctor === '[]') {
							return _elm_lang$core$List$reverse(revAcc);
						} else {
							var _v6 = _p3._1,
								_v7 = A2(
								_elm_lang$core$Maybe$withDefault,
								revAcc,
								A2(
									_elm_lang$core$Maybe$map,
									function (x) {
										return {ctor: '::', _0: x, _1: revAcc};
									},
									A2(_elm_lang$core$Array$get, _p3._0, elementArray)));
							order = _v6;
							revAcc = _v7;
							continue aux;
						}
					}
				});
			return A2(
				aux,
				order,
				{ctor: '[]'});
		}
	});
var _user$project$Utils$indexedMapFrom = F2(
	function (n, f) {
		return _elm_lang$core$List$indexedMap(
			function (i) {
				return f(i + n);
			});
	});
var _user$project$Utils$transpose = function (l) {
	return A2(_elm_lang$core$List$all, _elm_lang$core$List$isEmpty, l) ? {ctor: '[]'} : {
		ctor: '::',
		_0: A2(
			_elm_lang$core$List$concatMap,
			_elm_lang$core$List$take(1),
			l),
		_1: _user$project$Utils$transpose(
			A2(
				_elm_lang$core$List$map,
				_elm_lang$core$List$drop(1),
				l))
	};
};
var _user$project$Utils$firstCharWRegex = _elm_lang$core$Regex$regex('^[\\w_]');
var _user$project$Utils$lastCharWRegex = _elm_lang$core$Regex$regex('[\\w_]$');
var _user$project$Utils$wouldNotRecognizeTokenSplit = F2(
	function (leftStr, rightStr) {
		return A2(_elm_lang$core$Regex$contains, _user$project$Utils$lastCharWRegex, leftStr) && A2(_elm_lang$core$Regex$contains, _user$project$Utils$firstCharWRegex, rightStr);
	});
var _user$project$Utils$dictGetFirst = F2(
	function (keys, dictionary) {
		dictGetFirst:
		while (true) {
			var _p4 = keys;
			if (_p4.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p5 = A2(_elm_lang$core$Dict$get, _p4._0, dictionary);
				if (_p5.ctor === 'Just') {
					return _p5;
				} else {
					var _v10 = _p4._1,
						_v11 = dictionary;
					keys = _v10;
					dictionary = _v11;
					continue dictGetFirst;
				}
			}
		}
	});
var _user$project$Utils$fromResult = function (result) {
	var _p6 = result;
	if (_p6.ctor === 'Ok') {
		return _p6._0;
	} else {
		return _p6._0;
	}
};
var _user$project$Utils$isOdd = function (n) {
	return _elm_lang$core$Native_Utils.eq(
		A2(_elm_lang$core$Basics_ops['%'], n, 2),
		1);
};
var _user$project$Utils$isEven = function (n) {
	return _elm_lang$core$Native_Utils.eq(
		A2(_elm_lang$core$Basics_ops['%'], n, 2),
		0);
};
var _user$project$Utils$log = function (s) {
	return A2(
		_elm_lang$core$Debug$log,
		s,
		{ctor: '_Tuple0'});
};
var _user$project$Utils$applyIf = F3(
	function (cond, funToApply, $default) {
		return cond ? funToApply($default) : $default;
	});
var _user$project$Utils$or = A2(
	_elm_lang$core$List$foldl,
	F2(
		function (x, y) {
			return x || y;
		}),
	false);
var _user$project$Utils$and = A2(
	_elm_lang$core$List$foldl,
	F2(
		function (x, y) {
			return x && y;
		}),
	true);
var _user$project$Utils$compose = A2(
	_elm_lang$core$List$foldl,
	F2(
		function (x, y) {
			return function (_p7) {
				return x(
					y(_p7));
			};
		}),
	_elm_lang$core$Basics$identity);
var _user$project$Utils$unwrap8 = function (xs) {
	var _p8 = xs;
	if (((((((((_p8.ctor === '::') && (_p8._1.ctor === '::')) && (_p8._1._1.ctor === '::')) && (_p8._1._1._1.ctor === '::')) && (_p8._1._1._1._1.ctor === '::')) && (_p8._1._1._1._1._1.ctor === '::')) && (_p8._1._1._1._1._1._1.ctor === '::')) && (_p8._1._1._1._1._1._1._1.ctor === '::')) && (_p8._1._1._1._1._1._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple8', _0: _p8._0, _1: _p8._1._0, _2: _p8._1._1._0, _3: _p8._1._1._1._0, _4: _p8._1._1._1._1._0, _5: _p8._1._1._1._1._1._0, _6: _p8._1._1._1._1._1._1._0, _7: _p8._1._1._1._1._1._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1383, column: 14},
				end: {line: 1385, column: 29}
			},
			_p8)('unwrap7');
	}
};
var _user$project$Utils$unwrap7 = function (xs) {
	var _p10 = xs;
	if ((((((((_p10.ctor === '::') && (_p10._1.ctor === '::')) && (_p10._1._1.ctor === '::')) && (_p10._1._1._1.ctor === '::')) && (_p10._1._1._1._1.ctor === '::')) && (_p10._1._1._1._1._1.ctor === '::')) && (_p10._1._1._1._1._1._1.ctor === '::')) && (_p10._1._1._1._1._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple7', _0: _p10._0, _1: _p10._1._0, _2: _p10._1._1._0, _3: _p10._1._1._1._0, _4: _p10._1._1._1._1._0, _5: _p10._1._1._1._1._1._0, _6: _p10._1._1._1._1._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1379, column: 14},
				end: {line: 1381, column: 29}
			},
			_p10)('unwrap7');
	}
};
var _user$project$Utils$unwrap6 = function (xs) {
	var _p12 = xs;
	if (((((((_p12.ctor === '::') && (_p12._1.ctor === '::')) && (_p12._1._1.ctor === '::')) && (_p12._1._1._1.ctor === '::')) && (_p12._1._1._1._1.ctor === '::')) && (_p12._1._1._1._1._1.ctor === '::')) && (_p12._1._1._1._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple6', _0: _p12._0, _1: _p12._1._0, _2: _p12._1._1._0, _3: _p12._1._1._1._0, _4: _p12._1._1._1._1._0, _5: _p12._1._1._1._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1375, column: 14},
				end: {line: 1377, column: 29}
			},
			_p12)('unwrap6');
	}
};
var _user$project$Utils$unwrap5 = function (xs) {
	var _p14 = xs;
	if ((((((_p14.ctor === '::') && (_p14._1.ctor === '::')) && (_p14._1._1.ctor === '::')) && (_p14._1._1._1.ctor === '::')) && (_p14._1._1._1._1.ctor === '::')) && (_p14._1._1._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple5', _0: _p14._0, _1: _p14._1._0, _2: _p14._1._1._0, _3: _p14._1._1._1._0, _4: _p14._1._1._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1371, column: 14},
				end: {line: 1373, column: 29}
			},
			_p14)('unwrap5');
	}
};
var _user$project$Utils$unwrap4 = function (xs) {
	var _p16 = xs;
	if (((((_p16.ctor === '::') && (_p16._1.ctor === '::')) && (_p16._1._1.ctor === '::')) && (_p16._1._1._1.ctor === '::')) && (_p16._1._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple4', _0: _p16._0, _1: _p16._1._0, _2: _p16._1._1._0, _3: _p16._1._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1367, column: 14},
				end: {line: 1369, column: 29}
			},
			_p16)('unwrap4');
	}
};
var _user$project$Utils$unwrap3 = function (xs) {
	var _p18 = xs;
	if ((((_p18.ctor === '::') && (_p18._1.ctor === '::')) && (_p18._1._1.ctor === '::')) && (_p18._1._1._1.ctor === '[]')) {
		return {ctor: '_Tuple3', _0: _p18._0, _1: _p18._1._0, _2: _p18._1._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1363, column: 14},
				end: {line: 1365, column: 29}
			},
			_p18)('unwrap3');
	}
};
var _user$project$Utils$unwrap2 = function (xs) {
	var _p20 = xs;
	if (((_p20.ctor === '::') && (_p20._1.ctor === '::')) && (_p20._1._1.ctor === '[]')) {
		return {ctor: '_Tuple2', _0: _p20._0, _1: _p20._1._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1359, column: 14},
				end: {line: 1361, column: 29}
			},
			_p20)('unwrap2');
	}
};
var _user$project$Utils$unwrap1 = function (xs) {
	var _p22 = xs;
	if ((_p22.ctor === '::') && (_p22._1.ctor === '[]')) {
		return _p22._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1355, column: 14},
				end: {line: 1357, column: 29}
			},
			_p22)('unwrap1');
	}
};
var _user$project$Utils$unwrapSingletonSet = function (set) {
	var _p24 = _elm_lang$core$Set$toList(set);
	if ((_p24.ctor === '::') && (_p24._1.ctor === '[]')) {
		return _p24._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1351, column: 26},
				end: {line: 1353, column: 42}
			},
			_p24)('unwrapSingletonSet');
	}
};
var _user$project$Utils$pairToList = function (_p26) {
	var _p27 = _p26;
	return {
		ctor: '::',
		_0: _p27._0,
		_1: {
			ctor: '::',
			_0: _p27._1,
			_1: {ctor: '[]'}
		}
	};
};
var _user$project$Utils$uniPlusMinus = 'Â±';
var _user$project$Utils$uniDelta = 'Î”';
var _user$project$Utils$uniLambda = 'Î»';
var _user$project$Utils$uniCamera = 'ðŸ“·';
var _user$project$Utils$uniReload = 'âŽ‹';
var _user$project$Utils$uniRedo = 'â–¶';
var _user$project$Utils$uniUndo = 'â—€';
var _user$project$Utils$uniSave = 'ðŸ’¾';
var _user$project$Utils$uniEnter = 'â†µ';
var _user$project$Utils$uniRight = 'â†’';
var _user$project$Utils$uniLeft = 'â†';
var _user$project$Utils$radiansToDegrees = function (rad) {
	return (rad / _elm_lang$core$Basics$pi) * 180;
};
var _user$project$Utils$numToColor_ = function (val) {
	var min = 55;
	var max = 200;
	var diff = max - min;
	var n = _elm_lang$core$Basics$toFloat(
		A2(_elm_lang$core$Basics_ops['%'], val, 360));
	var i = (_elm_lang$core$Basics$floor(n) / 60) | 0;
	var _p28 = i;
	switch (_p28) {
		case 0:
			return {
				ctor: '_Tuple3',
				_0: max,
				_1: _elm_lang$core$Basics$round(min + (diff * (1 - ((60 - n) / 60)))),
				_2: min
			};
		case 1:
			return {
				ctor: '_Tuple3',
				_0: _elm_lang$core$Basics$round(max - (diff * (1 - ((120 - n) / 60)))),
				_1: max,
				_2: min
			};
		case 2:
			return {
				ctor: '_Tuple3',
				_0: min,
				_1: max,
				_2: _elm_lang$core$Basics$round(min + (diff * (1 - ((180 - n) / 60))))
			};
		case 3:
			return {
				ctor: '_Tuple3',
				_0: min,
				_1: _elm_lang$core$Basics$round(max - (diff * (1 - ((240 - n) / 60)))),
				_2: max
			};
		case 4:
			return {
				ctor: '_Tuple3',
				_0: _elm_lang$core$Basics$round(min + (diff * (1 - ((300 - n) / 60)))),
				_1: min,
				_2: max
			};
		case 5:
			return {
				ctor: '_Tuple3',
				_0: max,
				_1: min,
				_2: _elm_lang$core$Basics$round(max - (diff * (1 - ((360 - n) / 60))))
			};
		default:
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 1310, column: 6},
					end: {line: 1317, column: 37}
				},
				_p28)('numToColor');
	}
};
var _user$project$Utils$midpoint = F2(
	function (_p31, _p30) {
		var _p32 = _p31;
		var _p33 = _p30;
		return {ctor: '_Tuple2', _0: (_p32._0 + _p33._0) / 2, _1: (_p32._1 + _p33._1) / 2};
	});
var _user$project$Utils$distance = F2(
	function (_p35, _p34) {
		var _p36 = _p35;
		var _p37 = _p34;
		return _elm_lang$core$Basics$sqrt(
			Math.pow(_p37._0 - _p36._0, 2) + Math.pow(_p37._1 - _p36._1, 2));
	});
var _user$project$Utils$distanceInt = F2(
	function (_p39, _p38) {
		var _p40 = _p39;
		var _p41 = _p38;
		return A2(
			_user$project$Utils$distance,
			{
				ctor: '_Tuple2',
				_0: _elm_lang$core$Basics$toFloat(_p40._0),
				_1: _elm_lang$core$Basics$toFloat(_p40._1)
			},
			{
				ctor: '_Tuple2',
				_0: _elm_lang$core$Basics$toFloat(_p41._0),
				_1: _elm_lang$core$Basics$toFloat(_p41._1)
			});
	});
var _user$project$Utils$between = F2(
	function (x, _p42) {
		var _p43 = _p42;
		return (_elm_lang$core$Native_Utils.cmp(_p43._0, x) < 1) && (_elm_lang$core$Native_Utils.cmp(x, _p43._1) < 0);
	});
var _user$project$Utils$numToColor = F2(
	function (n, i) {
		var j = _elm_lang$core$Basics$round((i / n) * 500);
		if (A2(
			_user$project$Utils$between,
			j,
			{ctor: '_Tuple2', _0: 0, _1: 360})) {
			return _user$project$Utils$numToColor_(j);
		} else {
			if (A2(
				_user$project$Utils$between,
				j,
				{ctor: '_Tuple2', _0: 360, _1: 380})) {
				return {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0};
			} else {
				if (A2(
					_user$project$Utils$between,
					j,
					{ctor: '_Tuple2', _0: 480, _1: 500})) {
					return {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255};
				} else {
					var x = _elm_lang$core$Basics$round(
						255 * ((_elm_lang$core$Basics$toFloat(j) - 380) / 100));
					return {ctor: '_Tuple3', _0: x, _1: x, _2: x};
				}
			}
		}
	});
var _user$project$Utils$sgn = function (x) {
	return _elm_lang$core$Native_Utils.eq(x, 0) ? 0 : ((_elm_lang$core$Native_Utils.cmp(x, 0) < 0) ? -1 : ((_elm_lang$core$Native_Utils.cmp(x, 0) > 0) ? 1 : x));
};
var _user$project$Utils$commonPrefixPair = F2(
	function (l1, l2) {
		var _p44 = {ctor: '_Tuple2', _0: l1, _1: l2};
		if (((_p44.ctor === '_Tuple2') && (_p44._0.ctor === '::')) && (_p44._1.ctor === '::')) {
			var _p45 = _p44._0._0;
			return _elm_lang$core$Native_Utils.eq(_p45, _p44._1._0) ? {
				ctor: '::',
				_0: _p45,
				_1: A2(_user$project$Utils$commonPrefixPair, _p44._0._1, _p44._1._1)
			} : {ctor: '[]'};
		} else {
			return {ctor: '[]'};
		}
	});
var _user$project$Utils$commonPrefix = function (lists) {
	var _p46 = lists;
	if (_p46.ctor === '::') {
		return A3(_elm_lang$core$List$foldl, _user$project$Utils$commonPrefixPair, _p46._0, _p46._1);
	} else {
		return {ctor: '[]'};
	}
};
var _user$project$Utils$commonSuffix = function (lists) {
	return _elm_lang$core$List$reverse(
		_user$project$Utils$commonPrefix(
			A2(_elm_lang$core$List$map, _elm_lang$core$List$reverse, lists)));
};
var _user$project$Utils$removeCommonPrefix = function (lists) {
	var prefixLength = _elm_lang$core$List$length(
		_user$project$Utils$commonPrefix(lists));
	return A2(
		_elm_lang$core$List$map,
		_elm_lang$core$List$drop(prefixLength),
		lists);
};
var _user$project$Utils$removeCommonSuffix = function (lists) {
	return A2(
		_elm_lang$core$List$map,
		_elm_lang$core$List$reverse,
		_user$project$Utils$removeCommonPrefix(
			A2(_elm_lang$core$List$map, _elm_lang$core$List$reverse, lists)));
};
var _user$project$Utils$isPrefixOf = F2(
	function (longer, prefix) {
		var _p47 = {ctor: '_Tuple2', _0: longer, _1: prefix};
		if (_p47._1.ctor === '[]') {
			return true;
		} else {
			if (_p47._0.ctor === '[]') {
				return false;
			} else {
				return _elm_lang$core$Native_Utils.eq(_p47._0._0, _p47._1._0) && A2(_user$project$Utils$isPrefixOf, _p47._0._1, _p47._1._1);
			}
		}
	});
var _user$project$Utils$isPrefix = F2(
	function (prefix, longer) {
		return A2(_user$project$Utils$isPrefixOf, longer, prefix);
	});
var _user$project$Utils$dictIsEmpty = function (_p48) {
	return A2(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(x, y);
			}),
		{ctor: '[]'},
		_elm_lang$core$Dict$toList(_p48));
};
var _user$project$Utils$setIsEmpty = function (_p49) {
	return A2(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(x, y);
			}),
		{ctor: '[]'},
		_elm_lang$core$Set$toList(_p49));
};
var _user$project$Utils$bindResult = F2(
	function (res, f) {
		var _p50 = res;
		if (_p50.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p50._0);
		} else {
			return f(_p50._0);
		}
	});
var _user$project$Utils$flip = function (_p51) {
	var _p52 = _p51;
	return {ctor: '_Tuple2', _0: _p52._1, _1: _p52._0};
};
var _user$project$Utils$mapThd3 = F2(
	function (f, _p53) {
		var _p54 = _p53;
		return {
			ctor: '_Tuple3',
			_0: _p54._0,
			_1: _p54._1,
			_2: f(_p54._2)
		};
	});
var _user$project$Utils$mapSnd3 = F2(
	function (f, _p55) {
		var _p56 = _p55;
		return {
			ctor: '_Tuple3',
			_0: _p56._0,
			_1: f(_p56._1),
			_2: _p56._2
		};
	});
var _user$project$Utils$mapFst3 = F2(
	function (f, _p57) {
		var _p58 = _p57;
		return {
			ctor: '_Tuple3',
			_0: f(_p58._0),
			_1: _p58._1,
			_2: _p58._2
		};
	});
var _user$project$Utils$thd3 = function (_p59) {
	var _p60 = _p59;
	return _p60._2;
};
var _user$project$Utils$snd3 = function (_p61) {
	var _p62 = _p61;
	return _p62._1;
};
var _user$project$Utils$fst3 = function (_p63) {
	var _p64 = _p63;
	return _p64._0;
};
var _user$project$Utils$mapFour = F2(
	function (f, _p65) {
		var _p66 = _p65;
		return {
			ctor: '_Tuple4',
			_0: f(_p66._0),
			_1: f(_p66._1),
			_2: f(_p66._2),
			_3: f(_p66._3)
		};
	});
var _user$project$Utils$mapThree = F2(
	function (f, _p67) {
		var _p68 = _p67;
		return {
			ctor: '_Tuple3',
			_0: f(_p68._0),
			_1: f(_p68._1),
			_2: f(_p68._2)
		};
	});
var _user$project$Utils$mapBoth = F2(
	function (f, _p69) {
		var _p70 = _p69;
		return {
			ctor: '_Tuple2',
			_0: f(_p70._0),
			_1: f(_p70._1)
		};
	});
var _user$project$Utils$mapFirstSecond = F3(
	function (f, g, _p71) {
		var _p72 = _p71;
		return {
			ctor: '_Tuple2',
			_0: f(_p72._0),
			_1: g(_p72._1)
		};
	});
var _user$project$Utils$foldlResult = F3(
	function (f, resultAcc, list) {
		foldlResult:
		while (true) {
			var _p73 = {ctor: '_Tuple2', _0: resultAcc, _1: list};
			if (_p73._0.ctor === 'Err') {
				return resultAcc;
			} else {
				if (_p73._1.ctor === '::') {
					var _v47 = f,
						_v48 = A2(f, _p73._1._0, _p73._0._0),
						_v49 = _p73._1._1;
					f = _v47;
					resultAcc = _v48;
					list = _v49;
					continue foldlResult;
				} else {
					return resultAcc;
				}
			}
		}
	});
var _user$project$Utils$projOk = function (list) {
	return A3(
		_elm_lang$core$List$foldr,
		F2(
			function (res, out) {
				var _p74 = {ctor: '_Tuple2', _0: res, _1: out};
				if (_p74._1.ctor === 'Err') {
					return out;
				} else {
					if (_p74._0.ctor === 'Ok') {
						return _elm_lang$core$Result$Ok(
							{ctor: '::', _0: _p74._0._0, _1: _p74._1._0});
					} else {
						return _elm_lang$core$Result$Err(_p74._0._0);
					}
				}
			}),
		_elm_lang$core$Result$Ok(
			{ctor: '[]'}),
		list);
};
var _user$project$Utils$foldrMaybe = F3(
	function (f, maybeAcc, list) {
		var _p75 = list;
		if (_p75.ctor === '[]') {
			return maybeAcc;
		} else {
			return A2(
				_elm_lang$core$Maybe$andThen,
				function (acc) {
					return A2(f, _p75._0, acc);
				},
				A3(_user$project$Utils$foldrMaybe, f, maybeAcc, _p75._1));
		}
	});
var _user$project$Utils$foldlMaybe = F3(
	function (f, maybeAcc, list) {
		foldlMaybe:
		while (true) {
			var _p76 = {ctor: '_Tuple2', _0: maybeAcc, _1: list};
			if (_p76._0.ctor === 'Nothing') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				if (_p76._1.ctor === '::') {
					var _v53 = f,
						_v54 = A2(f, _p76._1._0, _p76._0._0),
						_v55 = _p76._1._1;
					f = _v53;
					maybeAcc = _v54;
					list = _v55;
					continue foldlMaybe;
				} else {
					return maybeAcc;
				}
			}
		}
	});
var _user$project$Utils$filterErrs = function (mxs) {
	filterErrs:
	while (true) {
		var _p77 = mxs;
		if (_p77.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			if (_p77._0.ctor === 'Ok') {
				var _v57 = _p77._1;
				mxs = _v57;
				continue filterErrs;
			} else {
				return {
					ctor: '::',
					_0: _p77._0._0,
					_1: _user$project$Utils$filterErrs(_p77._1)
				};
			}
		}
	}
};
var _user$project$Utils$filterOks = function (mxs) {
	filterOks:
	while (true) {
		var _p78 = mxs;
		if (_p78.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			if (_p78._0.ctor === 'Ok') {
				return {
					ctor: '::',
					_0: _p78._0._0,
					_1: _user$project$Utils$filterOks(_p78._1)
				};
			} else {
				var _v59 = _p78._1;
				mxs = _v59;
				continue filterOks;
			}
		}
	}
};
var _user$project$Utils$filterJusts = function (mxs) {
	filterJusts:
	while (true) {
		var _p79 = mxs;
		if (_p79.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			if (_p79._0.ctor === 'Just') {
				return {
					ctor: '::',
					_0: _p79._0._0,
					_1: _user$project$Utils$filterJusts(_p79._1)
				};
			} else {
				var _v61 = _p79._1;
				mxs = _v61;
				continue filterJusts;
			}
		}
	}
};
var _user$project$Utils$projJusts = A2(
	_elm_lang$core$List$foldr,
	F2(
		function (mx, acc) {
			var _p80 = {ctor: '_Tuple2', _0: mx, _1: acc};
			if (((_p80.ctor === '_Tuple2') && (_p80._0.ctor === 'Just')) && (_p80._1.ctor === 'Just')) {
				return _elm_lang$core$Maybe$Just(
					{ctor: '::', _0: _p80._0._0, _1: _p80._1._0});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		}),
	_elm_lang$core$Maybe$Just(
		{ctor: '[]'}));
var _user$project$Utils$bindMaybesToList = F2(
	function (list, f) {
		var _p81 = _user$project$Utils$projJusts(list);
		if (_p81.ctor === 'Nothing') {
			return {ctor: '[]'};
		} else {
			return f(_p81._0);
		}
	});
var _user$project$Utils$elseMaybe = F2(
	function (mx, $default) {
		var _p82 = mx;
		if (_p82.ctor === 'Just') {
			return _p82._0;
		} else {
			return $default;
		}
	});
var _user$project$Utils$plusMaybe = F2(
	function (mx, my) {
		var _p83 = mx;
		if (_p83.ctor === 'Just') {
			return mx;
		} else {
			return my;
		}
	});
var _user$project$Utils$firstMaybe = function (list) {
	return A3(_elm_lang$core$List$foldr, _user$project$Utils$plusMaybe, _elm_lang$core$Maybe$Nothing, list);
};
var _user$project$Utils$bindMaybe = _elm_lang$core$Maybe$andThen;
var _user$project$Utils$bindMaybe2 = F3(
	function (f, mx, my) {
		return A2(
			_user$project$Utils$bindMaybe,
			function (x) {
				return A2(
					_user$project$Utils$bindMaybe,
					f(x),
					my);
			},
			mx);
	});
var _user$project$Utils$bindMaybe3 = F4(
	function (f, mx, my, mz) {
		return A3(
			_user$project$Utils$bindMaybe2,
			F2(
				function (x, y) {
					return A2(
						_user$project$Utils$bindMaybe,
						A2(f, x, y),
						mz);
				}),
			mx,
			my);
	});
var _user$project$Utils$filterMaybe = F2(
	function (pred, mx) {
		var _p84 = mx;
		if (_p84.ctor === 'Just') {
			var _p85 = _p84._0;
			return pred(_p85) ? _elm_lang$core$Maybe$Just(_p85) : _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Utils$strFoldLeftWithIndex = F3(
	function (acc, list, fold) {
		return _elm_lang$core$Tuple$first(
			A3(
				_elm_lang$core$String$foldl,
				F2(
					function (a, _p86) {
						var _p87 = _p86;
						var _p88 = _p87._1;
						return {
							ctor: '_Tuple2',
							_0: A3(fold, _p87._0, _p88, a),
							_1: _p88 + 1
						};
					}),
				{ctor: '_Tuple2', _0: acc, _1: 0},
				list));
	});
var _user$project$Utils$strFoldLeft = F3(
	function (acc, list, fold) {
		return A3(
			_elm_lang$core$String$foldl,
			_elm_lang$core$Basics$flip(fold),
			acc,
			list);
	});
var _user$project$Utils$foldLeftWithIndex = F3(
	function (acc, list, fold) {
		return _elm_lang$core$Tuple$first(
			A3(
				_elm_lang$core$List$foldl,
				F2(
					function (a, _p89) {
						var _p90 = _p89;
						var _p91 = _p90._1;
						return {
							ctor: '_Tuple2',
							_0: A3(fold, _p90._0, _p91, a),
							_1: _p91 + 1
						};
					}),
				{ctor: '_Tuple2', _0: acc, _1: 0},
				list));
	});
var _user$project$Utils$foldRight = F3(
	function (list, acc, fold) {
		return A3(
			_elm_lang$core$List$foldl,
			fold,
			acc,
			_elm_lang$core$List$reverse(list));
	});
var _user$project$Utils$foldLeft = F3(
	function (acc, list, fold) {
		return A3(
			_elm_lang$core$List$foldl,
			_elm_lang$core$Basics$flip(fold),
			acc,
			list);
	});
var _user$project$Utils$spanWhile = F2(
	function (pred, list) {
		var aux = F2(
			function (acc, list) {
				aux:
				while (true) {
					var _p92 = list;
					if (_p92.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$List$reverse(acc),
							_1: {ctor: '[]'}
						};
					} else {
						var _p93 = _p92._0;
						if (pred(_p93)) {
							var _v70 = {ctor: '::', _0: _p93, _1: acc},
								_v71 = _p92._1;
							acc = _v70;
							list = _v71;
							continue aux;
						} else {
							return {
								ctor: '_Tuple2',
								_0: _elm_lang$core$List$reverse(acc),
								_1: list
							};
						}
					}
				}
			});
		return A2(
			aux,
			{ctor: '[]'},
			list);
	});
var _user$project$Utils$dropWhile = F2(
	function (pred, list) {
		dropWhile:
		while (true) {
			var _p94 = list;
			if (_p94.ctor === '[]') {
				return {ctor: '[]'};
			} else {
				if (pred(_p94._0)) {
					var _v73 = pred,
						_v74 = _p94._1;
					pred = _v73;
					list = _v74;
					continue dropWhile;
				} else {
					return list;
				}
			}
		}
	});
var _user$project$Utils$takeWhile = F2(
	function (pred, list) {
		var _p95 = list;
		if (_p95.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var _p96 = _p95._0;
			return pred(_p96) ? {
				ctor: '::',
				_0: _p96,
				_1: A2(_user$project$Utils$takeWhile, pred, _p95._1)
			} : {ctor: '[]'};
		}
	});
var _user$project$Utils$takeLast = F2(
	function (n, list) {
		return _elm_lang$core$List$reverse(
			A2(
				_elm_lang$core$List$take,
				n,
				_elm_lang$core$List$reverse(list)));
	});
var _user$project$Utils$maybeUncons = function (list) {
	var _p97 = list;
	if (_p97.ctor === '[]') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple2', _0: _p97._0, _1: _p97._1});
	}
};
var _user$project$Utils$uncons = function (xs) {
	var _p98 = xs;
	if (_p98.ctor === '::') {
		return {ctor: '_Tuple2', _0: _p98._0, _1: _p98._1};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 1032, column: 13},
				end: {line: 1034, column: 32}
			},
			_p98)('uncons');
	}
};
var _user$project$Utils$nth = F2(
	function (list, n) {
		nth:
		while (true) {
			var _p100 = list;
			if (_p100.ctor === '[]') {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Cannot find ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(n),
							'-th element of a empty list')));
			} else {
				if (_elm_lang$core$Native_Utils.eq(n, 0)) {
					return _elm_lang$core$Result$Ok(_p100._0);
				} else {
					var _v79 = _p100._1,
						_v80 = n - 1;
					list = _v79;
					n = _v80;
					continue nth;
				}
			}
		}
	});
var _user$project$Utils$maybeInitLast = function (list) {
	var _p101 = list;
	if (_p101.ctor === '[]') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		if (_p101._1.ctor === '[]') {
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: _p101._0
				});
		} else {
			return A2(
				_elm_lang$core$Maybe$map,
				function (_p102) {
					var _p103 = _p102;
					return {
						ctor: '_Tuple2',
						_0: {ctor: '::', _0: _p101._0, _1: _p103._0},
						_1: _p103._1
					};
				},
				_user$project$Utils$maybeInitLast(_p101._1));
		}
	}
};
var _user$project$Utils$maybeInit = function (list) {
	var _p104 = list;
	if (_p104.ctor === '[]') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		if (_p104._1.ctor === '[]') {
			return _elm_lang$core$Maybe$Just(
				{ctor: '[]'});
		} else {
			return A2(
				_elm_lang$core$Maybe$map,
				function (x) {
					return {ctor: '::', _0: _p104._0, _1: x};
				},
				_user$project$Utils$maybeInit(_p104._1));
		}
	}
};
var _user$project$Utils$maybeLast = function (list) {
	maybeLast:
	while (true) {
		var _p105 = list;
		if (_p105.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			if (_p105._1.ctor === '[]') {
				return _elm_lang$core$Maybe$Just(_p105._0);
			} else {
				var _v85 = _p105._1;
				list = _v85;
				continue maybeLast;
			}
		}
	}
};
var _user$project$Utils$dictGetSet = F2(
	function (k, d) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			_elm_lang$core$Set$empty,
			A2(_elm_lang$core$Dict$get, k, d));
	});
var _user$project$Utils$dictUnionSet = F3(
	function (k, more, dict) {
		return A3(
			_elm_lang$core$Dict$insert,
			k,
			A2(
				_elm_lang$core$Set$union,
				more,
				A2(_user$project$Utils$dictGetSet, k, dict)),
			dict);
	});
var _user$project$Utils$dictAddToSet = F3(
	function (k, v, dict) {
		var _p106 = A2(_elm_lang$core$Dict$get, k, dict);
		if (_p106.ctor === 'Just') {
			return A3(
				_elm_lang$core$Dict$insert,
				k,
				A2(_elm_lang$core$Set$insert, v, _p106._0),
				dict);
		} else {
			return A3(
				_elm_lang$core$Dict$insert,
				k,
				_elm_lang$core$Set$singleton(v),
				dict);
		}
	});
var _user$project$Utils$multiKeySingleValue = F2(
	function (keys, value) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (key, dict) {
					return A3(_elm_lang$core$Dict$insert, key, value, dict);
				}),
			_elm_lang$core$Dict$empty,
			keys);
	});
var _user$project$Utils$flipDict = function (dict) {
	return _elm_lang$core$Dict$fromList(
		A2(
			_elm_lang$core$List$map,
			_user$project$Utils$flip,
			_elm_lang$core$Dict$toList(dict)));
};
var _user$project$Utils$toggleDict = F2(
	function (_p107, dict) {
		var _p108 = _p107;
		var _p109 = _p108._0;
		return A2(_elm_lang$core$Dict$member, _p109, dict) ? A2(_elm_lang$core$Dict$remove, _p109, dict) : A3(_elm_lang$core$Dict$insert, _p109, _p108._1, dict);
	});
var _user$project$Utils$multiToggleSet = F2(
	function (insertSet, set) {
		return A2(
			_elm_lang$core$Set$diff,
			A2(_elm_lang$core$Set$union, insertSet, set),
			A2(_elm_lang$core$Set$intersect, insertSet, set));
	});
var _user$project$Utils$toggleSet = F2(
	function (x, set) {
		return A2(_elm_lang$core$Set$member, x, set) ? A2(_elm_lang$core$Set$remove, x, set) : A2(_elm_lang$core$Set$insert, x, set);
	});
var _user$project$Utils$getWithDefault = F3(
	function (key, $default, dict) {
		var _p110 = A2(_elm_lang$core$Dict$get, key, dict);
		if (_p110.ctor === 'Just') {
			return _p110._0;
		} else {
			return $default;
		}
	});
var _user$project$Utils$justGetError = F4(
	function (s, k, d, _p111) {
		var _p112 = _p111;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'Utils.justGet ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				s,
				A2(
					_elm_lang$core$Basics_ops['++'],
					': key ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(k),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' not found in dictionary ',
							_elm_lang$core$Basics$toString(d))))));
	});
var _user$project$Utils$unwrapNestedResult = function (nestedResult) {
	var _p113 = nestedResult;
	if (_p113.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p113._0);
	} else {
		if (_p113._0.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p113._0._0);
		} else {
			return _elm_lang$core$Result$Ok(_p113._0._0);
		}
	}
};
var _user$project$Utils$fromOk = F2(
	function (s, mx) {
		var _p114 = mx;
		if (_p114.ctor === 'Ok') {
			return _p114._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 931, column: 15},
					end: {line: 933, column: 60}
				},
				_p114)(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'fromOk [',
					A2(
						_elm_lang$core$Basics_ops['++'],
						s,
						A2(_elm_lang$core$Basics_ops['++'], ']: ', _p114._0))));
		}
	});
var _user$project$Utils$fromOk_ = _user$project$Utils$fromOk('');
var _user$project$Utils$parseInt = function (_p116) {
	return _user$project$Utils$fromOk_(
		_elm_lang$core$String$toInt(_p116));
};
var _user$project$Utils$parseFloat = function (_p117) {
	return _user$project$Utils$fromOk_(
		_elm_lang$core$String$toFloat(_p117));
};
var _user$project$Utils$fromOkay = F2(
	function (s, mx) {
		var _p118 = mx;
		if (_p118.ctor === 'Ok') {
			return _p118._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 924, column: 17},
					end: {line: 926, column: 53}
				},
				_p118)(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'fromOkay [',
					A2(_elm_lang$core$Basics_ops['++'], s, ']: ')));
		}
	});
var _user$project$Utils$fromJust__ = F2(
	function (f, mx) {
		var _p120 = mx;
		if (_p120.ctor === 'Just') {
			return _p120._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 919, column: 19},
					end: {line: 921, column: 33}
				},
				_p120)(
				f(
					{ctor: '_Tuple0'}));
		}
	});
var _user$project$Utils$justGet = F2(
	function (k, d) {
		return A2(
			_user$project$Utils$fromJust__,
			A3(_user$project$Utils$justGetError, '', k, d),
			A2(_elm_lang$core$Dict$get, k, d));
	});
var _user$project$Utils$justGet_ = F3(
	function (s, k, d) {
		return A2(
			_user$project$Utils$fromJust__,
			A3(_user$project$Utils$justGetError, s, k, d),
			A2(_elm_lang$core$Dict$get, k, d));
	});
var _user$project$Utils$fromJust_ = F2(
	function (s, mx) {
		var _p122 = mx;
		if (_p122.ctor === 'Just') {
			return _p122._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 914, column: 18},
					end: {line: 916, column: 53}
				},
				_p122)(
				A2(_elm_lang$core$Basics_ops['++'], 'Utils.fromJust_: ', s));
		}
	});
var _user$project$Utils$head = function (msg) {
	return function (_p124) {
		return A2(
			_user$project$Utils$fromJust_,
			msg,
			_elm_lang$core$List$head(_p124));
	};
};
var _user$project$Utils$head_ = _user$project$Utils$head('Utils.head_');
var _user$project$Utils$tail = function (msg) {
	return function (_p125) {
		return A2(
			_user$project$Utils$fromJust_,
			msg,
			_elm_lang$core$List$tail(_p125));
	};
};
var _user$project$Utils$last = function (msg) {
	return function (_p126) {
		return A2(
			_user$project$Utils$fromJust_,
			msg,
			_user$project$Utils$maybeLast(_p126));
	};
};
var _user$project$Utils$last_ = _user$project$Utils$last('Utils.last_');
var _user$project$Utils$init = function (msg) {
	return function (_p127) {
		return A2(
			_user$project$Utils$fromJust_,
			msg,
			_user$project$Utils$maybeInit(_p127));
	};
};
var _user$project$Utils$init_ = _user$project$Utils$init('Utils.init_');
var _user$project$Utils$tail_ = function (_p128) {
	return A2(
		_user$project$Utils$fromJust_,
		'Utils.tail_',
		_elm_lang$core$List$tail(_p128));
};
var _user$project$Utils$resultToBool = function (r) {
	var _p129 = r;
	if (_p129.ctor === 'Ok') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Utils$maybeToBool = function (m) {
	var _p130 = m;
	if (_p130.ctor === 'Just') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Utils$assert = F2(
	function (s, b) {
		return b ? {ctor: '_Tuple0'} : _elm_lang$core$Native_Utils.crash(
			'Utils',
			{
				start: {line: 900, column: 32},
				end: {line: 900, column: 43}
			})(
			A2(_elm_lang$core$Basics_ops['++'], 'assert error: ', s));
	});
var _user$project$Utils$lift_2_2 = F3(
	function (f, _p132, _p131) {
		var _p133 = _p132;
		var _p134 = _p131;
		return {
			ctor: '_Tuple2',
			_0: A2(f, _p133._0, _p134._0),
			_1: A2(f, _p133._1, _p134._1)
		};
	});
var _user$project$Utils$avg = function (ns) {
	return _elm_lang$core$List$sum(ns) / _elm_lang$core$Basics$toFloat(
		_elm_lang$core$List$length(ns));
};
var _user$project$Utils$sum = A2(
	_elm_lang$core$List$foldl,
	F2(
		function (x, y) {
			return x + y;
		}),
	0);
var _user$project$Utils$stringReplace = F3(
	function (target, replacement, string) {
		return A2(
			_elm_lang$core$String$join,
			replacement,
			A2(_elm_lang$core$String$split, target, string));
	});
var _user$project$Utils$capitalize = function (str) {
	var _p135 = A2(_elm_lang$core$String$split, '', str);
	if (_p135.ctor === '[]') {
		return '';
	} else {
		return A2(
			_elm_lang$core$String$join,
			'',
			{
				ctor: '::',
				_0: _elm_lang$core$String$toUpper(_p135._0),
				_1: _p135._1
			});
	}
};
var _user$project$Utils$pluralize = F2(
	function (count, singular) {
		var _p136 = count;
		if (_p136 === 1) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$Basics$toString(count),
				A2(_elm_lang$core$Basics_ops['++'], ' ', singular));
		} else {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$Basics$toString(count),
				A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(_elm_lang$core$Basics_ops['++'], singular, 's')));
		}
	});
var _user$project$Utils$perhapsPluralizeList = F2(
	function (str, list) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			str,
			_elm_lang$core$Native_Utils.eq(
				_elm_lang$core$List$length(list),
				1) ? '' : 's');
	});
var _user$project$Utils$niceTruncateString = F3(
	function (n, toBeContinuedStr, str) {
		return (_elm_lang$core$Native_Utils.cmp(
			_elm_lang$core$String$length(str),
			n) > 0) ? A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$String$trimRight(
				A2(
					_elm_lang$core$String$left,
					n - _elm_lang$core$String$length(toBeContinuedStr),
					str)),
			toBeContinuedStr) : str;
	});
var _user$project$Utils$squish = function (str) {
	return _elm_lang$core$String$trim(
		A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex('\\s+'),
			function (_p137) {
				return ' ';
			},
			str));
};
var _user$project$Utils$commonPrefixString = function (strings) {
	return _elm_lang$core$String$fromList(
		_user$project$Utils$commonPrefix(
			A2(_elm_lang$core$List$map, _elm_lang$core$String$toList, strings)));
};
var _user$project$Utils$commonSuffixString = function (strings) {
	return _elm_lang$core$String$reverse(
		_user$project$Utils$commonPrefixString(
			A2(_elm_lang$core$List$map, _elm_lang$core$String$reverse, strings)));
};
var _user$project$Utils$takeNLines = F2(
	function (n, s) {
		return A2(
			_elm_lang$core$String$join,
			'\n',
			A2(
				_elm_lang$core$List$take,
				n,
				_elm_lang$core$String$lines(s)));
	});
var _user$project$Utils$splitString = F2(
	function (n, s) {
		return {
			ctor: '_Tuple2',
			_0: A2(_elm_lang$core$String$left, n, s),
			_1: A2(_elm_lang$core$String$dropLeft, n, s)
		};
	});
var _user$project$Utils$munchString = F2(
	function (prefix, s) {
		var _p138 = A2(
			_user$project$Utils$splitString,
			_elm_lang$core$String$length(prefix),
			s);
		var pre = _p138._0;
		var suf = _p138._1;
		return _elm_lang$core$Native_Utils.eq(pre, prefix) ? _elm_lang$core$Maybe$Just(suf) : _elm_lang$core$Maybe$Nothing;
	});
var _user$project$Utils$lines = _elm_lang$core$String$join('\n');
var _user$project$Utils$commas = _elm_lang$core$String$join(', ');
var _user$project$Utils$spaces = _elm_lang$core$String$join(' ');
var _user$project$Utils$delimit = F3(
	function (a, b, s) {
		return _elm_lang$core$String$concat(
			{
				ctor: '::',
				_0: a,
				_1: {
					ctor: '::',
					_0: s,
					_1: {
						ctor: '::',
						_0: b,
						_1: {ctor: '[]'}
					}
				}
			});
	});
var _user$project$Utils$parens = A2(_user$project$Utils$delimit, '(', ')');
var _user$project$Utils$bracks = A2(_user$project$Utils$delimit, '[', ']');
var _user$project$Utils$ibracks = A2(_user$project$Utils$delimit, '[|', '|]');
var _user$project$Utils$braces = A2(_user$project$Utils$delimit, '{', '}');
var _user$project$Utils$angleBracks = A2(_user$project$Utils$delimit, '<', '>');
var _user$project$Utils$recordInitMake = F2(
	function (m, b) {
		return A2(
			_elm_lang$core$Maybe$andThen,
			function (_p139) {
				var _p140 = _p139;
				return A2(
					_elm_lang$core$Maybe$map,
					function (bv) {
						return {ctor: '_Tuple2', _0: bv, _1: _p140._1};
					},
					b);
			},
			m);
	});
var _user$project$Utils$recordInitValue = _elm_lang$core$Maybe$map(_elm_lang$core$Tuple$first);
var _user$project$Utils$recordValuesMake = _elm_lang$core$List$map2(
	F2(
		function (_p141, value) {
			var _p142 = _p141;
			return {ctor: '_Tuple5', _0: _p142._0, _1: _p142._1, _2: _p142._2, _3: _p142._3, _4: value};
		}));
var _user$project$Utils$recordValueMap = F2(
	function (_p143, a) {
		var _p144 = _p143;
		return {ctor: '_Tuple5', _0: _p144._0, _1: _p144._1, _2: _p144._2, _3: _p144._3, _4: a};
	});
var _user$project$Utils$recordValue = function (_p145) {
	var _p146 = _p145;
	return _p146._4;
};
var _user$project$Utils$recordValues = _elm_lang$core$List$map(_user$project$Utils$recordValue);
var _user$project$Utils$recordValuesMap = F2(
	function (f, ts) {
		return A2(
			_user$project$Utils$recordValuesMake,
			ts,
			A2(
				_elm_lang$core$List$map,
				f,
				_user$project$Utils$recordValues(ts)));
	});
var _user$project$Utils$recordKey = function (_p147) {
	var _p148 = _p147;
	return _p148._2;
};
var _user$project$Utils$recordKeys = _elm_lang$core$List$map(_user$project$Utils$recordKey);
var _user$project$Utils$listValuesMake = _elm_lang$core$List$map2(
	F2(
		function (_p149, value) {
			var _p150 = _p149;
			return {ctor: '_Tuple2', _0: _p150._0, _1: value};
		}));
var _user$project$Utils$listValueMake = F2(
	function (_p151, c) {
		var _p152 = _p151;
		return {ctor: '_Tuple2', _0: _p152._0, _1: c};
	});
var _user$project$Utils$listValue = _elm_lang$core$Tuple$second;
var _user$project$Utils$listValues = _elm_lang$core$List$map(_user$project$Utils$listValue);
var _user$project$Utils$listValuesMap = F2(
	function (f, ts) {
		return A2(
			_user$project$Utils$listValuesMake,
			ts,
			A2(
				_elm_lang$core$List$map,
				f,
				_user$project$Utils$listValues(ts)));
	});
var _user$project$Utils$count = F2(
	function (pred, list) {
		return _elm_lang$core$List$length(
			A2(_elm_lang$core$List$filter, pred, list));
	});
var _user$project$Utils$maybeConsensus = function (bools) {
	return A2(
		_elm_lang$core$List$all,
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(x, y);
			})(true),
		bools) ? _elm_lang$core$Maybe$Just(true) : (A2(
		_elm_lang$core$List$all,
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(x, y);
			})(false),
		bools) ? _elm_lang$core$Maybe$Just(false) : _elm_lang$core$Maybe$Nothing);
};
var _user$project$Utils$allSame = function (list) {
	var _p153 = list;
	if (_p153.ctor === '[]') {
		return false;
	} else {
		return A2(
			_elm_lang$core$List$all,
			F2(
				function (x, y) {
					return _elm_lang$core$Native_Utils.eq(x, y);
				})(_p153._0),
			_p153._1);
	}
};
var _user$project$Utils$changeTail = F2(
	function (f, list) {
		var _p154 = list;
		if (_p154.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: _p154._0,
				_1: f(_p154._1)
			};
		}
	});
var _user$project$Utils$mapTail = _user$project$Utils$changeTail;
var _user$project$Utils$getReplacei0 = F3(
	function (i, f, list) {
		var _p155 = {
			ctor: '_Tuple2',
			_0: A2(_elm_lang$core$List$take, i, list),
			_1: A2(_elm_lang$core$List$drop, i, list)
		};
		if ((_p155.ctor === '_Tuple2') && (_p155._1.ctor === '::')) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p155._0,
				A2(
					_elm_lang$core$Basics_ops['++'],
					{
						ctor: '::',
						_0: f(_p155._1._0),
						_1: {ctor: '[]'}
					},
					_p155._1._1));
		} else {
			return list;
		}
	});
var _user$project$Utils$getReplacei1 = F3(
	function (i, f, list) {
		return A3(_user$project$Utils$getReplacei0, i - 1, f, list);
	});
var _user$project$Utils$mapHead = F2(
	function (f, list) {
		return A3(_user$project$Utils$getReplacei0, 0, f, list);
	});
var _user$project$Utils$mapLast = F2(
	function (f, list) {
		return A3(
			_user$project$Utils$getReplacei0,
			_elm_lang$core$List$length(list) - 1,
			f,
			list);
	});
var _user$project$Utils$maybeGeti1 = F2(
	function (i, list) {
		return (_elm_lang$core$Native_Utils.cmp(i, 1) > -1) ? _elm_lang$core$List$head(
			A2(_elm_lang$core$List$drop, i - 1, list)) : _elm_lang$core$Maybe$Nothing;
	});
var _user$project$Utils$maybeGeti0 = F2(
	function (i, list) {
		return (_elm_lang$core$Native_Utils.cmp(i, 0) > -1) ? _elm_lang$core$List$head(
			A2(_elm_lang$core$List$drop, i, list)) : _elm_lang$core$Maybe$Nothing;
	});
var _user$project$Utils$inserti = F3(
	function (i, xi_, xs) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$List$take, i - 1, xs),
			A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: xi_,
					_1: {ctor: '[]'}
				},
				A2(_elm_lang$core$List$drop, i - 1, xs)));
	});
var _user$project$Utils$removei = F2(
	function (i, xs) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$List$take, i - 1, xs),
			A2(_elm_lang$core$List$drop, i, xs));
	});
var _user$project$Utils$replacei = F3(
	function (i, xi_, xs) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$List$take, i - 1, xs),
			A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: xi_,
					_1: {ctor: '[]'}
				},
				A2(_elm_lang$core$List$drop, i, xs)));
	});
var _user$project$Utils$replacei0 = F3(
	function (i, xi_, xs) {
		return A3(_user$project$Utils$replacei, i + 1, xi_, xs);
	});
var _user$project$Utils$geti = function (i) {
	return function (_p156) {
		return A2(
			_user$project$Utils$fromJust_,
			'Utils.geti',
			_elm_lang$core$List$head(
				A2(_elm_lang$core$List$drop, i - 1, _p156)));
	};
};
var _user$project$Utils$findi_ = F3(
	function (i, p, xs) {
		findi_:
		while (true) {
			var _p157 = xs;
			if (_p157.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				if (p(_p157._0)) {
					return _elm_lang$core$Maybe$Just(i);
				} else {
					var _v112 = i + 1,
						_v113 = p,
						_v114 = _p157._1;
					i = _v112;
					p = _v113;
					xs = _v114;
					continue findi_;
				}
			}
		}
	});
var _user$project$Utils$findi = F2(
	function (p, xs) {
		return A3(_user$project$Utils$findi_, 1, p, xs);
	});
var _user$project$Utils$firstOrLazySecond = F2(
	function (maybe1, lazyMaybe2) {
		var _p158 = maybe1;
		if (_p158.ctor === 'Just') {
			return maybe1;
		} else {
			return lazyMaybe2(
				{ctor: '_Tuple0'});
		}
	});
var _user$project$Utils$maybeOrElseLazy = _elm_lang$core$Basics$flip(_user$project$Utils$firstOrLazySecond);
var _user$project$Utils$splitPrefix = F2(
	function (f, list) {
		var _p159 = list;
		if (_p159.ctor === '[]') {
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'}
			};
		} else {
			var _p160 = f(_p159._0);
			if (_p160.ctor === 'Nothing') {
				return {
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: list
				};
			} else {
				return A2(
					_elm_lang$core$Tuple$mapFirst,
					F2(
						function (x, y) {
							return {ctor: '::', _0: x, _1: y};
						})(_p160._0),
					A2(_user$project$Utils$splitPrefix, f, _p159._1));
			}
		}
	});
var _user$project$Utils$removeFirstSuccess = F2(
	function (f, list) {
		var _p161 = list;
		if (_p161.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p164 = _p161._1;
			var _p163 = _p161._0;
			var _p162 = f(_p163);
			if (_p162.ctor === 'Nothing') {
				return A2(
					_elm_lang$core$Maybe$map,
					_elm_lang$core$Tuple$mapSecond(
						F2(
							function (x, y) {
								return {ctor: '::', _0: x, _1: y};
							})(_p163)),
					A2(_user$project$Utils$removeFirstSuccess, f, _p164));
			} else {
				return _elm_lang$core$Maybe$Just(
					{ctor: '_Tuple2', _0: _p162._0, _1: _p164});
			}
		}
	});
var _user$project$Utils$mapFirstSuccess = F2(
	function (f, list) {
		mapFirstSuccess:
		while (true) {
			var _p165 = list;
			if (_p165.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p166 = f(_p165._0);
				if (_p166.ctor === 'Nothing') {
					var _v122 = f,
						_v123 = _p165._1;
					f = _v122;
					list = _v123;
					continue mapFirstSuccess;
				} else {
					return _p166;
				}
			}
		}
	});
var _user$project$Utils$removeLastElement = function (list) {
	return A2(
		_elm_lang$core$List$take,
		_elm_lang$core$List$length(list) - 1,
		list);
};
var _user$project$Utils$maybeMapLast = F2(
	function (f, list) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (last) {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Utils$removeLastElement(list),
					{
						ctor: '::',
						_0: f(last),
						_1: {ctor: '[]'}
					});
			},
			_user$project$Utils$maybeLast(list));
	});
var _user$project$Utils$maybeRemoveFirst = F2(
	function (x, ys) {
		var _p167 = ys;
		if (_p167.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p171 = _p167._1;
			var _p170 = _p167._0._1;
			var _p169 = _p167._0._0;
			if (_elm_lang$core$Native_Utils.eq(x, _p169)) {
				return _elm_lang$core$Maybe$Just(
					{ctor: '_Tuple2', _0: _p170, _1: _p171});
			} else {
				var _p168 = A2(_user$project$Utils$maybeRemoveFirst, x, _p171);
				if (_p168.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple2',
							_0: _p168._0._0,
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p169, _1: _p170},
								_1: _p168._0._1
							}
						});
				}
			}
		}
	});
var _user$project$Utils$removeFirst = F2(
	function (x, ys) {
		var _p172 = ys;
		if (_p172.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var _p174 = _p172._1;
			var _p173 = _p172._0;
			return _elm_lang$core$Native_Utils.eq(x, _p173) ? _p174 : {
				ctor: '::',
				_0: _p173,
				_1: A2(_user$project$Utils$removeFirst, x, _p174)
			};
		}
	});
var _user$project$Utils$maybeFindAndRemoveFirst = F2(
	function (p, xs) {
		var _p175 = xs;
		if (_p175.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p179 = _p175._1;
			var _p178 = _p175._0;
			return p(_p178) ? _elm_lang$core$Maybe$Just(
				{ctor: '_Tuple2', _0: _p178, _1: _p179}) : A2(
				_elm_lang$core$Maybe$map,
				function (_p176) {
					var _p177 = _p176;
					return {
						ctor: '_Tuple2',
						_0: _p177._0,
						_1: {ctor: '::', _0: _p178, _1: _p177._1}
					};
				},
				A2(_user$project$Utils$maybeFindAndRemoveFirst, p, _p179));
		}
	});
var _user$project$Utils$findSublistIndex_ = F3(
	function (i, targetList, list) {
		findSublistIndex_:
		while (true) {
			if (_elm_lang$core$Native_Utils.eq(
				A2(
					_elm_lang$core$List$take,
					_elm_lang$core$List$length(targetList),
					list),
				targetList)) {
				return _elm_lang$core$Maybe$Just(i);
			} else {
				var _p180 = list;
				if (_p180.ctor === '[]') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					var _v130 = i + 1,
						_v131 = targetList,
						_v132 = _p180._1;
					i = _v130;
					targetList = _v131;
					list = _v132;
					continue findSublistIndex_;
				}
			}
		}
	});
var _user$project$Utils$findSublistIndex = F2(
	function (targetList, list) {
		return A3(_user$project$Utils$findSublistIndex_, 0, targetList, list);
	});
var _user$project$Utils$findFirst = F2(
	function (p, xs) {
		findFirst:
		while (true) {
			var _p181 = xs;
			if (_p181.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p182 = _p181._0;
				if (p(_p182)) {
					return _elm_lang$core$Maybe$Just(_p182);
				} else {
					var _v134 = p,
						_v135 = _p181._1;
					p = _v134;
					xs = _v135;
					continue findFirst;
				}
			}
		}
	});
var _user$project$Utils$findLast = F2(
	function (p, xs) {
		return A2(
			_user$project$Utils$findFirst,
			p,
			_elm_lang$core$List$reverse(xs));
	});
var _user$project$Utils$hasMatchingElement = function (p) {
	return function (_p183) {
		return _user$project$Utils$maybeToBool(
			A2(_user$project$Utils$findFirst, p, _p183));
	};
};
var _user$project$Utils$anyOverlapListSet = F2(
	function (items, set) {
		var _p184 = items;
		if (_p184.ctor === '[]') {
			return false;
		} else {
			return A2(_elm_lang$core$Set$member, _p184._0, set) || A2(_user$project$Utils$anyOverlapListSet, _p184._1, set);
		}
	});
var _user$project$Utils$unionAll = function (sets) {
	return A3(_elm_lang$core$List$foldl, _elm_lang$core$Set$union, _elm_lang$core$Set$empty, sets);
};
var _user$project$Utils$anyOverlap = function (sets) {
	return _elm_lang$core$Native_Utils.cmp(
		_elm_lang$core$Set$size(
			_user$project$Utils$unionAll(sets)),
		_elm_lang$core$List$sum(
			A2(_elm_lang$core$List$map, _elm_lang$core$Set$size, sets))) < 0;
};
var _user$project$Utils$intersectMany = function (list) {
	var _p185 = list;
	if (_p185.ctor === '::') {
		return A3(_elm_lang$core$List$foldl, _elm_lang$core$Set$intersect, _p185._0, _p185._1);
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Utils',
			{
				start: {line: 497, column: 22},
				end: {line: 499, column: 43}
			},
			_p185)('intersectMany');
	}
};
var _user$project$Utils$isSubset = F2(
	function (sub, sup) {
		return A2(
			_elm_lang$core$List$all,
			function (elem) {
				return A2(_elm_lang$core$Set$member, elem, sup);
			},
			_elm_lang$core$Set$toList(sub));
	});
var _user$project$Utils$oneOfEach = function (xss) {
	var _p187 = xss;
	if (_p187.ctor === '[]') {
		return {
			ctor: '::',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'}
		};
	} else {
		return A2(
			_elm_lang$core$List$concatMap,
			function (x) {
				return A2(
					_elm_lang$core$List$map,
					F2(
						function (x, y) {
							return {ctor: '::', _0: x, _1: y};
						})(x),
					_user$project$Utils$oneOfEach(_p187._1));
			},
			_p187._0);
	}
};
var _user$project$Utils$cartProd = F2(
	function (xs, ys) {
		return A2(
			_elm_lang$core$List$concatMap,
			function (x) {
				return A2(
					_elm_lang$core$List$map,
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})(x),
					ys);
			},
			xs);
	});
var _user$project$Utils$slice = F3(
	function (start, end, list) {
		return A2(
			_elm_lang$core$List$take,
			end - start,
			A2(_elm_lang$core$List$drop, start, list));
	});
var _user$project$Utils$dropLast = F2(
	function (n, list) {
		return _elm_lang$core$List$reverse(
			A2(
				_elm_lang$core$List$drop,
				n,
				_elm_lang$core$List$reverse(list)));
	});
var _user$project$Utils$toSentence = function (strings) {
	var _p188 = {
		ctor: '_Tuple2',
		_0: A2(_user$project$Utils$dropLast, 1, strings),
		_1: _user$project$Utils$maybeLast(strings)
	};
	if (_p188._1.ctor === 'Nothing') {
		return '';
	} else {
		if (_p188._0.ctor === '[]') {
			return _p188._1._0;
		} else {
			if (_p188._0._1.ctor === '[]') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p188._0._0,
					A2(_elm_lang$core$Basics_ops['++'], ' and ', _p188._1._0));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$String$join, ', ', _p188._0),
					A2(_elm_lang$core$Basics_ops['++'], ', and ', _p188._1._0));
			}
		}
	}
};
var _user$project$Utils$mergeStrings = function (strings) {
	var stringsWords = A2(
		_elm_lang$core$List$map,
		function (_p189) {
			return A2(
				_elm_lang$core$String$split,
				' ',
				_user$project$Utils$squish(_p189));
		},
		strings);
	var prefixWords = _user$project$Utils$commonPrefix(stringsWords);
	var noPrefixes = _user$project$Utils$removeCommonPrefix(stringsWords);
	var suffixWords = _user$project$Utils$commonSuffix(noPrefixes);
	var middleString = _user$project$Utils$toSentence(
		A2(
			_elm_lang$core$List$filter,
			function (_p190) {
				return !_elm_lang$core$String$isEmpty(_p190);
			},
			A2(
				_elm_lang$core$List$map,
				_elm_lang$core$String$join(' '),
				_user$project$Utils$removeCommonSuffix(noPrefixes))));
	return A2(
		_elm_lang$core$String$join,
		' ',
		A2(
			_elm_lang$core$List$filter,
			function (_p191) {
				return !_elm_lang$core$String$isEmpty(_p191);
			},
			A2(
				_elm_lang$core$Basics_ops['++'],
				prefixWords,
				A2(
					_elm_lang$core$Basics_ops['++'],
					{
						ctor: '::',
						_0: middleString,
						_1: {ctor: '[]'}
					},
					suffixWords))));
};
var _user$project$Utils$splitBy = F2(
	function (splitElems, list) {
		var _p192 = A2(_user$project$Utils$findSublistIndex, splitElems, list);
		if (_p192.ctor === 'Just') {
			var _p193 = _p192._0;
			return {
				ctor: '::',
				_0: A2(_elm_lang$core$List$take, _p193, list),
				_1: A2(
					_user$project$Utils$splitBy,
					splitElems,
					A2(
						_elm_lang$core$List$drop,
						_p193 + _elm_lang$core$List$length(splitElems),
						list))
			};
		} else {
			return {
				ctor: '::',
				_0: list,
				_1: {ctor: '[]'}
			};
		}
	});
var _user$project$Utils$split = F2(
	function (n, xs) {
		var aux = F3(
			function (prev, n, l) {
				aux:
				while (true) {
					if (_elm_lang$core$Native_Utils.eq(n, 0)) {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$List$reverse(prev),
							_1: l
						};
					} else {
						var _p194 = l;
						if (_p194.ctor === '[]') {
							return {
								ctor: '_Tuple2',
								_0: _elm_lang$core$List$reverse(prev),
								_1: {ctor: '[]'}
							};
						} else {
							var _v142 = {ctor: '::', _0: _p194._0, _1: prev},
								_v143 = n - 1,
								_v144 = _p194._1;
							prev = _v142;
							n = _v143;
							l = _v144;
							continue aux;
						}
					}
				}
			});
		return A3(
			aux,
			{ctor: '[]'},
			n,
			xs);
	});
var _user$project$Utils$snocUnapply = function (l) {
	var _p195 = l;
	if (_p195.ctor === '[]') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		if (_p195._1.ctor === '[]') {
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: _p195._0
				});
		} else {
			return A2(
				_elm_lang$core$Maybe$map,
				_elm_lang$core$Tuple$mapFirst(
					function (init) {
						return {ctor: '::', _0: _p195._0, _1: init};
					}),
				_user$project$Utils$snocUnapply(_p195._1));
		}
	}
};
var _user$project$Utils$lastLine = function (s) {
	return A2(
		_elm_lang$core$Maybe$withDefault,
		'',
		A2(
			_elm_lang$core$Maybe$map,
			_elm_lang$core$Tuple$second,
			_user$project$Utils$snocUnapply(
				_elm_lang$core$String$lines(s))));
};
var _user$project$Utils$snoc = F2(
	function (xs, x) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			xs,
			{
				ctor: '::',
				_0: x,
				_1: {ctor: '[]'}
			});
	});
var _user$project$Utils$snocMaybe = F2(
	function (xs, mx) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			xs,
			A2(
				_elm_lang$core$Maybe$map,
				_user$project$Utils$snoc(xs),
				mx));
	});
var _user$project$Utils$maybeUnpackSingleton = function (xs) {
	var _p196 = xs;
	if ((_p196.ctor === '::') && (_p196._1.ctor === '[]')) {
		return _elm_lang$core$Maybe$Just(_p196._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Utils$oneElement = function (xs) {
	var _p197 = xs;
	if ((_p197.ctor === '::') && (_p197._1.ctor === '[]')) {
		return true;
	} else {
		return false;
	}
};
var _user$project$Utils$zeroElements = function (xs) {
	var _p198 = xs;
	if (_p198.ctor === '[]') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Utils$clamp = F3(
	function (i, j, n) {
		return (_elm_lang$core$Native_Utils.cmp(n, i) < 0) ? i : ((_elm_lang$core$Native_Utils.cmp(j, n) < 0) ? j : n);
	});
var _user$project$Utils$oneToOneMappingExists = F2(
	function (l1, l2) {
		var numericRepresentation = function (list) {
			return _elm_lang$core$Tuple$second(
				A3(
					_elm_lang$core$List$foldl,
					F2(
						function (x, _p199) {
							var _p200 = _p199;
							var _p203 = _p200._1;
							var _p202 = _p200._0;
							var _p201 = A2(_elm_lang$core$Dict$get, x, _p202);
							if (_p201.ctor === 'Just') {
								return {
									ctor: '_Tuple2',
									_0: _p202,
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_p203,
										{
											ctor: '::',
											_0: _p201._0,
											_1: {ctor: '[]'}
										})
								};
							} else {
								var n = _elm_lang$core$Dict$size(_p202);
								var dict_ = A3(_elm_lang$core$Dict$insert, x, n, _p202);
								return {
									ctor: '_Tuple2',
									_0: dict_,
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_p203,
										{
											ctor: '::',
											_0: n,
											_1: {ctor: '[]'}
										})
								};
							}
						}),
					{
						ctor: '_Tuple2',
						_0: _elm_lang$core$Dict$empty,
						_1: {ctor: '[]'}
					},
					list));
		};
		return _elm_lang$core$Native_Utils.eq(
			numericRepresentation(l1),
			numericRepresentation(l2));
	});
var _user$project$Utils$pairsToDictOfLists = function (pairs) {
	return A3(
		_elm_lang$core$List$foldr,
		F2(
			function (_p204, dict) {
				var _p205 = _p204;
				var _p206 = _p205._0;
				var equivalents = A3(
					_user$project$Utils$getWithDefault,
					_p206,
					{ctor: '[]'},
					dict);
				return A3(
					_elm_lang$core$Dict$insert,
					_p206,
					{ctor: '::', _0: _p205._1, _1: equivalents},
					dict);
			}),
		_elm_lang$core$Dict$empty,
		pairs);
};
var _user$project$Utils$groupBy = F2(
	function (f, list) {
		return _user$project$Utils$pairsToDictOfLists(
			A2(
				_elm_lang$core$List$map,
				function (x) {
					return {
						ctor: '_Tuple2',
						_0: f(x),
						_1: x
					};
				},
				list));
	});
var _user$project$Utils$combinationsAsSet = F2(
	function (n, list) {
		var _p207 = {ctor: '_Tuple2', _0: n, _1: list};
		_v152_0:
		do {
			if (_p207._1.ctor === '[]') {
				if (_p207._0 === 0) {
					break _v152_0;
				} else {
					return {ctor: '[]'};
				}
			} else {
				if (_p207._0 === 0) {
					break _v152_0;
				} else {
					var _p208 = _p207._1._1;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$List$map,
							F2(
								function (x, y) {
									return {ctor: '::', _0: x, _1: y};
								})(_p207._1._0),
							A2(_user$project$Utils$combinationsAsSet, n - 1, _p208)),
						A2(_user$project$Utils$combinationsAsSet, n, _p208));
				}
			}
		} while(false);
		return {
			ctor: '::',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'}
		};
	});
var _user$project$Utils$isSublistAsSet = F2(
	function (sub, $super) {
		return A2(
			_elm_lang$core$List$all,
			function (x) {
				return A2(_elm_lang$core$List$member, x, $super);
			},
			sub);
	});
var _user$project$Utils$equalAsSets = F2(
	function (a, b) {
		return A2(_user$project$Utils$isSublistAsSet, a, b) && A2(_user$project$Utils$isSublistAsSet, b, a);
	});
var _user$project$Utils$intersectAsSet = F2(
	function (xs, ys) {
		return A2(
			_elm_lang$core$List$filter,
			function (x) {
				return A2(_elm_lang$core$List$member, x, ys);
			},
			xs);
	});
var _user$project$Utils$intersectAllAsSet = function (lists) {
	var _p209 = lists;
	if (_p209.ctor === '::') {
		return A3(_elm_lang$core$List$foldl, _user$project$Utils$intersectAsSet, _p209._0, _p209._1);
	} else {
		return {ctor: '[]'};
	}
};
var _user$project$Utils$removeAsSet = F2(
	function (x, xs) {
		return A2(
			_elm_lang$core$List$filter,
			F2(
				function (x, y) {
					return !_elm_lang$core$Native_Utils.eq(x, y);
				})(x),
			xs);
	});
var _user$project$Utils$diffAsSet = F2(
	function (xs, ys) {
		return A3(_elm_lang$core$List$foldl, _user$project$Utils$removeAsSet, xs, ys);
	});
var _user$project$Utils$removeAll = _user$project$Utils$diffAsSet;
var _user$project$Utils$addAsSet = F2(
	function (x, xs) {
		return A2(_elm_lang$core$List$member, x, xs) ? xs : {ctor: '::', _0: x, _1: xs};
	});
var _user$project$Utils$addAllAsSet = F2(
	function (xs, ys) {
		return A3(_elm_lang$core$List$foldl, _user$project$Utils$addAsSet, xs, ys);
	});
var _user$project$Utils$unionAllAsSet = function (lists) {
	return A3(
		_elm_lang$core$List$foldl,
		_user$project$Utils$addAllAsSet,
		{ctor: '[]'},
		lists);
};
var _user$project$Utils$listDiffSet = F2(
	function (list, setToRemove) {
		return A2(
			_elm_lang$core$List$filter,
			function (element) {
				return !A2(_elm_lang$core$Set$member, element, setToRemove);
			},
			list);
	});
var _user$project$Utils$listDiff = F2(
	function (l1, l2) {
		return A2(
			_user$project$Utils$listDiffSet,
			l1,
			_elm_lang$core$Set$fromList(l2));
	});
var _user$project$Utils$dedupByMaybe = F2(
	function (f, xs) {
		var _p210 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (x, _p211) {
					var _p212 = _p211;
					var _p216 = _p212._1;
					var _p215 = _p212._0;
					var _p213 = f(x);
					if (_p213.ctor === 'Just') {
						var _p214 = _p213._0;
						return A2(_elm_lang$core$Set$member, _p214, _p216) ? {ctor: '_Tuple2', _0: _p215, _1: _p216} : {
							ctor: '_Tuple2',
							_0: {ctor: '::', _0: x, _1: _p215},
							_1: A2(_elm_lang$core$Set$insert, _p214, _p216)
						};
					} else {
						return {
							ctor: '_Tuple2',
							_0: {ctor: '::', _0: x, _1: _p215},
							_1: _p216
						};
					}
				}),
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: _elm_lang$core$Set$empty
			},
			xs);
		var dedupedReversed = _p210._0;
		return _elm_lang$core$List$reverse(dedupedReversed);
	});
var _user$project$Utils$dedupBy = F2(
	function (f, xs) {
		return A2(
			_user$project$Utils$dedupByMaybe,
			function (_p217) {
				return _elm_lang$core$Maybe$Just(
					f(_p217));
			},
			xs);
	});
var _user$project$Utils$dedup = function (xs) {
	return A2(_user$project$Utils$dedupBy, _elm_lang$core$Basics$identity, xs);
};
var _user$project$Utils$listsEqualBy = F3(
	function (elementEqualityFunc, xs, ys) {
		var _p218 = {ctor: '_Tuple2', _0: xs, _1: ys};
		_v156_2:
		do {
			if (_p218.ctor === '_Tuple2') {
				if (_p218._0.ctor === '[]') {
					if (_p218._1.ctor === '[]') {
						return true;
					} else {
						break _v156_2;
					}
				} else {
					if (_p218._1.ctor === '::') {
						return A2(elementEqualityFunc, _p218._0._0, _p218._1._0) && A3(_user$project$Utils$listsEqualBy, elementEqualityFunc, _p218._0._1, _p218._1._1);
					} else {
						break _v156_2;
					}
				}
			} else {
				break _v156_2;
			}
		} while(false);
		return false;
	});
var _user$project$Utils$filterMapTogetherPreservingLeftovers = F3(
	function (f, l1, l2) {
		filterMapTogetherPreservingLeftovers:
		while (true) {
			var _p219 = {ctor: '_Tuple2', _0: l1, _1: l2};
			if (((_p219.ctor === '_Tuple2') && (_p219._0.ctor === '::')) && (_p219._1.ctor === '::')) {
				var _p223 = _p219._1._1;
				var _p222 = _p219._0._1;
				var _p220 = A2(f, _p219._0._0, _p219._1._0);
				if (_p220.ctor === 'Just') {
					var _p221 = A3(_user$project$Utils$filterMapTogetherPreservingLeftovers, f, _p222, _p223);
					var newXRest = _p221._0;
					var newYRest = _p221._1;
					return {
						ctor: '_Tuple2',
						_0: {ctor: '::', _0: _p220._0._0, _1: newXRest},
						_1: {ctor: '::', _0: _p220._0._1, _1: newYRest}
					};
				} else {
					var _v159 = f,
						_v160 = _p222,
						_v161 = _p223;
					f = _v159;
					l1 = _v160;
					l2 = _v161;
					continue filterMapTogetherPreservingLeftovers;
				}
			} else {
				return {ctor: '_Tuple2', _0: l1, _1: l2};
			}
		}
	});
var _user$project$Utils$maybeCons = F2(
	function (x, l) {
		var _p224 = x;
		if (_p224.ctor === 'Nothing') {
			return l;
		} else {
			return {ctor: '::', _0: _p224._0, _1: l};
		}
	});
var _user$project$Utils$reverse2 = function (_p225) {
	var _p226 = _p225;
	return {
		ctor: '_Tuple2',
		_0: _elm_lang$core$List$reverse(_p226._0),
		_1: _elm_lang$core$List$reverse(_p226._1)
	};
};
var _user$project$Utils$maybeReverseInsert = F2(
	function (elements, revAcc) {
		maybeReverseInsert:
		while (true) {
			var _p227 = elements;
			if (_p227.ctor === '[]') {
				return revAcc;
			} else {
				var _p229 = _p227._1;
				var _p228 = _p227._0;
				if (_p228.ctor === 'Nothing') {
					var _v166 = _p229,
						_v167 = revAcc;
					elements = _v166;
					revAcc = _v167;
					continue maybeReverseInsert;
				} else {
					var _v168 = _p229,
						_v169 = {ctor: '::', _0: _p228._0, _1: revAcc};
					elements = _v168;
					revAcc = _v169;
					continue maybeReverseInsert;
				}
			}
		}
	});
var _user$project$Utils$reverseInsert = F2(
	function (elements, revAcc) {
		reverseInsert:
		while (true) {
			var _p230 = elements;
			if (_p230.ctor === '[]') {
				return revAcc;
			} else {
				var _v171 = _p230._1,
					_v172 = {ctor: '::', _0: _p230._0, _1: revAcc};
				elements = _v171;
				revAcc = _v172;
				continue reverseInsert;
			}
		}
	});
var _user$project$Utils$orderWithDependencies = F2(
	function (elements, elemToNamesDepsIsrec) {
		var elemsWithDefs = function () {
			var aux = F3(
				function (definedNames, elements, revAcc) {
					aux:
					while (true) {
						var _p231 = elements;
						if (_p231.ctor === '[]') {
							return _elm_lang$core$List$reverse(revAcc);
						} else {
							var _p233 = _p231._0;
							var _p232 = elemToNamesDepsIsrec(_p233);
							var abst = _p232;
							var names = _p232._0;
							var deps = _p232._1;
							var isRec = _p232._2;
							var _v174 = A2(_elm_lang$core$Set$union, definedNames, names),
								_v175 = _p231._1,
								_v176 = {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: _p233,
									_1: {
										ctor: '_Tuple3',
										_0: names,
										_1: deps,
										_2: {
											isRec: isRec,
											isFirst: _elm_lang$core$Set$isEmpty(
												A2(_elm_lang$core$Set$intersect, names, definedNames))
										}
									}
								},
								_1: revAcc
							};
							definedNames = _v174;
							elements = _v175;
							revAcc = _v176;
							continue aux;
						}
					}
				});
			return A3(
				aux,
				_elm_lang$core$Set$empty,
				elements,
				{ctor: '[]'});
		}();
		var dependenciesToConsider = _elm_lang$core$Set$fromList(
			A2(
				_elm_lang$core$List$concatMap,
				function (_p234) {
					var _p235 = _p234;
					return _elm_lang$core$Set$toList(_p235._1._0);
				},
				elemsWithDefs));
		var aux = F5(
			function (testWaiting, okGroups, definedNames, waitingDefs, elemsWithDefs) {
				aux:
				while (true) {
					var finalDependencies = function (_p236) {
						var _p237 = _p236;
						var _p239 = _p237._0;
						var _p238 = _p237._2;
						return A2(
							_elm_lang$core$Set$diff,
							A2(_elm_lang$core$Set$intersect, dependenciesToConsider, _p237._1),
							_p238.isRec ? A2(_elm_lang$core$Set$union, _p239, definedNames) : (_p238.isFirst ? A2(_elm_lang$core$Set$union, _p239, definedNames) : definedNames));
					};
					var mbWaitingDefSatisfied = (!testWaiting) ? _elm_lang$core$Maybe$Nothing : A2(
						_user$project$Utils$removeFirstSuccess,
						function (_p240) {
							var _p241 = _p240;
							var theDependenciesAreSatisfied = _elm_lang$core$Set$isEmpty(
								finalDependencies(_p241._1));
							return theDependenciesAreSatisfied ? _elm_lang$core$Maybe$Just(
								{ctor: '_Tuple2', _0: _p241._0, _1: _p241._1._0}) : _elm_lang$core$Maybe$Nothing;
						},
						waitingDefs);
					var _p242 = mbWaitingDefSatisfied;
					if (_p242.ctor === 'Just') {
						var _v181 = true,
							_v182 = {ctor: '::', _0: _p242._0._0._0, _1: okGroups},
							_v183 = A2(_elm_lang$core$Set$union, definedNames, _p242._0._0._1),
							_v184 = _p242._0._1,
							_v185 = elemsWithDefs;
						testWaiting = _v181;
						okGroups = _v182;
						definedNames = _v183;
						waitingDefs = _v184;
						elemsWithDefs = _v185;
						continue aux;
					} else {
						var _p243 = elemsWithDefs;
						if (_p243.ctor === '[]') {
							return _elm_lang$core$List$isEmpty(waitingDefs) ? _elm_lang$core$Result$Ok(
								_elm_lang$core$List$reverse(okGroups)) : _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'I could not find a satisfying assignment for these mutually recursive definitions:\n',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$String$join,
											',\n',
											A2(
												_elm_lang$core$List$map,
												function (_p244) {
													var _p245 = _p244;
													var reald = finalDependencies(_p245._1);
													return A2(
														_elm_lang$core$Basics_ops['++'],
														A2(
															_elm_lang$core$String$join,
															',',
															_elm_lang$core$Set$toList(_p245._1._0)),
														A2(
															_elm_lang$core$Basics_ops['++'],
															' depend(s) on ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																A2(
																	_elm_lang$core$String$join,
																	',',
																	_elm_lang$core$Set$toList(reald)),
																_p245._1._2.isRec ? ' and recursively on each other' : '')));
												},
												waitingDefs)),
										'\nWe don\'t support mutual recursion between lambdas and non-lambda (yet). Create a lambda, and then call it if you wish.')));
						} else {
							var _p257 = _p243._1;
							var _p256 = _p243._0._1;
							var _p255 = _p243._0._0;
							var theDependenciesAreSatisfied = _elm_lang$core$Set$isEmpty(
								finalDependencies(_p256));
							if (theDependenciesAreSatisfied) {
								var _v188 = true,
									_v189 = {
									ctor: '::',
									_0: {
										ctor: '::',
										_0: _p255,
										_1: {ctor: '[]'}
									},
									_1: okGroups
								},
									_v190 = A2(_elm_lang$core$Set$union, definedNames, _p243._0._1._0),
									_v191 = waitingDefs,
									_v192 = _p257;
								testWaiting = _v188;
								okGroups = _v189;
								definedNames = _v190;
								waitingDefs = _v191;
								elemsWithDefs = _v192;
								continue aux;
							} else {
								var _p246 = function () {
									if (_p243._0._1._2.isRec) {
										var xau = F4(
											function (retestWaiting, collectedWaitingGroups, remainingWaitingGroups, _p247) {
												xau:
												while (true) {
													var _p248 = _p247;
													var _p254 = _p248._1._0;
													var _p253 = _p248;
													var _p249 = remainingWaitingGroups;
													if (_p249.ctor === '[]') {
														return {
															ctor: '_Tuple2',
															_0: _elm_lang$core$List$reverse(
																{ctor: '::', _0: _p253, _1: collectedWaitingGroups}),
															_1: retestWaiting
														};
													} else {
														var _p252 = _p249._1;
														var _p251 = _p249._0._1._0;
														var _p250 = _p249._0._1._2;
														if (_p250.isRec && ((!_elm_lang$core$Set$isEmpty(
															A2(
																_elm_lang$core$Set$intersect,
																finalDependencies(_p249._0._1),
																_p254))) && (!_elm_lang$core$Set$isEmpty(
															A2(
																_elm_lang$core$Set$intersect,
																finalDependencies(_p248._1),
																_p251))))) {
															var newDefToIntegrate = {
																ctor: '_Tuple2',
																_0: A2(_elm_lang$core$Basics_ops['++'], _p249._0._0, _p248._0),
																_1: {
																	ctor: '_Tuple3',
																	_0: A2(_elm_lang$core$Set$union, _p251, _p254),
																	_1: A2(_elm_lang$core$Set$union, _p249._0._1._1, _p248._1._1),
																	_2: {isRec: true, isFirst: _p250.isFirst && _p248._1._2.isFirst}
																}
															};
															var _v195 = true,
																_v196 = {ctor: '[]'},
																_v197 = A2(_user$project$Utils$reverseInsert, collectedWaitingGroups, _p252),
																_v198 = newDefToIntegrate;
															retestWaiting = _v195;
															collectedWaitingGroups = _v196;
															remainingWaitingGroups = _v197;
															_p247 = _v198;
															continue xau;
														} else {
															var _v199 = retestWaiting,
																_v200 = {ctor: '::', _0: _p249._0, _1: collectedWaitingGroups},
																_v201 = _p252,
																_v202 = _p253;
															retestWaiting = _v199;
															collectedWaitingGroups = _v200;
															remainingWaitingGroups = _v201;
															_p247 = _v202;
															continue xau;
														}
													}
												}
											});
										return A4(
											xau,
											false,
											{ctor: '[]'},
											waitingDefs,
											{
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: _p255,
													_1: {ctor: '[]'}
												},
												_1: _p256
											});
									} else {
										return {
											ctor: '_Tuple2',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												waitingDefs,
												{
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: {
															ctor: '::',
															_0: _p255,
															_1: {ctor: '[]'}
														},
														_1: _p256
													},
													_1: {ctor: '[]'}
												}),
											_1: false
										};
									}
								}();
								var newWaitingDefs = _p246._0;
								var retestWaiting = _p246._1;
								var _v203 = retestWaiting,
									_v204 = okGroups,
									_v205 = definedNames,
									_v206 = newWaitingDefs,
									_v207 = _p257;
								testWaiting = _v203;
								okGroups = _v204;
								definedNames = _v205;
								waitingDefs = _v206;
								elemsWithDefs = _v207;
								continue aux;
							}
						}
					}
				}
			});
		return A5(
			aux,
			false,
			{ctor: '[]'},
			_elm_lang$core$Set$empty,
			{ctor: '[]'},
			elemsWithDefs);
	});
var _user$project$Utils$zipi_ = F2(
	function (i, list) {
		var _p258 = list;
		if (_p258.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: i, _1: _p258._0},
				_1: A2(_user$project$Utils$zipi_, i + 1, _p258._1)
			};
		}
	});
var _user$project$Utils$mapi_ = F3(
	function (initI, f, xs) {
		return A2(
			_elm_lang$core$List$map,
			f,
			A2(_user$project$Utils$zipi_, initI, xs));
	});
var _user$project$Utils$mapi0 = _user$project$Utils$mapi_(0);
var _user$project$Utils$mapi1 = _user$project$Utils$mapi_(1);
var _user$project$Utils$naturalToCamelCase = function (natural) {
	return A2(
		_elm_lang$core$String$join,
		'',
		A2(
			_user$project$Utils$mapi1,
			function (_p259) {
				var _p260 = _p259;
				var _p261 = _p260._1;
				return _elm_lang$core$Native_Utils.eq(_p260._0, 1) ? _p261 : _user$project$Utils$capitalize(_p261);
			},
			A2(
				_elm_lang$core$List$map,
				_elm_lang$core$String$toLower,
				A2(_elm_lang$core$String$split, ' ', natural))));
};
var _user$project$Utils$foldli_ = F4(
	function (initI, f, init, xs) {
		return A3(
			_elm_lang$core$List$foldl,
			f,
			init,
			A2(_user$project$Utils$zipi_, initI, xs));
	});
var _user$project$Utils$foldli0 = _user$project$Utils$foldli_(0);
var _user$project$Utils$foldli1 = _user$project$Utils$foldli_(1);
var _user$project$Utils$manySetDiffs = function (sets) {
	return A2(
		_user$project$Utils$mapi1,
		function (_p262) {
			var _p263 = _p262;
			return A3(
				_user$project$Utils$foldli1,
				F2(
					function (_p264, acc) {
						var _p265 = _p264;
						return _elm_lang$core$Native_Utils.eq(_p263._0, _p265._0) ? acc : A2(_elm_lang$core$Set$diff, acc, _p265._1);
					}),
				_p263._1,
				sets);
		},
		sets);
};
var _user$project$Utils$cartProdWithDiff = function (_p266) {
	return _user$project$Utils$oneOfEach(
		A2(
			_elm_lang$core$List$map,
			_elm_lang$core$Set$toList,
			_user$project$Utils$manySetDiffs(_p266)));
};
var _user$project$Utils$zipi1 = _user$project$Utils$zipi_(1);
var _user$project$Utils$filteri1 = F2(
	function (f, xs) {
		return A2(
			_elm_lang$core$List$map,
			_elm_lang$core$Tuple$second,
			A2(
				_elm_lang$core$List$filter,
				f,
				_user$project$Utils$zipi1(xs)));
	});
var _user$project$Utils$concatMapi1 = F2(
	function (f, xs) {
		return A2(
			_elm_lang$core$List$concatMap,
			f,
			_user$project$Utils$zipi1(xs));
	});
var _user$project$Utils$zipi0 = _user$project$Utils$zipi_(0);
var _user$project$Utils$resultOrElseLazy = F2(
	function (rb, ra) {
		var _p267 = ra;
		if (_p267.ctor === 'Ok') {
			return ra;
		} else {
			var _p268 = rb(
				{ctor: '_Tuple0'});
			if (_p268.ctor === 'Err') {
				return ra;
			} else {
				return _p268;
			}
		}
	});
var _user$project$Utils$maybeWithLazyDefault = F2(
	function (mba, callback) {
		var _p269 = mba;
		if (_p269.ctor === 'Just') {
			return _p269._0;
		} else {
			return callback(
				{ctor: '_Tuple0'});
		}
	});
var _user$project$Utils$maybeWithDefaultLazy = _elm_lang$core$Basics$flip(_user$project$Utils$maybeWithLazyDefault);
var _user$project$Utils$maybeOrElse = F2(
	function (mb, ma) {
		var _p270 = ma;
		if (_p270.ctor === 'Just') {
			return ma;
		} else {
			return mb;
		}
	});
var _user$project$Utils$maybeIsEmpty = function (mb) {
	return A2(
		_elm_lang$core$Maybe$withDefault,
		true,
		A2(
			_elm_lang$core$Maybe$map,
			function (_p271) {
				return false;
			},
			mb));
};
var _user$project$Utils$maybeZipN = function (lists) {
	if (A2(_elm_lang$core$List$all, _user$project$Utils$zeroElements, lists)) {
		return _elm_lang$core$Maybe$Just(
			{ctor: '[]'});
	} else {
		if (A2(_elm_lang$core$List$all, _user$project$Utils$oneElement, lists)) {
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '::',
					_0: _elm_lang$core$List$concat(lists),
					_1: {ctor: '[]'}
				});
		} else {
			var maybeHeads = _user$project$Utils$projJusts(
				A2(_elm_lang$core$List$map, _elm_lang$core$List$head, lists));
			var maybeTails = _user$project$Utils$projJusts(
				A2(_elm_lang$core$List$map, _elm_lang$core$List$tail, lists));
			var _p272 = {ctor: '_Tuple2', _0: maybeHeads, _1: maybeTails};
			if (((_p272.ctor === '_Tuple2') && (_p272._0.ctor === 'Just')) && (_p272._1.ctor === 'Just')) {
				return A2(
					_elm_lang$core$Maybe$map,
					F2(
						function (x, y) {
							return {ctor: '::', _0: x, _1: y};
						})(_p272._0._0),
					_user$project$Utils$maybeZipN(_p272._1._0));
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		}
	}
};
var _user$project$Utils$unzip3 = function (zipped) {
	return A3(
		_elm_lang$core$List$foldr,
		F2(
			function (_p274, _p273) {
				var _p275 = _p274;
				var _p276 = _p273;
				return {
					ctor: '_Tuple3',
					_0: {ctor: '::', _0: _p275._0, _1: _p276._0},
					_1: {ctor: '::', _0: _p275._1, _1: _p276._1},
					_2: {ctor: '::', _0: _p275._2, _1: _p276._2}
				};
			}),
		{
			ctor: '_Tuple3',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'},
			_2: {ctor: '[]'}
		},
		zipped);
};
var _user$project$Utils$zip3 = F3(
	function (xs, ys, zs) {
		var _p277 = {ctor: '_Tuple3', _0: xs, _1: ys, _2: zs};
		if ((((_p277.ctor === '_Tuple3') && (_p277._0.ctor === '::')) && (_p277._1.ctor === '::')) && (_p277._2.ctor === '::')) {
			return {
				ctor: '::',
				_0: {ctor: '_Tuple3', _0: _p277._0._0, _1: _p277._1._0, _2: _p277._2._0},
				_1: A3(_user$project$Utils$zip3, _p277._0._1, _p277._1._1, _p277._2._1)
			};
		} else {
			return {ctor: '[]'};
		}
	});
var _user$project$Utils$maybeZipDicts = F2(
	function (d1, d2) {
		return (!_elm_lang$core$Native_Utils.eq(
			_elm_lang$core$Dict$keys(d1),
			_elm_lang$core$Dict$keys(d2))) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
			A2(
				_elm_lang$core$Dict$map,
				F2(
					function (k, v1) {
						return {
							ctor: '_Tuple2',
							_0: v1,
							_1: A2(_user$project$Utils$justGet, k, d2)
						};
					}),
				d1));
	});
var _user$project$Utils$maybeZip = F2(
	function (xs, ys) {
		var _p278 = {ctor: '_Tuple2', _0: xs, _1: ys};
		_v220_2:
		do {
			if (_p278.ctor === '_Tuple2') {
				if (_p278._0.ctor === '::') {
					if (_p278._1.ctor === '::') {
						var _p279 = A2(_user$project$Utils$maybeZip, _p278._0._1, _p278._1._1);
						if (_p279.ctor === 'Nothing') {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							return _elm_lang$core$Maybe$Just(
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _p278._0._0, _1: _p278._1._0},
									_1: _p279._0
								});
						}
					} else {
						break _v220_2;
					}
				} else {
					if (_p278._1.ctor === '[]') {
						return _elm_lang$core$Maybe$Just(
							{ctor: '[]'});
					} else {
						break _v220_2;
					}
				}
			} else {
				break _v220_2;
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	});
var _user$project$Utils$inserted = F3(
	function (l, index, elem) {
		if (_elm_lang$core$Native_Utils.eq(index, 0)) {
			return {ctor: '::', _0: elem, _1: l};
		} else {
			var _p280 = l;
			if (_p280.ctor === '[]') {
				return {
					ctor: '::',
					_0: elem,
					_1: {ctor: '[]'}
				};
			} else {
				return {
					ctor: '::',
					_0: _p280._0,
					_1: A3(_user$project$Utils$inserted, _p280._1, index - 1, elem)
				};
			}
		}
	});
var _user$project$Utils$updated = F3(
	function (l, index, elem) {
		if (_elm_lang$core$Native_Utils.eq(index, 0)) {
			var _p281 = l;
			if (_p281.ctor === '::') {
				return {ctor: '::', _0: elem, _1: _p281._1};
			} else {
				return {
					ctor: '::',
					_0: elem,
					_1: {ctor: '[]'}
				};
			}
		} else {
			var _p282 = l;
			if (_p282.ctor === '[]') {
				return {
					ctor: '::',
					_0: elem,
					_1: {ctor: '[]'}
				};
			} else {
				return {
					ctor: '::',
					_0: _p282._0,
					_1: A3(_user$project$Utils$updated, _p282._1, index - 1, elem)
				};
			}
		}
	});
var _user$project$Utils$zipWithIndex = function () {
	var aux = F2(
		function (i, l) {
			var _p283 = l;
			if (_p283.ctor === '[]') {
				return {ctor: '[]'};
			} else {
				return {
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: _p283._0, _1: i},
					_1: A2(aux, i + 1, _p283._1)
				};
			}
		});
	return aux(0);
}();
var _user$project$Utils$zipWith = F3(
	function (f, xs, ys) {
		var _p284 = {ctor: '_Tuple2', _0: xs, _1: ys};
		if (((_p284.ctor === '_Tuple2') && (_p284._0.ctor === '::')) && (_p284._1.ctor === '::')) {
			return {
				ctor: '::',
				_0: A2(f, _p284._0._0, _p284._1._0),
				_1: A3(_user$project$Utils$zipWith, f, _p284._0._1, _p284._1._1)
			};
		} else {
			return {ctor: '[]'};
		}
	});
var _user$project$Utils$zip = _user$project$Utils$zipWith(
	F2(
		function (v0, v1) {
			return {ctor: '_Tuple2', _0: v0, _1: v1};
		}));
var _user$project$Utils$overlappingAdjacentPairs_ = F2(
	function (includeLast, list) {
		var shiftList = function () {
			var _p285 = list;
			if (_p285.ctor === '::') {
				var _p286 = _p285._1;
				return includeLast ? A2(
					_elm_lang$core$Basics_ops['++'],
					_p286,
					{
						ctor: '::',
						_0: _p285._0,
						_1: {ctor: '[]'}
					}) : _p286;
			} else {
				return {ctor: '[]'};
			}
		}();
		return A2(_user$project$Utils$zip, list, shiftList);
	});
var _user$project$Utils$circOverlappingAdjacentPairs = function (list) {
	return A2(_user$project$Utils$overlappingAdjacentPairs_, true, list);
};
var _user$project$Utils$overlappingAdjacentPairs = function (list) {
	return A2(_user$project$Utils$overlappingAdjacentPairs_, false, list);
};
var _user$project$Utils$stringSuggestions = F2(
	function (trueStrings, wrongString) {
		var wrongStringCanonical = _elm_lang$core$String$toLower(
			_elm_lang$core$String$trim(wrongString));
		var trueStringsCanonical = A2(
			_elm_lang$core$List$map,
			function (_p287) {
				return _elm_lang$core$String$toLower(
					_elm_lang$core$String$trim(_p287));
			},
			trueStrings);
		var trueMapping = A2(_user$project$Utils$zip, trueStringsCanonical, trueStrings);
		var guess1 = A2(
			_elm_lang$core$List$map,
			_elm_lang$core$Tuple$second,
			A2(
				_elm_lang$core$List$filter,
				function (_p288) {
					var _p289 = _p288;
					return _elm_lang$core$Native_Utils.eq(_p289._0, wrongStringCanonical);
				},
				trueMapping));
		var _p290 = guess1;
		if (_p290.ctor === '::') {
			return guess1;
		} else {
			var firstChar = A3(_elm_lang$core$String$slice, 0, 1, wrongStringCanonical);
			var guess2 = A2(
				_elm_lang$core$List$map,
				_elm_lang$core$Tuple$second,
				A2(
					_elm_lang$core$List$filter,
					function (_p291) {
						var _p292 = _p291;
						return _elm_lang$core$Native_Utils.eq(
							A3(_elm_lang$core$String$slice, 0, 1, _p292._0),
							firstChar);
					},
					trueMapping));
			var _p293 = guess2;
			if (_p293.ctor === '::') {
				return A2(_elm_lang$core$List$take, 5, guess2);
			} else {
				var lastChar = A3(
					_elm_lang$core$String$slice,
					-1,
					_elm_lang$core$String$length(wrongStringCanonical),
					wrongStringCanonical);
				var guess3 = A2(
					_elm_lang$core$List$map,
					_elm_lang$core$Tuple$second,
					A2(
						_elm_lang$core$List$filter,
						function (_p294) {
							var _p295 = _p294;
							var _p296 = _p295._0;
							return _elm_lang$core$Native_Utils.eq(
								A3(
									_elm_lang$core$String$slice,
									-1,
									_elm_lang$core$String$length(_p296),
									_p296),
								firstChar);
						},
						trueMapping));
				var _p297 = guess3;
				if (_p297.ctor === '::') {
					return A2(_elm_lang$core$List$take, 5, guess2);
				} else {
					return A2(_elm_lang$core$List$take, 5, trueStrings);
				}
			}
		}
	});
var _user$project$Utils$update = F2(
	function (_p298, vals) {
		var _p299 = _p298;
		var _p304 = _p299._1;
		var _p303 = _p299._0;
		var _p300 = vals;
		if (_p300.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var _p302 = _p300._1;
			var _p301 = _p300._0._0;
			return _elm_lang$core$Native_Utils.eq(_p301, _p303) ? {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: _p301, _1: _p304},
				_1: _p302
			} : {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: _p301, _1: _p300._0._1},
				_1: A2(
					_user$project$Utils$update,
					{ctor: '_Tuple2', _0: _p303, _1: _p304},
					_p302)
			};
		}
	});
var _user$project$Utils$maybeFindTail = F2(
	function (k, l) {
		maybeFindTail:
		while (true) {
			var _p305 = l;
			if (_p305.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p306 = _p305._1;
				if (_elm_lang$core$Native_Utils.eq(k, _p305._0._0)) {
					return _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple2', _0: _p305._0._1, _1: _p306});
				} else {
					var _v237 = k,
						_v238 = _p306;
					k = _v237;
					l = _v238;
					continue maybeFindTail;
				}
			}
		}
	});
var _user$project$Utils$maybeFind = F2(
	function (k, l) {
		maybeFind:
		while (true) {
			var _p307 = l;
			if (_p307.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				if (_elm_lang$core$Native_Utils.eq(k, _p307._0._0)) {
					return _elm_lang$core$Maybe$Just(_p307._0._1);
				} else {
					var _v240 = k,
						_v241 = _p307._1;
					k = _v240;
					l = _v241;
					continue maybeFind;
				}
			}
		}
	});
var _user$project$Utils$find = F3(
	function (err, d, k) {
		var _p308 = A2(_user$project$Utils$maybeFind, k, d);
		if (_p308.ctor === 'Just') {
			return _p308._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Utils',
				{
					start: {line: 42, column: 3},
					end: {line: 44, column: 52}
				},
				_p308)(
				A2(_elm_lang$core$Basics_ops['++'], 'Utils.find: ', err));
		}
	});
var _user$project$Utils$find_ = F2(
	function (d, k) {
		return A3(
			_user$project$Utils$find,
			A2(
				_elm_lang$core$Basics_ops['++'],
				'[',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(k),
					']')),
			d,
			k);
	});
var _user$project$Utils$correctFloatError = function (x) {
	if (_elm_lang$core$Native_Utils.eq(x, 0.0)) {
		return x;
	} else {
		var tens = 0 - _elm_lang$core$Basics$toFloat(
			_elm_lang$core$Basics$round(
				A2(
					_elm_lang$core$Basics$logBase,
					10,
					_elm_lang$core$Basics$abs(x))));
		var multiplier = ((((((((((((2 * 2) * 2) * 3) * 3) * 5) * 5) * 7) * 11) * 13) * 17) * 19) * 23) * Math.pow(10.0, tens + 1);
		var corrected = _elm_lang$core$Basics$toFloat(
			_elm_lang$core$Basics$round(x * multiplier)) / multiplier;
		return (_elm_lang$core$Native_Utils.cmp(
			_elm_lang$core$Basics$abs(corrected - x) / x,
			1.0e-7) < 0) ? corrected : x;
	}
};
var _user$project$Utils$infinity = 1 / 0;

var _user$project$ColorNum$htmlColorNames = A2(
	_elm_lang$core$List$map,
	_elm_lang$core$Tuple$mapFirst(_elm_lang$core$String$toLower),
	A2(
		_elm_lang$core$Basics_ops['++'],
		{
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 'AliceBlue',
				_1: {
					ctor: '_Tuple2',
					_0: {ctor: '_Tuple3', _0: 240, _1: 248, _2: 255},
					_1: {ctor: '_Tuple3', _0: 208, _1: 1, _2: 0.97}
				}
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: 'AntiqueWhite',
					_1: {
						ctor: '_Tuple2',
						_0: {ctor: '_Tuple3', _0: 250, _1: 235, _2: 215},
						_1: {ctor: '_Tuple3', _0: 34, _1: 0.78, _2: 0.91}
					}
				},
				_1: {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'Aqua',
						_1: {
							ctor: '_Tuple2',
							_0: {ctor: '_Tuple3', _0: 0, _1: 255, _2: 255},
							_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.5}
						}
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: 'Aquamarine',
							_1: {
								ctor: '_Tuple2',
								_0: {ctor: '_Tuple3', _0: 127, _1: 255, _2: 212},
								_1: {ctor: '_Tuple3', _0: 160, _1: 1, _2: 0.75}
							}
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'Azure',
								_1: {
									ctor: '_Tuple2',
									_0: {ctor: '_Tuple3', _0: 240, _1: 255, _2: 255},
									_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.97}
								}
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'Beige',
									_1: {
										ctor: '_Tuple2',
										_0: {ctor: '_Tuple3', _0: 245, _1: 245, _2: 220},
										_1: {ctor: '_Tuple3', _0: 60, _1: 0.56, _2: 0.91}
									}
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'Bisque',
										_1: {
											ctor: '_Tuple2',
											_0: {ctor: '_Tuple3', _0: 255, _1: 228, _2: 196},
											_1: {ctor: '_Tuple3', _0: 33, _1: 1, _2: 0.88}
										}
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'Black',
											_1: {
												ctor: '_Tuple2',
												_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
												_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0}
											}
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 'BlanchedAlmond',
												_1: {
													ctor: '_Tuple2',
													_0: {ctor: '_Tuple3', _0: 255, _1: 235, _2: 205},
													_1: {ctor: '_Tuple3', _0: 36, _1: 1, _2: 0.9}
												}
											},
											_1: {
												ctor: '::',
												_0: {
													ctor: '_Tuple2',
													_0: 'Blue',
													_1: {
														ctor: '_Tuple2',
														_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 255},
														_1: {ctor: '_Tuple3', _0: 240, _1: 1, _2: 0.5}
													}
												},
												_1: {
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: 'BlueViolet',
														_1: {
															ctor: '_Tuple2',
															_0: {ctor: '_Tuple3', _0: 138, _1: 43, _2: 226},
															_1: {ctor: '_Tuple3', _0: 271, _1: 0.76, _2: 0.53}
														}
													},
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: 'Brown',
															_1: {
																ctor: '_Tuple2',
																_0: {ctor: '_Tuple3', _0: 165, _1: 42, _2: 42},
																_1: {ctor: '_Tuple3', _0: 0, _1: 0.59, _2: 0.41}
															}
														},
														_1: {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: 'BurlyWood',
																_1: {
																	ctor: '_Tuple2',
																	_0: {ctor: '_Tuple3', _0: 222, _1: 184, _2: 135},
																	_1: {ctor: '_Tuple3', _0: 34, _1: 0.57, _2: 0.7}
																}
															},
															_1: {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: 'CadetBlue',
																	_1: {
																		ctor: '_Tuple2',
																		_0: {ctor: '_Tuple3', _0: 95, _1: 158, _2: 160},
																		_1: {ctor: '_Tuple3', _0: 182, _1: 0.25, _2: 0.5}
																	}
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: 'Chartreuse',
																		_1: {
																			ctor: '_Tuple2',
																			_0: {ctor: '_Tuple3', _0: 127, _1: 255, _2: 0},
																			_1: {ctor: '_Tuple3', _0: 90, _1: 1, _2: 0.5}
																		}
																	},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: 'Chocolate',
																			_1: {
																				ctor: '_Tuple2',
																				_0: {ctor: '_Tuple3', _0: 210, _1: 105, _2: 30},
																				_1: {ctor: '_Tuple3', _0: 25, _1: 0.75, _2: 0.47}
																			}
																		},
																		_1: {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: 'Coral',
																				_1: {
																					ctor: '_Tuple2',
																					_0: {ctor: '_Tuple3', _0: 255, _1: 127, _2: 80},
																					_1: {ctor: '_Tuple3', _0: 16, _1: 1, _2: 0.66}
																				}
																			},
																			_1: {
																				ctor: '::',
																				_0: {
																					ctor: '_Tuple2',
																					_0: 'CornflowerBlue',
																					_1: {
																						ctor: '_Tuple2',
																						_0: {ctor: '_Tuple3', _0: 100, _1: 149, _2: 237},
																						_1: {ctor: '_Tuple3', _0: 219, _1: 0.79, _2: 0.66}
																					}
																				},
																				_1: {
																					ctor: '::',
																					_0: {
																						ctor: '_Tuple2',
																						_0: 'Cornsilk',
																						_1: {
																							ctor: '_Tuple2',
																							_0: {ctor: '_Tuple3', _0: 255, _1: 248, _2: 220},
																							_1: {ctor: '_Tuple3', _0: 48, _1: 1, _2: 0.93}
																						}
																					},
																					_1: {
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: 'Crimson',
																							_1: {
																								ctor: '_Tuple2',
																								_0: {ctor: '_Tuple3', _0: 220, _1: 20, _2: 60},
																								_1: {ctor: '_Tuple3', _0: 348, _1: 0.83, _2: 0.47}
																							}
																						},
																						_1: {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: 'Cyan',
																								_1: {
																									ctor: '_Tuple2',
																									_0: {ctor: '_Tuple3', _0: 0, _1: 255, _2: 255},
																									_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.5}
																								}
																							},
																							_1: {
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: 'DarkBlue',
																									_1: {
																										ctor: '_Tuple2',
																										_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 139},
																										_1: {ctor: '_Tuple3', _0: 240, _1: 1, _2: 0.27}
																									}
																								},
																								_1: {
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: 'DarkCyan',
																										_1: {
																											ctor: '_Tuple2',
																											_0: {ctor: '_Tuple3', _0: 0, _1: 139, _2: 139},
																											_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.27}
																										}
																									},
																									_1: {
																										ctor: '::',
																										_0: {
																											ctor: '_Tuple2',
																											_0: 'DarkGoldenRod',
																											_1: {
																												ctor: '_Tuple2',
																												_0: {ctor: '_Tuple3', _0: 184, _1: 134, _2: 11},
																												_1: {ctor: '_Tuple3', _0: 43, _1: 0.89, _2: 0.38}
																											}
																										},
																										_1: {
																											ctor: '::',
																											_0: {
																												ctor: '_Tuple2',
																												_0: 'DarkGray',
																												_1: {
																													ctor: '_Tuple2',
																													_0: {ctor: '_Tuple3', _0: 169, _1: 169, _2: 169},
																													_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.66}
																												}
																											},
																											_1: {
																												ctor: '::',
																												_0: {
																													ctor: '_Tuple2',
																													_0: 'DarkGrey',
																													_1: {
																														ctor: '_Tuple2',
																														_0: {ctor: '_Tuple3', _0: 169, _1: 169, _2: 169},
																														_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.66}
																													}
																												},
																												_1: {
																													ctor: '::',
																													_0: {
																														ctor: '_Tuple2',
																														_0: 'DarkGreen',
																														_1: {
																															ctor: '_Tuple2',
																															_0: {ctor: '_Tuple3', _0: 0, _1: 100, _2: 0},
																															_1: {ctor: '_Tuple3', _0: 120, _1: 1, _2: 0.2}
																														}
																													},
																													_1: {
																														ctor: '::',
																														_0: {
																															ctor: '_Tuple2',
																															_0: 'DarkKhaki',
																															_1: {
																																ctor: '_Tuple2',
																																_0: {ctor: '_Tuple3', _0: 189, _1: 183, _2: 107},
																																_1: {ctor: '_Tuple3', _0: 56, _1: 0.38, _2: 0.58}
																															}
																														},
																														_1: {
																															ctor: '::',
																															_0: {
																																ctor: '_Tuple2',
																																_0: 'DarkMagenta',
																																_1: {
																																	ctor: '_Tuple2',
																																	_0: {ctor: '_Tuple3', _0: 139, _1: 0, _2: 139},
																																	_1: {ctor: '_Tuple3', _0: 300, _1: 1, _2: 0.27}
																																}
																															},
																															_1: {
																																ctor: '::',
																																_0: {
																																	ctor: '_Tuple2',
																																	_0: 'DarkOliveGreen',
																																	_1: {
																																		ctor: '_Tuple2',
																																		_0: {ctor: '_Tuple3', _0: 85, _1: 107, _2: 47},
																																		_1: {ctor: '_Tuple3', _0: 82, _1: 0.39, _2: 0.3}
																																	}
																																},
																																_1: {
																																	ctor: '::',
																																	_0: {
																																		ctor: '_Tuple2',
																																		_0: 'DarkOrange',
																																		_1: {
																																			ctor: '_Tuple2',
																																			_0: {ctor: '_Tuple3', _0: 255, _1: 140, _2: 0},
																																			_1: {ctor: '_Tuple3', _0: 33, _1: 1, _2: 0.5}
																																		}
																																	},
																																	_1: {
																																		ctor: '::',
																																		_0: {
																																			ctor: '_Tuple2',
																																			_0: 'DarkOrchid',
																																			_1: {
																																				ctor: '_Tuple2',
																																				_0: {ctor: '_Tuple3', _0: 153, _1: 50, _2: 204},
																																				_1: {ctor: '_Tuple3', _0: 280, _1: 0.61, _2: 0.5}
																																			}
																																		},
																																		_1: {
																																			ctor: '::',
																																			_0: {
																																				ctor: '_Tuple2',
																																				_0: 'DarkRed',
																																				_1: {
																																					ctor: '_Tuple2',
																																					_0: {ctor: '_Tuple3', _0: 139, _1: 0, _2: 0},
																																					_1: {ctor: '_Tuple3', _0: 0, _1: 1, _2: 0.27}
																																				}
																																			},
																																			_1: {
																																				ctor: '::',
																																				_0: {
																																					ctor: '_Tuple2',
																																					_0: 'DarkSalmon',
																																					_1: {
																																						ctor: '_Tuple2',
																																						_0: {ctor: '_Tuple3', _0: 233, _1: 150, _2: 122},
																																						_1: {ctor: '_Tuple3', _0: 15, _1: 0.72, _2: 0.7}
																																					}
																																				},
																																				_1: {
																																					ctor: '::',
																																					_0: {
																																						ctor: '_Tuple2',
																																						_0: 'DarkSeaGreen',
																																						_1: {
																																							ctor: '_Tuple2',
																																							_0: {ctor: '_Tuple3', _0: 143, _1: 188, _2: 143},
																																							_1: {ctor: '_Tuple3', _0: 120, _1: 0.25, _2: 0.65}
																																						}
																																					},
																																					_1: {
																																						ctor: '::',
																																						_0: {
																																							ctor: '_Tuple2',
																																							_0: 'DarkSlateBlue',
																																							_1: {
																																								ctor: '_Tuple2',
																																								_0: {ctor: '_Tuple3', _0: 72, _1: 61, _2: 139},
																																								_1: {ctor: '_Tuple3', _0: 248, _1: 0.39, _2: 0.39}
																																							}
																																						},
																																						_1: {
																																							ctor: '::',
																																							_0: {
																																								ctor: '_Tuple2',
																																								_0: 'DarkSlateGray',
																																								_1: {
																																									ctor: '_Tuple2',
																																									_0: {ctor: '_Tuple3', _0: 47, _1: 79, _2: 79},
																																									_1: {ctor: '_Tuple3', _0: 180, _1: 0.25, _2: 0.25}
																																								}
																																							},
																																							_1: {
																																								ctor: '::',
																																								_0: {
																																									ctor: '_Tuple2',
																																									_0: 'DarkSlateGrey',
																																									_1: {
																																										ctor: '_Tuple2',
																																										_0: {ctor: '_Tuple3', _0: 47, _1: 79, _2: 79},
																																										_1: {ctor: '_Tuple3', _0: 180, _1: 0.25, _2: 0.25}
																																									}
																																								},
																																								_1: {
																																									ctor: '::',
																																									_0: {
																																										ctor: '_Tuple2',
																																										_0: 'DarkTurquoise',
																																										_1: {
																																											ctor: '_Tuple2',
																																											_0: {ctor: '_Tuple3', _0: 0, _1: 206, _2: 209},
																																											_1: {ctor: '_Tuple3', _0: 181, _1: 1, _2: 0.41}
																																										}
																																									},
																																									_1: {
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: 'DarkViolet',
																																											_1: {
																																												ctor: '_Tuple2',
																																												_0: {ctor: '_Tuple3', _0: 148, _1: 0, _2: 211},
																																												_1: {ctor: '_Tuple3', _0: 282, _1: 1, _2: 0.41}
																																											}
																																										},
																																										_1: {
																																											ctor: '::',
																																											_0: {
																																												ctor: '_Tuple2',
																																												_0: 'DeepPink',
																																												_1: {
																																													ctor: '_Tuple2',
																																													_0: {ctor: '_Tuple3', _0: 255, _1: 20, _2: 147},
																																													_1: {ctor: '_Tuple3', _0: 328, _1: 1, _2: 0.54}
																																												}
																																											},
																																											_1: {
																																												ctor: '::',
																																												_0: {
																																													ctor: '_Tuple2',
																																													_0: 'DeepSkyBlue',
																																													_1: {
																																														ctor: '_Tuple2',
																																														_0: {ctor: '_Tuple3', _0: 0, _1: 191, _2: 255},
																																														_1: {ctor: '_Tuple3', _0: 195, _1: 1, _2: 0.5}
																																													}
																																												},
																																												_1: {
																																													ctor: '::',
																																													_0: {
																																														ctor: '_Tuple2',
																																														_0: 'DimGray',
																																														_1: {
																																															ctor: '_Tuple2',
																																															_0: {ctor: '_Tuple3', _0: 105, _1: 105, _2: 105},
																																															_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.41}
																																														}
																																													},
																																													_1: {
																																														ctor: '::',
																																														_0: {
																																															ctor: '_Tuple2',
																																															_0: 'DimGrey',
																																															_1: {
																																																ctor: '_Tuple2',
																																																_0: {ctor: '_Tuple3', _0: 105, _1: 105, _2: 105},
																																																_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.41}
																																															}
																																														},
																																														_1: {
																																															ctor: '::',
																																															_0: {
																																																ctor: '_Tuple2',
																																																_0: 'DodgerBlue',
																																																_1: {
																																																	ctor: '_Tuple2',
																																																	_0: {ctor: '_Tuple3', _0: 30, _1: 144, _2: 255},
																																																	_1: {ctor: '_Tuple3', _0: 210, _1: 1, _2: 0.56}
																																																}
																																															},
																																															_1: {
																																																ctor: '::',
																																																_0: {
																																																	ctor: '_Tuple2',
																																																	_0: 'FireBrick',
																																																	_1: {
																																																		ctor: '_Tuple2',
																																																		_0: {ctor: '_Tuple3', _0: 178, _1: 34, _2: 34},
																																																		_1: {ctor: '_Tuple3', _0: 0, _1: 0.68, _2: 0.42}
																																																	}
																																																},
																																																_1: {
																																																	ctor: '::',
																																																	_0: {
																																																		ctor: '_Tuple2',
																																																		_0: 'FloralWhite',
																																																		_1: {
																																																			ctor: '_Tuple2',
																																																			_0: {ctor: '_Tuple3', _0: 255, _1: 250, _2: 240},
																																																			_1: {ctor: '_Tuple3', _0: 40, _1: 1, _2: 0.97}
																																																		}
																																																	},
																																																	_1: {
																																																		ctor: '::',
																																																		_0: {
																																																			ctor: '_Tuple2',
																																																			_0: 'ForestGreen',
																																																			_1: {
																																																				ctor: '_Tuple2',
																																																				_0: {ctor: '_Tuple3', _0: 34, _1: 139, _2: 34},
																																																				_1: {ctor: '_Tuple3', _0: 120, _1: 0.61, _2: 0.34}
																																																			}
																																																		},
																																																		_1: {
																																																			ctor: '::',
																																																			_0: {
																																																				ctor: '_Tuple2',
																																																				_0: 'Fuchsia',
																																																				_1: {
																																																					ctor: '_Tuple2',
																																																					_0: {ctor: '_Tuple3', _0: 255, _1: 0, _2: 255},
																																																					_1: {ctor: '_Tuple3', _0: 300, _1: 1, _2: 0.5}
																																																				}
																																																			},
																																																			_1: {
																																																				ctor: '::',
																																																				_0: {
																																																					ctor: '_Tuple2',
																																																					_0: 'Gainsboro',
																																																					_1: {
																																																						ctor: '_Tuple2',
																																																						_0: {ctor: '_Tuple3', _0: 220, _1: 220, _2: 220},
																																																						_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.86}
																																																					}
																																																				},
																																																				_1: {
																																																					ctor: '::',
																																																					_0: {
																																																						ctor: '_Tuple2',
																																																						_0: 'GhostWhite',
																																																						_1: {
																																																							ctor: '_Tuple2',
																																																							_0: {ctor: '_Tuple3', _0: 248, _1: 248, _2: 255},
																																																							_1: {ctor: '_Tuple3', _0: 240, _1: 1, _2: 0.99}
																																																						}
																																																					},
																																																					_1: {
																																																						ctor: '::',
																																																						_0: {
																																																							ctor: '_Tuple2',
																																																							_0: 'Gold',
																																																							_1: {
																																																								ctor: '_Tuple2',
																																																								_0: {ctor: '_Tuple3', _0: 255, _1: 215, _2: 0},
																																																								_1: {ctor: '_Tuple3', _0: 51, _1: 1, _2: 0.5}
																																																							}
																																																						},
																																																						_1: {
																																																							ctor: '::',
																																																							_0: {
																																																								ctor: '_Tuple2',
																																																								_0: 'GoldenRod',
																																																								_1: {
																																																									ctor: '_Tuple2',
																																																									_0: {ctor: '_Tuple3', _0: 218, _1: 165, _2: 32},
																																																									_1: {ctor: '_Tuple3', _0: 43, _1: 0.74, _2: 0.49}
																																																								}
																																																							},
																																																							_1: {
																																																								ctor: '::',
																																																								_0: {
																																																									ctor: '_Tuple2',
																																																									_0: 'Gray',
																																																									_1: {
																																																										ctor: '_Tuple2',
																																																										_0: {ctor: '_Tuple3', _0: 128, _1: 128, _2: 128},
																																																										_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.5}
																																																									}
																																																								},
																																																								_1: {
																																																									ctor: '::',
																																																									_0: {
																																																										ctor: '_Tuple2',
																																																										_0: 'Grey',
																																																										_1: {
																																																											ctor: '_Tuple2',
																																																											_0: {ctor: '_Tuple3', _0: 128, _1: 128, _2: 128},
																																																											_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.5}
																																																										}
																																																									},
																																																									_1: {
																																																										ctor: '::',
																																																										_0: {
																																																											ctor: '_Tuple2',
																																																											_0: 'Green',
																																																											_1: {
																																																												ctor: '_Tuple2',
																																																												_0: {ctor: '_Tuple3', _0: 0, _1: 128, _2: 0},
																																																												_1: {ctor: '_Tuple3', _0: 120, _1: 1, _2: 0.25}
																																																											}
																																																										},
																																																										_1: {
																																																											ctor: '::',
																																																											_0: {
																																																												ctor: '_Tuple2',
																																																												_0: 'GreenYellow',
																																																												_1: {
																																																													ctor: '_Tuple2',
																																																													_0: {ctor: '_Tuple3', _0: 173, _1: 255, _2: 47},
																																																													_1: {ctor: '_Tuple3', _0: 84, _1: 1, _2: 0.59}
																																																												}
																																																											},
																																																											_1: {
																																																												ctor: '::',
																																																												_0: {
																																																													ctor: '_Tuple2',
																																																													_0: 'HoneyDew',
																																																													_1: {
																																																														ctor: '_Tuple2',
																																																														_0: {ctor: '_Tuple3', _0: 240, _1: 255, _2: 240},
																																																														_1: {ctor: '_Tuple3', _0: 120, _1: 1, _2: 0.97}
																																																													}
																																																												},
																																																												_1: {
																																																													ctor: '::',
																																																													_0: {
																																																														ctor: '_Tuple2',
																																																														_0: 'HotPink',
																																																														_1: {
																																																															ctor: '_Tuple2',
																																																															_0: {ctor: '_Tuple3', _0: 255, _1: 105, _2: 180},
																																																															_1: {ctor: '_Tuple3', _0: 330, _1: 1, _2: 0.71}
																																																														}
																																																													},
																																																													_1: {
																																																														ctor: '::',
																																																														_0: {
																																																															ctor: '_Tuple2',
																																																															_0: 'IndianRed',
																																																															_1: {
																																																																ctor: '_Tuple2',
																																																																_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0}
																																																															}
																																																														},
																																																														_1: {
																																																															ctor: '::',
																																																															_0: {
																																																																ctor: '_Tuple2',
																																																																_0: 'Indigo',
																																																																_1: {
																																																																	ctor: '_Tuple2',
																																																																	_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																	_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0}
																																																																}
																																																															},
																																																															_1: {
																																																																ctor: '::',
																																																																_0: {
																																																																	ctor: '_Tuple2',
																																																																	_0: 'Ivory',
																																																																	_1: {
																																																																		ctor: '_Tuple2',
																																																																		_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 240},
																																																																		_1: {ctor: '_Tuple3', _0: 60, _1: 1, _2: 0.97}
																																																																	}
																																																																},
																																																																_1: {
																																																																	ctor: '::',
																																																																	_0: {
																																																																		ctor: '_Tuple2',
																																																																		_0: 'Khaki',
																																																																		_1: {
																																																																			ctor: '_Tuple2',
																																																																			_0: {ctor: '_Tuple3', _0: 240, _1: 230, _2: 140},
																																																																			_1: {ctor: '_Tuple3', _0: 54, _1: 0.77, _2: 0.75}
																																																																		}
																																																																	},
																																																																	_1: {
																																																																		ctor: '::',
																																																																		_0: {
																																																																			ctor: '_Tuple2',
																																																																			_0: 'Lavender',
																																																																			_1: {
																																																																				ctor: '_Tuple2',
																																																																				_0: {ctor: '_Tuple3', _0: 230, _1: 230, _2: 250},
																																																																				_1: {ctor: '_Tuple3', _0: 240, _1: 0.67, _2: 0.94}
																																																																			}
																																																																		},
																																																																		_1: {
																																																																			ctor: '::',
																																																																			_0: {
																																																																				ctor: '_Tuple2',
																																																																				_0: 'LavenderBlush',
																																																																				_1: {
																																																																					ctor: '_Tuple2',
																																																																					_0: {ctor: '_Tuple3', _0: 255, _1: 240, _2: 245},
																																																																					_1: {ctor: '_Tuple3', _0: 340, _1: 1, _2: 0.97}
																																																																				}
																																																																			},
																																																																			_1: {
																																																																				ctor: '::',
																																																																				_0: {
																																																																					ctor: '_Tuple2',
																																																																					_0: 'LawnGreen',
																																																																					_1: {
																																																																						ctor: '_Tuple2',
																																																																						_0: {ctor: '_Tuple3', _0: 124, _1: 252, _2: 0},
																																																																						_1: {ctor: '_Tuple3', _0: 90, _1: 1, _2: 0.49}
																																																																					}
																																																																				},
																																																																				_1: {
																																																																					ctor: '::',
																																																																					_0: {
																																																																						ctor: '_Tuple2',
																																																																						_0: 'LemonChiffon',
																																																																						_1: {
																																																																							ctor: '_Tuple2',
																																																																							_0: {ctor: '_Tuple3', _0: 255, _1: 250, _2: 205},
																																																																							_1: {ctor: '_Tuple3', _0: 54, _1: 1, _2: 0.9}
																																																																						}
																																																																					},
																																																																					_1: {
																																																																						ctor: '::',
																																																																						_0: {
																																																																							ctor: '_Tuple2',
																																																																							_0: 'LightBlue',
																																																																							_1: {
																																																																								ctor: '_Tuple2',
																																																																								_0: {ctor: '_Tuple3', _0: 173, _1: 216, _2: 230},
																																																																								_1: {ctor: '_Tuple3', _0: 195, _1: 0.53, _2: 0.79}
																																																																							}
																																																																						},
																																																																						_1: {
																																																																							ctor: '::',
																																																																							_0: {
																																																																								ctor: '_Tuple2',
																																																																								_0: 'LightCoral',
																																																																								_1: {
																																																																									ctor: '_Tuple2',
																																																																									_0: {ctor: '_Tuple3', _0: 240, _1: 128, _2: 128},
																																																																									_1: {ctor: '_Tuple3', _0: 0, _1: 0.79, _2: 0.72}
																																																																								}
																																																																							},
																																																																							_1: {
																																																																								ctor: '::',
																																																																								_0: {
																																																																									ctor: '_Tuple2',
																																																																									_0: 'LightCyan',
																																																																									_1: {
																																																																										ctor: '_Tuple2',
																																																																										_0: {ctor: '_Tuple3', _0: 224, _1: 255, _2: 255},
																																																																										_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.94}
																																																																									}
																																																																								},
																																																																								_1: {
																																																																									ctor: '::',
																																																																									_0: {
																																																																										ctor: '_Tuple2',
																																																																										_0: 'LightGoldenRodYellow',
																																																																										_1: {
																																																																											ctor: '_Tuple2',
																																																																											_0: {ctor: '_Tuple3', _0: 250, _1: 250, _2: 210},
																																																																											_1: {ctor: '_Tuple3', _0: 60, _1: 0.8, _2: 0.9}
																																																																										}
																																																																									},
																																																																									_1: {
																																																																										ctor: '::',
																																																																										_0: {
																																																																											ctor: '_Tuple2',
																																																																											_0: 'LightGray',
																																																																											_1: {
																																																																												ctor: '_Tuple2',
																																																																												_0: {ctor: '_Tuple3', _0: 211, _1: 211, _2: 211},
																																																																												_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.83}
																																																																											}
																																																																										},
																																																																										_1: {
																																																																											ctor: '::',
																																																																											_0: {
																																																																												ctor: '_Tuple2',
																																																																												_0: 'LightGrey',
																																																																												_1: {
																																																																													ctor: '_Tuple2',
																																																																													_0: {ctor: '_Tuple3', _0: 211, _1: 211, _2: 211},
																																																																													_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.83}
																																																																												}
																																																																											},
																																																																											_1: {
																																																																												ctor: '::',
																																																																												_0: {
																																																																													ctor: '_Tuple2',
																																																																													_0: 'LightGreen',
																																																																													_1: {
																																																																														ctor: '_Tuple2',
																																																																														_0: {ctor: '_Tuple3', _0: 144, _1: 238, _2: 144},
																																																																														_1: {ctor: '_Tuple3', _0: 120, _1: 0.73, _2: 0.75}
																																																																													}
																																																																												},
																																																																												_1: {
																																																																													ctor: '::',
																																																																													_0: {
																																																																														ctor: '_Tuple2',
																																																																														_0: 'LightPink',
																																																																														_1: {
																																																																															ctor: '_Tuple2',
																																																																															_0: {ctor: '_Tuple3', _0: 255, _1: 182, _2: 193},
																																																																															_1: {ctor: '_Tuple3', _0: 351, _1: 1, _2: 0.86}
																																																																														}
																																																																													},
																																																																													_1: {ctor: '[]'}
																																																																												}
																																																																											}
																																																																										}
																																																																									}
																																																																								}
																																																																							}
																																																																						}
																																																																					}
																																																																				}
																																																																			}
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		},
		{
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 'LightSalmon',
				_1: {
					ctor: '_Tuple2',
					_0: {ctor: '_Tuple3', _0: 255, _1: 160, _2: 122},
					_1: {ctor: '_Tuple3', _0: 17, _1: 1, _2: 0.74}
				}
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: 'LightSeaGreen',
					_1: {
						ctor: '_Tuple2',
						_0: {ctor: '_Tuple3', _0: 32, _1: 178, _2: 170},
						_1: {ctor: '_Tuple3', _0: 177, _1: 0.7, _2: 0.41}
					}
				},
				_1: {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'LightSkyBlue',
						_1: {
							ctor: '_Tuple2',
							_0: {ctor: '_Tuple3', _0: 135, _1: 206, _2: 250},
							_1: {ctor: '_Tuple3', _0: 203, _1: 0.92, _2: 0.75}
						}
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: 'LightSlateGray',
							_1: {
								ctor: '_Tuple2',
								_0: {ctor: '_Tuple3', _0: 119, _1: 136, _2: 153},
								_1: {ctor: '_Tuple3', _0: 210, _1: 0.14, _2: 0.53}
							}
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'LightSlateGrey',
								_1: {
									ctor: '_Tuple2',
									_0: {ctor: '_Tuple3', _0: 119, _1: 136, _2: 153},
									_1: {ctor: '_Tuple3', _0: 210, _1: 0.14, _2: 0.53}
								}
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'LightSteelBlue',
									_1: {
										ctor: '_Tuple2',
										_0: {ctor: '_Tuple3', _0: 176, _1: 196, _2: 222},
										_1: {ctor: '_Tuple3', _0: 214, _1: 0.41, _2: 0.78}
									}
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'LightYellow',
										_1: {
											ctor: '_Tuple2',
											_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 224},
											_1: {ctor: '_Tuple3', _0: 60, _1: 1, _2: 0.94}
										}
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'Lime',
											_1: {
												ctor: '_Tuple2',
												_0: {ctor: '_Tuple3', _0: 0, _1: 255, _2: 0},
												_1: {ctor: '_Tuple3', _0: 120, _1: 1, _2: 0.5}
											}
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 'LimeGreen',
												_1: {
													ctor: '_Tuple2',
													_0: {ctor: '_Tuple3', _0: 50, _1: 205, _2: 50},
													_1: {ctor: '_Tuple3', _0: 120, _1: 0.61, _2: 0.5}
												}
											},
											_1: {
												ctor: '::',
												_0: {
													ctor: '_Tuple2',
													_0: 'Linen',
													_1: {
														ctor: '_Tuple2',
														_0: {ctor: '_Tuple3', _0: 250, _1: 240, _2: 230},
														_1: {ctor: '_Tuple3', _0: 30, _1: 0.67, _2: 0.94}
													}
												},
												_1: {
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: 'Magenta',
														_1: {
															ctor: '_Tuple2',
															_0: {ctor: '_Tuple3', _0: 255, _1: 0, _2: 255},
															_1: {ctor: '_Tuple3', _0: 300, _1: 1, _2: 0.5}
														}
													},
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: 'Maroon',
															_1: {
																ctor: '_Tuple2',
																_0: {ctor: '_Tuple3', _0: 128, _1: 0, _2: 0},
																_1: {ctor: '_Tuple3', _0: 0, _1: 1, _2: 0.25}
															}
														},
														_1: {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: 'MediumAquaMarine',
																_1: {
																	ctor: '_Tuple2',
																	_0: {ctor: '_Tuple3', _0: 102, _1: 205, _2: 170},
																	_1: {ctor: '_Tuple3', _0: 160, _1: 0.51, _2: 0.6}
																}
															},
															_1: {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: 'MediumBlue',
																	_1: {
																		ctor: '_Tuple2',
																		_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 205},
																		_1: {ctor: '_Tuple3', _0: 240, _1: 1, _2: 0.4}
																	}
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: 'MediumOrchid',
																		_1: {
																			ctor: '_Tuple2',
																			_0: {ctor: '_Tuple3', _0: 186, _1: 85, _2: 211},
																			_1: {ctor: '_Tuple3', _0: 288, _1: 0.59, _2: 0.58}
																		}
																	},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: 'MediumPurple',
																			_1: {
																				ctor: '_Tuple2',
																				_0: {ctor: '_Tuple3', _0: 147, _1: 112, _2: 219},
																				_1: {ctor: '_Tuple3', _0: 260, _1: 0.6, _2: 0.65}
																			}
																		},
																		_1: {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: 'MediumSeaGreen',
																				_1: {
																					ctor: '_Tuple2',
																					_0: {ctor: '_Tuple3', _0: 60, _1: 179, _2: 113},
																					_1: {ctor: '_Tuple3', _0: 147, _1: 0.5, _2: 0.47}
																				}
																			},
																			_1: {
																				ctor: '::',
																				_0: {
																					ctor: '_Tuple2',
																					_0: 'MediumSlateBlue',
																					_1: {
																						ctor: '_Tuple2',
																						_0: {ctor: '_Tuple3', _0: 123, _1: 104, _2: 238},
																						_1: {ctor: '_Tuple3', _0: 249, _1: 0.8, _2: 0.67}
																					}
																				},
																				_1: {
																					ctor: '::',
																					_0: {
																						ctor: '_Tuple2',
																						_0: 'MediumSpringGreen',
																						_1: {
																							ctor: '_Tuple2',
																							_0: {ctor: '_Tuple3', _0: 0, _1: 250, _2: 154},
																							_1: {ctor: '_Tuple3', _0: 157, _1: 1, _2: 0.49}
																						}
																					},
																					_1: {
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: 'MediumTurquoise',
																							_1: {
																								ctor: '_Tuple2',
																								_0: {ctor: '_Tuple3', _0: 72, _1: 209, _2: 204},
																								_1: {ctor: '_Tuple3', _0: 178, _1: 0.6, _2: 0.55}
																							}
																						},
																						_1: {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: 'MediumVioletRed',
																								_1: {
																									ctor: '_Tuple2',
																									_0: {ctor: '_Tuple3', _0: 199, _1: 21, _2: 133},
																									_1: {ctor: '_Tuple3', _0: 322, _1: 0.81, _2: 0.43}
																								}
																							},
																							_1: {
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: 'MidnightBlue',
																									_1: {
																										ctor: '_Tuple2',
																										_0: {ctor: '_Tuple3', _0: 25, _1: 25, _2: 112},
																										_1: {ctor: '_Tuple3', _0: 240, _1: 0.64, _2: 0.27}
																									}
																								},
																								_1: {
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: 'MintCream',
																										_1: {
																											ctor: '_Tuple2',
																											_0: {ctor: '_Tuple3', _0: 245, _1: 255, _2: 250},
																											_1: {ctor: '_Tuple3', _0: 150, _1: 1, _2: 0.98}
																										}
																									},
																									_1: {
																										ctor: '::',
																										_0: {
																											ctor: '_Tuple2',
																											_0: 'MistyRose',
																											_1: {
																												ctor: '_Tuple2',
																												_0: {ctor: '_Tuple3', _0: 255, _1: 228, _2: 225},
																												_1: {ctor: '_Tuple3', _0: 6, _1: 1, _2: 0.94}
																											}
																										},
																										_1: {
																											ctor: '::',
																											_0: {
																												ctor: '_Tuple2',
																												_0: 'Moccasin',
																												_1: {
																													ctor: '_Tuple2',
																													_0: {ctor: '_Tuple3', _0: 255, _1: 228, _2: 181},
																													_1: {ctor: '_Tuple3', _0: 38, _1: 1, _2: 0.85}
																												}
																											},
																											_1: {
																												ctor: '::',
																												_0: {
																													ctor: '_Tuple2',
																													_0: 'NavajoWhite',
																													_1: {
																														ctor: '_Tuple2',
																														_0: {ctor: '_Tuple3', _0: 255, _1: 222, _2: 173},
																														_1: {ctor: '_Tuple3', _0: 36, _1: 1, _2: 0.84}
																													}
																												},
																												_1: {
																													ctor: '::',
																													_0: {
																														ctor: '_Tuple2',
																														_0: 'Navy',
																														_1: {
																															ctor: '_Tuple2',
																															_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 128},
																															_1: {ctor: '_Tuple3', _0: 240, _1: 1, _2: 0.25}
																														}
																													},
																													_1: {
																														ctor: '::',
																														_0: {
																															ctor: '_Tuple2',
																															_0: 'OldLace',
																															_1: {
																																ctor: '_Tuple2',
																																_0: {ctor: '_Tuple3', _0: 253, _1: 245, _2: 230},
																																_1: {ctor: '_Tuple3', _0: 39, _1: 0.85, _2: 0.95}
																															}
																														},
																														_1: {
																															ctor: '::',
																															_0: {
																																ctor: '_Tuple2',
																																_0: 'Olive',
																																_1: {
																																	ctor: '_Tuple2',
																																	_0: {ctor: '_Tuple3', _0: 128, _1: 128, _2: 0},
																																	_1: {ctor: '_Tuple3', _0: 60, _1: 1, _2: 0.25}
																																}
																															},
																															_1: {
																																ctor: '::',
																																_0: {
																																	ctor: '_Tuple2',
																																	_0: 'OliveDrab',
																																	_1: {
																																		ctor: '_Tuple2',
																																		_0: {ctor: '_Tuple3', _0: 107, _1: 142, _2: 35},
																																		_1: {ctor: '_Tuple3', _0: 80, _1: 0.6, _2: 0.35}
																																	}
																																},
																																_1: {
																																	ctor: '::',
																																	_0: {
																																		ctor: '_Tuple2',
																																		_0: 'Orange',
																																		_1: {
																																			ctor: '_Tuple2',
																																			_0: {ctor: '_Tuple3', _0: 255, _1: 165, _2: 0},
																																			_1: {ctor: '_Tuple3', _0: 39, _1: 1, _2: 0.5}
																																		}
																																	},
																																	_1: {
																																		ctor: '::',
																																		_0: {
																																			ctor: '_Tuple2',
																																			_0: 'OrangeRed',
																																			_1: {
																																				ctor: '_Tuple2',
																																				_0: {ctor: '_Tuple3', _0: 255, _1: 69, _2: 0},
																																				_1: {ctor: '_Tuple3', _0: 16, _1: 1, _2: 0.5}
																																			}
																																		},
																																		_1: {
																																			ctor: '::',
																																			_0: {
																																				ctor: '_Tuple2',
																																				_0: 'Orchid',
																																				_1: {
																																					ctor: '_Tuple2',
																																					_0: {ctor: '_Tuple3', _0: 218, _1: 112, _2: 214},
																																					_1: {ctor: '_Tuple3', _0: 302, _1: 0.59, _2: 0.65}
																																				}
																																			},
																																			_1: {
																																				ctor: '::',
																																				_0: {
																																					ctor: '_Tuple2',
																																					_0: 'PaleGoldenRod',
																																					_1: {
																																						ctor: '_Tuple2',
																																						_0: {ctor: '_Tuple3', _0: 238, _1: 232, _2: 170},
																																						_1: {ctor: '_Tuple3', _0: 55, _1: 0.67, _2: 0.8}
																																					}
																																				},
																																				_1: {
																																					ctor: '::',
																																					_0: {
																																						ctor: '_Tuple2',
																																						_0: 'PaleGreen',
																																						_1: {
																																							ctor: '_Tuple2',
																																							_0: {ctor: '_Tuple3', _0: 152, _1: 251, _2: 152},
																																							_1: {ctor: '_Tuple3', _0: 120, _1: 0.93, _2: 0.79}
																																						}
																																					},
																																					_1: {
																																						ctor: '::',
																																						_0: {
																																							ctor: '_Tuple2',
																																							_0: 'PaleTurquoise',
																																							_1: {
																																								ctor: '_Tuple2',
																																								_0: {ctor: '_Tuple3', _0: 175, _1: 238, _2: 238},
																																								_1: {ctor: '_Tuple3', _0: 180, _1: 0.65, _2: 0.81}
																																							}
																																						},
																																						_1: {
																																							ctor: '::',
																																							_0: {
																																								ctor: '_Tuple2',
																																								_0: 'PaleVioletRed',
																																								_1: {
																																									ctor: '_Tuple2',
																																									_0: {ctor: '_Tuple3', _0: 219, _1: 112, _2: 147},
																																									_1: {ctor: '_Tuple3', _0: 340, _1: 0.6, _2: 0.65}
																																								}
																																							},
																																							_1: {
																																								ctor: '::',
																																								_0: {
																																									ctor: '_Tuple2',
																																									_0: 'PapayaWhip',
																																									_1: {
																																										ctor: '_Tuple2',
																																										_0: {ctor: '_Tuple3', _0: 255, _1: 239, _2: 213},
																																										_1: {ctor: '_Tuple3', _0: 37, _1: 1, _2: 0.92}
																																									}
																																								},
																																								_1: {
																																									ctor: '::',
																																									_0: {
																																										ctor: '_Tuple2',
																																										_0: 'PeachPuff',
																																										_1: {
																																											ctor: '_Tuple2',
																																											_0: {ctor: '_Tuple3', _0: 255, _1: 218, _2: 185},
																																											_1: {ctor: '_Tuple3', _0: 28, _1: 1, _2: 0.86}
																																										}
																																									},
																																									_1: {
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: 'Peru',
																																											_1: {
																																												ctor: '_Tuple2',
																																												_0: {ctor: '_Tuple3', _0: 205, _1: 133, _2: 63},
																																												_1: {ctor: '_Tuple3', _0: 30, _1: 0.59, _2: 0.53}
																																											}
																																										},
																																										_1: {
																																											ctor: '::',
																																											_0: {
																																												ctor: '_Tuple2',
																																												_0: 'Pink',
																																												_1: {
																																													ctor: '_Tuple2',
																																													_0: {ctor: '_Tuple3', _0: 255, _1: 192, _2: 203},
																																													_1: {ctor: '_Tuple3', _0: 350, _1: 1, _2: 0.88}
																																												}
																																											},
																																											_1: {
																																												ctor: '::',
																																												_0: {
																																													ctor: '_Tuple2',
																																													_0: 'Plum',
																																													_1: {
																																														ctor: '_Tuple2',
																																														_0: {ctor: '_Tuple3', _0: 221, _1: 160, _2: 221},
																																														_1: {ctor: '_Tuple3', _0: 300, _1: 0.47, _2: 0.75}
																																													}
																																												},
																																												_1: {
																																													ctor: '::',
																																													_0: {
																																														ctor: '_Tuple2',
																																														_0: 'PowderBlue',
																																														_1: {
																																															ctor: '_Tuple2',
																																															_0: {ctor: '_Tuple3', _0: 176, _1: 224, _2: 230},
																																															_1: {ctor: '_Tuple3', _0: 187, _1: 0.52, _2: 0.8}
																																														}
																																													},
																																													_1: {
																																														ctor: '::',
																																														_0: {
																																															ctor: '_Tuple2',
																																															_0: 'Purple',
																																															_1: {
																																																ctor: '_Tuple2',
																																																_0: {ctor: '_Tuple3', _0: 128, _1: 0, _2: 128},
																																																_1: {ctor: '_Tuple3', _0: 300, _1: 1, _2: 0.25}
																																															}
																																														},
																																														_1: {
																																															ctor: '::',
																																															_0: {
																																																ctor: '_Tuple2',
																																																_0: 'RebeccaPurple',
																																																_1: {
																																																	ctor: '_Tuple2',
																																																	_0: {ctor: '_Tuple3', _0: 102, _1: 51, _2: 153},
																																																	_1: {ctor: '_Tuple3', _0: 270, _1: 0.5, _2: 0.4}
																																																}
																																															},
																																															_1: {
																																																ctor: '::',
																																																_0: {
																																																	ctor: '_Tuple2',
																																																	_0: 'Red',
																																																	_1: {
																																																		ctor: '_Tuple2',
																																																		_0: {ctor: '_Tuple3', _0: 255, _1: 0, _2: 0},
																																																		_1: {ctor: '_Tuple3', _0: 0, _1: 1, _2: 0.5}
																																																	}
																																																},
																																																_1: {
																																																	ctor: '::',
																																																	_0: {
																																																		ctor: '_Tuple2',
																																																		_0: 'RosyBrown',
																																																		_1: {
																																																			ctor: '_Tuple2',
																																																			_0: {ctor: '_Tuple3', _0: 188, _1: 143, _2: 143},
																																																			_1: {ctor: '_Tuple3', _0: 0, _1: 0.25, _2: 0.65}
																																																		}
																																																	},
																																																	_1: {
																																																		ctor: '::',
																																																		_0: {
																																																			ctor: '_Tuple2',
																																																			_0: 'RoyalBlue',
																																																			_1: {
																																																				ctor: '_Tuple2',
																																																				_0: {ctor: '_Tuple3', _0: 65, _1: 105, _2: 225},
																																																				_1: {ctor: '_Tuple3', _0: 225, _1: 0.73, _2: 0.57}
																																																			}
																																																		},
																																																		_1: {
																																																			ctor: '::',
																																																			_0: {
																																																				ctor: '_Tuple2',
																																																				_0: 'SaddleBrown',
																																																				_1: {
																																																					ctor: '_Tuple2',
																																																					_0: {ctor: '_Tuple3', _0: 139, _1: 69, _2: 19},
																																																					_1: {ctor: '_Tuple3', _0: 25, _1: 0.76, _2: 0.31}
																																																				}
																																																			},
																																																			_1: {
																																																				ctor: '::',
																																																				_0: {
																																																					ctor: '_Tuple2',
																																																					_0: 'Salmon',
																																																					_1: {
																																																						ctor: '_Tuple2',
																																																						_0: {ctor: '_Tuple3', _0: 250, _1: 128, _2: 114},
																																																						_1: {ctor: '_Tuple3', _0: 6, _1: 0.93, _2: 0.71}
																																																					}
																																																				},
																																																				_1: {
																																																					ctor: '::',
																																																					_0: {
																																																						ctor: '_Tuple2',
																																																						_0: 'SandyBrown',
																																																						_1: {
																																																							ctor: '_Tuple2',
																																																							_0: {ctor: '_Tuple3', _0: 244, _1: 164, _2: 96},
																																																							_1: {ctor: '_Tuple3', _0: 28, _1: 0.87, _2: 0.67}
																																																						}
																																																					},
																																																					_1: {
																																																						ctor: '::',
																																																						_0: {
																																																							ctor: '_Tuple2',
																																																							_0: 'SeaGreen',
																																																							_1: {
																																																								ctor: '_Tuple2',
																																																								_0: {ctor: '_Tuple3', _0: 46, _1: 139, _2: 87},
																																																								_1: {ctor: '_Tuple3', _0: 146, _1: 0.5, _2: 0.36}
																																																							}
																																																						},
																																																						_1: {
																																																							ctor: '::',
																																																							_0: {
																																																								ctor: '_Tuple2',
																																																								_0: 'SeaShell',
																																																								_1: {
																																																									ctor: '_Tuple2',
																																																									_0: {ctor: '_Tuple3', _0: 255, _1: 245, _2: 238},
																																																									_1: {ctor: '_Tuple3', _0: 25, _1: 1, _2: 0.97}
																																																								}
																																																							},
																																																							_1: {
																																																								ctor: '::',
																																																								_0: {
																																																									ctor: '_Tuple2',
																																																									_0: 'Sienna',
																																																									_1: {
																																																										ctor: '_Tuple2',
																																																										_0: {ctor: '_Tuple3', _0: 160, _1: 82, _2: 45},
																																																										_1: {ctor: '_Tuple3', _0: 19, _1: 0.56, _2: 0.4}
																																																									}
																																																								},
																																																								_1: {
																																																									ctor: '::',
																																																									_0: {
																																																										ctor: '_Tuple2',
																																																										_0: 'Silver',
																																																										_1: {
																																																											ctor: '_Tuple2',
																																																											_0: {ctor: '_Tuple3', _0: 192, _1: 192, _2: 192},
																																																											_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.75}
																																																										}
																																																									},
																																																									_1: {
																																																										ctor: '::',
																																																										_0: {
																																																											ctor: '_Tuple2',
																																																											_0: 'SkyBlue',
																																																											_1: {
																																																												ctor: '_Tuple2',
																																																												_0: {ctor: '_Tuple3', _0: 135, _1: 206, _2: 235},
																																																												_1: {ctor: '_Tuple3', _0: 197, _1: 0.71, _2: 0.73}
																																																											}
																																																										},
																																																										_1: {
																																																											ctor: '::',
																																																											_0: {
																																																												ctor: '_Tuple2',
																																																												_0: 'SlateBlue',
																																																												_1: {
																																																													ctor: '_Tuple2',
																																																													_0: {ctor: '_Tuple3', _0: 106, _1: 90, _2: 205},
																																																													_1: {ctor: '_Tuple3', _0: 248, _1: 0.53, _2: 0.58}
																																																												}
																																																											},
																																																											_1: {
																																																												ctor: '::',
																																																												_0: {
																																																													ctor: '_Tuple2',
																																																													_0: 'SlateGray',
																																																													_1: {
																																																														ctor: '_Tuple2',
																																																														_0: {ctor: '_Tuple3', _0: 112, _1: 128, _2: 144},
																																																														_1: {ctor: '_Tuple3', _0: 210, _1: 0.13, _2: 0.5}
																																																													}
																																																												},
																																																												_1: {
																																																													ctor: '::',
																																																													_0: {
																																																														ctor: '_Tuple2',
																																																														_0: 'SlateGrey',
																																																														_1: {
																																																															ctor: '_Tuple2',
																																																															_0: {ctor: '_Tuple3', _0: 112, _1: 128, _2: 144},
																																																															_1: {ctor: '_Tuple3', _0: 210, _1: 0.13, _2: 0.5}
																																																														}
																																																													},
																																																													_1: {
																																																														ctor: '::',
																																																														_0: {
																																																															ctor: '_Tuple2',
																																																															_0: 'Snow',
																																																															_1: {
																																																																ctor: '_Tuple2',
																																																																_0: {ctor: '_Tuple3', _0: 255, _1: 250, _2: 250},
																																																																_1: {ctor: '_Tuple3', _0: 0, _1: 1, _2: 0.99}
																																																															}
																																																														},
																																																														_1: {
																																																															ctor: '::',
																																																															_0: {
																																																																ctor: '_Tuple2',
																																																																_0: 'SpringGreen',
																																																																_1: {
																																																																	ctor: '_Tuple2',
																																																																	_0: {ctor: '_Tuple3', _0: 0, _1: 255, _2: 127},
																																																																	_1: {ctor: '_Tuple3', _0: 150, _1: 1, _2: 0.5}
																																																																}
																																																															},
																																																															_1: {
																																																																ctor: '::',
																																																																_0: {
																																																																	ctor: '_Tuple2',
																																																																	_0: 'SteelBlue',
																																																																	_1: {
																																																																		ctor: '_Tuple2',
																																																																		_0: {ctor: '_Tuple3', _0: 70, _1: 130, _2: 180},
																																																																		_1: {ctor: '_Tuple3', _0: 207, _1: 0.44, _2: 0.49}
																																																																	}
																																																																},
																																																																_1: {
																																																																	ctor: '::',
																																																																	_0: {
																																																																		ctor: '_Tuple2',
																																																																		_0: 'Tan',
																																																																		_1: {
																																																																			ctor: '_Tuple2',
																																																																			_0: {ctor: '_Tuple3', _0: 210, _1: 180, _2: 140},
																																																																			_1: {ctor: '_Tuple3', _0: 34, _1: 0.44, _2: 0.69}
																																																																		}
																																																																	},
																																																																	_1: {
																																																																		ctor: '::',
																																																																		_0: {
																																																																			ctor: '_Tuple2',
																																																																			_0: 'Teal',
																																																																			_1: {
																																																																				ctor: '_Tuple2',
																																																																				_0: {ctor: '_Tuple3', _0: 0, _1: 128, _2: 128},
																																																																				_1: {ctor: '_Tuple3', _0: 180, _1: 1, _2: 0.25}
																																																																			}
																																																																		},
																																																																		_1: {
																																																																			ctor: '::',
																																																																			_0: {
																																																																				ctor: '_Tuple2',
																																																																				_0: 'Thistle',
																																																																				_1: {
																																																																					ctor: '_Tuple2',
																																																																					_0: {ctor: '_Tuple3', _0: 216, _1: 191, _2: 216},
																																																																					_1: {ctor: '_Tuple3', _0: 300, _1: 0.24, _2: 0.8}
																																																																				}
																																																																			},
																																																																			_1: {
																																																																				ctor: '::',
																																																																				_0: {
																																																																					ctor: '_Tuple2',
																																																																					_0: 'Tomato',
																																																																					_1: {
																																																																						ctor: '_Tuple2',
																																																																						_0: {ctor: '_Tuple3', _0: 255, _1: 99, _2: 71},
																																																																						_1: {ctor: '_Tuple3', _0: 9, _1: 1, _2: 0.64}
																																																																					}
																																																																				},
																																																																				_1: {
																																																																					ctor: '::',
																																																																					_0: {
																																																																						ctor: '_Tuple2',
																																																																						_0: 'Turquoise',
																																																																						_1: {
																																																																							ctor: '_Tuple2',
																																																																							_0: {ctor: '_Tuple3', _0: 64, _1: 224, _2: 208},
																																																																							_1: {ctor: '_Tuple3', _0: 174, _1: 0.72, _2: 0.56}
																																																																						}
																																																																					},
																																																																					_1: {
																																																																						ctor: '::',
																																																																						_0: {
																																																																							ctor: '_Tuple2',
																																																																							_0: 'Violet',
																																																																							_1: {
																																																																								ctor: '_Tuple2',
																																																																								_0: {ctor: '_Tuple3', _0: 238, _1: 130, _2: 238},
																																																																								_1: {ctor: '_Tuple3', _0: 300, _1: 0.76, _2: 0.72}
																																																																							}
																																																																						},
																																																																						_1: {
																																																																							ctor: '::',
																																																																							_0: {
																																																																								ctor: '_Tuple2',
																																																																								_0: 'Wheat',
																																																																								_1: {
																																																																									ctor: '_Tuple2',
																																																																									_0: {ctor: '_Tuple3', _0: 245, _1: 222, _2: 179},
																																																																									_1: {ctor: '_Tuple3', _0: 39, _1: 0.77, _2: 0.83}
																																																																								}
																																																																							},
																																																																							_1: {
																																																																								ctor: '::',
																																																																								_0: {
																																																																									ctor: '_Tuple2',
																																																																									_0: 'White',
																																																																									_1: {
																																																																										ctor: '_Tuple2',
																																																																										_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																										_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 1}
																																																																									}
																																																																								},
																																																																								_1: {
																																																																									ctor: '::',
																																																																									_0: {
																																																																										ctor: '_Tuple2',
																																																																										_0: 'WhiteSmoke',
																																																																										_1: {
																																																																											ctor: '_Tuple2',
																																																																											_0: {ctor: '_Tuple3', _0: 245, _1: 245, _2: 245},
																																																																											_1: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0.96}
																																																																										}
																																																																									},
																																																																									_1: {
																																																																										ctor: '::',
																																																																										_0: {
																																																																											ctor: '_Tuple2',
																																																																											_0: 'Yellow',
																																																																											_1: {
																																																																												ctor: '_Tuple2',
																																																																												_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 0},
																																																																												_1: {ctor: '_Tuple3', _0: 60, _1: 1, _2: 0.5}
																																																																											}
																																																																										},
																																																																										_1: {
																																																																											ctor: '::',
																																																																											_0: {
																																																																												ctor: '_Tuple2',
																																																																												_0: 'YellowGreen',
																																																																												_1: {
																																																																													ctor: '_Tuple2',
																																																																													_0: {ctor: '_Tuple3', _0: 154, _1: 205, _2: 50},
																																																																													_1: {ctor: '_Tuple3', _0: 80, _1: 0.61, _2: 0.5}
																																																																												}
																																																																											},
																																																																											_1: {ctor: '[]'}
																																																																										}
																																																																									}
																																																																								}
																																																																							}
																																																																						}
																																																																					}
																																																																				}
																																																																			}
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}));
var _user$project$ColorNum$numHtmlColorNames = _elm_lang$core$List$length(_user$project$ColorNum$htmlColorNames);
var _user$project$ColorNum$randomHtmlColorName = function (randomInt) {
	var i = _elm_lang$core$Basics$round(
		(_elm_lang$core$Basics$toFloat(randomInt) / 470) * _elm_lang$core$Basics$toFloat(_user$project$ColorNum$numHtmlColorNames));
	var _p0 = A2(_user$project$Utils$maybeGeti0, i, _user$project$ColorNum$htmlColorNames);
	if (_p0.ctor === 'Just') {
		return _p0._0._0;
	} else {
		return 'gray';
	}
};
var _user$project$ColorNum$convertStringToRgbAndHue = function (_p1) {
	var _p2 = _p1;
	var colorName = _elm_lang$core$String$toLower(_p2._1);
	var values = A2(_user$project$Utils$maybeFind, colorName, _user$project$ColorNum$htmlColorNames);
	return A2(
		_elm_lang$core$Maybe$map,
		function (_p3) {
			var _p4 = _p3;
			var colorNum = _elm_lang$core$Native_Utils.eq(colorName, 'black') ? 360 : (_elm_lang$core$Native_Utils.eq(colorName, 'white') ? 499 : ((A2(_elm_lang$core$String$contains, 'gray', colorName) || A2(_elm_lang$core$String$contains, 'grey', colorName)) ? 450 : _p4._1._0));
			return {
				ctor: '_Tuple3',
				_0: _p2._0,
				_1: {ctor: '_Tuple3', _0: _p4._0._0, _1: _p4._0._1, _2: _p4._0._2},
				_2: colorNum
			};
		},
		values);
};
var _user$project$ColorNum$codes = A2(
	_elm_lang$core$Basics_ops['++'],
	{
		ctor: '::',
		_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 55},
		_1: {
			ctor: '::',
			_0: {ctor: '_Tuple3', _0: 200, _1: 57, _2: 55},
			_1: {
				ctor: '::',
				_0: {ctor: '_Tuple3', _0: 200, _1: 60, _2: 55},
				_1: {
					ctor: '::',
					_0: {ctor: '_Tuple3', _0: 200, _1: 62, _2: 55},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple3', _0: 200, _1: 65, _2: 55},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple3', _0: 200, _1: 67, _2: 55},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple3', _0: 200, _1: 70, _2: 55},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple3', _0: 200, _1: 72, _2: 55},
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple3', _0: 200, _1: 74, _2: 55},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple3', _0: 200, _1: 77, _2: 55},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple3', _0: 200, _1: 79, _2: 55},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple3', _0: 200, _1: 82, _2: 55},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple3', _0: 200, _1: 84, _2: 55},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple3', _0: 200, _1: 86, _2: 55},
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple3', _0: 200, _1: 89, _2: 55},
																_1: {
																	ctor: '::',
																	_0: {ctor: '_Tuple3', _0: 200, _1: 91, _2: 55},
																	_1: {
																		ctor: '::',
																		_0: {ctor: '_Tuple3', _0: 200, _1: 94, _2: 55},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple3', _0: 200, _1: 96, _2: 55},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple3', _0: 200, _1: 99, _2: 55},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple3', _0: 200, _1: 101, _2: 55},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple3', _0: 200, _1: 103, _2: 55},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple3', _0: 200, _1: 106, _2: 55},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple3', _0: 200, _1: 108, _2: 55},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple3', _0: 200, _1: 111, _2: 55},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple3', _0: 200, _1: 113, _2: 55},
																										_1: {
																											ctor: '::',
																											_0: {ctor: '_Tuple3', _0: 200, _1: 115, _2: 55},
																											_1: {
																												ctor: '::',
																												_0: {ctor: '_Tuple3', _0: 200, _1: 118, _2: 55},
																												_1: {
																													ctor: '::',
																													_0: {ctor: '_Tuple3', _0: 200, _1: 120, _2: 55},
																													_1: {
																														ctor: '::',
																														_0: {ctor: '_Tuple3', _0: 200, _1: 123, _2: 55},
																														_1: {
																															ctor: '::',
																															_0: {ctor: '_Tuple3', _0: 200, _1: 125, _2: 55},
																															_1: {
																																ctor: '::',
																																_0: {ctor: '_Tuple3', _0: 200, _1: 128, _2: 55},
																																_1: {
																																	ctor: '::',
																																	_0: {ctor: '_Tuple3', _0: 200, _1: 130, _2: 55},
																																	_1: {
																																		ctor: '::',
																																		_0: {ctor: '_Tuple3', _0: 200, _1: 132, _2: 55},
																																		_1: {
																																			ctor: '::',
																																			_0: {ctor: '_Tuple3', _0: 200, _1: 135, _2: 55},
																																			_1: {
																																				ctor: '::',
																																				_0: {ctor: '_Tuple3', _0: 200, _1: 137, _2: 55},
																																				_1: {
																																					ctor: '::',
																																					_0: {ctor: '_Tuple3', _0: 200, _1: 140, _2: 55},
																																					_1: {
																																						ctor: '::',
																																						_0: {ctor: '_Tuple3', _0: 200, _1: 142, _2: 55},
																																						_1: {
																																							ctor: '::',
																																							_0: {ctor: '_Tuple3', _0: 200, _1: 144, _2: 55},
																																							_1: {
																																								ctor: '::',
																																								_0: {ctor: '_Tuple3', _0: 200, _1: 147, _2: 55},
																																								_1: {
																																									ctor: '::',
																																									_0: {ctor: '_Tuple3', _0: 200, _1: 149, _2: 55},
																																									_1: {
																																										ctor: '::',
																																										_0: {ctor: '_Tuple3', _0: 200, _1: 152, _2: 55},
																																										_1: {
																																											ctor: '::',
																																											_0: {ctor: '_Tuple3', _0: 200, _1: 154, _2: 55},
																																											_1: {
																																												ctor: '::',
																																												_0: {ctor: '_Tuple3', _0: 200, _1: 157, _2: 55},
																																												_1: {
																																													ctor: '::',
																																													_0: {ctor: '_Tuple3', _0: 200, _1: 159, _2: 55},
																																													_1: {
																																														ctor: '::',
																																														_0: {ctor: '_Tuple3', _0: 200, _1: 161, _2: 55},
																																														_1: {
																																															ctor: '::',
																																															_0: {ctor: '_Tuple3', _0: 200, _1: 164, _2: 55},
																																															_1: {
																																																ctor: '::',
																																																_0: {ctor: '_Tuple3', _0: 200, _1: 166, _2: 55},
																																																_1: {
																																																	ctor: '::',
																																																	_0: {ctor: '_Tuple3', _0: 200, _1: 169, _2: 55},
																																																	_1: {
																																																		ctor: '::',
																																																		_0: {ctor: '_Tuple3', _0: 200, _1: 171, _2: 55},
																																																		_1: {
																																																			ctor: '::',
																																																			_0: {ctor: '_Tuple3', _0: 200, _1: 173, _2: 55},
																																																			_1: {
																																																				ctor: '::',
																																																				_0: {ctor: '_Tuple3', _0: 200, _1: 176, _2: 55},
																																																				_1: {
																																																					ctor: '::',
																																																					_0: {ctor: '_Tuple3', _0: 200, _1: 178, _2: 55},
																																																					_1: {
																																																						ctor: '::',
																																																						_0: {ctor: '_Tuple3', _0: 200, _1: 181, _2: 55},
																																																						_1: {
																																																							ctor: '::',
																																																							_0: {ctor: '_Tuple3', _0: 200, _1: 183, _2: 55},
																																																							_1: {
																																																								ctor: '::',
																																																								_0: {ctor: '_Tuple3', _0: 200, _1: 186, _2: 55},
																																																								_1: {
																																																									ctor: '::',
																																																									_0: {ctor: '_Tuple3', _0: 200, _1: 188, _2: 55},
																																																									_1: {
																																																										ctor: '::',
																																																										_0: {ctor: '_Tuple3', _0: 200, _1: 190, _2: 55},
																																																										_1: {
																																																											ctor: '::',
																																																											_0: {ctor: '_Tuple3', _0: 200, _1: 193, _2: 55},
																																																											_1: {
																																																												ctor: '::',
																																																												_0: {ctor: '_Tuple3', _0: 200, _1: 195, _2: 55},
																																																												_1: {
																																																													ctor: '::',
																																																													_0: {ctor: '_Tuple3', _0: 200, _1: 198, _2: 55},
																																																													_1: {
																																																														ctor: '::',
																																																														_0: {ctor: '_Tuple3', _0: 200, _1: 200, _2: 55},
																																																														_1: {
																																																															ctor: '::',
																																																															_0: {ctor: '_Tuple3', _0: 198, _1: 200, _2: 55},
																																																															_1: {
																																																																ctor: '::',
																																																																_0: {ctor: '_Tuple3', _0: 195, _1: 200, _2: 55},
																																																																_1: {
																																																																	ctor: '::',
																																																																	_0: {ctor: '_Tuple3', _0: 193, _1: 200, _2: 55},
																																																																	_1: {
																																																																		ctor: '::',
																																																																		_0: {ctor: '_Tuple3', _0: 190, _1: 200, _2: 55},
																																																																		_1: {
																																																																			ctor: '::',
																																																																			_0: {ctor: '_Tuple3', _0: 188, _1: 200, _2: 55},
																																																																			_1: {
																																																																				ctor: '::',
																																																																				_0: {ctor: '_Tuple3', _0: 186, _1: 200, _2: 55},
																																																																				_1: {
																																																																					ctor: '::',
																																																																					_0: {ctor: '_Tuple3', _0: 183, _1: 200, _2: 55},
																																																																					_1: {
																																																																						ctor: '::',
																																																																						_0: {ctor: '_Tuple3', _0: 181, _1: 200, _2: 55},
																																																																						_1: {
																																																																							ctor: '::',
																																																																							_0: {ctor: '_Tuple3', _0: 178, _1: 200, _2: 55},
																																																																							_1: {
																																																																								ctor: '::',
																																																																								_0: {ctor: '_Tuple3', _0: 176, _1: 200, _2: 55},
																																																																								_1: {
																																																																									ctor: '::',
																																																																									_0: {ctor: '_Tuple3', _0: 173, _1: 200, _2: 55},
																																																																									_1: {
																																																																										ctor: '::',
																																																																										_0: {ctor: '_Tuple3', _0: 171, _1: 200, _2: 55},
																																																																										_1: {
																																																																											ctor: '::',
																																																																											_0: {ctor: '_Tuple3', _0: 169, _1: 200, _2: 55},
																																																																											_1: {
																																																																												ctor: '::',
																																																																												_0: {ctor: '_Tuple3', _0: 166, _1: 200, _2: 55},
																																																																												_1: {
																																																																													ctor: '::',
																																																																													_0: {ctor: '_Tuple3', _0: 164, _1: 200, _2: 55},
																																																																													_1: {
																																																																														ctor: '::',
																																																																														_0: {ctor: '_Tuple3', _0: 161, _1: 200, _2: 55},
																																																																														_1: {
																																																																															ctor: '::',
																																																																															_0: {ctor: '_Tuple3', _0: 159, _1: 200, _2: 55},
																																																																															_1: {
																																																																																ctor: '::',
																																																																																_0: {ctor: '_Tuple3', _0: 157, _1: 200, _2: 55},
																																																																																_1: {
																																																																																	ctor: '::',
																																																																																	_0: {ctor: '_Tuple3', _0: 154, _1: 200, _2: 55},
																																																																																	_1: {
																																																																																		ctor: '::',
																																																																																		_0: {ctor: '_Tuple3', _0: 152, _1: 200, _2: 55},
																																																																																		_1: {
																																																																																			ctor: '::',
																																																																																			_0: {ctor: '_Tuple3', _0: 149, _1: 200, _2: 55},
																																																																																			_1: {
																																																																																				ctor: '::',
																																																																																				_0: {ctor: '_Tuple3', _0: 147, _1: 200, _2: 55},
																																																																																				_1: {
																																																																																					ctor: '::',
																																																																																					_0: {ctor: '_Tuple3', _0: 144, _1: 200, _2: 55},
																																																																																					_1: {
																																																																																						ctor: '::',
																																																																																						_0: {ctor: '_Tuple3', _0: 142, _1: 200, _2: 55},
																																																																																						_1: {
																																																																																							ctor: '::',
																																																																																							_0: {ctor: '_Tuple3', _0: 140, _1: 200, _2: 55},
																																																																																							_1: {
																																																																																								ctor: '::',
																																																																																								_0: {ctor: '_Tuple3', _0: 137, _1: 200, _2: 55},
																																																																																								_1: {
																																																																																									ctor: '::',
																																																																																									_0: {ctor: '_Tuple3', _0: 135, _1: 200, _2: 55},
																																																																																									_1: {
																																																																																										ctor: '::',
																																																																																										_0: {ctor: '_Tuple3', _0: 132, _1: 200, _2: 55},
																																																																																										_1: {
																																																																																											ctor: '::',
																																																																																											_0: {ctor: '_Tuple3', _0: 130, _1: 200, _2: 55},
																																																																																											_1: {
																																																																																												ctor: '::',
																																																																																												_0: {ctor: '_Tuple3', _0: 128, _1: 200, _2: 55},
																																																																																												_1: {
																																																																																													ctor: '::',
																																																																																													_0: {ctor: '_Tuple3', _0: 125, _1: 200, _2: 55},
																																																																																													_1: {
																																																																																														ctor: '::',
																																																																																														_0: {ctor: '_Tuple3', _0: 123, _1: 200, _2: 55},
																																																																																														_1: {
																																																																																															ctor: '::',
																																																																																															_0: {ctor: '_Tuple3', _0: 120, _1: 200, _2: 55},
																																																																																															_1: {
																																																																																																ctor: '::',
																																																																																																_0: {ctor: '_Tuple3', _0: 118, _1: 200, _2: 55},
																																																																																																_1: {
																																																																																																	ctor: '::',
																																																																																																	_0: {ctor: '_Tuple3', _0: 115, _1: 200, _2: 55},
																																																																																																	_1: {
																																																																																																		ctor: '::',
																																																																																																		_0: {ctor: '_Tuple3', _0: 113, _1: 200, _2: 55},
																																																																																																		_1: {
																																																																																																			ctor: '::',
																																																																																																			_0: {ctor: '_Tuple3', _0: 111, _1: 200, _2: 55},
																																																																																																			_1: {
																																																																																																				ctor: '::',
																																																																																																				_0: {ctor: '_Tuple3', _0: 108, _1: 200, _2: 55},
																																																																																																				_1: {
																																																																																																					ctor: '::',
																																																																																																					_0: {ctor: '_Tuple3', _0: 106, _1: 200, _2: 55},
																																																																																																					_1: {
																																																																																																						ctor: '::',
																																																																																																						_0: {ctor: '_Tuple3', _0: 103, _1: 200, _2: 55},
																																																																																																						_1: {
																																																																																																							ctor: '::',
																																																																																																							_0: {ctor: '_Tuple3', _0: 101, _1: 200, _2: 55},
																																																																																																							_1: {
																																																																																																								ctor: '::',
																																																																																																								_0: {ctor: '_Tuple3', _0: 99, _1: 200, _2: 55},
																																																																																																								_1: {
																																																																																																									ctor: '::',
																																																																																																									_0: {ctor: '_Tuple3', _0: 96, _1: 200, _2: 55},
																																																																																																									_1: {
																																																																																																										ctor: '::',
																																																																																																										_0: {ctor: '_Tuple3', _0: 94, _1: 200, _2: 55},
																																																																																																										_1: {
																																																																																																											ctor: '::',
																																																																																																											_0: {ctor: '_Tuple3', _0: 91, _1: 200, _2: 55},
																																																																																																											_1: {
																																																																																																												ctor: '::',
																																																																																																												_0: {ctor: '_Tuple3', _0: 89, _1: 200, _2: 55},
																																																																																																												_1: {
																																																																																																													ctor: '::',
																																																																																																													_0: {ctor: '_Tuple3', _0: 86, _1: 200, _2: 55},
																																																																																																													_1: {
																																																																																																														ctor: '::',
																																																																																																														_0: {ctor: '_Tuple3', _0: 84, _1: 200, _2: 55},
																																																																																																														_1: {
																																																																																																															ctor: '::',
																																																																																																															_0: {ctor: '_Tuple3', _0: 82, _1: 200, _2: 55},
																																																																																																															_1: {
																																																																																																																ctor: '::',
																																																																																																																_0: {ctor: '_Tuple3', _0: 79, _1: 200, _2: 55},
																																																																																																																_1: {
																																																																																																																	ctor: '::',
																																																																																																																	_0: {ctor: '_Tuple3', _0: 77, _1: 200, _2: 55},
																																																																																																																	_1: {
																																																																																																																		ctor: '::',
																																																																																																																		_0: {ctor: '_Tuple3', _0: 74, _1: 200, _2: 55},
																																																																																																																		_1: {
																																																																																																																			ctor: '::',
																																																																																																																			_0: {ctor: '_Tuple3', _0: 72, _1: 200, _2: 55},
																																																																																																																			_1: {
																																																																																																																				ctor: '::',
																																																																																																																				_0: {ctor: '_Tuple3', _0: 70, _1: 200, _2: 55},
																																																																																																																				_1: {
																																																																																																																					ctor: '::',
																																																																																																																					_0: {ctor: '_Tuple3', _0: 67, _1: 200, _2: 55},
																																																																																																																					_1: {
																																																																																																																						ctor: '::',
																																																																																																																						_0: {ctor: '_Tuple3', _0: 65, _1: 200, _2: 55},
																																																																																																																						_1: {
																																																																																																																							ctor: '::',
																																																																																																																							_0: {ctor: '_Tuple3', _0: 62, _1: 200, _2: 55},
																																																																																																																							_1: {
																																																																																																																								ctor: '::',
																																																																																																																								_0: {ctor: '_Tuple3', _0: 60, _1: 200, _2: 55},
																																																																																																																								_1: {
																																																																																																																									ctor: '::',
																																																																																																																									_0: {ctor: '_Tuple3', _0: 57, _1: 200, _2: 55},
																																																																																																																									_1: {
																																																																																																																										ctor: '::',
																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 55},
																																																																																																																										_1: {
																																																																																																																											ctor: '::',
																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 57},
																																																																																																																											_1: {
																																																																																																																												ctor: '::',
																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 60},
																																																																																																																												_1: {
																																																																																																																													ctor: '::',
																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 62},
																																																																																																																													_1: {
																																																																																																																														ctor: '::',
																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 65},
																																																																																																																														_1: {
																																																																																																																															ctor: '::',
																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 67},
																																																																																																																															_1: {
																																																																																																																																ctor: '::',
																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 70},
																																																																																																																																_1: {
																																																																																																																																	ctor: '::',
																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 72},
																																																																																																																																	_1: {
																																																																																																																																		ctor: '::',
																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 74},
																																																																																																																																		_1: {
																																																																																																																																			ctor: '::',
																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 77},
																																																																																																																																			_1: {
																																																																																																																																				ctor: '::',
																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 79},
																																																																																																																																				_1: {
																																																																																																																																					ctor: '::',
																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 82},
																																																																																																																																					_1: {
																																																																																																																																						ctor: '::',
																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 84},
																																																																																																																																						_1: {
																																																																																																																																							ctor: '::',
																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 86},
																																																																																																																																							_1: {
																																																																																																																																								ctor: '::',
																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 89},
																																																																																																																																								_1: {
																																																																																																																																									ctor: '::',
																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 91},
																																																																																																																																									_1: {
																																																																																																																																										ctor: '::',
																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 94},
																																																																																																																																										_1: {
																																																																																																																																											ctor: '::',
																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 96},
																																																																																																																																											_1: {
																																																																																																																																												ctor: '::',
																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 99},
																																																																																																																																												_1: {
																																																																																																																																													ctor: '::',
																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 101},
																																																																																																																																													_1: {
																																																																																																																																														ctor: '::',
																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 103},
																																																																																																																																														_1: {
																																																																																																																																															ctor: '::',
																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 106},
																																																																																																																																															_1: {
																																																																																																																																																ctor: '::',
																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 108},
																																																																																																																																																_1: {
																																																																																																																																																	ctor: '::',
																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 111},
																																																																																																																																																	_1: {
																																																																																																																																																		ctor: '::',
																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 113},
																																																																																																																																																		_1: {
																																																																																																																																																			ctor: '::',
																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 115},
																																																																																																																																																			_1: {
																																																																																																																																																				ctor: '::',
																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 118},
																																																																																																																																																				_1: {
																																																																																																																																																					ctor: '::',
																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 120},
																																																																																																																																																					_1: {
																																																																																																																																																						ctor: '::',
																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 123},
																																																																																																																																																						_1: {
																																																																																																																																																							ctor: '::',
																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 125},
																																																																																																																																																							_1: {
																																																																																																																																																								ctor: '::',
																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 128},
																																																																																																																																																								_1: {
																																																																																																																																																									ctor: '::',
																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 130},
																																																																																																																																																									_1: {
																																																																																																																																																										ctor: '::',
																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 132},
																																																																																																																																																										_1: {
																																																																																																																																																											ctor: '::',
																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 135},
																																																																																																																																																											_1: {
																																																																																																																																																												ctor: '::',
																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 137},
																																																																																																																																																												_1: {
																																																																																																																																																													ctor: '::',
																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 140},
																																																																																																																																																													_1: {
																																																																																																																																																														ctor: '::',
																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 142},
																																																																																																																																																														_1: {
																																																																																																																																																															ctor: '::',
																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 144},
																																																																																																																																																															_1: {
																																																																																																																																																																ctor: '::',
																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 147},
																																																																																																																																																																_1: {
																																																																																																																																																																	ctor: '::',
																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 149},
																																																																																																																																																																	_1: {
																																																																																																																																																																		ctor: '::',
																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 152},
																																																																																																																																																																		_1: {
																																																																																																																																																																			ctor: '::',
																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 154},
																																																																																																																																																																			_1: {
																																																																																																																																																																				ctor: '::',
																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 157},
																																																																																																																																																																				_1: {
																																																																																																																																																																					ctor: '::',
																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 159},
																																																																																																																																																																					_1: {
																																																																																																																																																																						ctor: '::',
																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 161},
																																																																																																																																																																						_1: {
																																																																																																																																																																							ctor: '::',
																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 164},
																																																																																																																																																																							_1: {
																																																																																																																																																																								ctor: '::',
																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 166},
																																																																																																																																																																								_1: {
																																																																																																																																																																									ctor: '::',
																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 169},
																																																																																																																																																																									_1: {
																																																																																																																																																																										ctor: '::',
																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 171},
																																																																																																																																																																										_1: {
																																																																																																																																																																											ctor: '::',
																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 173},
																																																																																																																																																																											_1: {
																																																																																																																																																																												ctor: '::',
																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 176},
																																																																																																																																																																												_1: {
																																																																																																																																																																													ctor: '::',
																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 178},
																																																																																																																																																																													_1: {
																																																																																																																																																																														ctor: '::',
																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 181},
																																																																																																																																																																														_1: {
																																																																																																																																																																															ctor: '::',
																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 183},
																																																																																																																																																																															_1: {
																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 186},
																																																																																																																																																																																_1: {
																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 188},
																																																																																																																																																																																	_1: {
																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 190},
																																																																																																																																																																																		_1: {
																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 193},
																																																																																																																																																																																			_1: {
																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 195},
																																																																																																																																																																																				_1: {
																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 198},
																																																																																																																																																																																					_1: {
																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 200, _2: 200},
																																																																																																																																																																																						_1: {
																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 198, _2: 200},
																																																																																																																																																																																							_1: {
																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 195, _2: 200},
																																																																																																																																																																																								_1: {
																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 193, _2: 200},
																																																																																																																																																																																									_1: {
																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 190, _2: 200},
																																																																																																																																																																																										_1: {
																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 188, _2: 200},
																																																																																																																																																																																											_1: {
																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 186, _2: 200},
																																																																																																																																																																																												_1: {
																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 183, _2: 200},
																																																																																																																																																																																													_1: {
																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 181, _2: 200},
																																																																																																																																																																																														_1: {
																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 178, _2: 200},
																																																																																																																																																																																															_1: {
																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 176, _2: 200},
																																																																																																																																																																																																_1: {
																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 173, _2: 200},
																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 171, _2: 200},
																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 169, _2: 200},
																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 166, _2: 200},
																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 164, _2: 200},
																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 161, _2: 200},
																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 159, _2: 200},
																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 157, _2: 200},
																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 154, _2: 200},
																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 152, _2: 200},
																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 149, _2: 200},
																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 147, _2: 200},
																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 144, _2: 200},
																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 142, _2: 200},
																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 140, _2: 200},
																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 137, _2: 200},
																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 135, _2: 200},
																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 132, _2: 200},
																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 130, _2: 200},
																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 128, _2: 200},
																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 125, _2: 200},
																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 123, _2: 200},
																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 120, _2: 200},
																																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 118, _2: 200},
																																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 115, _2: 200},
																																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 113, _2: 200},
																																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 111, _2: 200},
																																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 108, _2: 200},
																																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 106, _2: 200},
																																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 103, _2: 200},
																																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 101, _2: 200},
																																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 99, _2: 200},
																																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 96, _2: 200},
																																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 94, _2: 200},
																																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 55, _1: 91, _2: 200},
																																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 55, _1: 89, _2: 200},
																																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 55, _1: 86, _2: 200},
																																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 55, _1: 84, _2: 200},
																																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 55, _1: 82, _2: 200},
																																																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 55, _1: 79, _2: 200},
																																																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 55, _1: 77, _2: 200},
																																																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 55, _1: 74, _2: 200},
																																																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 55, _1: 72, _2: 200},
																																																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 55, _1: 70, _2: 200},
																																																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 55, _1: 67, _2: 200},
																																																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 55, _1: 65, _2: 200},
																																																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 55, _1: 62, _2: 200},
																																																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 55, _1: 60, _2: 200},
																																																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 55, _1: 57, _2: 200},
																																																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 55, _1: 55, _2: 200},
																																																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 57, _1: 55, _2: 200},
																																																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 60, _1: 55, _2: 200},
																																																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 62, _1: 55, _2: 200},
																																																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 65, _1: 55, _2: 200},
																																																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 67, _1: 55, _2: 200},
																																																																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 70, _1: 55, _2: 200},
																																																																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 72, _1: 55, _2: 200},
																																																																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 74, _1: 55, _2: 200},
																																																																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 77, _1: 55, _2: 200},
																																																																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 79, _1: 55, _2: 200},
																																																																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 82, _1: 55, _2: 200},
																																																																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 84, _1: 55, _2: 200},
																																																																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 86, _1: 55, _2: 200},
																																																																																																																																																																																																																																																															_1: {ctor: '[]'}
																																																																																																																																																																																																																																																														}
																																																																																																																																																																																																																																																													}
																																																																																																																																																																																																																																																												}
																																																																																																																																																																																																																																																											}
																																																																																																																																																																																																																																																										}
																																																																																																																																																																																																																																																									}
																																																																																																																																																																																																																																																								}
																																																																																																																																																																																																																																																							}
																																																																																																																																																																																																																																																						}
																																																																																																																																																																																																																																																					}
																																																																																																																																																																																																																																																				}
																																																																																																																																																																																																																																																			}
																																																																																																																																																																																																																																																		}
																																																																																																																																																																																																																																																	}
																																																																																																																																																																																																																																																}
																																																																																																																																																																																																																																															}
																																																																																																																																																																																																																																														}
																																																																																																																																																																																																																																													}
																																																																																																																																																																																																																																												}
																																																																																																																																																																																																																																											}
																																																																																																																																																																																																																																										}
																																																																																																																																																																																																																																									}
																																																																																																																																																																																																																																								}
																																																																																																																																																																																																																																							}
																																																																																																																																																																																																																																						}
																																																																																																																																																																																																																																					}
																																																																																																																																																																																																																																				}
																																																																																																																																																																																																																																			}
																																																																																																																																																																																																																																		}
																																																																																																																																																																																																																																	}
																																																																																																																																																																																																																																}
																																																																																																																																																																																																																															}
																																																																																																																																																																																																																														}
																																																																																																																																																																																																																													}
																																																																																																																																																																																																																												}
																																																																																																																																																																																																																											}
																																																																																																																																																																																																																										}
																																																																																																																																																																																																																									}
																																																																																																																																																																																																																								}
																																																																																																																																																																																																																							}
																																																																																																																																																																																																																						}
																																																																																																																																																																																																																					}
																																																																																																																																																																																																																				}
																																																																																																																																																																																																																			}
																																																																																																																																																																																																																		}
																																																																																																																																																																																																																	}
																																																																																																																																																																																																																}
																																																																																																																																																																																																															}
																																																																																																																																																																																																														}
																																																																																																																																																																																																													}
																																																																																																																																																																																																												}
																																																																																																																																																																																																											}
																																																																																																																																																																																																										}
																																																																																																																																																																																																									}
																																																																																																																																																																																																								}
																																																																																																																																																																																																							}
																																																																																																																																																																																																						}
																																																																																																																																																																																																					}
																																																																																																																																																																																																				}
																																																																																																																																																																																																			}
																																																																																																																																																																																																		}
																																																																																																																																																																																																	}
																																																																																																																																																																																																}
																																																																																																																																																																																															}
																																																																																																																																																																																														}
																																																																																																																																																																																													}
																																																																																																																																																																																												}
																																																																																																																																																																																											}
																																																																																																																																																																																										}
																																																																																																																																																																																									}
																																																																																																																																																																																								}
																																																																																																																																																																																							}
																																																																																																																																																																																						}
																																																																																																																																																																																					}
																																																																																																																																																																																				}
																																																																																																																																																																																			}
																																																																																																																																																																																		}
																																																																																																																																																																																	}
																																																																																																																																																																																}
																																																																																																																																																																															}
																																																																																																																																																																														}
																																																																																																																																																																													}
																																																																																																																																																																												}
																																																																																																																																																																											}
																																																																																																																																																																										}
																																																																																																																																																																									}
																																																																																																																																																																								}
																																																																																																																																																																							}
																																																																																																																																																																						}
																																																																																																																																																																					}
																																																																																																																																																																				}
																																																																																																																																																																			}
																																																																																																																																																																		}
																																																																																																																																																																	}
																																																																																																																																																																}
																																																																																																																																																															}
																																																																																																																																																														}
																																																																																																																																																													}
																																																																																																																																																												}
																																																																																																																																																											}
																																																																																																																																																										}
																																																																																																																																																									}
																																																																																																																																																								}
																																																																																																																																																							}
																																																																																																																																																						}
																																																																																																																																																					}
																																																																																																																																																				}
																																																																																																																																																			}
																																																																																																																																																		}
																																																																																																																																																	}
																																																																																																																																																}
																																																																																																																																															}
																																																																																																																																														}
																																																																																																																																													}
																																																																																																																																												}
																																																																																																																																											}
																																																																																																																																										}
																																																																																																																																									}
																																																																																																																																								}
																																																																																																																																							}
																																																																																																																																						}
																																																																																																																																					}
																																																																																																																																				}
																																																																																																																																			}
																																																																																																																																		}
																																																																																																																																	}
																																																																																																																																}
																																																																																																																															}
																																																																																																																														}
																																																																																																																													}
																																																																																																																												}
																																																																																																																											}
																																																																																																																										}
																																																																																																																									}
																																																																																																																								}
																																																																																																																							}
																																																																																																																						}
																																																																																																																					}
																																																																																																																				}
																																																																																																																			}
																																																																																																																		}
																																																																																																																	}
																																																																																																																}
																																																																																																															}
																																																																																																														}
																																																																																																													}
																																																																																																												}
																																																																																																											}
																																																																																																										}
																																																																																																									}
																																																																																																								}
																																																																																																							}
																																																																																																						}
																																																																																																					}
																																																																																																				}
																																																																																																			}
																																																																																																		}
																																																																																																	}
																																																																																																}
																																																																																															}
																																																																																														}
																																																																																													}
																																																																																												}
																																																																																											}
																																																																																										}
																																																																																									}
																																																																																								}
																																																																																							}
																																																																																						}
																																																																																					}
																																																																																				}
																																																																																			}
																																																																																		}
																																																																																	}
																																																																																}
																																																																															}
																																																																														}
																																																																													}
																																																																												}
																																																																											}
																																																																										}
																																																																									}
																																																																								}
																																																																							}
																																																																						}
																																																																					}
																																																																				}
																																																																			}
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	},
	{
		ctor: '::',
		_0: {ctor: '_Tuple3', _0: 89, _1: 55, _2: 200},
		_1: {
			ctor: '::',
			_0: {ctor: '_Tuple3', _0: 91, _1: 55, _2: 200},
			_1: {
				ctor: '::',
				_0: {ctor: '_Tuple3', _0: 94, _1: 55, _2: 200},
				_1: {
					ctor: '::',
					_0: {ctor: '_Tuple3', _0: 96, _1: 55, _2: 200},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple3', _0: 99, _1: 55, _2: 200},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple3', _0: 101, _1: 55, _2: 200},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple3', _0: 103, _1: 55, _2: 200},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple3', _0: 106, _1: 55, _2: 200},
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple3', _0: 108, _1: 55, _2: 200},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple3', _0: 111, _1: 55, _2: 200},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple3', _0: 113, _1: 55, _2: 200},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple3', _0: 115, _1: 55, _2: 200},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple3', _0: 118, _1: 55, _2: 200},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple3', _0: 120, _1: 55, _2: 200},
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple3', _0: 123, _1: 55, _2: 200},
																_1: {
																	ctor: '::',
																	_0: {ctor: '_Tuple3', _0: 125, _1: 55, _2: 200},
																	_1: {
																		ctor: '::',
																		_0: {ctor: '_Tuple3', _0: 128, _1: 55, _2: 200},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple3', _0: 130, _1: 55, _2: 200},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple3', _0: 132, _1: 55, _2: 200},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple3', _0: 135, _1: 55, _2: 200},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple3', _0: 137, _1: 55, _2: 200},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple3', _0: 140, _1: 55, _2: 200},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple3', _0: 142, _1: 55, _2: 200},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple3', _0: 144, _1: 55, _2: 200},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple3', _0: 147, _1: 55, _2: 200},
																										_1: {
																											ctor: '::',
																											_0: {ctor: '_Tuple3', _0: 149, _1: 55, _2: 200},
																											_1: {
																												ctor: '::',
																												_0: {ctor: '_Tuple3', _0: 152, _1: 55, _2: 200},
																												_1: {
																													ctor: '::',
																													_0: {ctor: '_Tuple3', _0: 154, _1: 55, _2: 200},
																													_1: {
																														ctor: '::',
																														_0: {ctor: '_Tuple3', _0: 157, _1: 55, _2: 200},
																														_1: {
																															ctor: '::',
																															_0: {ctor: '_Tuple3', _0: 159, _1: 55, _2: 200},
																															_1: {
																																ctor: '::',
																																_0: {ctor: '_Tuple3', _0: 161, _1: 55, _2: 200},
																																_1: {
																																	ctor: '::',
																																	_0: {ctor: '_Tuple3', _0: 164, _1: 55, _2: 200},
																																	_1: {
																																		ctor: '::',
																																		_0: {ctor: '_Tuple3', _0: 166, _1: 55, _2: 200},
																																		_1: {
																																			ctor: '::',
																																			_0: {ctor: '_Tuple3', _0: 169, _1: 55, _2: 200},
																																			_1: {
																																				ctor: '::',
																																				_0: {ctor: '_Tuple3', _0: 171, _1: 55, _2: 200},
																																				_1: {
																																					ctor: '::',
																																					_0: {ctor: '_Tuple3', _0: 173, _1: 55, _2: 200},
																																					_1: {
																																						ctor: '::',
																																						_0: {ctor: '_Tuple3', _0: 176, _1: 55, _2: 200},
																																						_1: {
																																							ctor: '::',
																																							_0: {ctor: '_Tuple3', _0: 178, _1: 55, _2: 200},
																																							_1: {
																																								ctor: '::',
																																								_0: {ctor: '_Tuple3', _0: 181, _1: 55, _2: 200},
																																								_1: {
																																									ctor: '::',
																																									_0: {ctor: '_Tuple3', _0: 183, _1: 55, _2: 200},
																																									_1: {
																																										ctor: '::',
																																										_0: {ctor: '_Tuple3', _0: 186, _1: 55, _2: 200},
																																										_1: {
																																											ctor: '::',
																																											_0: {ctor: '_Tuple3', _0: 188, _1: 55, _2: 200},
																																											_1: {
																																												ctor: '::',
																																												_0: {ctor: '_Tuple3', _0: 190, _1: 55, _2: 200},
																																												_1: {
																																													ctor: '::',
																																													_0: {ctor: '_Tuple3', _0: 193, _1: 55, _2: 200},
																																													_1: {
																																														ctor: '::',
																																														_0: {ctor: '_Tuple3', _0: 195, _1: 55, _2: 200},
																																														_1: {
																																															ctor: '::',
																																															_0: {ctor: '_Tuple3', _0: 198, _1: 55, _2: 200},
																																															_1: {
																																																ctor: '::',
																																																_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 200},
																																																_1: {
																																																	ctor: '::',
																																																	_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 198},
																																																	_1: {
																																																		ctor: '::',
																																																		_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 195},
																																																		_1: {
																																																			ctor: '::',
																																																			_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 193},
																																																			_1: {
																																																				ctor: '::',
																																																				_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 190},
																																																				_1: {
																																																					ctor: '::',
																																																					_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 188},
																																																					_1: {
																																																						ctor: '::',
																																																						_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 186},
																																																						_1: {
																																																							ctor: '::',
																																																							_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 183},
																																																							_1: {
																																																								ctor: '::',
																																																								_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 181},
																																																								_1: {
																																																									ctor: '::',
																																																									_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 178},
																																																									_1: {
																																																										ctor: '::',
																																																										_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 176},
																																																										_1: {
																																																											ctor: '::',
																																																											_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 173},
																																																											_1: {
																																																												ctor: '::',
																																																												_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 171},
																																																												_1: {
																																																													ctor: '::',
																																																													_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 169},
																																																													_1: {
																																																														ctor: '::',
																																																														_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 166},
																																																														_1: {
																																																															ctor: '::',
																																																															_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 164},
																																																															_1: {
																																																																ctor: '::',
																																																																_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 161},
																																																																_1: {
																																																																	ctor: '::',
																																																																	_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 159},
																																																																	_1: {
																																																																		ctor: '::',
																																																																		_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 157},
																																																																		_1: {
																																																																			ctor: '::',
																																																																			_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 154},
																																																																			_1: {
																																																																				ctor: '::',
																																																																				_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 152},
																																																																				_1: {
																																																																					ctor: '::',
																																																																					_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 149},
																																																																					_1: {
																																																																						ctor: '::',
																																																																						_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 147},
																																																																						_1: {
																																																																							ctor: '::',
																																																																							_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 144},
																																																																							_1: {
																																																																								ctor: '::',
																																																																								_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 142},
																																																																								_1: {
																																																																									ctor: '::',
																																																																									_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 140},
																																																																									_1: {
																																																																										ctor: '::',
																																																																										_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 137},
																																																																										_1: {
																																																																											ctor: '::',
																																																																											_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 135},
																																																																											_1: {
																																																																												ctor: '::',
																																																																												_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 132},
																																																																												_1: {
																																																																													ctor: '::',
																																																																													_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 130},
																																																																													_1: {
																																																																														ctor: '::',
																																																																														_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 128},
																																																																														_1: {
																																																																															ctor: '::',
																																																																															_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 125},
																																																																															_1: {
																																																																																ctor: '::',
																																																																																_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 123},
																																																																																_1: {
																																																																																	ctor: '::',
																																																																																	_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 120},
																																																																																	_1: {
																																																																																		ctor: '::',
																																																																																		_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 118},
																																																																																		_1: {
																																																																																			ctor: '::',
																																																																																			_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 115},
																																																																																			_1: {
																																																																																				ctor: '::',
																																																																																				_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 113},
																																																																																				_1: {
																																																																																					ctor: '::',
																																																																																					_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 111},
																																																																																					_1: {
																																																																																						ctor: '::',
																																																																																						_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 108},
																																																																																						_1: {
																																																																																							ctor: '::',
																																																																																							_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 106},
																																																																																							_1: {
																																																																																								ctor: '::',
																																																																																								_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 103},
																																																																																								_1: {
																																																																																									ctor: '::',
																																																																																									_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 101},
																																																																																									_1: {
																																																																																										ctor: '::',
																																																																																										_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 99},
																																																																																										_1: {
																																																																																											ctor: '::',
																																																																																											_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 96},
																																																																																											_1: {
																																																																																												ctor: '::',
																																																																																												_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 94},
																																																																																												_1: {
																																																																																													ctor: '::',
																																																																																													_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 91},
																																																																																													_1: {
																																																																																														ctor: '::',
																																																																																														_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 89},
																																																																																														_1: {
																																																																																															ctor: '::',
																																																																																															_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 86},
																																																																																															_1: {
																																																																																																ctor: '::',
																																																																																																_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 84},
																																																																																																_1: {
																																																																																																	ctor: '::',
																																																																																																	_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 82},
																																																																																																	_1: {
																																																																																																		ctor: '::',
																																																																																																		_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 79},
																																																																																																		_1: {
																																																																																																			ctor: '::',
																																																																																																			_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 77},
																																																																																																			_1: {
																																																																																																				ctor: '::',
																																																																																																				_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 74},
																																																																																																				_1: {
																																																																																																					ctor: '::',
																																																																																																					_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 72},
																																																																																																					_1: {
																																																																																																						ctor: '::',
																																																																																																						_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 70},
																																																																																																						_1: {
																																																																																																							ctor: '::',
																																																																																																							_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 67},
																																																																																																							_1: {
																																																																																																								ctor: '::',
																																																																																																								_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 65},
																																																																																																								_1: {
																																																																																																									ctor: '::',
																																																																																																									_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 62},
																																																																																																									_1: {
																																																																																																										ctor: '::',
																																																																																																										_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 60},
																																																																																																										_1: {
																																																																																																											ctor: '::',
																																																																																																											_0: {ctor: '_Tuple3', _0: 200, _1: 55, _2: 57},
																																																																																																											_1: {
																																																																																																												ctor: '::',
																																																																																																												_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																												_1: {
																																																																																																													ctor: '::',
																																																																																																													_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																													_1: {
																																																																																																														ctor: '::',
																																																																																																														_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																														_1: {
																																																																																																															ctor: '::',
																																																																																																															_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																															_1: {
																																																																																																																ctor: '::',
																																																																																																																_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																_1: {
																																																																																																																	ctor: '::',
																																																																																																																	_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																	_1: {
																																																																																																																		ctor: '::',
																																																																																																																		_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																		_1: {
																																																																																																																			ctor: '::',
																																																																																																																			_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																			_1: {
																																																																																																																				ctor: '::',
																																																																																																																				_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																				_1: {
																																																																																																																					ctor: '::',
																																																																																																																					_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																					_1: {
																																																																																																																						ctor: '::',
																																																																																																																						_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																						_1: {
																																																																																																																							ctor: '::',
																																																																																																																							_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																							_1: {
																																																																																																																								ctor: '::',
																																																																																																																								_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																								_1: {
																																																																																																																									ctor: '::',
																																																																																																																									_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																									_1: {
																																																																																																																										ctor: '::',
																																																																																																																										_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																										_1: {
																																																																																																																											ctor: '::',
																																																																																																																											_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																											_1: {
																																																																																																																												ctor: '::',
																																																																																																																												_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																												_1: {
																																																																																																																													ctor: '::',
																																																																																																																													_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																													_1: {
																																																																																																																														ctor: '::',
																																																																																																																														_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																														_1: {
																																																																																																																															ctor: '::',
																																																																																																																															_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																															_1: {
																																																																																																																																ctor: '::',
																																																																																																																																_0: {ctor: '_Tuple3', _0: 0, _1: 0, _2: 0},
																																																																																																																																_1: {
																																																																																																																																	ctor: '::',
																																																																																																																																	_0: {ctor: '_Tuple3', _0: 3, _1: 3, _2: 3},
																																																																																																																																	_1: {
																																																																																																																																		ctor: '::',
																																																																																																																																		_0: {ctor: '_Tuple3', _0: 5, _1: 5, _2: 5},
																																																																																																																																		_1: {
																																																																																																																																			ctor: '::',
																																																																																																																																			_0: {ctor: '_Tuple3', _0: 8, _1: 8, _2: 8},
																																																																																																																																			_1: {
																																																																																																																																				ctor: '::',
																																																																																																																																				_0: {ctor: '_Tuple3', _0: 10, _1: 10, _2: 10},
																																																																																																																																				_1: {
																																																																																																																																					ctor: '::',
																																																																																																																																					_0: {ctor: '_Tuple3', _0: 13, _1: 13, _2: 13},
																																																																																																																																					_1: {
																																																																																																																																						ctor: '::',
																																																																																																																																						_0: {ctor: '_Tuple3', _0: 15, _1: 15, _2: 15},
																																																																																																																																						_1: {
																																																																																																																																							ctor: '::',
																																																																																																																																							_0: {ctor: '_Tuple3', _0: 18, _1: 18, _2: 18},
																																																																																																																																							_1: {
																																																																																																																																								ctor: '::',
																																																																																																																																								_0: {ctor: '_Tuple3', _0: 20, _1: 20, _2: 20},
																																																																																																																																								_1: {
																																																																																																																																									ctor: '::',
																																																																																																																																									_0: {ctor: '_Tuple3', _0: 23, _1: 23, _2: 23},
																																																																																																																																									_1: {
																																																																																																																																										ctor: '::',
																																																																																																																																										_0: {ctor: '_Tuple3', _0: 26, _1: 26, _2: 26},
																																																																																																																																										_1: {
																																																																																																																																											ctor: '::',
																																																																																																																																											_0: {ctor: '_Tuple3', _0: 28, _1: 28, _2: 28},
																																																																																																																																											_1: {
																																																																																																																																												ctor: '::',
																																																																																																																																												_0: {ctor: '_Tuple3', _0: 31, _1: 31, _2: 31},
																																																																																																																																												_1: {
																																																																																																																																													ctor: '::',
																																																																																																																																													_0: {ctor: '_Tuple3', _0: 33, _1: 33, _2: 33},
																																																																																																																																													_1: {
																																																																																																																																														ctor: '::',
																																																																																																																																														_0: {ctor: '_Tuple3', _0: 36, _1: 36, _2: 36},
																																																																																																																																														_1: {
																																																																																																																																															ctor: '::',
																																																																																																																																															_0: {ctor: '_Tuple3', _0: 38, _1: 38, _2: 38},
																																																																																																																																															_1: {
																																																																																																																																																ctor: '::',
																																																																																																																																																_0: {ctor: '_Tuple3', _0: 41, _1: 41, _2: 41},
																																																																																																																																																_1: {
																																																																																																																																																	ctor: '::',
																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 43, _1: 43, _2: 43},
																																																																																																																																																	_1: {
																																																																																																																																																		ctor: '::',
																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 46, _1: 46, _2: 46},
																																																																																																																																																		_1: {
																																																																																																																																																			ctor: '::',
																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 48, _1: 48, _2: 48},
																																																																																																																																																			_1: {
																																																																																																																																																				ctor: '::',
																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 51, _1: 51, _2: 51},
																																																																																																																																																				_1: {
																																																																																																																																																					ctor: '::',
																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 54, _1: 54, _2: 54},
																																																																																																																																																					_1: {
																																																																																																																																																						ctor: '::',
																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 56, _1: 56, _2: 56},
																																																																																																																																																						_1: {
																																																																																																																																																							ctor: '::',
																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 59, _1: 59, _2: 59},
																																																																																																																																																							_1: {
																																																																																																																																																								ctor: '::',
																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 61, _1: 61, _2: 61},
																																																																																																																																																								_1: {
																																																																																																																																																									ctor: '::',
																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 64, _1: 64, _2: 64},
																																																																																																																																																									_1: {
																																																																																																																																																										ctor: '::',
																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 66, _1: 66, _2: 66},
																																																																																																																																																										_1: {
																																																																																																																																																											ctor: '::',
																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 69, _1: 69, _2: 69},
																																																																																																																																																											_1: {
																																																																																																																																																												ctor: '::',
																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 71, _1: 71, _2: 71},
																																																																																																																																																												_1: {
																																																																																																																																																													ctor: '::',
																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 74, _1: 74, _2: 74},
																																																																																																																																																													_1: {
																																																																																																																																																														ctor: '::',
																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 77, _1: 77, _2: 77},
																																																																																																																																																														_1: {
																																																																																																																																																															ctor: '::',
																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 79, _1: 79, _2: 79},
																																																																																																																																																															_1: {
																																																																																																																																																																ctor: '::',
																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 82, _1: 82, _2: 82},
																																																																																																																																																																_1: {
																																																																																																																																																																	ctor: '::',
																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 84, _1: 84, _2: 84},
																																																																																																																																																																	_1: {
																																																																																																																																																																		ctor: '::',
																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 87, _1: 87, _2: 87},
																																																																																																																																																																		_1: {
																																																																																																																																																																			ctor: '::',
																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 89, _1: 89, _2: 89},
																																																																																																																																																																			_1: {
																																																																																																																																																																				ctor: '::',
																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 92, _1: 92, _2: 92},
																																																																																																																																																																				_1: {
																																																																																																																																																																					ctor: '::',
																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 94, _1: 94, _2: 94},
																																																																																																																																																																					_1: {
																																																																																																																																																																						ctor: '::',
																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 97, _1: 97, _2: 97},
																																																																																																																																																																						_1: {
																																																																																																																																																																							ctor: '::',
																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 99, _1: 99, _2: 99},
																																																																																																																																																																							_1: {
																																																																																																																																																																								ctor: '::',
																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 102, _1: 102, _2: 102},
																																																																																																																																																																								_1: {
																																																																																																																																																																									ctor: '::',
																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 105, _1: 105, _2: 105},
																																																																																																																																																																									_1: {
																																																																																																																																																																										ctor: '::',
																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 107, _1: 107, _2: 107},
																																																																																																																																																																										_1: {
																																																																																																																																																																											ctor: '::',
																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 110, _1: 110, _2: 110},
																																																																																																																																																																											_1: {
																																																																																																																																																																												ctor: '::',
																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 112, _1: 112, _2: 112},
																																																																																																																																																																												_1: {
																																																																																																																																																																													ctor: '::',
																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 115, _1: 115, _2: 115},
																																																																																																																																																																													_1: {
																																																																																																																																																																														ctor: '::',
																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 117, _1: 117, _2: 117},
																																																																																																																																																																														_1: {
																																																																																																																																																																															ctor: '::',
																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 120, _1: 120, _2: 120},
																																																																																																																																																																															_1: {
																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 122, _1: 122, _2: 122},
																																																																																																																																																																																_1: {
																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 125, _1: 125, _2: 125},
																																																																																																																																																																																	_1: {
																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 128, _1: 128, _2: 128},
																																																																																																																																																																																		_1: {
																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 130, _1: 130, _2: 130},
																																																																																																																																																																																			_1: {
																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 133, _1: 133, _2: 133},
																																																																																																																																																																																				_1: {
																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 135, _1: 135, _2: 135},
																																																																																																																																																																																					_1: {
																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 138, _1: 138, _2: 138},
																																																																																																																																																																																						_1: {
																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 140, _1: 140, _2: 140},
																																																																																																																																																																																							_1: {
																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 143, _1: 143, _2: 143},
																																																																																																																																																																																								_1: {
																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 145, _1: 145, _2: 145},
																																																																																																																																																																																									_1: {
																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 148, _1: 148, _2: 148},
																																																																																																																																																																																										_1: {
																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 150, _1: 150, _2: 150},
																																																																																																																																																																																											_1: {
																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 153, _1: 153, _2: 153},
																																																																																																																																																																																												_1: {
																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 156, _1: 156, _2: 156},
																																																																																																																																																																																													_1: {
																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 158, _1: 158, _2: 158},
																																																																																																																																																																																														_1: {
																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 161, _1: 161, _2: 161},
																																																																																																																																																																																															_1: {
																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 163, _1: 163, _2: 163},
																																																																																																																																																																																																_1: {
																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 166, _1: 166, _2: 166},
																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 168, _1: 168, _2: 168},
																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 171, _1: 171, _2: 171},
																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 173, _1: 173, _2: 173},
																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 176, _1: 176, _2: 176},
																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 179, _1: 179, _2: 179},
																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 181, _1: 181, _2: 181},
																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 184, _1: 184, _2: 184},
																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 186, _1: 186, _2: 186},
																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 189, _1: 189, _2: 189},
																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 191, _1: 191, _2: 191},
																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 194, _1: 194, _2: 194},
																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 196, _1: 196, _2: 196},
																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 199, _1: 199, _2: 199},
																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 201, _1: 201, _2: 201},
																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 204, _1: 204, _2: 204},
																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 207, _1: 207, _2: 207},
																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 209, _1: 209, _2: 209},
																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 212, _1: 212, _2: 212},
																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 214, _1: 214, _2: 214},
																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 217, _1: 217, _2: 217},
																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 219, _1: 219, _2: 219},
																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 222, _1: 222, _2: 222},
																																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 224, _1: 224, _2: 224},
																																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 227, _1: 227, _2: 227},
																																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 230, _1: 230, _2: 230},
																																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 232, _1: 232, _2: 232},
																																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 235, _1: 235, _2: 235},
																																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 237, _1: 237, _2: 237},
																																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 240, _1: 240, _2: 240},
																																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 242, _1: 242, _2: 242},
																																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 245, _1: 245, _2: 245},
																																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 247, _1: 247, _2: 247},
																																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 250, _1: 250, _2: 250},
																																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 252, _1: 252, _2: 252},
																																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																							_1: {
																																																																																																																																																																																																																																								ctor: '::',
																																																																																																																																																																																																																																								_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																								_1: {
																																																																																																																																																																																																																																									ctor: '::',
																																																																																																																																																																																																																																									_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																									_1: {
																																																																																																																																																																																																																																										ctor: '::',
																																																																																																																																																																																																																																										_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																										_1: {
																																																																																																																																																																																																																																											ctor: '::',
																																																																																																																																																																																																																																											_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																											_1: {
																																																																																																																																																																																																																																												ctor: '::',
																																																																																																																																																																																																																																												_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																												_1: {
																																																																																																																																																																																																																																													ctor: '::',
																																																																																																																																																																																																																																													_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																													_1: {
																																																																																																																																																																																																																																														ctor: '::',
																																																																																																																																																																																																																																														_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																														_1: {
																																																																																																																																																																																																																																															ctor: '::',
																																																																																																																																																																																																																																															_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																															_1: {
																																																																																																																																																																																																																																																ctor: '::',
																																																																																																																																																																																																																																																_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																_1: {
																																																																																																																																																																																																																																																	ctor: '::',
																																																																																																																																																																																																																																																	_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																	_1: {
																																																																																																																																																																																																																																																		ctor: '::',
																																																																																																																																																																																																																																																		_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																		_1: {
																																																																																																																																																																																																																																																			ctor: '::',
																																																																																																																																																																																																																																																			_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																			_1: {
																																																																																																																																																																																																																																																				ctor: '::',
																																																																																																																																																																																																																																																				_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																				_1: {
																																																																																																																																																																																																																																																					ctor: '::',
																																																																																																																																																																																																																																																					_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																					_1: {
																																																																																																																																																																																																																																																						ctor: '::',
																																																																																																																																																																																																																																																						_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																						_1: {
																																																																																																																																																																																																																																																							ctor: '::',
																																																																																																																																																																																																																																																							_0: {ctor: '_Tuple3', _0: 255, _1: 255, _2: 255},
																																																																																																																																																																																																																																																							_1: {ctor: '[]'}
																																																																																																																																																																																																																																																						}
																																																																																																																																																																																																																																																					}
																																																																																																																																																																																																																																																				}
																																																																																																																																																																																																																																																			}
																																																																																																																																																																																																																																																		}
																																																																																																																																																																																																																																																	}
																																																																																																																																																																																																																																																}
																																																																																																																																																																																																																																															}
																																																																																																																																																																																																																																														}
																																																																																																																																																																																																																																													}
																																																																																																																																																																																																																																												}
																																																																																																																																																																																																																																											}
																																																																																																																																																																																																																																										}
																																																																																																																																																																																																																																									}
																																																																																																																																																																																																																																								}
																																																																																																																																																																																																																																							}
																																																																																																																																																																																																																																						}
																																																																																																																																																																																																																																					}
																																																																																																																																																																																																																																				}
																																																																																																																																																																																																																																			}
																																																																																																																																																																																																																																		}
																																																																																																																																																																																																																																	}
																																																																																																																																																																																																																																}
																																																																																																																																																																																																																															}
																																																																																																																																																																																																																														}
																																																																																																																																																																																																																													}
																																																																																																																																																																																																																												}
																																																																																																																																																																																																																											}
																																																																																																																																																																																																																										}
																																																																																																																																																																																																																									}
																																																																																																																																																																																																																								}
																																																																																																																																																																																																																							}
																																																																																																																																																																																																																						}
																																																																																																																																																																																																																					}
																																																																																																																																																																																																																				}
																																																																																																																																																																																																																			}
																																																																																																																																																																																																																		}
																																																																																																																																																																																																																	}
																																																																																																																																																																																																																}
																																																																																																																																																																																																															}
																																																																																																																																																																																																														}
																																																																																																																																																																																																													}
																																																																																																																																																																																																												}
																																																																																																																																																																																																											}
																																																																																																																																																																																																										}
																																																																																																																																																																																																									}
																																																																																																																																																																																																								}
																																																																																																																																																																																																							}
																																																																																																																																																																																																						}
																																																																																																																																																																																																					}
																																																																																																																																																																																																				}
																																																																																																																																																																																																			}
																																																																																																																																																																																																		}
																																																																																																																																																																																																	}
																																																																																																																																																																																																}
																																																																																																																																																																																															}
																																																																																																																																																																																														}
																																																																																																																																																																																													}
																																																																																																																																																																																												}
																																																																																																																																																																																											}
																																																																																																																																																																																										}
																																																																																																																																																																																									}
																																																																																																																																																																																								}
																																																																																																																																																																																							}
																																																																																																																																																																																						}
																																																																																																																																																																																					}
																																																																																																																																																																																				}
																																																																																																																																																																																			}
																																																																																																																																																																																		}
																																																																																																																																																																																	}
																																																																																																																																																																																}
																																																																																																																																																																															}
																																																																																																																																																																														}
																																																																																																																																																																													}
																																																																																																																																																																												}
																																																																																																																																																																											}
																																																																																																																																																																										}
																																																																																																																																																																									}
																																																																																																																																																																								}
																																																																																																																																																																							}
																																																																																																																																																																						}
																																																																																																																																																																					}
																																																																																																																																																																				}
																																																																																																																																																																			}
																																																																																																																																																																		}
																																																																																																																																																																	}
																																																																																																																																																																}
																																																																																																																																																															}
																																																																																																																																																														}
																																																																																																																																																													}
																																																																																																																																																												}
																																																																																																																																																											}
																																																																																																																																																										}
																																																																																																																																																									}
																																																																																																																																																								}
																																																																																																																																																							}
																																																																																																																																																						}
																																																																																																																																																					}
																																																																																																																																																				}
																																																																																																																																																			}
																																																																																																																																																		}
																																																																																																																																																	}
																																																																																																																																																}
																																																																																																																																															}
																																																																																																																																														}
																																																																																																																																													}
																																																																																																																																												}
																																																																																																																																											}
																																																																																																																																										}
																																																																																																																																									}
																																																																																																																																								}
																																																																																																																																							}
																																																																																																																																						}
																																																																																																																																					}
																																																																																																																																				}
																																																																																																																																			}
																																																																																																																																		}
																																																																																																																																	}
																																																																																																																																}
																																																																																																																															}
																																																																																																																														}
																																																																																																																													}
																																																																																																																												}
																																																																																																																											}
																																																																																																																										}
																																																																																																																									}
																																																																																																																								}
																																																																																																																							}
																																																																																																																						}
																																																																																																																					}
																																																																																																																				}
																																																																																																																			}
																																																																																																																		}
																																																																																																																	}
																																																																																																																}
																																																																																																															}
																																																																																																														}
																																																																																																													}
																																																																																																												}
																																																																																																											}
																																																																																																										}
																																																																																																									}
																																																																																																								}
																																																																																																							}
																																																																																																						}
																																																																																																					}
																																																																																																				}
																																																																																																			}
																																																																																																		}
																																																																																																	}
																																																																																																}
																																																																																															}
																																																																																														}
																																																																																													}
																																																																																												}
																																																																																											}
																																																																																										}
																																																																																									}
																																																																																								}
																																																																																							}
																																																																																						}
																																																																																					}
																																																																																				}
																																																																																			}
																																																																																		}
																																																																																	}
																																																																																}
																																																																															}
																																																																														}
																																																																													}
																																																																												}
																																																																											}
																																																																										}
																																																																									}
																																																																								}
																																																																							}
																																																																						}
																																																																					}
																																																																				}
																																																																			}
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$ColorNum$dict = function () {
	var f = F2(
		function (_p5, acc) {
			var _p6 = _p5;
			return A3(
				_elm_lang$core$Dict$insert,
				_p6._0 - 1,
				{
					ctor: '::',
					_0: _p6._1._0,
					_1: {
						ctor: '::',
						_0: _p6._1._1,
						_1: {
							ctor: '::',
							_0: _p6._1._2,
							_1: {
								ctor: '::',
								_0: 1.0,
								_1: {ctor: '[]'}
							}
						}
					}
				},
				acc);
		});
	return A3(_user$project$Utils$foldli1, f, _elm_lang$core$Dict$empty, _user$project$ColorNum$codes);
}();
var _user$project$ColorNum$convert = function (i) {
	var _p7 = A2(
		_elm_lang$core$Dict$get,
		_elm_lang$core$Basics$floor(i),
		_user$project$ColorNum$dict);
	if (_p7.ctor === 'Nothing') {
		return {
			ctor: '::',
			_0: 0,
			_1: {
				ctor: '::',
				_0: 0,
				_1: {
					ctor: '::',
					_0: 0,
					_1: {
						ctor: '::',
						_0: 1,
						_1: {ctor: '[]'}
					}
				}
			}
		};
	} else {
		return _p7._0;
	}
};

var _user$project$Config$debugLog = F3(
	function (b, s, x) {
		return b ? A2(_elm_lang$core$Debug$log, s, x) : x;
	});
var _user$project$Config$debugTypeChecker = true;
var _user$project$Config$debugStorage = false;
var _user$project$Config$debugSync = false;
var _user$project$Config$debugController = false;
var _user$project$Config$debugView = false;
var _user$project$Config$debugParser = false;
var _user$project$Config$elmConfDemo = false;
var _user$project$Config$params = {
	strVersion: _user$project$Config$elmConfDemo ? 'version: elm-conf-2018-demo' : 'v0.7.0',
	debugLayout: false,
	wGut: 10,
	topSection: {h: 38, wLogo: 25, wBtnO: 180, hBtnO: 25, wJunk: 250},
	botSection: {h: 60},
	mainSection: {
		widgets: {wBtn: 120, wBtnWide: 140, hBtn: 25, font: 'Helvetica, sans-serif', fontSize: '10pt'},
		vertical: {hExtra: 6, wGut: 10},
		horizontal: {wExtra: 15, hGut: 10},
		canvas: {border: '2px solid darkGray', hZoneInfo: 40},
		codebox: {border: '2px solid darkGray', font: 'Courier, monospace', fontSize: '12pt'},
		uiWidgets: {pad: 5, wSlider: 100, hSlider: 25, wCaption: 100, rBall: '10px', fontSize: '11pt', font: 'Tahoma, sans-serif'}
	}
};
var _user$project$Config$computeLayoutInfo = function (model) {
	var hBot = _user$project$Config$params.botSection.h;
	var hTop = _user$project$Config$params.topSection.h;
	var hWindow = model.dimensions.height;
	var hCodebox = (hWindow - (hTop + hBot)) - 3;
	var hCanvas = hCodebox;
	var wWindow = model.dimensions.width;
	var wCodebox = ((wWindow / 2) | 0) - 10;
	var wCanvas = wCodebox;
	var wSideGutter = _user$project$Config$params.wGut;
	return {hTop: hTop, hBot: hBot, hMid: hCodebox, wCodebox: wCodebox, hCodebox: hCodebox, wCanvas: wCanvas, hCanvas: hCanvas, xCanvas: wCodebox, yCanvas: hCodebox};
};

var _user$project$Either$Right = function (a) {
	return {ctor: 'Right', _0: a};
};
var _user$project$Either$Left = function (a) {
	return {ctor: 'Left', _0: a};
};

var __globalBoolState__ = false;

 // Thanks to https://www.w3.org/TR/html52/syntax.html#named-character-references
var htmlNamedEntities = JSON.parse(`{"&Aacute;": "\\u00C1", "&Aacute": "\\u00C1", "&aacute;": "\\u00E1", "&aacute": "\\u00E1", "&Abreve;": "\\u0102", "&abreve;": "\\u0103", "&ac;": "\\u223E", "&acd;": "\\u223F", "&acE;": "\\u223E\\u0333", "&Acirc;": "\\u00C2", "&Acirc": "\\u00C2", "&acirc;": "\\u00E2", "&acirc": "\\u00E2", "&acute;": "\\u00B4", "&acute": "\\u00B4", "&Acy;": "\\u0410", "&acy;": "\\u0430", "&AElig;": "\\u00C6", "&AElig": "\\u00C6", "&aelig;": "\\u00E6", "&aelig": "\\u00E6", "&af;": "\\u2061", "&Afr;": "\\uD835\\uDD04", "&afr;": "\\uD835\\uDD1E", "&Agrave;": "\\u00C0", "&Agrave": "\\u00C0", "&agrave;": "\\u00E0", "&agrave": "\\u00E0", "&alefsym;": "\\u2135", "&aleph;": "\\u2135", "&Alpha;": "\\u0391", "&alpha;": "\\u03B1", "&Amacr;": "\\u0100", "&amacr;": "\\u0101", "&amalg;": "\\u2A3F", "&amp;": "\\u0026", "&amp": "\\u0026", "&AMP;": "\\u0026", "&AMP": "\\u0026", "&andand;": "\\u2A55", "&And;": "\\u2A53", "&and;": "\\u2227", "&andd;": "\\u2A5C", "&andslope;": "\\u2A58", "&andv;": "\\u2A5A", "&ang;": "\\u2220", "&ange;": "\\u29A4", "&angle;": "\\u2220", "&angmsdaa;": "\\u29A8", "&angmsdab;": "\\u29A9", "&angmsdac;": "\\u29AA", "&angmsdad;": "\\u29AB", "&angmsdae;": "\\u29AC", "&angmsdaf;": "\\u29AD", "&angmsdag;": "\\u29AE", "&angmsdah;": "\\u29AF", "&angmsd;": "\\u2221", "&angrt;": "\\u221F", "&angrtvb;": "\\u22BE", "&angrtvbd;": "\\u299D", "&angsph;": "\\u2222", "&angst;": "\\u00C5", "&angzarr;": "\\u237C", "&Aogon;": "\\u0104", "&aogon;": "\\u0105", "&Aopf;": "\\uD835\\uDD38", "&aopf;": "\\uD835\\uDD52", "&apacir;": "\\u2A6F", "&ap;": "\\u2248", "&apE;": "\\u2A70", "&ape;": "\\u224A", "&apid;": "\\u224B", "&apos;": "\\u0027", "&ApplyFunction;": "\\u2061", "&approx;": "\\u2248", "&approxeq;": "\\u224A", "&Aring;": "\\u00C5", "&Aring": "\\u00C5", "&aring;": "\\u00E5", "&aring": "\\u00E5", "&Ascr;": "\\uD835\\uDC9C", "&ascr;": "\\uD835\\uDCB6", "&Assign;": "\\u2254", "&ast;": "\\u002A", "&asymp;": "\\u2248", "&asympeq;": "\\u224D", "&Atilde;": "\\u00C3", "&Atilde": "\\u00C3", "&atilde;": "\\u00E3", "&atilde": "\\u00E3", "&Auml;": "\\u00C4", "&Auml": "\\u00C4", "&auml;": "\\u00E4", "&auml": "\\u00E4", "&awconint;": "\\u2233", "&awint;": "\\u2A11", "&backcong;": "\\u224C", "&backepsilon;": "\\u03F6", "&backprime;": "\\u2035", "&backsim;": "\\u223D", "&backsimeq;": "\\u22CD", "&Backslash;": "\\u2216", "&Barv;": "\\u2AE7", "&barvee;": "\\u22BD", "&barwed;": "\\u2305", "&Barwed;": "\\u2306", "&barwedge;": "\\u2305", "&bbrk;": "\\u23B5", "&bbrktbrk;": "\\u23B6", "&bcong;": "\\u224C", "&Bcy;": "\\u0411", "&bcy;": "\\u0431", "&bdquo;": "\\u201E", "&becaus;": "\\u2235", "&because;": "\\u2235", "&Because;": "\\u2235", "&bemptyv;": "\\u29B0", "&bepsi;": "\\u03F6", "&bernou;": "\\u212C", "&Bernoullis;": "\\u212C", "&Beta;": "\\u0392", "&beta;": "\\u03B2", "&beth;": "\\u2136", "&between;": "\\u226C", "&Bfr;": "\\uD835\\uDD05", "&bfr;": "\\uD835\\uDD1F", "&bigcap;": "\\u22C2", "&bigcirc;": "\\u25EF", "&bigcup;": "\\u22C3", "&bigodot;": "\\u2A00", "&bigoplus;": "\\u2A01", "&bigotimes;": "\\u2A02", "&bigsqcup;": "\\u2A06", "&bigstar;": "\\u2605", "&bigtriangledown;": "\\u25BD", "&bigtriangleup;": "\\u25B3", "&biguplus;": "\\u2A04", "&bigvee;": "\\u22C1", "&bigwedge;": "\\u22C0", "&bkarow;": "\\u290D", "&blacklozenge;": "\\u29EB", "&blacksquare;": "\\u25AA", "&blacktriangle;": "\\u25B4", "&blacktriangledown;": "\\u25BE", "&blacktriangleleft;": "\\u25C2", "&blacktriangleright;": "\\u25B8", "&blank;": "\\u2423", "&blk12;": "\\u2592", "&blk14;": "\\u2591", "&blk34;": "\\u2593", "&block;": "\\u2588", "&bne;": "\\u003D\\u20E5", "&bnequiv;": "\\u2261\\u20E5", "&bNot;": "\\u2AED", "&bnot;": "\\u2310", "&Bopf;": "\\uD835\\uDD39", "&bopf;": "\\uD835\\uDD53", "&bot;": "\\u22A5", "&bottom;": "\\u22A5", "&bowtie;": "\\u22C8", "&boxbox;": "\\u29C9", "&boxdl;": "\\u2510", "&boxdL;": "\\u2555", "&boxDl;": "\\u2556", "&boxDL;": "\\u2557", "&boxdr;": "\\u250C", "&boxdR;": "\\u2552", "&boxDr;": "\\u2553", "&boxDR;": "\\u2554", "&boxh;": "\\u2500", "&boxH;": "\\u2550", "&boxhd;": "\\u252C", "&boxHd;": "\\u2564", "&boxhD;": "\\u2565", "&boxHD;": "\\u2566", "&boxhu;": "\\u2534", "&boxHu;": "\\u2567", "&boxhU;": "\\u2568", "&boxHU;": "\\u2569", "&boxminus;": "\\u229F", "&boxplus;": "\\u229E", "&boxtimes;": "\\u22A0", "&boxul;": "\\u2518", "&boxuL;": "\\u255B", "&boxUl;": "\\u255C", "&boxUL;": "\\u255D", "&boxur;": "\\u2514", "&boxuR;": "\\u2558", "&boxUr;": "\\u2559", "&boxUR;": "\\u255A", "&boxv;": "\\u2502", "&boxV;": "\\u2551", "&boxvh;": "\\u253C", "&boxvH;": "\\u256A", "&boxVh;": "\\u256B", "&boxVH;": "\\u256C", "&boxvl;": "\\u2524", "&boxvL;": "\\u2561", "&boxVl;": "\\u2562", "&boxVL;": "\\u2563", "&boxvr;": "\\u251C", "&boxvR;": "\\u255E", "&boxVr;": "\\u255F", "&boxVR;": "\\u2560", "&bprime;": "\\u2035", "&breve;": "\\u02D8", "&Breve;": "\\u02D8", "&brvbar;": "\\u00A6", "&brvbar": "\\u00A6", "&bscr;": "\\uD835\\uDCB7", "&Bscr;": "\\u212C", "&bsemi;": "\\u204F", "&bsim;": "\\u223D", "&bsime;": "\\u22CD", "&bsolb;": "\\u29C5", "&bsol;": "\\u005C", "&bsolhsub;": "\\u27C8", "&bull;": "\\u2022", "&bullet;": "\\u2022", "&bump;": "\\u224E", "&bumpE;": "\\u2AAE", "&bumpe;": "\\u224F", "&Bumpeq;": "\\u224E", "&bumpeq;": "\\u224F", "&Cacute;": "\\u0106", "&cacute;": "\\u0107", "&capand;": "\\u2A44", "&capbrcup;": "\\u2A49", "&capcap;": "\\u2A4B", "&cap;": "\\u2229", "&Cap;": "\\u22D2", "&capcup;": "\\u2A47", "&capdot;": "\\u2A40", "&CapitalDifferentialD;": "\\u2145", "&caps;": "\\u2229\\uFE00", "&caret;": "\\u2041", "&caron;": "\\u02C7", "&Cayleys;": "\\u212D", "&ccaps;": "\\u2A4D", "&Ccaron;": "\\u010C", "&ccaron;": "\\u010D", "&Ccedil;": "\\u00C7", "&Ccedil": "\\u00C7", "&ccedil;": "\\u00E7", "&ccedil": "\\u00E7", "&Ccirc;": "\\u0108", "&ccirc;": "\\u0109", "&Cconint;": "\\u2230", "&ccups;": "\\u2A4C", "&ccupssm;": "\\u2A50", "&Cdot;": "\\u010A", "&cdot;": "\\u010B", "&cedil;": "\\u00B8", "&cedil": "\\u00B8", "&Cedilla;": "\\u00B8", "&cemptyv;": "\\u29B2", "&cent;": "\\u00A2", "&cent": "\\u00A2", "&centerdot;": "\\u00B7", "&CenterDot;": "\\u00B7", "&cfr;": "\\uD835\\uDD20", "&Cfr;": "\\u212D", "&CHcy;": "\\u0427", "&chcy;": "\\u0447", "&check;": "\\u2713", "&checkmark;": "\\u2713", "&Chi;": "\\u03A7", "&chi;": "\\u03C7", "&circ;": "\\u02C6", "&circeq;": "\\u2257", "&circlearrowleft;": "\\u21BA", "&circlearrowright;": "\\u21BB", "&circledast;": "\\u229B", "&circledcirc;": "\\u229A", "&circleddash;": "\\u229D", "&CircleDot;": "\\u2299", "&circledR;": "\\u00AE", "&circledS;": "\\u24C8", "&CircleMinus;": "\\u2296", "&CirclePlus;": "\\u2295", "&CircleTimes;": "\\u2297", "&cir;": "\\u25CB", "&cirE;": "\\u29C3", "&cire;": "\\u2257", "&cirfnint;": "\\u2A10", "&cirmid;": "\\u2AEF", "&cirscir;": "\\u29C2", "&ClockwiseContourIntegral;": "\\u2232", "&CloseCurlyDoubleQuote;": "\\u201D", "&CloseCurlyQuote;": "\\u2019", "&clubs;": "\\u2663", "&clubsuit;": "\\u2663", "&colon;": "\\u003A", "&Colon;": "\\u2237", "&Colone;": "\\u2A74", "&colone;": "\\u2254", "&coloneq;": "\\u2254", "&comma;": "\\u002C", "&commat;": "\\u0040", "&comp;": "\\u2201", "&compfn;": "\\u2218", "&complement;": "\\u2201", "&complexes;": "\\u2102", "&cong;": "\\u2245", "&congdot;": "\\u2A6D", "&Congruent;": "\\u2261", "&conint;": "\\u222E", "&Conint;": "\\u222F", "&ContourIntegral;": "\\u222E", "&copf;": "\\uD835\\uDD54", "&Copf;": "\\u2102", "&coprod;": "\\u2210", "&Coproduct;": "\\u2210", "&copy;": "\\u00A9", "&copy": "\\u00A9", "&COPY;": "\\u00A9", "&COPY": "\\u00A9", "&copysr;": "\\u2117", "&CounterClockwiseContourIntegral;": "\\u2233", "&crarr;": "\\u21B5", "&cross;": "\\u2717", "&Cross;": "\\u2A2F", "&Cscr;": "\\uD835\\uDC9E", "&cscr;": "\\uD835\\uDCB8", "&csub;": "\\u2ACF", "&csube;": "\\u2AD1", "&csup;": "\\u2AD0", "&csupe;": "\\u2AD2", "&ctdot;": "\\u22EF", "&cudarrl;": "\\u2938", "&cudarrr;": "\\u2935", "&cuepr;": "\\u22DE", "&cuesc;": "\\u22DF", "&cularr;": "\\u21B6", "&cularrp;": "\\u293D", "&cupbrcap;": "\\u2A48", "&cupcap;": "\\u2A46", "&CupCap;": "\\u224D", "&cup;": "\\u222A", "&Cup;": "\\u22D3", "&cupcup;": "\\u2A4A", "&cupdot;": "\\u228D", "&cupor;": "\\u2A45", "&cups;": "\\u222A\\uFE00", "&curarr;": "\\u21B7", "&curarrm;": "\\u293C", "&curlyeqprec;": "\\u22DE", "&curlyeqsucc;": "\\u22DF", "&curlyvee;": "\\u22CE", "&curlywedge;": "\\u22CF", "&curren;": "\\u00A4", "&curren": "\\u00A4", "&curvearrowleft;": "\\u21B6", "&curvearrowright;": "\\u21B7", "&cuvee;": "\\u22CE", "&cuwed;": "\\u22CF", "&cwconint;": "\\u2232", "&cwint;": "\\u2231", "&cylcty;": "\\u232D", "&dagger;": "\\u2020", "&Dagger;": "\\u2021", "&daleth;": "\\u2138", "&darr;": "\\u2193", "&Darr;": "\\u21A1", "&dArr;": "\\u21D3", "&dash;": "\\u2010", "&Dashv;": "\\u2AE4", "&dashv;": "\\u22A3", "&dbkarow;": "\\u290F", "&dblac;": "\\u02DD", "&Dcaron;": "\\u010E", "&dcaron;": "\\u010F", "&Dcy;": "\\u0414", "&dcy;": "\\u0434", "&ddagger;": "\\u2021", "&ddarr;": "\\u21CA", "&DD;": "\\u2145", "&dd;": "\\u2146", "&DDotrahd;": "\\u2911", "&ddotseq;": "\\u2A77", "&deg;": "\\u00B0", "&deg": "\\u00B0", "&Del;": "\\u2207", "&Delta;": "\\u0394", "&delta;": "\\u03B4", "&demptyv;": "\\u29B1", "&dfisht;": "\\u297F", "&Dfr;": "\\uD835\\uDD07", "&dfr;": "\\uD835\\uDD21", "&dHar;": "\\u2965", "&dharl;": "\\u21C3", "&dharr;": "\\u21C2", "&DiacriticalAcute;": "\\u00B4", "&DiacriticalDot;": "\\u02D9", "&DiacriticalDoubleAcute;": "\\u02DD", "&DiacriticalGrave;": "\\u0060", "&DiacriticalTilde;": "\\u02DC", "&diam;": "\\u22C4", "&diamond;": "\\u22C4", "&Diamond;": "\\u22C4", "&diamondsuit;": "\\u2666", "&diams;": "\\u2666", "&die;": "\\u00A8", "&DifferentialD;": "\\u2146", "&digamma;": "\\u03DD", "&disin;": "\\u22F2", "&div;": "\\u00F7", "&divide;": "\\u00F7", "&divide": "\\u00F7", "&divideontimes;": "\\u22C7", "&divonx;": "\\u22C7", "&DJcy;": "\\u0402", "&djcy;": "\\u0452", "&dlcorn;": "\\u231E", "&dlcrop;": "\\u230D", "&dollar;": "\\u0024", "&Dopf;": "\\uD835\\uDD3B", "&dopf;": "\\uD835\\uDD55", "&Dot;": "\\u00A8", "&dot;": "\\u02D9", "&DotDot;": "\\u20DC", "&doteq;": "\\u2250", "&doteqdot;": "\\u2251", "&DotEqual;": "\\u2250", "&dotminus;": "\\u2238", "&dotplus;": "\\u2214", "&dotsquare;": "\\u22A1", "&doublebarwedge;": "\\u2306", "&DoubleContourIntegral;": "\\u222F", "&DoubleDot;": "\\u00A8", "&DoubleDownArrow;": "\\u21D3", "&DoubleLeftArrow;": "\\u21D0", "&DoubleLeftRightArrow;": "\\u21D4", "&DoubleLeftTee;": "\\u2AE4", "&DoubleLongLeftArrow;": "\\u27F8", "&DoubleLongLeftRightArrow;": "\\u27FA", "&DoubleLongRightArrow;": "\\u27F9", "&DoubleRightArrow;": "\\u21D2", "&DoubleRightTee;": "\\u22A8", "&DoubleUpArrow;": "\\u21D1", "&DoubleUpDownArrow;": "\\u21D5", "&DoubleVerticalBar;": "\\u2225", "&DownArrowBar;": "\\u2913", "&downarrow;": "\\u2193", "&DownArrow;": "\\u2193", "&Downarrow;": "\\u21D3", "&DownArrowUpArrow;": "\\u21F5", "&DownBreve;": "\\u0311", "&downdownarrows;": "\\u21CA", "&downharpoonleft;": "\\u21C3", "&downharpoonright;": "\\u21C2", "&DownLeftRightVector;": "\\u2950", "&DownLeftTeeVector;": "\\u295E", "&DownLeftVectorBar;": "\\u2956", "&DownLeftVector;": "\\u21BD", "&DownRightTeeVector;": "\\u295F", "&DownRightVectorBar;": "\\u2957", "&DownRightVector;": "\\u21C1", "&DownTeeArrow;": "\\u21A7", "&DownTee;": "\\u22A4", "&drbkarow;": "\\u2910", "&drcorn;": "\\u231F", "&drcrop;": "\\u230C", "&Dscr;": "\\uD835\\uDC9F", "&dscr;": "\\uD835\\uDCB9", "&DScy;": "\\u0405", "&dscy;": "\\u0455", "&dsol;": "\\u29F6", "&Dstrok;": "\\u0110", "&dstrok;": "\\u0111", "&dtdot;": "\\u22F1", "&dtri;": "\\u25BF", "&dtrif;": "\\u25BE", "&duarr;": "\\u21F5", "&duhar;": "\\u296F", "&dwangle;": "\\u29A6", "&DZcy;": "\\u040F", "&dzcy;": "\\u045F", "&dzigrarr;": "\\u27FF", "&Eacute;": "\\u00C9", "&Eacute": "\\u00C9", "&eacute;": "\\u00E9", "&eacute": "\\u00E9", "&easter;": "\\u2A6E", "&Ecaron;": "\\u011A", "&ecaron;": "\\u011B", "&Ecirc;": "\\u00CA", "&Ecirc": "\\u00CA", "&ecirc;": "\\u00EA", "&ecirc": "\\u00EA", "&ecir;": "\\u2256", "&ecolon;": "\\u2255", "&Ecy;": "\\u042D", "&ecy;": "\\u044D", "&eDDot;": "\\u2A77", "&Edot;": "\\u0116", "&edot;": "\\u0117", "&eDot;": "\\u2251", "&ee;": "\\u2147", "&efDot;": "\\u2252", "&Efr;": "\\uD835\\uDD08", "&efr;": "\\uD835\\uDD22", "&eg;": "\\u2A9A", "&Egrave;": "\\u00C8", "&Egrave": "\\u00C8", "&egrave;": "\\u00E8", "&egrave": "\\u00E8", "&egs;": "\\u2A96", "&egsdot;": "\\u2A98", "&el;": "\\u2A99", "&Element;": "\\u2208", "&elinters;": "\\u23E7", "&ell;": "\\u2113", "&els;": "\\u2A95", "&elsdot;": "\\u2A97", "&Emacr;": "\\u0112", "&emacr;": "\\u0113", "&empty;": "\\u2205", "&emptyset;": "\\u2205", "&EmptySmallSquare;": "\\u25FB", "&emptyv;": "\\u2205", "&EmptyVerySmallSquare;": "\\u25AB", "&emsp13;": "\\u2004", "&emsp14;": "\\u2005", "&emsp;": "\\u2003", "&ENG;": "\\u014A", "&eng;": "\\u014B", "&ensp;": "\\u2002", "&Eogon;": "\\u0118", "&eogon;": "\\u0119", "&Eopf;": "\\uD835\\uDD3C", "&eopf;": "\\uD835\\uDD56", "&epar;": "\\u22D5", "&eparsl;": "\\u29E3", "&eplus;": "\\u2A71", "&epsi;": "\\u03B5", "&Epsilon;": "\\u0395", "&epsilon;": "\\u03B5", "&epsiv;": "\\u03F5", "&eqcirc;": "\\u2256", "&eqcolon;": "\\u2255", "&eqsim;": "\\u2242", "&eqslantgtr;": "\\u2A96", "&eqslantless;": "\\u2A95", "&Equal;": "\\u2A75", "&equals;": "\\u003D", "&EqualTilde;": "\\u2242", "&equest;": "\\u225F", "&Equilibrium;": "\\u21CC", "&equiv;": "\\u2261", "&equivDD;": "\\u2A78", "&eqvparsl;": "\\u29E5", "&erarr;": "\\u2971", "&erDot;": "\\u2253", "&escr;": "\\u212F", "&Escr;": "\\u2130", "&esdot;": "\\u2250", "&Esim;": "\\u2A73", "&esim;": "\\u2242", "&Eta;": "\\u0397", "&eta;": "\\u03B7", "&ETH;": "\\u00D0", "&ETH": "\\u00D0", "&eth;": "\\u00F0", "&eth": "\\u00F0", "&Euml;": "\\u00CB", "&Euml": "\\u00CB", "&euml;": "\\u00EB", "&euml": "\\u00EB", "&euro;": "\\u20AC", "&excl;": "\\u0021", "&exist;": "\\u2203", "&Exists;": "\\u2203", "&expectation;": "\\u2130", "&exponentiale;": "\\u2147", "&ExponentialE;": "\\u2147", "&fallingdotseq;": "\\u2252", "&Fcy;": "\\u0424", "&fcy;": "\\u0444", "&female;": "\\u2640", "&ffilig;": "\\uFB03", "&fflig;": "\\uFB00", "&ffllig;": "\\uFB04", "&Ffr;": "\\uD835\\uDD09", "&ffr;": "\\uD835\\uDD23", "&filig;": "\\uFB01", "&FilledSmallSquare;": "\\u25FC", "&FilledVerySmallSquare;": "\\u25AA", "&fjlig;": "\\u0066\\u006A", "&flat;": "\\u266D", "&fllig;": "\\uFB02", "&fltns;": "\\u25B1", "&fnof;": "\\u0192", "&Fopf;": "\\uD835\\uDD3D", "&fopf;": "\\uD835\\uDD57", "&forall;": "\\u2200", "&ForAll;": "\\u2200", "&fork;": "\\u22D4", "&forkv;": "\\u2AD9", "&Fouriertrf;": "\\u2131", "&fpartint;": "\\u2A0D", "&frac12;": "\\u00BD", "&frac12": "\\u00BD", "&frac13;": "\\u2153", "&frac14;": "\\u00BC", "&frac14": "\\u00BC", "&frac15;": "\\u2155", "&frac16;": "\\u2159", "&frac18;": "\\u215B", "&frac23;": "\\u2154", "&frac25;": "\\u2156", "&frac34;": "\\u00BE", "&frac34": "\\u00BE", "&frac35;": "\\u2157", "&frac38;": "\\u215C", "&frac45;": "\\u2158", "&frac56;": "\\u215A", "&frac58;": "\\u215D", "&frac78;": "\\u215E", "&frasl;": "\\u2044", "&frown;": "\\u2322", "&fscr;": "\\uD835\\uDCBB", "&Fscr;": "\\u2131", "&gacute;": "\\u01F5", "&Gamma;": "\\u0393", "&gamma;": "\\u03B3", "&Gammad;": "\\u03DC", "&gammad;": "\\u03DD", "&gap;": "\\u2A86", "&Gbreve;": "\\u011E", "&gbreve;": "\\u011F", "&Gcedil;": "\\u0122", "&Gcirc;": "\\u011C", "&gcirc;": "\\u011D", "&Gcy;": "\\u0413", "&gcy;": "\\u0433", "&Gdot;": "\\u0120", "&gdot;": "\\u0121", "&ge;": "\\u2265", "&gE;": "\\u2267", "&gEl;": "\\u2A8C", "&gel;": "\\u22DB", "&geq;": "\\u2265", "&geqq;": "\\u2267", "&geqslant;": "\\u2A7E", "&gescc;": "\\u2AA9", "&ges;": "\\u2A7E", "&gesdot;": "\\u2A80", "&gesdoto;": "\\u2A82", "&gesdotol;": "\\u2A84", "&gesl;": "\\u22DB\\uFE00", "&gesles;": "\\u2A94", "&Gfr;": "\\uD835\\uDD0A", "&gfr;": "\\uD835\\uDD24", "&gg;": "\\u226B", "&Gg;": "\\u22D9", "&ggg;": "\\u22D9", "&gimel;": "\\u2137", "&GJcy;": "\\u0403", "&gjcy;": "\\u0453", "&gla;": "\\u2AA5", "&gl;": "\\u2277", "&glE;": "\\u2A92", "&glj;": "\\u2AA4", "&gnap;": "\\u2A8A", "&gnapprox;": "\\u2A8A", "&gne;": "\\u2A88", "&gnE;": "\\u2269", "&gneq;": "\\u2A88", "&gneqq;": "\\u2269", "&gnsim;": "\\u22E7", "&Gopf;": "\\uD835\\uDD3E", "&gopf;": "\\uD835\\uDD58", "&grave;": "\\u0060", "&GreaterEqual;": "\\u2265", "&GreaterEqualLess;": "\\u22DB", "&GreaterFullEqual;": "\\u2267", "&GreaterGreater;": "\\u2AA2", "&GreaterLess;": "\\u2277", "&GreaterSlantEqual;": "\\u2A7E", "&GreaterTilde;": "\\u2273", "&Gscr;": "\\uD835\\uDCA2", "&gscr;": "\\u210A", "&gsim;": "\\u2273", "&gsime;": "\\u2A8E", "&gsiml;": "\\u2A90", "&gtcc;": "\\u2AA7", "&gtcir;": "\\u2A7A", "&gt;": "\\u003E", "&gt": "\\u003E", "&GT;": "\\u003E", "&GT": "\\u003E", "&Gt;": "\\u226B", "&gtdot;": "\\u22D7", "&gtlPar;": "\\u2995", "&gtquest;": "\\u2A7C", "&gtrapprox;": "\\u2A86", "&gtrarr;": "\\u2978", "&gtrdot;": "\\u22D7", "&gtreqless;": "\\u22DB", "&gtreqqless;": "\\u2A8C", "&gtrless;": "\\u2277", "&gtrsim;": "\\u2273", "&gvertneqq;": "\\u2269\\uFE00", "&gvnE;": "\\u2269\\uFE00", "&Hacek;": "\\u02C7", "&hairsp;": "\\u200A", "&half;": "\\u00BD", "&hamilt;": "\\u210B", "&HARDcy;": "\\u042A", "&hardcy;": "\\u044A", "&harrcir;": "\\u2948", "&harr;": "\\u2194", "&hArr;": "\\u21D4", "&harrw;": "\\u21AD", "&Hat;": "\\u005E", "&hbar;": "\\u210F", "&Hcirc;": "\\u0124", "&hcirc;": "\\u0125", "&hearts;": "\\u2665", "&heartsuit;": "\\u2665", "&hellip;": "\\u2026", "&hercon;": "\\u22B9", "&hfr;": "\\uD835\\uDD25", "&Hfr;": "\\u210C", "&HilbertSpace;": "\\u210B", "&hksearow;": "\\u2925", "&hkswarow;": "\\u2926", "&hoarr;": "\\u21FF", "&homtht;": "\\u223B", "&hookleftarrow;": "\\u21A9", "&hookrightarrow;": "\\u21AA", "&hopf;": "\\uD835\\uDD59", "&Hopf;": "\\u210D", "&horbar;": "\\u2015", "&HorizontalLine;": "\\u2500", "&hscr;": "\\uD835\\uDCBD", "&Hscr;": "\\u210B", "&hslash;": "\\u210F", "&Hstrok;": "\\u0126", "&hstrok;": "\\u0127", "&HumpDownHump;": "\\u224E", "&HumpEqual;": "\\u224F", "&hybull;": "\\u2043", "&hyphen;": "\\u2010", "&Iacute;": "\\u00CD", "&Iacute": "\\u00CD", "&iacute;": "\\u00ED", "&iacute": "\\u00ED", "&ic;": "\\u2063", "&Icirc;": "\\u00CE", "&Icirc": "\\u00CE", "&icirc;": "\\u00EE", "&icirc": "\\u00EE", "&Icy;": "\\u0418", "&icy;": "\\u0438", "&Idot;": "\\u0130", "&IEcy;": "\\u0415", "&iecy;": "\\u0435", "&iexcl;": "\\u00A1", "&iexcl": "\\u00A1", "&iff;": "\\u21D4", "&ifr;": "\\uD835\\uDD26", "&Ifr;": "\\u2111", "&Igrave;": "\\u00CC", "&Igrave": "\\u00CC", "&igrave;": "\\u00EC", "&igrave": "\\u00EC", "&ii;": "\\u2148", "&iiiint;": "\\u2A0C", "&iiint;": "\\u222D", "&iinfin;": "\\u29DC", "&iiota;": "\\u2129", "&IJlig;": "\\u0132", "&ijlig;": "\\u0133", "&Imacr;": "\\u012A", "&imacr;": "\\u012B", "&image;": "\\u2111", "&ImaginaryI;": "\\u2148", "&imagline;": "\\u2110", "&imagpart;": "\\u2111", "&imath;": "\\u0131", "&Im;": "\\u2111", "&imof;": "\\u22B7", "&imped;": "\\u01B5", "&Implies;": "\\u21D2", "&incare;": "\\u2105", "&in;": "\\u2208", "&infin;": "\\u221E", "&infintie;": "\\u29DD", "&inodot;": "\\u0131", "&intcal;": "\\u22BA", "&int;": "\\u222B", "&Int;": "\\u222C", "&integers;": "\\u2124", "&Integral;": "\\u222B", "&intercal;": "\\u22BA", "&Intersection;": "\\u22C2", "&intlarhk;": "\\u2A17", "&intprod;": "\\u2A3C", "&InvisibleComma;": "\\u2063", "&InvisibleTimes;": "\\u2062", "&IOcy;": "\\u0401", "&iocy;": "\\u0451", "&Iogon;": "\\u012E", "&iogon;": "\\u012F", "&Iopf;": "\\uD835\\uDD40", "&iopf;": "\\uD835\\uDD5A", "&Iota;": "\\u0399", "&iota;": "\\u03B9", "&iprod;": "\\u2A3C", "&iquest;": "\\u00BF", "&iquest": "\\u00BF", "&iscr;": "\\uD835\\uDCBE", "&Iscr;": "\\u2110", "&isin;": "\\u2208", "&isindot;": "\\u22F5", "&isinE;": "\\u22F9", "&isins;": "\\u22F4", "&isinsv;": "\\u22F3", "&isinv;": "\\u2208", "&it;": "\\u2062", "&Itilde;": "\\u0128", "&itilde;": "\\u0129", "&Iukcy;": "\\u0406", "&iukcy;": "\\u0456", "&Iuml;": "\\u00CF", "&Iuml": "\\u00CF", "&iuml;": "\\u00EF", "&iuml": "\\u00EF", "&Jcirc;": "\\u0134", "&jcirc;": "\\u0135", "&Jcy;": "\\u0419", "&jcy;": "\\u0439", "&Jfr;": "\\uD835\\uDD0D", "&jfr;": "\\uD835\\uDD27", "&jmath;": "\\u0237", "&Jopf;": "\\uD835\\uDD41", "&jopf;": "\\uD835\\uDD5B", "&Jscr;": "\\uD835\\uDCA5", "&jscr;": "\\uD835\\uDCBF", "&Jsercy;": "\\u0408", "&jsercy;": "\\u0458", "&Jukcy;": "\\u0404", "&jukcy;": "\\u0454", "&Kappa;": "\\u039A", "&kappa;": "\\u03BA", "&kappav;": "\\u03F0", "&Kcedil;": "\\u0136", "&kcedil;": "\\u0137", "&Kcy;": "\\u041A", "&kcy;": "\\u043A", "&Kfr;": "\\uD835\\uDD0E", "&kfr;": "\\uD835\\uDD28", "&kgreen;": "\\u0138", "&KHcy;": "\\u0425", "&khcy;": "\\u0445", "&KJcy;": "\\u040C", "&kjcy;": "\\u045C", "&Kopf;": "\\uD835\\uDD42", "&kopf;": "\\uD835\\uDD5C", "&Kscr;": "\\uD835\\uDCA6", "&kscr;": "\\uD835\\uDCC0", "&lAarr;": "\\u21DA", "&Lacute;": "\\u0139", "&lacute;": "\\u013A", "&laemptyv;": "\\u29B4", "&lagran;": "\\u2112", "&Lambda;": "\\u039B", "&lambda;": "\\u03BB", "&lang;": "\\u27E8", "&Lang;": "\\u27EA", "&langd;": "\\u2991", "&langle;": "\\u27E8", "&lap;": "\\u2A85", "&Laplacetrf;": "\\u2112", "&laquo;": "\\u00AB", "&laquo": "\\u00AB", "&larrb;": "\\u21E4", "&larrbfs;": "\\u291F", "&larr;": "\\u2190", "&Larr;": "\\u219E", "&lArr;": "\\u21D0", "&larrfs;": "\\u291D", "&larrhk;": "\\u21A9", "&larrlp;": "\\u21AB", "&larrpl;": "\\u2939", "&larrsim;": "\\u2973", "&larrtl;": "\\u21A2", "&latail;": "\\u2919", "&lAtail;": "\\u291B", "&lat;": "\\u2AAB", "&late;": "\\u2AAD", "&lates;": "\\u2AAD\\uFE00", "&lbarr;": "\\u290C", "&lBarr;": "\\u290E", "&lbbrk;": "\\u2772", "&lbrace;": "\\u007B", "&lbrack;": "\\u005B", "&lbrke;": "\\u298B", "&lbrksld;": "\\u298F", "&lbrkslu;": "\\u298D", "&Lcaron;": "\\u013D", "&lcaron;": "\\u013E", "&Lcedil;": "\\u013B", "&lcedil;": "\\u013C", "&lceil;": "\\u2308", "&lcub;": "\\u007B", "&Lcy;": "\\u041B", "&lcy;": "\\u043B", "&ldca;": "\\u2936", "&ldquo;": "\\u201C", "&ldquor;": "\\u201E", "&ldrdhar;": "\\u2967", "&ldrushar;": "\\u294B", "&ldsh;": "\\u21B2", "&le;": "\\u2264", "&lE;": "\\u2266", "&LeftAngleBracket;": "\\u27E8", "&LeftArrowBar;": "\\u21E4", "&leftarrow;": "\\u2190", "&LeftArrow;": "\\u2190", "&Leftarrow;": "\\u21D0", "&LeftArrowRightArrow;": "\\u21C6", "&leftarrowtail;": "\\u21A2", "&LeftCeiling;": "\\u2308", "&LeftDoubleBracket;": "\\u27E6", "&LeftDownTeeVector;": "\\u2961", "&LeftDownVectorBar;": "\\u2959", "&LeftDownVector;": "\\u21C3", "&LeftFloor;": "\\u230A", "&leftharpoondown;": "\\u21BD", "&leftharpoonup;": "\\u21BC", "&leftleftarrows;": "\\u21C7", "&leftrightarrow;": "\\u2194", "&LeftRightArrow;": "\\u2194", "&Leftrightarrow;": "\\u21D4", "&leftrightarrows;": "\\u21C6", "&leftrightharpoons;": "\\u21CB", "&leftrightsquigarrow;": "\\u21AD", "&LeftRightVector;": "\\u294E", "&LeftTeeArrow;": "\\u21A4", "&LeftTee;": "\\u22A3", "&LeftTeeVector;": "\\u295A", "&leftthreetimes;": "\\u22CB", "&LeftTriangleBar;": "\\u29CF", "&LeftTriangle;": "\\u22B2", "&LeftTriangleEqual;": "\\u22B4", "&LeftUpDownVector;": "\\u2951", "&LeftUpTeeVector;": "\\u2960", "&LeftUpVectorBar;": "\\u2958", "&LeftUpVector;": "\\u21BF", "&LeftVectorBar;": "\\u2952", "&LeftVector;": "\\u21BC", "&lEg;": "\\u2A8B", "&leg;": "\\u22DA", "&leq;": "\\u2264", "&leqq;": "\\u2266", "&leqslant;": "\\u2A7D", "&lescc;": "\\u2AA8", "&les;": "\\u2A7D", "&lesdot;": "\\u2A7F", "&lesdoto;": "\\u2A81", "&lesdotor;": "\\u2A83", "&lesg;": "\\u22DA\\uFE00", "&lesges;": "\\u2A93", "&lessapprox;": "\\u2A85", "&lessdot;": "\\u22D6", "&lesseqgtr;": "\\u22DA", "&lesseqqgtr;": "\\u2A8B", "&LessEqualGreater;": "\\u22DA", "&LessFullEqual;": "\\u2266", "&LessGreater;": "\\u2276", "&lessgtr;": "\\u2276", "&LessLess;": "\\u2AA1", "&lesssim;": "\\u2272", "&LessSlantEqual;": "\\u2A7D", "&LessTilde;": "\\u2272", "&lfisht;": "\\u297C", "&lfloor;": "\\u230A", "&Lfr;": "\\uD835\\uDD0F", "&lfr;": "\\uD835\\uDD29", "&lg;": "\\u2276", "&lgE;": "\\u2A91", "&lHar;": "\\u2962", "&lhard;": "\\u21BD", "&lharu;": "\\u21BC", "&lharul;": "\\u296A", "&lhblk;": "\\u2584", "&LJcy;": "\\u0409", "&ljcy;": "\\u0459", "&llarr;": "\\u21C7", "&ll;": "\\u226A", "&Ll;": "\\u22D8", "&llcorner;": "\\u231E", "&Lleftarrow;": "\\u21DA", "&llhard;": "\\u296B", "&lltri;": "\\u25FA", "&Lmidot;": "\\u013F", "&lmidot;": "\\u0140", "&lmoustache;": "\\u23B0", "&lmoust;": "\\u23B0", "&lnap;": "\\u2A89", "&lnapprox;": "\\u2A89", "&lne;": "\\u2A87", "&lnE;": "\\u2268", "&lneq;": "\\u2A87", "&lneqq;": "\\u2268", "&lnsim;": "\\u22E6", "&loang;": "\\u27EC", "&loarr;": "\\u21FD", "&lobrk;": "\\u27E6", "&longleftarrow;": "\\u27F5", "&LongLeftArrow;": "\\u27F5", "&Longleftarrow;": "\\u27F8", "&longleftrightarrow;": "\\u27F7", "&LongLeftRightArrow;": "\\u27F7", "&Longleftrightarrow;": "\\u27FA", "&longmapsto;": "\\u27FC", "&longrightarrow;": "\\u27F6", "&LongRightArrow;": "\\u27F6", "&Longrightarrow;": "\\u27F9", "&looparrowleft;": "\\u21AB", "&looparrowright;": "\\u21AC", "&lopar;": "\\u2985", "&Lopf;": "\\uD835\\uDD43", "&lopf;": "\\uD835\\uDD5D", "&loplus;": "\\u2A2D", "&lotimes;": "\\u2A34", "&lowast;": "\\u2217", "&lowbar;": "\\u005F", "&LowerLeftArrow;": "\\u2199", "&LowerRightArrow;": "\\u2198", "&loz;": "\\u25CA", "&lozenge;": "\\u25CA", "&lozf;": "\\u29EB", "&lpar;": "\\u0028", "&lparlt;": "\\u2993", "&lrarr;": "\\u21C6", "&lrcorner;": "\\u231F", "&lrhar;": "\\u21CB", "&lrhard;": "\\u296D", "&lrm;": "\\u200E", "&lrtri;": "\\u22BF", "&lsaquo;": "\\u2039", "&lscr;": "\\uD835\\uDCC1", "&Lscr;": "\\u2112", "&lsh;": "\\u21B0", "&Lsh;": "\\u21B0", "&lsim;": "\\u2272", "&lsime;": "\\u2A8D", "&lsimg;": "\\u2A8F", "&lsqb;": "\\u005B", "&lsquo;": "\\u2018", "&lsquor;": "\\u201A", "&Lstrok;": "\\u0141", "&lstrok;": "\\u0142", "&ltcc;": "\\u2AA6", "&ltcir;": "\\u2A79", "&lt;": "\\u003C", "&lt": "\\u003C", "&LT;": "\\u003C", "&LT": "\\u003C", "&Lt;": "\\u226A", "&ltdot;": "\\u22D6", "&lthree;": "\\u22CB", "&ltimes;": "\\u22C9", "&ltlarr;": "\\u2976", "&ltquest;": "\\u2A7B", "&ltri;": "\\u25C3", "&ltrie;": "\\u22B4", "&ltrif;": "\\u25C2", "&ltrPar;": "\\u2996", "&lurdshar;": "\\u294A", "&luruhar;": "\\u2966", "&lvertneqq;": "\\u2268\\uFE00", "&lvnE;": "\\u2268\\uFE00", "&macr;": "\\u00AF", "&macr": "\\u00AF", "&male;": "\\u2642", "&malt;": "\\u2720", "&maltese;": "\\u2720", "&Map;": "\\u2905", "&map;": "\\u21A6", "&mapsto;": "\\u21A6", "&mapstodown;": "\\u21A7", "&mapstoleft;": "\\u21A4", "&mapstoup;": "\\u21A5", "&marker;": "\\u25AE", "&mcomma;": "\\u2A29", "&Mcy;": "\\u041C", "&mcy;": "\\u043C", "&mdash;": "\\u2014", "&mDDot;": "\\u223A", "&measuredangle;": "\\u2221", "&MediumSpace;": "\\u205F", "&Mellintrf;": "\\u2133", "&Mfr;": "\\uD835\\uDD10", "&mfr;": "\\uD835\\uDD2A", "&mho;": "\\u2127", "&micro;": "\\u00B5", "&micro": "\\u00B5", "&midast;": "\\u002A", "&midcir;": "\\u2AF0", "&mid;": "\\u2223", "&middot;": "\\u00B7", "&middot": "\\u00B7", "&minusb;": "\\u229F", "&minus;": "\\u2212", "&minusd;": "\\u2238", "&minusdu;": "\\u2A2A", "&MinusPlus;": "\\u2213", "&mlcp;": "\\u2ADB", "&mldr;": "\\u2026", "&mnplus;": "\\u2213", "&models;": "\\u22A7", "&Mopf;": "\\uD835\\uDD44", "&mopf;": "\\uD835\\uDD5E", "&mp;": "\\u2213", "&mscr;": "\\uD835\\uDCC2", "&Mscr;": "\\u2133", "&mstpos;": "\\u223E", "&Mu;": "\\u039C", "&mu;": "\\u03BC", "&multimap;": "\\u22B8", "&mumap;": "\\u22B8", "&nabla;": "\\u2207", "&Nacute;": "\\u0143", "&nacute;": "\\u0144", "&nang;": "\\u2220\\u20D2", "&nap;": "\\u2249", "&napE;": "\\u2A70\\u0338", "&napid;": "\\u224B\\u0338", "&napos;": "\\u0149", "&napprox;": "\\u2249", "&natural;": "\\u266E", "&naturals;": "\\u2115", "&natur;": "\\u266E", "&nbsp;": "\\u00A0", "&nbsp": "\\u00A0", "&nbump;": "\\u224E\\u0338", "&nbumpe;": "\\u224F\\u0338", "&ncap;": "\\u2A43", "&Ncaron;": "\\u0147", "&ncaron;": "\\u0148", "&Ncedil;": "\\u0145", "&ncedil;": "\\u0146", "&ncong;": "\\u2247", "&ncongdot;": "\\u2A6D\\u0338", "&ncup;": "\\u2A42", "&Ncy;": "\\u041D", "&ncy;": "\\u043D", "&ndash;": "\\u2013", "&nearhk;": "\\u2924", "&nearr;": "\\u2197", "&neArr;": "\\u21D7", "&nearrow;": "\\u2197", "&ne;": "\\u2260", "&nedot;": "\\u2250\\u0338", "&NegativeMediumSpace;": "\\u200B", "&NegativeThickSpace;": "\\u200B", "&NegativeThinSpace;": "\\u200B", "&NegativeVeryThinSpace;": "\\u200B", "&nequiv;": "\\u2262", "&nesear;": "\\u2928", "&nesim;": "\\u2242\\u0338", "&NestedGreaterGreater;": "\\u226B", "&NestedLessLess;": "\\u226A", "&NewLine;": "\\u000A", "&nexist;": "\\u2204", "&nexists;": "\\u2204", "&Nfr;": "\\uD835\\uDD11", "&nfr;": "\\uD835\\uDD2B", "&ngE;": "\\u2267\\u0338", "&nge;": "\\u2271", "&ngeq;": "\\u2271", "&ngeqq;": "\\u2267\\u0338", "&ngeqslant;": "\\u2A7E\\u0338", "&nges;": "\\u2A7E\\u0338", "&nGg;": "\\u22D9\\u0338", "&ngsim;": "\\u2275", "&nGt;": "\\u226B\\u20D2", "&ngt;": "\\u226F", "&ngtr;": "\\u226F", "&nGtv;": "\\u226B\\u0338", "&nharr;": "\\u21AE", "&nhArr;": "\\u21CE", "&nhpar;": "\\u2AF2", "&ni;": "\\u220B", "&nis;": "\\u22FC", "&nisd;": "\\u22FA", "&niv;": "\\u220B", "&NJcy;": "\\u040A", "&njcy;": "\\u045A", "&nlarr;": "\\u219A", "&nlArr;": "\\u21CD", "&nldr;": "\\u2025", "&nlE;": "\\u2266\\u0338", "&nle;": "\\u2270", "&nleftarrow;": "\\u219A", "&nLeftarrow;": "\\u21CD", "&nleftrightarrow;": "\\u21AE", "&nLeftrightarrow;": "\\u21CE", "&nleq;": "\\u2270", "&nleqq;": "\\u2266\\u0338", "&nleqslant;": "\\u2A7D\\u0338", "&nles;": "\\u2A7D\\u0338", "&nless;": "\\u226E", "&nLl;": "\\u22D8\\u0338", "&nlsim;": "\\u2274", "&nLt;": "\\u226A\\u20D2", "&nlt;": "\\u226E", "&nltri;": "\\u22EA", "&nltrie;": "\\u22EC", "&nLtv;": "\\u226A\\u0338", "&nmid;": "\\u2224", "&NoBreak;": "\\u2060", "&NonBreakingSpace;": "\\u00A0", "&nopf;": "\\uD835\\uDD5F", "&Nopf;": "\\u2115", "&Not;": "\\u2AEC", "&not;": "\\u00AC", "&not": "\\u00AC", "&NotCongruent;": "\\u2262", "&NotCupCap;": "\\u226D", "&NotDoubleVerticalBar;": "\\u2226", "&NotElement;": "\\u2209", "&NotEqual;": "\\u2260", "&NotEqualTilde;": "\\u2242\\u0338", "&NotExists;": "\\u2204", "&NotGreater;": "\\u226F", "&NotGreaterEqual;": "\\u2271", "&NotGreaterFullEqual;": "\\u2267\\u0338", "&NotGreaterGreater;": "\\u226B\\u0338", "&NotGreaterLess;": "\\u2279", "&NotGreaterSlantEqual;": "\\u2A7E\\u0338", "&NotGreaterTilde;": "\\u2275", "&NotHumpDownHump;": "\\u224E\\u0338", "&NotHumpEqual;": "\\u224F\\u0338", "&notin;": "\\u2209", "&notindot;": "\\u22F5\\u0338", "&notinE;": "\\u22F9\\u0338", "&notinva;": "\\u2209", "&notinvb;": "\\u22F7", "&notinvc;": "\\u22F6", "&NotLeftTriangleBar;": "\\u29CF\\u0338", "&NotLeftTriangle;": "\\u22EA", "&NotLeftTriangleEqual;": "\\u22EC", "&NotLess;": "\\u226E", "&NotLessEqual;": "\\u2270", "&NotLessGreater;": "\\u2278", "&NotLessLess;": "\\u226A\\u0338", "&NotLessSlantEqual;": "\\u2A7D\\u0338", "&NotLessTilde;": "\\u2274", "&NotNestedGreaterGreater;": "\\u2AA2\\u0338", "&NotNestedLessLess;": "\\u2AA1\\u0338", "&notni;": "\\u220C", "&notniva;": "\\u220C", "&notnivb;": "\\u22FE", "&notnivc;": "\\u22FD", "&NotPrecedes;": "\\u2280", "&NotPrecedesEqual;": "\\u2AAF\\u0338", "&NotPrecedesSlantEqual;": "\\u22E0", "&NotReverseElement;": "\\u220C", "&NotRightTriangleBar;": "\\u29D0\\u0338", "&NotRightTriangle;": "\\u22EB", "&NotRightTriangleEqual;": "\\u22ED", "&NotSquareSubset;": "\\u228F\\u0338", "&NotSquareSubsetEqual;": "\\u22E2", "&NotSquareSuperset;": "\\u2290\\u0338", "&NotSquareSupersetEqual;": "\\u22E3", "&NotSubset;": "\\u2282\\u20D2", "&NotSubsetEqual;": "\\u2288", "&NotSucceeds;": "\\u2281", "&NotSucceedsEqual;": "\\u2AB0\\u0338", "&NotSucceedsSlantEqual;": "\\u22E1", "&NotSucceedsTilde;": "\\u227F\\u0338", "&NotSuperset;": "\\u2283\\u20D2", "&NotSupersetEqual;": "\\u2289", "&NotTilde;": "\\u2241", "&NotTildeEqual;": "\\u2244", "&NotTildeFullEqual;": "\\u2247", "&NotTildeTilde;": "\\u2249", "&NotVerticalBar;": "\\u2224", "&nparallel;": "\\u2226", "&npar;": "\\u2226", "&nparsl;": "\\u2AFD\\u20E5", "&npart;": "\\u2202\\u0338", "&npolint;": "\\u2A14", "&npr;": "\\u2280", "&nprcue;": "\\u22E0", "&nprec;": "\\u2280", "&npreceq;": "\\u2AAF\\u0338", "&npre;": "\\u2AAF\\u0338", "&nrarrc;": "\\u2933\\u0338", "&nrarr;": "\\u219B", "&nrArr;": "\\u21CF", "&nrarrw;": "\\u219D\\u0338", "&nrightarrow;": "\\u219B", "&nRightarrow;": "\\u21CF", "&nrtri;": "\\u22EB", "&nrtrie;": "\\u22ED", "&nsc;": "\\u2281", "&nsccue;": "\\u22E1", "&nsce;": "\\u2AB0\\u0338", "&Nscr;": "\\uD835\\uDCA9", "&nscr;": "\\uD835\\uDCC3", "&nshortmid;": "\\u2224", "&nshortparallel;": "\\u2226", "&nsim;": "\\u2241", "&nsime;": "\\u2244", "&nsimeq;": "\\u2244", "&nsmid;": "\\u2224", "&nspar;": "\\u2226", "&nsqsube;": "\\u22E2", "&nsqsupe;": "\\u22E3", "&nsub;": "\\u2284", "&nsubE;": "\\u2AC5\\u0338", "&nsube;": "\\u2288", "&nsubset;": "\\u2282\\u20D2", "&nsubseteq;": "\\u2288", "&nsubseteqq;": "\\u2AC5\\u0338", "&nsucc;": "\\u2281", "&nsucceq;": "\\u2AB0\\u0338", "&nsup;": "\\u2285", "&nsupE;": "\\u2AC6\\u0338", "&nsupe;": "\\u2289", "&nsupset;": "\\u2283\\u20D2", "&nsupseteq;": "\\u2289", "&nsupseteqq;": "\\u2AC6\\u0338", "&ntgl;": "\\u2279", "&Ntilde;": "\\u00D1", "&Ntilde": "\\u00D1", "&ntilde;": "\\u00F1", "&ntilde": "\\u00F1", "&ntlg;": "\\u2278", "&ntriangleleft;": "\\u22EA", "&ntrianglelefteq;": "\\u22EC", "&ntriangleright;": "\\u22EB", "&ntrianglerighteq;": "\\u22ED", "&Nu;": "\\u039D", "&nu;": "\\u03BD", "&num;": "\\u0023", "&numero;": "\\u2116", "&numsp;": "\\u2007", "&nvap;": "\\u224D\\u20D2", "&nvdash;": "\\u22AC", "&nvDash;": "\\u22AD", "&nVdash;": "\\u22AE", "&nVDash;": "\\u22AF", "&nvge;": "\\u2265\\u20D2", "&nvgt;": "\\u003E\\u20D2", "&nvHarr;": "\\u2904", "&nvinfin;": "\\u29DE", "&nvlArr;": "\\u2902", "&nvle;": "\\u2264\\u20D2", "&nvlt;": "\\u003C\\u20D2", "&nvltrie;": "\\u22B4\\u20D2", "&nvrArr;": "\\u2903", "&nvrtrie;": "\\u22B5\\u20D2", "&nvsim;": "\\u223C\\u20D2", "&nwarhk;": "\\u2923", "&nwarr;": "\\u2196", "&nwArr;": "\\u21D6", "&nwarrow;": "\\u2196", "&nwnear;": "\\u2927", "&Oacute;": "\\u00D3", "&Oacute": "\\u00D3", "&oacute;": "\\u00F3", "&oacute": "\\u00F3", "&oast;": "\\u229B", "&Ocirc;": "\\u00D4", "&Ocirc": "\\u00D4", "&ocirc;": "\\u00F4", "&ocirc": "\\u00F4", "&ocir;": "\\u229A", "&Ocy;": "\\u041E", "&ocy;": "\\u043E", "&odash;": "\\u229D", "&Odblac;": "\\u0150", "&odblac;": "\\u0151", "&odiv;": "\\u2A38", "&odot;": "\\u2299", "&odsold;": "\\u29BC", "&OElig;": "\\u0152", "&oelig;": "\\u0153", "&ofcir;": "\\u29BF", "&Ofr;": "\\uD835\\uDD12", "&ofr;": "\\uD835\\uDD2C", "&ogon;": "\\u02DB", "&Ograve;": "\\u00D2", "&Ograve": "\\u00D2", "&ograve;": "\\u00F2", "&ograve": "\\u00F2", "&ogt;": "\\u29C1", "&ohbar;": "\\u29B5", "&ohm;": "\\u03A9", "&oint;": "\\u222E", "&olarr;": "\\u21BA", "&olcir;": "\\u29BE", "&olcross;": "\\u29BB", "&oline;": "\\u203E", "&olt;": "\\u29C0", "&Omacr;": "\\u014C", "&omacr;": "\\u014D", "&Omega;": "\\u03A9", "&omega;": "\\u03C9", "&Omicron;": "\\u039F", "&omicron;": "\\u03BF", "&omid;": "\\u29B6", "&ominus;": "\\u2296", "&Oopf;": "\\uD835\\uDD46", "&oopf;": "\\uD835\\uDD60", "&opar;": "\\u29B7", "&OpenCurlyDoubleQuote;": "\\u201C", "&OpenCurlyQuote;": "\\u2018", "&operp;": "\\u29B9", "&oplus;": "\\u2295", "&orarr;": "\\u21BB", "&Or;": "\\u2A54", "&or;": "\\u2228", "&ord;": "\\u2A5D", "&order;": "\\u2134", "&orderof;": "\\u2134", "&ordf;": "\\u00AA", "&ordf": "\\u00AA", "&ordm;": "\\u00BA", "&ordm": "\\u00BA", "&origof;": "\\u22B6", "&oror;": "\\u2A56", "&orslope;": "\\u2A57", "&orv;": "\\u2A5B", "&oS;": "\\u24C8", "&Oscr;": "\\uD835\\uDCAA", "&oscr;": "\\u2134", "&Oslash;": "\\u00D8", "&Oslash": "\\u00D8", "&oslash;": "\\u00F8", "&oslash": "\\u00F8", "&osol;": "\\u2298", "&Otilde;": "\\u00D5", "&Otilde": "\\u00D5", "&otilde;": "\\u00F5", "&otilde": "\\u00F5", "&otimesas;": "\\u2A36", "&Otimes;": "\\u2A37", "&otimes;": "\\u2297", "&Ouml;": "\\u00D6", "&Ouml": "\\u00D6", "&ouml;": "\\u00F6", "&ouml": "\\u00F6", "&ovbar;": "\\u233D", "&OverBar;": "\\u203E", "&OverBrace;": "\\u23DE", "&OverBracket;": "\\u23B4", "&OverParenthesis;": "\\u23DC", "&para;": "\\u00B6", "&para": "\\u00B6", "&parallel;": "\\u2225", "&par;": "\\u2225", "&parsim;": "\\u2AF3", "&parsl;": "\\u2AFD", "&part;": "\\u2202", "&PartialD;": "\\u2202", "&Pcy;": "\\u041F", "&pcy;": "\\u043F", "&percnt;": "\\u0025", "&period;": "\\u002E", "&permil;": "\\u2030", "&perp;": "\\u22A5", "&pertenk;": "\\u2031", "&Pfr;": "\\uD835\\uDD13", "&pfr;": "\\uD835\\uDD2D", "&Phi;": "\\u03A6", "&phi;": "\\u03C6", "&phiv;": "\\u03D5", "&phmmat;": "\\u2133", "&phone;": "\\u260E", "&Pi;": "\\u03A0", "&pi;": "\\u03C0", "&pitchfork;": "\\u22D4", "&piv;": "\\u03D6", "&planck;": "\\u210F", "&planckh;": "\\u210E", "&plankv;": "\\u210F", "&plusacir;": "\\u2A23", "&plusb;": "\\u229E", "&pluscir;": "\\u2A22", "&plus;": "\\u002B", "&plusdo;": "\\u2214", "&plusdu;": "\\u2A25", "&pluse;": "\\u2A72", "&PlusMinus;": "\\u00B1", "&plusmn;": "\\u00B1", "&plusmn": "\\u00B1", "&plussim;": "\\u2A26", "&plustwo;": "\\u2A27", "&pm;": "\\u00B1", "&Poincareplane;": "\\u210C", "&pointint;": "\\u2A15", "&popf;": "\\uD835\\uDD61", "&Popf;": "\\u2119", "&pound;": "\\u00A3", "&pound": "\\u00A3", "&prap;": "\\u2AB7", "&Pr;": "\\u2ABB", "&pr;": "\\u227A", "&prcue;": "\\u227C", "&precapprox;": "\\u2AB7", "&prec;": "\\u227A", "&preccurlyeq;": "\\u227C", "&Precedes;": "\\u227A", "&PrecedesEqual;": "\\u2AAF", "&PrecedesSlantEqual;": "\\u227C", "&PrecedesTilde;": "\\u227E", "&preceq;": "\\u2AAF", "&precnapprox;": "\\u2AB9", "&precneqq;": "\\u2AB5", "&precnsim;": "\\u22E8", "&pre;": "\\u2AAF", "&prE;": "\\u2AB3", "&precsim;": "\\u227E", "&prime;": "\\u2032", "&Prime;": "\\u2033", "&primes;": "\\u2119", "&prnap;": "\\u2AB9", "&prnE;": "\\u2AB5", "&prnsim;": "\\u22E8", "&prod;": "\\u220F", "&Product;": "\\u220F", "&profalar;": "\\u232E", "&profline;": "\\u2312", "&profsurf;": "\\u2313", "&prop;": "\\u221D", "&Proportional;": "\\u221D", "&Proportion;": "\\u2237", "&propto;": "\\u221D", "&prsim;": "\\u227E", "&prurel;": "\\u22B0", "&Pscr;": "\\uD835\\uDCAB", "&pscr;": "\\uD835\\uDCC5", "&Psi;": "\\u03A8", "&psi;": "\\u03C8", "&puncsp;": "\\u2008", "&Qfr;": "\\uD835\\uDD14", "&qfr;": "\\uD835\\uDD2E", "&qint;": "\\u2A0C", "&qopf;": "\\uD835\\uDD62", "&Qopf;": "\\u211A", "&qprime;": "\\u2057", "&Qscr;": "\\uD835\\uDCAC", "&qscr;": "\\uD835\\uDCC6", "&quaternions;": "\\u210D", "&quatint;": "\\u2A16", "&quest;": "\\u003F", "&questeq;": "\\u225F", "&quot;": "\\u0022", "&quot": "\\u0022", "&QUOT;": "\\u0022", "&QUOT": "\\u0022", "&rAarr;": "\\u21DB", "&race;": "\\u223D\\u0331", "&Racute;": "\\u0154", "&racute;": "\\u0155", "&radic;": "\\u221A", "&raemptyv;": "\\u29B3", "&rang;": "\\u27E9", "&Rang;": "\\u27EB", "&rangd;": "\\u2992", "&range;": "\\u29A5", "&rangle;": "\\u27E9", "&raquo;": "\\u00BB", "&raquo": "\\u00BB", "&rarrap;": "\\u2975", "&rarrb;": "\\u21E5", "&rarrbfs;": "\\u2920", "&rarrc;": "\\u2933", "&rarr;": "\\u2192", "&Rarr;": "\\u21A0", "&rArr;": "\\u21D2", "&rarrfs;": "\\u291E", "&rarrhk;": "\\u21AA", "&rarrlp;": "\\u21AC", "&rarrpl;": "\\u2945", "&rarrsim;": "\\u2974", "&Rarrtl;": "\\u2916", "&rarrtl;": "\\u21A3", "&rarrw;": "\\u219D", "&ratail;": "\\u291A", "&rAtail;": "\\u291C", "&ratio;": "\\u2236", "&rationals;": "\\u211A", "&rbarr;": "\\u290D", "&rBarr;": "\\u290F", "&RBarr;": "\\u2910", "&rbbrk;": "\\u2773", "&rbrace;": "\\u007D", "&rbrack;": "\\u005D", "&rbrke;": "\\u298C", "&rbrksld;": "\\u298E", "&rbrkslu;": "\\u2990", "&Rcaron;": "\\u0158", "&rcaron;": "\\u0159", "&Rcedil;": "\\u0156", "&rcedil;": "\\u0157", "&rceil;": "\\u2309", "&rcub;": "\\u007D", "&Rcy;": "\\u0420", "&rcy;": "\\u0440", "&rdca;": "\\u2937", "&rdldhar;": "\\u2969", "&rdquo;": "\\u201D", "&rdquor;": "\\u201D", "&rdsh;": "\\u21B3", "&real;": "\\u211C", "&realine;": "\\u211B", "&realpart;": "\\u211C", "&reals;": "\\u211D", "&Re;": "\\u211C", "&rect;": "\\u25AD", "&reg;": "\\u00AE", "&reg": "\\u00AE", "&REG;": "\\u00AE", "&REG": "\\u00AE", "&ReverseElement;": "\\u220B", "&ReverseEquilibrium;": "\\u21CB", "&ReverseUpEquilibrium;": "\\u296F", "&rfisht;": "\\u297D", "&rfloor;": "\\u230B", "&rfr;": "\\uD835\\uDD2F", "&Rfr;": "\\u211C", "&rHar;": "\\u2964", "&rhard;": "\\u21C1", "&rharu;": "\\u21C0", "&rharul;": "\\u296C", "&Rho;": "\\u03A1", "&rho;": "\\u03C1", "&rhov;": "\\u03F1", "&RightAngleBracket;": "\\u27E9", "&RightArrowBar;": "\\u21E5", "&rightarrow;": "\\u2192", "&RightArrow;": "\\u2192", "&Rightarrow;": "\\u21D2", "&RightArrowLeftArrow;": "\\u21C4", "&rightarrowtail;": "\\u21A3", "&RightCeiling;": "\\u2309", "&RightDoubleBracket;": "\\u27E7", "&RightDownTeeVector;": "\\u295D", "&RightDownVectorBar;": "\\u2955", "&RightDownVector;": "\\u21C2", "&RightFloor;": "\\u230B", "&rightharpoondown;": "\\u21C1", "&rightharpoonup;": "\\u21C0", "&rightleftarrows;": "\\u21C4", "&rightleftharpoons;": "\\u21CC", "&rightrightarrows;": "\\u21C9", "&rightsquigarrow;": "\\u219D", "&RightTeeArrow;": "\\u21A6", "&RightTee;": "\\u22A2", "&RightTeeVector;": "\\u295B", "&rightthreetimes;": "\\u22CC", "&RightTriangleBar;": "\\u29D0", "&RightTriangle;": "\\u22B3", "&RightTriangleEqual;": "\\u22B5", "&RightUpDownVector;": "\\u294F", "&RightUpTeeVector;": "\\u295C", "&RightUpVectorBar;": "\\u2954", "&RightUpVector;": "\\u21BE", "&RightVectorBar;": "\\u2953", "&RightVector;": "\\u21C0", "&ring;": "\\u02DA", "&risingdotseq;": "\\u2253", "&rlarr;": "\\u21C4", "&rlhar;": "\\u21CC", "&rlm;": "\\u200F", "&rmoustache;": "\\u23B1", "&rmoust;": "\\u23B1", "&rnmid;": "\\u2AEE", "&roang;": "\\u27ED", "&roarr;": "\\u21FE", "&robrk;": "\\u27E7", "&ropar;": "\\u2986", "&ropf;": "\\uD835\\uDD63", "&Ropf;": "\\u211D", "&roplus;": "\\u2A2E", "&rotimes;": "\\u2A35", "&RoundImplies;": "\\u2970", "&rpar;": "\\u0029", "&rpargt;": "\\u2994", "&rppolint;": "\\u2A12", "&rrarr;": "\\u21C9", "&Rrightarrow;": "\\u21DB", "&rsaquo;": "\\u203A", "&rscr;": "\\uD835\\uDCC7", "&Rscr;": "\\u211B", "&rsh;": "\\u21B1", "&Rsh;": "\\u21B1", "&rsqb;": "\\u005D", "&rsquo;": "\\u2019", "&rsquor;": "\\u2019", "&rthree;": "\\u22CC", "&rtimes;": "\\u22CA", "&rtri;": "\\u25B9", "&rtrie;": "\\u22B5", "&rtrif;": "\\u25B8", "&rtriltri;": "\\u29CE", "&RuleDelayed;": "\\u29F4", "&ruluhar;": "\\u2968", "&rx;": "\\u211E", "&Sacute;": "\\u015A", "&sacute;": "\\u015B", "&sbquo;": "\\u201A", "&scap;": "\\u2AB8", "&Scaron;": "\\u0160", "&scaron;": "\\u0161", "&Sc;": "\\u2ABC", "&sc;": "\\u227B", "&sccue;": "\\u227D", "&sce;": "\\u2AB0", "&scE;": "\\u2AB4", "&Scedil;": "\\u015E", "&scedil;": "\\u015F", "&Scirc;": "\\u015C", "&scirc;": "\\u015D", "&scnap;": "\\u2ABA", "&scnE;": "\\u2AB6", "&scnsim;": "\\u22E9", "&scpolint;": "\\u2A13", "&scsim;": "\\u227F", "&Scy;": "\\u0421", "&scy;": "\\u0441", "&sdotb;": "\\u22A1", "&sdot;": "\\u22C5", "&sdote;": "\\u2A66", "&searhk;": "\\u2925", "&searr;": "\\u2198", "&seArr;": "\\u21D8", "&searrow;": "\\u2198", "&sect;": "\\u00A7", "&sect": "\\u00A7", "&semi;": "\\u003B", "&seswar;": "\\u2929", "&setminus;": "\\u2216", "&setmn;": "\\u2216", "&sext;": "\\u2736", "&Sfr;": "\\uD835\\uDD16", "&sfr;": "\\uD835\\uDD30", "&sfrown;": "\\u2322", "&sharp;": "\\u266F", "&SHCHcy;": "\\u0429", "&shchcy;": "\\u0449", "&SHcy;": "\\u0428", "&shcy;": "\\u0448", "&ShortDownArrow;": "\\u2193", "&ShortLeftArrow;": "\\u2190", "&shortmid;": "\\u2223", "&shortparallel;": "\\u2225", "&ShortRightArrow;": "\\u2192", "&ShortUpArrow;": "\\u2191", "&shy;": "\\u00AD", "&shy": "\\u00AD", "&Sigma;": "\\u03A3", "&sigma;": "\\u03C3", "&sigmaf;": "\\u03C2", "&sigmav;": "\\u03C2", "&sim;": "\\u223C", "&simdot;": "\\u2A6A", "&sime;": "\\u2243", "&simeq;": "\\u2243", "&simg;": "\\u2A9E", "&simgE;": "\\u2AA0", "&siml;": "\\u2A9D", "&simlE;": "\\u2A9F", "&simne;": "\\u2246", "&simplus;": "\\u2A24", "&simrarr;": "\\u2972", "&slarr;": "\\u2190", "&SmallCircle;": "\\u2218", "&smallsetminus;": "\\u2216", "&smashp;": "\\u2A33", "&smeparsl;": "\\u29E4", "&smid;": "\\u2223", "&smile;": "\\u2323", "&smt;": "\\u2AAA", "&smte;": "\\u2AAC", "&smtes;": "\\u2AAC\\uFE00", "&SOFTcy;": "\\u042C", "&softcy;": "\\u044C", "&solbar;": "\\u233F", "&solb;": "\\u29C4", "&sol;": "\\u002F", "&Sopf;": "\\uD835\\uDD4A", "&sopf;": "\\uD835\\uDD64", "&spades;": "\\u2660", "&spadesuit;": "\\u2660", "&spar;": "\\u2225", "&sqcap;": "\\u2293", "&sqcaps;": "\\u2293\\uFE00", "&sqcup;": "\\u2294", "&sqcups;": "\\u2294\\uFE00", "&Sqrt;": "\\u221A", "&sqsub;": "\\u228F", "&sqsube;": "\\u2291", "&sqsubset;": "\\u228F", "&sqsubseteq;": "\\u2291", "&sqsup;": "\\u2290", "&sqsupe;": "\\u2292", "&sqsupset;": "\\u2290", "&sqsupseteq;": "\\u2292", "&square;": "\\u25A1", "&Square;": "\\u25A1", "&SquareIntersection;": "\\u2293", "&SquareSubset;": "\\u228F", "&SquareSubsetEqual;": "\\u2291", "&SquareSuperset;": "\\u2290", "&SquareSupersetEqual;": "\\u2292", "&SquareUnion;": "\\u2294", "&squarf;": "\\u25AA", "&squ;": "\\u25A1", "&squf;": "\\u25AA", "&srarr;": "\\u2192", "&Sscr;": "\\uD835\\uDCAE", "&sscr;": "\\uD835\\uDCC8", "&ssetmn;": "\\u2216", "&ssmile;": "\\u2323", "&sstarf;": "\\u22C6", "&Star;": "\\u22C6", "&star;": "\\u2606", "&starf;": "\\u2605", "&straightepsilon;": "\\u03F5", "&straightphi;": "\\u03D5", "&strns;": "\\u00AF", "&sub;": "\\u2282", "&Sub;": "\\u22D0", "&subdot;": "\\u2ABD", "&subE;": "\\u2AC5", "&sube;": "\\u2286", "&subedot;": "\\u2AC3", "&submult;": "\\u2AC1", "&subnE;": "\\u2ACB", "&subne;": "\\u228A", "&subplus;": "\\u2ABF", "&subrarr;": "\\u2979", "&subset;": "\\u2282", "&Subset;": "\\u22D0", "&subseteq;": "\\u2286", "&subseteqq;": "\\u2AC5", "&SubsetEqual;": "\\u2286", "&subsetneq;": "\\u228A", "&subsetneqq;": "\\u2ACB", "&subsim;": "\\u2AC7", "&subsub;": "\\u2AD5", "&subsup;": "\\u2AD3", "&succapprox;": "\\u2AB8", "&succ;": "\\u227B", "&succcurlyeq;": "\\u227D", "&Succeeds;": "\\u227B", "&SucceedsEqual;": "\\u2AB0", "&SucceedsSlantEqual;": "\\u227D", "&SucceedsTilde;": "\\u227F", "&succeq;": "\\u2AB0", "&succnapprox;": "\\u2ABA", "&succneqq;": "\\u2AB6", "&succnsim;": "\\u22E9", "&succsim;": "\\u227F", "&SuchThat;": "\\u220B", "&sum;": "\\u2211", "&Sum;": "\\u2211", "&sung;": "\\u266A", "&sup1;": "\\u00B9", "&sup1": "\\u00B9", "&sup2;": "\\u00B2", "&sup2": "\\u00B2", "&sup3;": "\\u00B3", "&sup3": "\\u00B3", "&sup;": "\\u2283", "&Sup;": "\\u22D1", "&supdot;": "\\u2ABE", "&supdsub;": "\\u2AD8", "&supE;": "\\u2AC6", "&supe;": "\\u2287", "&supedot;": "\\u2AC4", "&Superset;": "\\u2283", "&SupersetEqual;": "\\u2287", "&suphsol;": "\\u27C9", "&suphsub;": "\\u2AD7", "&suplarr;": "\\u297B", "&supmult;": "\\u2AC2", "&supnE;": "\\u2ACC", "&supne;": "\\u228B", "&supplus;": "\\u2AC0", "&supset;": "\\u2283", "&Supset;": "\\u22D1", "&supseteq;": "\\u2287", "&supseteqq;": "\\u2AC6", "&supsetneq;": "\\u228B", "&supsetneqq;": "\\u2ACC", "&supsim;": "\\u2AC8", "&supsub;": "\\u2AD4", "&supsup;": "\\u2AD6", "&swarhk;": "\\u2926", "&swarr;": "\\u2199", "&swArr;": "\\u21D9", "&swarrow;": "\\u2199", "&swnwar;": "\\u292A", "&szlig;": "\\u00DF", "&szlig": "\\u00DF", "&Tab;": "\\u0009", "&target;": "\\u2316", "&Tau;": "\\u03A4", "&tau;": "\\u03C4", "&tbrk;": "\\u23B4", "&Tcaron;": "\\u0164", "&tcaron;": "\\u0165", "&Tcedil;": "\\u0162", "&tcedil;": "\\u0163", "&Tcy;": "\\u0422", "&tcy;": "\\u0442", "&tdot;": "\\u20DB", "&telrec;": "\\u2315", "&Tfr;": "\\uD835\\uDD17", "&tfr;": "\\uD835\\uDD31", "&there4;": "\\u2234", "&therefore;": "\\u2234", "&Therefore;": "\\u2234", "&Theta;": "\\u0398", "&theta;": "\\u03B8", "&thetasym;": "\\u03D1", "&thetav;": "\\u03D1", "&thickapprox;": "\\u2248", "&thicksim;": "\\u223C", "&ThickSpace;": "\\u205F\\u200A", "&ThinSpace;": "\\u2009", "&thinsp;": "\\u2009", "&thkap;": "\\u2248", "&thksim;": "\\u223C", "&THORN;": "\\u00DE", "&THORN": "\\u00DE", "&thorn;": "\\u00FE", "&thorn": "\\u00FE", "&tilde;": "\\u02DC", "&Tilde;": "\\u223C", "&TildeEqual;": "\\u2243", "&TildeFullEqual;": "\\u2245", "&TildeTilde;": "\\u2248", "&timesbar;": "\\u2A31", "&timesb;": "\\u22A0", "&times;": "\\u00D7", "&times": "\\u00D7", "&timesd;": "\\u2A30", "&tint;": "\\u222D", "&toea;": "\\u2928", "&topbot;": "\\u2336", "&topcir;": "\\u2AF1", "&top;": "\\u22A4", "&Topf;": "\\uD835\\uDD4B", "&topf;": "\\uD835\\uDD65", "&topfork;": "\\u2ADA", "&tosa;": "\\u2929", "&tprime;": "\\u2034", "&trade;": "\\u2122", "&TRADE;": "\\u2122", "&triangle;": "\\u25B5", "&triangledown;": "\\u25BF", "&triangleleft;": "\\u25C3", "&trianglelefteq;": "\\u22B4", "&triangleq;": "\\u225C", "&triangleright;": "\\u25B9", "&trianglerighteq;": "\\u22B5", "&tridot;": "\\u25EC", "&trie;": "\\u225C", "&triminus;": "\\u2A3A", "&TripleDot;": "\\u20DB", "&triplus;": "\\u2A39", "&trisb;": "\\u29CD", "&tritime;": "\\u2A3B", "&trpezium;": "\\u23E2", "&Tscr;": "\\uD835\\uDCAF", "&tscr;": "\\uD835\\uDCC9", "&TScy;": "\\u0426", "&tscy;": "\\u0446", "&TSHcy;": "\\u040B", "&tshcy;": "\\u045B", "&Tstrok;": "\\u0166", "&tstrok;": "\\u0167", "&twixt;": "\\u226C", "&twoheadleftarrow;": "\\u219E", "&twoheadrightarrow;": "\\u21A0", "&Uacute;": "\\u00DA", "&Uacute": "\\u00DA", "&uacute;": "\\u00FA", "&uacute": "\\u00FA", "&uarr;": "\\u2191", "&Uarr;": "\\u219F", "&uArr;": "\\u21D1", "&Uarrocir;": "\\u2949", "&Ubrcy;": "\\u040E", "&ubrcy;": "\\u045E", "&Ubreve;": "\\u016C", "&ubreve;": "\\u016D", "&Ucirc;": "\\u00DB", "&Ucirc": "\\u00DB", "&ucirc;": "\\u00FB", "&ucirc": "\\u00FB", "&Ucy;": "\\u0423", "&ucy;": "\\u0443", "&udarr;": "\\u21C5", "&Udblac;": "\\u0170", "&udblac;": "\\u0171", "&udhar;": "\\u296E", "&ufisht;": "\\u297E", "&Ufr;": "\\uD835\\uDD18", "&ufr;": "\\uD835\\uDD32", "&Ugrave;": "\\u00D9", "&Ugrave": "\\u00D9", "&ugrave;": "\\u00F9", "&ugrave": "\\u00F9", "&uHar;": "\\u2963", "&uharl;": "\\u21BF", "&uharr;": "\\u21BE", "&uhblk;": "\\u2580", "&ulcorn;": "\\u231C", "&ulcorner;": "\\u231C", "&ulcrop;": "\\u230F", "&ultri;": "\\u25F8", "&Umacr;": "\\u016A", "&umacr;": "\\u016B", "&uml;": "\\u00A8", "&uml": "\\u00A8", "&UnderBar;": "\\u005F", "&UnderBrace;": "\\u23DF", "&UnderBracket;": "\\u23B5", "&UnderParenthesis;": "\\u23DD", "&Union;": "\\u22C3", "&UnionPlus;": "\\u228E", "&Uogon;": "\\u0172", "&uogon;": "\\u0173", "&Uopf;": "\\uD835\\uDD4C", "&uopf;": "\\uD835\\uDD66", "&UpArrowBar;": "\\u2912", "&uparrow;": "\\u2191", "&UpArrow;": "\\u2191", "&Uparrow;": "\\u21D1", "&UpArrowDownArrow;": "\\u21C5", "&updownarrow;": "\\u2195", "&UpDownArrow;": "\\u2195", "&Updownarrow;": "\\u21D5", "&UpEquilibrium;": "\\u296E", "&upharpoonleft;": "\\u21BF", "&upharpoonright;": "\\u21BE", "&uplus;": "\\u228E", "&UpperLeftArrow;": "\\u2196", "&UpperRightArrow;": "\\u2197", "&upsi;": "\\u03C5", "&Upsi;": "\\u03D2", "&upsih;": "\\u03D2", "&Upsilon;": "\\u03A5", "&upsilon;": "\\u03C5", "&UpTeeArrow;": "\\u21A5", "&UpTee;": "\\u22A5", "&upuparrows;": "\\u21C8", "&urcorn;": "\\u231D", "&urcorner;": "\\u231D", "&urcrop;": "\\u230E", "&Uring;": "\\u016E", "&uring;": "\\u016F", "&urtri;": "\\u25F9", "&Uscr;": "\\uD835\\uDCB0", "&uscr;": "\\uD835\\uDCCA", "&utdot;": "\\u22F0", "&Utilde;": "\\u0168", "&utilde;": "\\u0169", "&utri;": "\\u25B5", "&utrif;": "\\u25B4", "&uuarr;": "\\u21C8", "&Uuml;": "\\u00DC", "&Uuml": "\\u00DC", "&uuml;": "\\u00FC", "&uuml": "\\u00FC", "&uwangle;": "\\u29A7", "&vangrt;": "\\u299C", "&varepsilon;": "\\u03F5", "&varkappa;": "\\u03F0", "&varnothing;": "\\u2205", "&varphi;": "\\u03D5", "&varpi;": "\\u03D6", "&varpropto;": "\\u221D", "&varr;": "\\u2195", "&vArr;": "\\u21D5", "&varrho;": "\\u03F1", "&varsigma;": "\\u03C2", "&varsubsetneq;": "\\u228A\\uFE00", "&varsubsetneqq;": "\\u2ACB\\uFE00", "&varsupsetneq;": "\\u228B\\uFE00", "&varsupsetneqq;": "\\u2ACC\\uFE00", "&vartheta;": "\\u03D1", "&vartriangleleft;": "\\u22B2", "&vartriangleright;": "\\u22B3", "&vBar;": "\\u2AE8", "&Vbar;": "\\u2AEB", "&vBarv;": "\\u2AE9", "&Vcy;": "\\u0412", "&vcy;": "\\u0432", "&vdash;": "\\u22A2", "&vDash;": "\\u22A8", "&Vdash;": "\\u22A9", "&VDash;": "\\u22AB", "&Vdashl;": "\\u2AE6", "&veebar;": "\\u22BB", "&vee;": "\\u2228", "&Vee;": "\\u22C1", "&veeeq;": "\\u225A", "&vellip;": "\\u22EE", "&verbar;": "\\u007C", "&Verbar;": "\\u2016", "&vert;": "\\u007C", "&Vert;": "\\u2016", "&VerticalBar;": "\\u2223", "&VerticalLine;": "\\u007C", "&VerticalSeparator;": "\\u2758", "&VerticalTilde;": "\\u2240", "&VeryThinSpace;": "\\u200A", "&Vfr;": "\\uD835\\uDD19", "&vfr;": "\\uD835\\uDD33", "&vltri;": "\\u22B2", "&vnsub;": "\\u2282\\u20D2", "&vnsup;": "\\u2283\\u20D2", "&Vopf;": "\\uD835\\uDD4D", "&vopf;": "\\uD835\\uDD67", "&vprop;": "\\u221D", "&vrtri;": "\\u22B3", "&Vscr;": "\\uD835\\uDCB1", "&vscr;": "\\uD835\\uDCCB", "&vsubnE;": "\\u2ACB\\uFE00", "&vsubne;": "\\u228A\\uFE00", "&vsupnE;": "\\u2ACC\\uFE00", "&vsupne;": "\\u228B\\uFE00", "&Vvdash;": "\\u22AA", "&vzigzag;": "\\u299A", "&Wcirc;": "\\u0174", "&wcirc;": "\\u0175", "&wedbar;": "\\u2A5F", "&wedge;": "\\u2227", "&Wedge;": "\\u22C0", "&wedgeq;": "\\u2259", "&weierp;": "\\u2118", "&Wfr;": "\\uD835\\uDD1A", "&wfr;": "\\uD835\\uDD34", "&Wopf;": "\\uD835\\uDD4E", "&wopf;": "\\uD835\\uDD68", "&wp;": "\\u2118", "&wr;": "\\u2240", "&wreath;": "\\u2240", "&Wscr;": "\\uD835\\uDCB2", "&wscr;": "\\uD835\\uDCCC", "&xcap;": "\\u22C2", "&xcirc;": "\\u25EF", "&xcup;": "\\u22C3", "&xdtri;": "\\u25BD", "&Xfr;": "\\uD835\\uDD1B", "&xfr;": "\\uD835\\uDD35", "&xharr;": "\\u27F7", "&xhArr;": "\\u27FA", "&Xi;": "\\u039E", "&xi;": "\\u03BE", "&xlarr;": "\\u27F5", "&xlArr;": "\\u27F8", "&xmap;": "\\u27FC", "&xnis;": "\\u22FB", "&xodot;": "\\u2A00", "&Xopf;": "\\uD835\\uDD4F", "&xopf;": "\\uD835\\uDD69", "&xoplus;": "\\u2A01", "&xotime;": "\\u2A02", "&xrarr;": "\\u27F6", "&xrArr;": "\\u27F9", "&Xscr;": "\\uD835\\uDCB3", "&xscr;": "\\uD835\\uDCCD", "&xsqcup;": "\\u2A06", "&xuplus;": "\\u2A04", "&xutri;": "\\u25B3", "&xvee;": "\\u22C1", "&xwedge;": "\\u22C0", "&Yacute;": "\\u00DD", "&Yacute": "\\u00DD", "&yacute;": "\\u00FD", "&yacute": "\\u00FD", "&YAcy;": "\\u042F", "&yacy;": "\\u044F", "&Ycirc;": "\\u0176", "&ycirc;": "\\u0177", "&Ycy;": "\\u042B", "&ycy;": "\\u044B", "&yen;": "\\u00A5", "&yen": "\\u00A5", "&Yfr;": "\\uD835\\uDD1C", "&yfr;": "\\uD835\\uDD36", "&YIcy;": "\\u0407", "&yicy;": "\\u0457", "&Yopf;": "\\uD835\\uDD50", "&yopf;": "\\uD835\\uDD6A", "&Yscr;": "\\uD835\\uDCB4", "&yscr;": "\\uD835\\uDCCE", "&YUcy;": "\\u042E", "&yucy;": "\\u044E", "&yuml;": "\\u00FF", "&yuml": "\\u00FF", "&Yuml;": "\\u0178", "&Zacute;": "\\u0179", "&zacute;": "\\u017A", "&Zcaron;": "\\u017D", "&zcaron;": "\\u017E", "&Zcy;": "\\u0417", "&zcy;": "\\u0437", "&Zdot;": "\\u017B", "&zdot;": "\\u017C", "&zeetrf;": "\\u2128", "&ZeroWidthSpace;": "\\u200B", "&Zeta;": "\\u0396", "&zeta;": "\\u03B6", "&zfr;": "\\uD835\\uDD37", "&Zfr;": "\\u2128", "&ZHcy;": "\\u0416", "&zhcy;": "\\u0436", "&zigrarr;": "\\u21DD", "&zopf;": "\\uD835\\uDD6B", "&Zopf;": "\\u2124", "&Zscr;": "\\uD835\\uDCB5", "&zscr;": "\\uD835\\uDCCF", "&zwj;": "\\u200D", "&zwnj;": "\\u200C"}`);
var htmlNumEntities = JSON.parse(`{"193": "\\u00C1", "193": "\\u00C1", "225": "\\u00E1", "225": "\\u00E1", "258": "\\u0102", "259": "\\u0103", "8766": "\\u223E", "8767": "\\u223F", "8766": "\\u223E", "819": "\\u0333", "194": "\\u00C2", "194": "\\u00C2", "226": "\\u00E2", "226": "\\u00E2", "180": "\\u00B4", "180": "\\u00B4", "1040": "\\u0410", "1072": "\\u0430", "198": "\\u00C6", "198": "\\u00C6", "230": "\\u00E6", "230": "\\u00E6", "8289": "\\u2061", "120068": "\\uD835\\uDD04", "120094": "\\uD835\\uDD1E", "192": "\\u00C0", "192": "\\u00C0", "224": "\\u00E0", "224": "\\u00E0", "8501": "\\u2135", "8501": "\\u2135", "913": "\\u0391", "945": "\\u03B1", "256": "\\u0100", "257": "\\u0101", "10815": "\\u2A3F", "38": "\\u0026", "38": "\\u0026", "38": "\\u0026", "38": "\\u0026", "10837": "\\u2A55", "10835": "\\u2A53", "8743": "\\u2227", "10844": "\\u2A5C", "10840": "\\u2A58", "10842": "\\u2A5A", "8736": "\\u2220", "10660": "\\u29A4", "8736": "\\u2220", "10664": "\\u29A8", "10665": "\\u29A9", "10666": "\\u29AA", "10667": "\\u29AB", "10668": "\\u29AC", "10669": "\\u29AD", "10670": "\\u29AE", "10671": "\\u29AF", "8737": "\\u2221", "8735": "\\u221F", "8894": "\\u22BE", "10653": "\\u299D", "8738": "\\u2222", "197": "\\u00C5", "9084": "\\u237C", "260": "\\u0104", "261": "\\u0105", "120120": "\\uD835\\uDD38", "120146": "\\uD835\\uDD52", "10863": "\\u2A6F", "8776": "\\u2248", "10864": "\\u2A70", "8778": "\\u224A", "8779": "\\u224B", "39": "\\u0027", "8289": "\\u2061", "8776": "\\u2248", "8778": "\\u224A", "197": "\\u00C5", "197": "\\u00C5", "229": "\\u00E5", "229": "\\u00E5", "119964": "\\uD835\\uDC9C", "119990": "\\uD835\\uDCB6", "8788": "\\u2254", "42": "\\u002A", "8776": "\\u2248", "8781": "\\u224D", "195": "\\u00C3", "195": "\\u00C3", "227": "\\u00E3", "227": "\\u00E3", "196": "\\u00C4", "196": "\\u00C4", "228": "\\u00E4", "228": "\\u00E4", "8755": "\\u2233", "10769": "\\u2A11", "8780": "\\u224C", "1014": "\\u03F6", "8245": "\\u2035", "8765": "\\u223D", "8909": "\\u22CD", "8726": "\\u2216", "10983": "\\u2AE7", "8893": "\\u22BD", "8965": "\\u2305", "8966": "\\u2306", "8965": "\\u2305", "9141": "\\u23B5", "9142": "\\u23B6", "8780": "\\u224C", "1041": "\\u0411", "1073": "\\u0431", "8222": "\\u201E", "8757": "\\u2235", "8757": "\\u2235", "8757": "\\u2235", "10672": "\\u29B0", "1014": "\\u03F6", "8492": "\\u212C", "8492": "\\u212C", "914": "\\u0392", "946": "\\u03B2", "8502": "\\u2136", "8812": "\\u226C", "120069": "\\uD835\\uDD05", "120095": "\\uD835\\uDD1F", "8898": "\\u22C2", "9711": "\\u25EF", "8899": "\\u22C3", "10752": "\\u2A00", "10753": "\\u2A01", "10754": "\\u2A02", "10758": "\\u2A06", "9733": "\\u2605", "9661": "\\u25BD", "9651": "\\u25B3", "10756": "\\u2A04", "8897": "\\u22C1", "8896": "\\u22C0", "10509": "\\u290D", "10731": "\\u29EB", "9642": "\\u25AA", "9652": "\\u25B4", "9662": "\\u25BE", "9666": "\\u25C2", "9656": "\\u25B8", "9251": "\\u2423", "9618": "\\u2592", "9617": "\\u2591", "9619": "\\u2593", "9608": "\\u2588", "61": "\\u003D", "8421": "\\u20E5", "8801": "\\u2261", "8421": "\\u20E5", "10989": "\\u2AED", "8976": "\\u2310", "120121": "\\uD835\\uDD39", "120147": "\\uD835\\uDD53", "8869": "\\u22A5", "8869": "\\u22A5", "8904": "\\u22C8", "10697": "\\u29C9", "9488": "\\u2510", "9557": "\\u2555", "9558": "\\u2556", "9559": "\\u2557", "9484": "\\u250C", "9554": "\\u2552", "9555": "\\u2553", "9556": "\\u2554", "9472": "\\u2500", "9552": "\\u2550", "9516": "\\u252C", "9572": "\\u2564", "9573": "\\u2565", "9574": "\\u2566", "9524": "\\u2534", "9575": "\\u2567", "9576": "\\u2568", "9577": "\\u2569", "8863": "\\u229F", "8862": "\\u229E", "8864": "\\u22A0", "9496": "\\u2518", "9563": "\\u255B", "9564": "\\u255C", "9565": "\\u255D", "9492": "\\u2514", "9560": "\\u2558", "9561": "\\u2559", "9562": "\\u255A", "9474": "\\u2502", "9553": "\\u2551", "9532": "\\u253C", "9578": "\\u256A", "9579": "\\u256B", "9580": "\\u256C", "9508": "\\u2524", "9569": "\\u2561", "9570": "\\u2562", "9571": "\\u2563", "9500": "\\u251C", "9566": "\\u255E", "9567": "\\u255F", "9568": "\\u2560", "8245": "\\u2035", "728": "\\u02D8", "728": "\\u02D8", "166": "\\u00A6", "166": "\\u00A6", "119991": "\\uD835\\uDCB7", "8492": "\\u212C", "8271": "\\u204F", "8765": "\\u223D", "8909": "\\u22CD", "10693": "\\u29C5", "92": "\\u005C", "10184": "\\u27C8", "8226": "\\u2022", "8226": "\\u2022", "8782": "\\u224E", "10926": "\\u2AAE", "8783": "\\u224F", "8782": "\\u224E", "8783": "\\u224F", "262": "\\u0106", "263": "\\u0107", "10820": "\\u2A44", "10825": "\\u2A49", "10827": "\\u2A4B", "8745": "\\u2229", "8914": "\\u22D2", "10823": "\\u2A47", "10816": "\\u2A40", "8517": "\\u2145", "8745": "\\u2229", "65024": "\\uFE00", "8257": "\\u2041", "711": "\\u02C7", "8493": "\\u212D", "10829": "\\u2A4D", "268": "\\u010C", "269": "\\u010D", "199": "\\u00C7", "199": "\\u00C7", "231": "\\u00E7", "231": "\\u00E7", "264": "\\u0108", "265": "\\u0109", "8752": "\\u2230", "10828": "\\u2A4C", "10832": "\\u2A50", "266": "\\u010A", "267": "\\u010B", "184": "\\u00B8", "184": "\\u00B8", "184": "\\u00B8", "10674": "\\u29B2", "162": "\\u00A2", "162": "\\u00A2", "183": "\\u00B7", "183": "\\u00B7", "120096": "\\uD835\\uDD20", "8493": "\\u212D", "1063": "\\u0427", "1095": "\\u0447", "10003": "\\u2713", "10003": "\\u2713", "935": "\\u03A7", "967": "\\u03C7", "710": "\\u02C6", "8791": "\\u2257", "8634": "\\u21BA", "8635": "\\u21BB", "8859": "\\u229B", "8858": "\\u229A", "8861": "\\u229D", "8857": "\\u2299", "174": "\\u00AE", "9416": "\\u24C8", "8854": "\\u2296", "8853": "\\u2295", "8855": "\\u2297", "9675": "\\u25CB", "10691": "\\u29C3", "8791": "\\u2257", "10768": "\\u2A10", "10991": "\\u2AEF", "10690": "\\u29C2", "8754": "\\u2232", "8221": "\\u201D", "8217": "\\u2019", "9827": "\\u2663", "9827": "\\u2663", "58": "\\u003A", "8759": "\\u2237", "10868": "\\u2A74", "8788": "\\u2254", "8788": "\\u2254", "44": "\\u002C", "64": "\\u0040", "8705": "\\u2201", "8728": "\\u2218", "8705": "\\u2201", "8450": "\\u2102", "8773": "\\u2245", "10861": "\\u2A6D", "8801": "\\u2261", "8750": "\\u222E", "8751": "\\u222F", "8750": "\\u222E", "120148": "\\uD835\\uDD54", "8450": "\\u2102", "8720": "\\u2210", "8720": "\\u2210", "169": "\\u00A9", "169": "\\u00A9", "169": "\\u00A9", "169": "\\u00A9", "8471": "\\u2117", "8755": "\\u2233", "8629": "\\u21B5", "10007": "\\u2717", "10799": "\\u2A2F", "119966": "\\uD835\\uDC9E", "119992": "\\uD835\\uDCB8", "10959": "\\u2ACF", "10961": "\\u2AD1", "10960": "\\u2AD0", "10962": "\\u2AD2", "8943": "\\u22EF", "10552": "\\u2938", "10549": "\\u2935", "8926": "\\u22DE", "8927": "\\u22DF", "8630": "\\u21B6", "10557": "\\u293D", "10824": "\\u2A48", "10822": "\\u2A46", "8781": "\\u224D", "8746": "\\u222A", "8915": "\\u22D3", "10826": "\\u2A4A", "8845": "\\u228D", "10821": "\\u2A45", "8746": "\\u222A", "65024": "\\uFE00", "8631": "\\u21B7", "10556": "\\u293C", "8926": "\\u22DE", "8927": "\\u22DF", "8910": "\\u22CE", "8911": "\\u22CF", "164": "\\u00A4", "164": "\\u00A4", "8630": "\\u21B6", "8631": "\\u21B7", "8910": "\\u22CE", "8911": "\\u22CF", "8754": "\\u2232", "8753": "\\u2231", "9005": "\\u232D", "8224": "\\u2020", "8225": "\\u2021", "8504": "\\u2138", "8595": "\\u2193", "8609": "\\u21A1", "8659": "\\u21D3", "8208": "\\u2010", "10980": "\\u2AE4", "8867": "\\u22A3", "10511": "\\u290F", "733": "\\u02DD", "270": "\\u010E", "271": "\\u010F", "1044": "\\u0414", "1076": "\\u0434", "8225": "\\u2021", "8650": "\\u21CA", "8517": "\\u2145", "8518": "\\u2146", "10513": "\\u2911", "10871": "\\u2A77", "176": "\\u00B0", "176": "\\u00B0", "8711": "\\u2207", "916": "\\u0394", "948": "\\u03B4", "10673": "\\u29B1", "10623": "\\u297F", "120071": "\\uD835\\uDD07", "120097": "\\uD835\\uDD21", "10597": "\\u2965", "8643": "\\u21C3", "8642": "\\u21C2", "180": "\\u00B4", "729": "\\u02D9", "733": "\\u02DD", "96": "\\u0060", "732": "\\u02DC", "8900": "\\u22C4", "8900": "\\u22C4", "8900": "\\u22C4", "9830": "\\u2666", "9830": "\\u2666", "168": "\\u00A8", "8518": "\\u2146", "989": "\\u03DD", "8946": "\\u22F2", "247": "\\u00F7", "247": "\\u00F7", "247": "\\u00F7", "8903": "\\u22C7", "8903": "\\u22C7", "1026": "\\u0402", "1106": "\\u0452", "8990": "\\u231E", "8973": "\\u230D", "36": "\\u0024", "120123": "\\uD835\\uDD3B", "120149": "\\uD835\\uDD55", "168": "\\u00A8", "729": "\\u02D9", "8412": "\\u20DC", "8784": "\\u2250", "8785": "\\u2251", "8784": "\\u2250", "8760": "\\u2238", "8724": "\\u2214", "8865": "\\u22A1", "8966": "\\u2306", "8751": "\\u222F", "168": "\\u00A8", "8659": "\\u21D3", "8656": "\\u21D0", "8660": "\\u21D4", "10980": "\\u2AE4", "10232": "\\u27F8", "10234": "\\u27FA", "10233": "\\u27F9", "8658": "\\u21D2", "8872": "\\u22A8", "8657": "\\u21D1", "8661": "\\u21D5", "8741": "\\u2225", "10515": "\\u2913", "8595": "\\u2193", "8595": "\\u2193", "8659": "\\u21D3", "8693": "\\u21F5", "785": "\\u0311", "8650": "\\u21CA", "8643": "\\u21C3", "8642": "\\u21C2", "10576": "\\u2950", "10590": "\\u295E", "10582": "\\u2956", "8637": "\\u21BD", "10591": "\\u295F", "10583": "\\u2957", "8641": "\\u21C1", "8615": "\\u21A7", "8868": "\\u22A4", "10512": "\\u2910", "8991": "\\u231F", "8972": "\\u230C", "119967": "\\uD835\\uDC9F", "119993": "\\uD835\\uDCB9", "1029": "\\u0405", "1109": "\\u0455", "10742": "\\u29F6", "272": "\\u0110", "273": "\\u0111", "8945": "\\u22F1", "9663": "\\u25BF", "9662": "\\u25BE", "8693": "\\u21F5", "10607": "\\u296F", "10662": "\\u29A6", "1039": "\\u040F", "1119": "\\u045F", "10239": "\\u27FF", "201": "\\u00C9", "201": "\\u00C9", "233": "\\u00E9", "233": "\\u00E9", "10862": "\\u2A6E", "282": "\\u011A", "283": "\\u011B", "202": "\\u00CA", "202": "\\u00CA", "234": "\\u00EA", "234": "\\u00EA", "8790": "\\u2256", "8789": "\\u2255", "1069": "\\u042D", "1101": "\\u044D", "10871": "\\u2A77", "278": "\\u0116", "279": "\\u0117", "8785": "\\u2251", "8519": "\\u2147", "8786": "\\u2252", "120072": "\\uD835\\uDD08", "120098": "\\uD835\\uDD22", "10906": "\\u2A9A", "200": "\\u00C8", "200": "\\u00C8", "232": "\\u00E8", "232": "\\u00E8", "10902": "\\u2A96", "10904": "\\u2A98", "10905": "\\u2A99", "8712": "\\u2208", "9191": "\\u23E7", "8467": "\\u2113", "10901": "\\u2A95", "10903": "\\u2A97", "274": "\\u0112", "275": "\\u0113", "8709": "\\u2205", "8709": "\\u2205", "9723": "\\u25FB", "8709": "\\u2205", "9643": "\\u25AB", "8196": "\\u2004", "8197": "\\u2005", "8195": "\\u2003", "330": "\\u014A", "331": "\\u014B", "8194": "\\u2002", "280": "\\u0118", "281": "\\u0119", "120124": "\\uD835\\uDD3C", "120150": "\\uD835\\uDD56", "8917": "\\u22D5", "10723": "\\u29E3", "10865": "\\u2A71", "949": "\\u03B5", "917": "\\u0395", "949": "\\u03B5", "1013": "\\u03F5", "8790": "\\u2256", "8789": "\\u2255", "8770": "\\u2242", "10902": "\\u2A96", "10901": "\\u2A95", "10869": "\\u2A75", "61": "\\u003D", "8770": "\\u2242", "8799": "\\u225F", "8652": "\\u21CC", "8801": "\\u2261", "10872": "\\u2A78", "10725": "\\u29E5", "10609": "\\u2971", "8787": "\\u2253", "8495": "\\u212F", "8496": "\\u2130", "8784": "\\u2250", "10867": "\\u2A73", "8770": "\\u2242", "919": "\\u0397", "951": "\\u03B7", "208": "\\u00D0", "208": "\\u00D0", "240": "\\u00F0", "240": "\\u00F0", "203": "\\u00CB", "203": "\\u00CB", "235": "\\u00EB", "235": "\\u00EB", "8364": "\\u20AC", "33": "\\u0021", "8707": "\\u2203", "8707": "\\u2203", "8496": "\\u2130", "8519": "\\u2147", "8519": "\\u2147", "8786": "\\u2252", "1060": "\\u0424", "1092": "\\u0444", "9792": "\\u2640", "64259": "\\uFB03", "64256": "\\uFB00", "64260": "\\uFB04", "120073": "\\uD835\\uDD09", "120099": "\\uD835\\uDD23", "64257": "\\uFB01", "9724": "\\u25FC", "9642": "\\u25AA", "102": "\\u0066", "106": "\\u006A", "9837": "\\u266D", "64258": "\\uFB02", "9649": "\\u25B1", "402": "\\u0192", "120125": "\\uD835\\uDD3D", "120151": "\\uD835\\uDD57", "8704": "\\u2200", "8704": "\\u2200", "8916": "\\u22D4", "10969": "\\u2AD9", "8497": "\\u2131", "10765": "\\u2A0D", "189": "\\u00BD", "189": "\\u00BD", "8531": "\\u2153", "188": "\\u00BC", "188": "\\u00BC", "8533": "\\u2155", "8537": "\\u2159", "8539": "\\u215B", "8532": "\\u2154", "8534": "\\u2156", "190": "\\u00BE", "190": "\\u00BE", "8535": "\\u2157", "8540": "\\u215C", "8536": "\\u2158", "8538": "\\u215A", "8541": "\\u215D", "8542": "\\u215E", "8260": "\\u2044", "8994": "\\u2322", "119995": "\\uD835\\uDCBB", "8497": "\\u2131", "501": "\\u01F5", "915": "\\u0393", "947": "\\u03B3", "988": "\\u03DC", "989": "\\u03DD", "10886": "\\u2A86", "286": "\\u011E", "287": "\\u011F", "290": "\\u0122", "284": "\\u011C", "285": "\\u011D", "1043": "\\u0413", "1075": "\\u0433", "288": "\\u0120", "289": "\\u0121", "8805": "\\u2265", "8807": "\\u2267", "10892": "\\u2A8C", "8923": "\\u22DB", "8805": "\\u2265", "8807": "\\u2267", "10878": "\\u2A7E", "10921": "\\u2AA9", "10878": "\\u2A7E", "10880": "\\u2A80", "10882": "\\u2A82", "10884": "\\u2A84", "8923": "\\u22DB", "65024": "\\uFE00", "10900": "\\u2A94", "120074": "\\uD835\\uDD0A", "120100": "\\uD835\\uDD24", "8811": "\\u226B", "8921": "\\u22D9", "8921": "\\u22D9", "8503": "\\u2137", "1027": "\\u0403", "1107": "\\u0453", "10917": "\\u2AA5", "8823": "\\u2277", "10898": "\\u2A92", "10916": "\\u2AA4", "10890": "\\u2A8A", "10890": "\\u2A8A", "10888": "\\u2A88", "8809": "\\u2269", "10888": "\\u2A88", "8809": "\\u2269", "8935": "\\u22E7", "120126": "\\uD835\\uDD3E", "120152": "\\uD835\\uDD58", "96": "\\u0060", "8805": "\\u2265", "8923": "\\u22DB", "8807": "\\u2267", "10914": "\\u2AA2", "8823": "\\u2277", "10878": "\\u2A7E", "8819": "\\u2273", "119970": "\\uD835\\uDCA2", "8458": "\\u210A", "8819": "\\u2273", "10894": "\\u2A8E", "10896": "\\u2A90", "10919": "\\u2AA7", "10874": "\\u2A7A", "62": "\\u003E", "62": "\\u003E", "62": "\\u003E", "62": "\\u003E", "8811": "\\u226B", "8919": "\\u22D7", "10645": "\\u2995", "10876": "\\u2A7C", "10886": "\\u2A86", "10616": "\\u2978", "8919": "\\u22D7", "8923": "\\u22DB", "10892": "\\u2A8C", "8823": "\\u2277", "8819": "\\u2273", "8809": "\\u2269", "65024": "\\uFE00", "8809": "\\u2269", "65024": "\\uFE00", "711": "\\u02C7", "8202": "\\u200A", "189": "\\u00BD", "8459": "\\u210B", "1066": "\\u042A", "1098": "\\u044A", "10568": "\\u2948", "8596": "\\u2194", "8660": "\\u21D4", "8621": "\\u21AD", "94": "\\u005E", "8463": "\\u210F", "292": "\\u0124", "293": "\\u0125", "9829": "\\u2665", "9829": "\\u2665", "8230": "\\u2026", "8889": "\\u22B9", "120101": "\\uD835\\uDD25", "8460": "\\u210C", "8459": "\\u210B", "10533": "\\u2925", "10534": "\\u2926", "8703": "\\u21FF", "8763": "\\u223B", "8617": "\\u21A9", "8618": "\\u21AA", "120153": "\\uD835\\uDD59", "8461": "\\u210D", "8213": "\\u2015", "9472": "\\u2500", "119997": "\\uD835\\uDCBD", "8459": "\\u210B", "8463": "\\u210F", "294": "\\u0126", "295": "\\u0127", "8782": "\\u224E", "8783": "\\u224F", "8259": "\\u2043", "8208": "\\u2010", "205": "\\u00CD", "205": "\\u00CD", "237": "\\u00ED", "237": "\\u00ED", "8291": "\\u2063", "206": "\\u00CE", "206": "\\u00CE", "238": "\\u00EE", "238": "\\u00EE", "1048": "\\u0418", "1080": "\\u0438", "304": "\\u0130", "1045": "\\u0415", "1077": "\\u0435", "161": "\\u00A1", "161": "\\u00A1", "8660": "\\u21D4", "120102": "\\uD835\\uDD26", "8465": "\\u2111", "204": "\\u00CC", "204": "\\u00CC", "236": "\\u00EC", "236": "\\u00EC", "8520": "\\u2148", "10764": "\\u2A0C", "8749": "\\u222D", "10716": "\\u29DC", "8489": "\\u2129", "306": "\\u0132", "307": "\\u0133", "298": "\\u012A", "299": "\\u012B", "8465": "\\u2111", "8520": "\\u2148", "8464": "\\u2110", "8465": "\\u2111", "305": "\\u0131", "8465": "\\u2111", "8887": "\\u22B7", "437": "\\u01B5", "8658": "\\u21D2", "8453": "\\u2105", "8712": "\\u2208", "8734": "\\u221E", "10717": "\\u29DD", "305": "\\u0131", "8890": "\\u22BA", "8747": "\\u222B", "8748": "\\u222C", "8484": "\\u2124", "8747": "\\u222B", "8890": "\\u22BA", "8898": "\\u22C2", "10775": "\\u2A17", "10812": "\\u2A3C", "8291": "\\u2063", "8290": "\\u2062", "1025": "\\u0401", "1105": "\\u0451", "302": "\\u012E", "303": "\\u012F", "120128": "\\uD835\\uDD40", "120154": "\\uD835\\uDD5A", "921": "\\u0399", "953": "\\u03B9", "10812": "\\u2A3C", "191": "\\u00BF", "191": "\\u00BF", "119998": "\\uD835\\uDCBE", "8464": "\\u2110", "8712": "\\u2208", "8949": "\\u22F5", "8953": "\\u22F9", "8948": "\\u22F4", "8947": "\\u22F3", "8712": "\\u2208", "8290": "\\u2062", "296": "\\u0128", "297": "\\u0129", "1030": "\\u0406", "1110": "\\u0456", "207": "\\u00CF", "207": "\\u00CF", "239": "\\u00EF", "239": "\\u00EF", "308": "\\u0134", "309": "\\u0135", "1049": "\\u0419", "1081": "\\u0439", "120077": "\\uD835\\uDD0D", "120103": "\\uD835\\uDD27", "567": "\\u0237", "120129": "\\uD835\\uDD41", "120155": "\\uD835\\uDD5B", "119973": "\\uD835\\uDCA5", "119999": "\\uD835\\uDCBF", "1032": "\\u0408", "1112": "\\u0458", "1028": "\\u0404", "1108": "\\u0454", "922": "\\u039A", "954": "\\u03BA", "1008": "\\u03F0", "310": "\\u0136", "311": "\\u0137", "1050": "\\u041A", "1082": "\\u043A", "120078": "\\uD835\\uDD0E", "120104": "\\uD835\\uDD28", "312": "\\u0138", "1061": "\\u0425", "1093": "\\u0445", "1036": "\\u040C", "1116": "\\u045C", "120130": "\\uD835\\uDD42", "120156": "\\uD835\\uDD5C", "119974": "\\uD835\\uDCA6", "120000": "\\uD835\\uDCC0", "8666": "\\u21DA", "313": "\\u0139", "314": "\\u013A", "10676": "\\u29B4", "8466": "\\u2112", "923": "\\u039B", "955": "\\u03BB", "10216": "\\u27E8", "10218": "\\u27EA", "10641": "\\u2991", "10216": "\\u27E8", "10885": "\\u2A85", "8466": "\\u2112", "171": "\\u00AB", "171": "\\u00AB", "8676": "\\u21E4", "10527": "\\u291F", "8592": "\\u2190", "8606": "\\u219E", "8656": "\\u21D0", "10525": "\\u291D", "8617": "\\u21A9", "8619": "\\u21AB", "10553": "\\u2939", "10611": "\\u2973", "8610": "\\u21A2", "10521": "\\u2919", "10523": "\\u291B", "10923": "\\u2AAB", "10925": "\\u2AAD", "10925": "\\u2AAD", "65024": "\\uFE00", "10508": "\\u290C", "10510": "\\u290E", "10098": "\\u2772", "123": "\\u007B", "91": "\\u005B", "10635": "\\u298B", "10639": "\\u298F", "10637": "\\u298D", "317": "\\u013D", "318": "\\u013E", "315": "\\u013B", "316": "\\u013C", "8968": "\\u2308", "123": "\\u007B", "1051": "\\u041B", "1083": "\\u043B", "10550": "\\u2936", "8220": "\\u201C", "8222": "\\u201E", "10599": "\\u2967", "10571": "\\u294B", "8626": "\\u21B2", "8804": "\\u2264", "8806": "\\u2266", "10216": "\\u27E8", "8676": "\\u21E4", "8592": "\\u2190", "8592": "\\u2190", "8656": "\\u21D0", "8646": "\\u21C6", "8610": "\\u21A2", "8968": "\\u2308", "10214": "\\u27E6", "10593": "\\u2961", "10585": "\\u2959", "8643": "\\u21C3", "8970": "\\u230A", "8637": "\\u21BD", "8636": "\\u21BC", "8647": "\\u21C7", "8596": "\\u2194", "8596": "\\u2194", "8660": "\\u21D4", "8646": "\\u21C6", "8651": "\\u21CB", "8621": "\\u21AD", "10574": "\\u294E", "8612": "\\u21A4", "8867": "\\u22A3", "10586": "\\u295A", "8907": "\\u22CB", "10703": "\\u29CF", "8882": "\\u22B2", "8884": "\\u22B4", "10577": "\\u2951", "10592": "\\u2960", "10584": "\\u2958", "8639": "\\u21BF", "10578": "\\u2952", "8636": "\\u21BC", "10891": "\\u2A8B", "8922": "\\u22DA", "8804": "\\u2264", "8806": "\\u2266", "10877": "\\u2A7D", "10920": "\\u2AA8", "10877": "\\u2A7D", "10879": "\\u2A7F", "10881": "\\u2A81", "10883": "\\u2A83", "8922": "\\u22DA", "65024": "\\uFE00", "10899": "\\u2A93", "10885": "\\u2A85", "8918": "\\u22D6", "8922": "\\u22DA", "10891": "\\u2A8B", "8922": "\\u22DA", "8806": "\\u2266", "8822": "\\u2276", "8822": "\\u2276", "10913": "\\u2AA1", "8818": "\\u2272", "10877": "\\u2A7D", "8818": "\\u2272", "10620": "\\u297C", "8970": "\\u230A", "120079": "\\uD835\\uDD0F", "120105": "\\uD835\\uDD29", "8822": "\\u2276", "10897": "\\u2A91", "10594": "\\u2962", "8637": "\\u21BD", "8636": "\\u21BC", "10602": "\\u296A", "9604": "\\u2584", "1033": "\\u0409", "1113": "\\u0459", "8647": "\\u21C7", "8810": "\\u226A", "8920": "\\u22D8", "8990": "\\u231E", "8666": "\\u21DA", "10603": "\\u296B", "9722": "\\u25FA", "319": "\\u013F", "320": "\\u0140", "9136": "\\u23B0", "9136": "\\u23B0", "10889": "\\u2A89", "10889": "\\u2A89", "10887": "\\u2A87", "8808": "\\u2268", "10887": "\\u2A87", "8808": "\\u2268", "8934": "\\u22E6", "10220": "\\u27EC", "8701": "\\u21FD", "10214": "\\u27E6", "10229": "\\u27F5", "10229": "\\u27F5", "10232": "\\u27F8", "10231": "\\u27F7", "10231": "\\u27F7", "10234": "\\u27FA", "10236": "\\u27FC", "10230": "\\u27F6", "10230": "\\u27F6", "10233": "\\u27F9", "8619": "\\u21AB", "8620": "\\u21AC", "10629": "\\u2985", "120131": "\\uD835\\uDD43", "120157": "\\uD835\\uDD5D", "10797": "\\u2A2D", "10804": "\\u2A34", "8727": "\\u2217", "95": "\\u005F", "8601": "\\u2199", "8600": "\\u2198", "9674": "\\u25CA", "9674": "\\u25CA", "10731": "\\u29EB", "40": "\\u0028", "10643": "\\u2993", "8646": "\\u21C6", "8991": "\\u231F", "8651": "\\u21CB", "10605": "\\u296D", "8206": "\\u200E", "8895": "\\u22BF", "8249": "\\u2039", "120001": "\\uD835\\uDCC1", "8466": "\\u2112", "8624": "\\u21B0", "8624": "\\u21B0", "8818": "\\u2272", "10893": "\\u2A8D", "10895": "\\u2A8F", "91": "\\u005B", "8216": "\\u2018", "8218": "\\u201A", "321": "\\u0141", "322": "\\u0142", "10918": "\\u2AA6", "10873": "\\u2A79", "60": "\\u003C", "60": "\\u003C", "60": "\\u003C", "60": "\\u003C", "8810": "\\u226A", "8918": "\\u22D6", "8907": "\\u22CB", "8905": "\\u22C9", "10614": "\\u2976", "10875": "\\u2A7B", "9667": "\\u25C3", "8884": "\\u22B4", "9666": "\\u25C2", "10646": "\\u2996", "10570": "\\u294A", "10598": "\\u2966", "8808": "\\u2268", "65024": "\\uFE00", "8808": "\\u2268", "65024": "\\uFE00", "175": "\\u00AF", "175": "\\u00AF", "9794": "\\u2642", "10016": "\\u2720", "10016": "\\u2720", "10501": "\\u2905", "8614": "\\u21A6", "8614": "\\u21A6", "8615": "\\u21A7", "8612": "\\u21A4", "8613": "\\u21A5", "9646": "\\u25AE", "10793": "\\u2A29", "1052": "\\u041C", "1084": "\\u043C", "8212": "\\u2014", "8762": "\\u223A", "8737": "\\u2221", "8287": "\\u205F", "8499": "\\u2133", "120080": "\\uD835\\uDD10", "120106": "\\uD835\\uDD2A", "8487": "\\u2127", "181": "\\u00B5", "181": "\\u00B5", "42": "\\u002A", "10992": "\\u2AF0", "8739": "\\u2223", "183": "\\u00B7", "183": "\\u00B7", "8863": "\\u229F", "8722": "\\u2212", "8760": "\\u2238", "10794": "\\u2A2A", "8723": "\\u2213", "10971": "\\u2ADB", "8230": "\\u2026", "8723": "\\u2213", "8871": "\\u22A7", "120132": "\\uD835\\uDD44", "120158": "\\uD835\\uDD5E", "8723": "\\u2213", "120002": "\\uD835\\uDCC2", "8499": "\\u2133", "8766": "\\u223E", "924": "\\u039C", "956": "\\u03BC", "8888": "\\u22B8", "8888": "\\u22B8", "8711": "\\u2207", "323": "\\u0143", "324": "\\u0144", "8736": "\\u2220", "8402": "\\u20D2", "8777": "\\u2249", "10864": "\\u2A70", "824": "\\u0338", "8779": "\\u224B", "824": "\\u0338", "329": "\\u0149", "8777": "\\u2249", "9838": "\\u266E", "8469": "\\u2115", "9838": "\\u266E", "160": "\\u00A0", "160": "\\u00A0", "8782": "\\u224E", "824": "\\u0338", "8783": "\\u224F", "824": "\\u0338", "10819": "\\u2A43", "327": "\\u0147", "328": "\\u0148", "325": "\\u0145", "326": "\\u0146", "8775": "\\u2247", "10861": "\\u2A6D", "824": "\\u0338", "10818": "\\u2A42", "1053": "\\u041D", "1085": "\\u043D", "8211": "\\u2013", "10532": "\\u2924", "8599": "\\u2197", "8663": "\\u21D7", "8599": "\\u2197", "8800": "\\u2260", "8784": "\\u2250", "824": "\\u0338", "8203": "\\u200B", "8203": "\\u200B", "8203": "\\u200B", "8203": "\\u200B", "8802": "\\u2262", "10536": "\\u2928", "8770": "\\u2242", "824": "\\u0338", "8811": "\\u226B", "8810": "\\u226A", "10": "\\u000A", "8708": "\\u2204", "8708": "\\u2204", "120081": "\\uD835\\uDD11", "120107": "\\uD835\\uDD2B", "8807": "\\u2267", "824": "\\u0338", "8817": "\\u2271", "8817": "\\u2271", "8807": "\\u2267", "824": "\\u0338", "10878": "\\u2A7E", "824": "\\u0338", "10878": "\\u2A7E", "824": "\\u0338", "8921": "\\u22D9", "824": "\\u0338", "8821": "\\u2275", "8811": "\\u226B", "8402": "\\u20D2", "8815": "\\u226F", "8815": "\\u226F", "8811": "\\u226B", "824": "\\u0338", "8622": "\\u21AE", "8654": "\\u21CE", "10994": "\\u2AF2", "8715": "\\u220B", "8956": "\\u22FC", "8954": "\\u22FA", "8715": "\\u220B", "1034": "\\u040A", "1114": "\\u045A", "8602": "\\u219A", "8653": "\\u21CD", "8229": "\\u2025", "8806": "\\u2266", "824": "\\u0338", "8816": "\\u2270", "8602": "\\u219A", "8653": "\\u21CD", "8622": "\\u21AE", "8654": "\\u21CE", "8816": "\\u2270", "8806": "\\u2266", "824": "\\u0338", "10877": "\\u2A7D", "824": "\\u0338", "10877": "\\u2A7D", "824": "\\u0338", "8814": "\\u226E", "8920": "\\u22D8", "824": "\\u0338", "8820": "\\u2274", "8810": "\\u226A", "8402": "\\u20D2", "8814": "\\u226E", "8938": "\\u22EA", "8940": "\\u22EC", "8810": "\\u226A", "824": "\\u0338", "8740": "\\u2224", "8288": "\\u2060", "160": "\\u00A0", "120159": "\\uD835\\uDD5F", "8469": "\\u2115", "10988": "\\u2AEC", "172": "\\u00AC", "172": "\\u00AC", "8802": "\\u2262", "8813": "\\u226D", "8742": "\\u2226", "8713": "\\u2209", "8800": "\\u2260", "8770": "\\u2242", "824": "\\u0338", "8708": "\\u2204", "8815": "\\u226F", "8817": "\\u2271", "8807": "\\u2267", "824": "\\u0338", "8811": "\\u226B", "824": "\\u0338", "8825": "\\u2279", "10878": "\\u2A7E", "824": "\\u0338", "8821": "\\u2275", "8782": "\\u224E", "824": "\\u0338", "8783": "\\u224F", "824": "\\u0338", "8713": "\\u2209", "8949": "\\u22F5", "824": "\\u0338", "8953": "\\u22F9", "824": "\\u0338", "8713": "\\u2209", "8951": "\\u22F7", "8950": "\\u22F6", "10703": "\\u29CF", "824": "\\u0338", "8938": "\\u22EA", "8940": "\\u22EC", "8814": "\\u226E", "8816": "\\u2270", "8824": "\\u2278", "8810": "\\u226A", "824": "\\u0338", "10877": "\\u2A7D", "824": "\\u0338", "8820": "\\u2274", "10914": "\\u2AA2", "824": "\\u0338", "10913": "\\u2AA1", "824": "\\u0338", "8716": "\\u220C", "8716": "\\u220C", "8958": "\\u22FE", "8957": "\\u22FD", "8832": "\\u2280", "10927": "\\u2AAF", "824": "\\u0338", "8928": "\\u22E0", "8716": "\\u220C", "10704": "\\u29D0", "824": "\\u0338", "8939": "\\u22EB", "8941": "\\u22ED", "8847": "\\u228F", "824": "\\u0338", "8930": "\\u22E2", "8848": "\\u2290", "824": "\\u0338", "8931": "\\u22E3", "8834": "\\u2282", "8402": "\\u20D2", "8840": "\\u2288", "8833": "\\u2281", "10928": "\\u2AB0", "824": "\\u0338", "8929": "\\u22E1", "8831": "\\u227F", "824": "\\u0338", "8835": "\\u2283", "8402": "\\u20D2", "8841": "\\u2289", "8769": "\\u2241", "8772": "\\u2244", "8775": "\\u2247", "8777": "\\u2249", "8740": "\\u2224", "8742": "\\u2226", "8742": "\\u2226", "11005": "\\u2AFD", "8421": "\\u20E5", "8706": "\\u2202", "824": "\\u0338", "10772": "\\u2A14", "8832": "\\u2280", "8928": "\\u22E0", "8832": "\\u2280", "10927": "\\u2AAF", "824": "\\u0338", "10927": "\\u2AAF", "824": "\\u0338", "10547": "\\u2933", "824": "\\u0338", "8603": "\\u219B", "8655": "\\u21CF", "8605": "\\u219D", "824": "\\u0338", "8603": "\\u219B", "8655": "\\u21CF", "8939": "\\u22EB", "8941": "\\u22ED", "8833": "\\u2281", "8929": "\\u22E1", "10928": "\\u2AB0", "824": "\\u0338", "119977": "\\uD835\\uDCA9", "120003": "\\uD835\\uDCC3", "8740": "\\u2224", "8742": "\\u2226", "8769": "\\u2241", "8772": "\\u2244", "8772": "\\u2244", "8740": "\\u2224", "8742": "\\u2226", "8930": "\\u22E2", "8931": "\\u22E3", "8836": "\\u2284", "10949": "\\u2AC5", "824": "\\u0338", "8840": "\\u2288", "8834": "\\u2282", "8402": "\\u20D2", "8840": "\\u2288", "10949": "\\u2AC5", "824": "\\u0338", "8833": "\\u2281", "10928": "\\u2AB0", "824": "\\u0338", "8837": "\\u2285", "10950": "\\u2AC6", "824": "\\u0338", "8841": "\\u2289", "8835": "\\u2283", "8402": "\\u20D2", "8841": "\\u2289", "10950": "\\u2AC6", "824": "\\u0338", "8825": "\\u2279", "209": "\\u00D1", "209": "\\u00D1", "241": "\\u00F1", "241": "\\u00F1", "8824": "\\u2278", "8938": "\\u22EA", "8940": "\\u22EC", "8939": "\\u22EB", "8941": "\\u22ED", "925": "\\u039D", "957": "\\u03BD", "35": "\\u0023", "8470": "\\u2116", "8199": "\\u2007", "8781": "\\u224D", "8402": "\\u20D2", "8876": "\\u22AC", "8877": "\\u22AD", "8878": "\\u22AE", "8879": "\\u22AF", "8805": "\\u2265", "8402": "\\u20D2", "62": "\\u003E", "8402": "\\u20D2", "10500": "\\u2904", "10718": "\\u29DE", "10498": "\\u2902", "8804": "\\u2264", "8402": "\\u20D2", "60": "\\u003C", "8402": "\\u20D2", "8884": "\\u22B4", "8402": "\\u20D2", "10499": "\\u2903", "8885": "\\u22B5", "8402": "\\u20D2", "8764": "\\u223C", "8402": "\\u20D2", "10531": "\\u2923", "8598": "\\u2196", "8662": "\\u21D6", "8598": "\\u2196", "10535": "\\u2927", "211": "\\u00D3", "211": "\\u00D3", "243": "\\u00F3", "243": "\\u00F3", "8859": "\\u229B", "212": "\\u00D4", "212": "\\u00D4", "244": "\\u00F4", "244": "\\u00F4", "8858": "\\u229A", "1054": "\\u041E", "1086": "\\u043E", "8861": "\\u229D", "336": "\\u0150", "337": "\\u0151", "10808": "\\u2A38", "8857": "\\u2299", "10684": "\\u29BC", "338": "\\u0152", "339": "\\u0153", "10687": "\\u29BF", "120082": "\\uD835\\uDD12", "120108": "\\uD835\\uDD2C", "731": "\\u02DB", "210": "\\u00D2", "210": "\\u00D2", "242": "\\u00F2", "242": "\\u00F2", "10689": "\\u29C1", "10677": "\\u29B5", "937": "\\u03A9", "8750": "\\u222E", "8634": "\\u21BA", "10686": "\\u29BE", "10683": "\\u29BB", "8254": "\\u203E", "10688": "\\u29C0", "332": "\\u014C", "333": "\\u014D", "937": "\\u03A9", "969": "\\u03C9", "927": "\\u039F", "959": "\\u03BF", "10678": "\\u29B6", "8854": "\\u2296", "120134": "\\uD835\\uDD46", "120160": "\\uD835\\uDD60", "10679": "\\u29B7", "8220": "\\u201C", "8216": "\\u2018", "10681": "\\u29B9", "8853": "\\u2295", "8635": "\\u21BB", "10836": "\\u2A54", "8744": "\\u2228", "10845": "\\u2A5D", "8500": "\\u2134", "8500": "\\u2134", "170": "\\u00AA", "170": "\\u00AA", "186": "\\u00BA", "186": "\\u00BA", "8886": "\\u22B6", "10838": "\\u2A56", "10839": "\\u2A57", "10843": "\\u2A5B", "9416": "\\u24C8", "119978": "\\uD835\\uDCAA", "8500": "\\u2134", "216": "\\u00D8", "216": "\\u00D8", "248": "\\u00F8", "248": "\\u00F8", "8856": "\\u2298", "213": "\\u00D5", "213": "\\u00D5", "245": "\\u00F5", "245": "\\u00F5", "10806": "\\u2A36", "10807": "\\u2A37", "8855": "\\u2297", "214": "\\u00D6", "214": "\\u00D6", "246": "\\u00F6", "246": "\\u00F6", "9021": "\\u233D", "8254": "\\u203E", "9182": "\\u23DE", "9140": "\\u23B4", "9180": "\\u23DC", "182": "\\u00B6", "182": "\\u00B6", "8741": "\\u2225", "8741": "\\u2225", "10995": "\\u2AF3", "11005": "\\u2AFD", "8706": "\\u2202", "8706": "\\u2202", "1055": "\\u041F", "1087": "\\u043F", "37": "\\u0025", "46": "\\u002E", "8240": "\\u2030", "8869": "\\u22A5", "8241": "\\u2031", "120083": "\\uD835\\uDD13", "120109": "\\uD835\\uDD2D", "934": "\\u03A6", "966": "\\u03C6", "981": "\\u03D5", "8499": "\\u2133", "9742": "\\u260E", "928": "\\u03A0", "960": "\\u03C0", "8916": "\\u22D4", "982": "\\u03D6", "8463": "\\u210F", "8462": "\\u210E", "8463": "\\u210F", "10787": "\\u2A23", "8862": "\\u229E", "10786": "\\u2A22", "43": "\\u002B", "8724": "\\u2214", "10789": "\\u2A25", "10866": "\\u2A72", "177": "\\u00B1", "177": "\\u00B1", "177": "\\u00B1", "10790": "\\u2A26", "10791": "\\u2A27", "177": "\\u00B1", "8460": "\\u210C", "10773": "\\u2A15", "120161": "\\uD835\\uDD61", "8473": "\\u2119", "163": "\\u00A3", "163": "\\u00A3", "10935": "\\u2AB7", "10939": "\\u2ABB", "8826": "\\u227A", "8828": "\\u227C", "10935": "\\u2AB7", "8826": "\\u227A", "8828": "\\u227C", "8826": "\\u227A", "10927": "\\u2AAF", "8828": "\\u227C", "8830": "\\u227E", "10927": "\\u2AAF", "10937": "\\u2AB9", "10933": "\\u2AB5", "8936": "\\u22E8", "10927": "\\u2AAF", "10931": "\\u2AB3", "8830": "\\u227E", "8242": "\\u2032", "8243": "\\u2033", "8473": "\\u2119", "10937": "\\u2AB9", "10933": "\\u2AB5", "8936": "\\u22E8", "8719": "\\u220F", "8719": "\\u220F", "9006": "\\u232E", "8978": "\\u2312", "8979": "\\u2313", "8733": "\\u221D", "8733": "\\u221D", "8759": "\\u2237", "8733": "\\u221D", "8830": "\\u227E", "8880": "\\u22B0", "119979": "\\uD835\\uDCAB", "120005": "\\uD835\\uDCC5", "936": "\\u03A8", "968": "\\u03C8", "8200": "\\u2008", "120084": "\\uD835\\uDD14", "120110": "\\uD835\\uDD2E", "10764": "\\u2A0C", "120162": "\\uD835\\uDD62", "8474": "\\u211A", "8279": "\\u2057", "119980": "\\uD835\\uDCAC", "120006": "\\uD835\\uDCC6", "8461": "\\u210D", "10774": "\\u2A16", "63": "\\u003F", "8799": "\\u225F", "34": "\\u0022", "34": "\\u0022", "34": "\\u0022", "34": "\\u0022", "8667": "\\u21DB", "8765": "\\u223D", "817": "\\u0331", "340": "\\u0154", "341": "\\u0155", "8730": "\\u221A", "10675": "\\u29B3", "10217": "\\u27E9", "10219": "\\u27EB", "10642": "\\u2992", "10661": "\\u29A5", "10217": "\\u27E9", "187": "\\u00BB", "187": "\\u00BB", "10613": "\\u2975", "8677": "\\u21E5", "10528": "\\u2920", "10547": "\\u2933", "8594": "\\u2192", "8608": "\\u21A0", "8658": "\\u21D2", "10526": "\\u291E", "8618": "\\u21AA", "8620": "\\u21AC", "10565": "\\u2945", "10612": "\\u2974", "10518": "\\u2916", "8611": "\\u21A3", "8605": "\\u219D", "10522": "\\u291A", "10524": "\\u291C", "8758": "\\u2236", "8474": "\\u211A", "10509": "\\u290D", "10511": "\\u290F", "10512": "\\u2910", "10099": "\\u2773", "125": "\\u007D", "93": "\\u005D", "10636": "\\u298C", "10638": "\\u298E", "10640": "\\u2990", "344": "\\u0158", "345": "\\u0159", "342": "\\u0156", "343": "\\u0157", "8969": "\\u2309", "125": "\\u007D", "1056": "\\u0420", "1088": "\\u0440", "10551": "\\u2937", "10601": "\\u2969", "8221": "\\u201D", "8221": "\\u201D", "8627": "\\u21B3", "8476": "\\u211C", "8475": "\\u211B", "8476": "\\u211C", "8477": "\\u211D", "8476": "\\u211C", "9645": "\\u25AD", "174": "\\u00AE", "174": "\\u00AE", "174": "\\u00AE", "174": "\\u00AE", "8715": "\\u220B", "8651": "\\u21CB", "10607": "\\u296F", "10621": "\\u297D", "8971": "\\u230B", "120111": "\\uD835\\uDD2F", "8476": "\\u211C", "10596": "\\u2964", "8641": "\\u21C1", "8640": "\\u21C0", "10604": "\\u296C", "929": "\\u03A1", "961": "\\u03C1", "1009": "\\u03F1", "10217": "\\u27E9", "8677": "\\u21E5", "8594": "\\u2192", "8594": "\\u2192", "8658": "\\u21D2", "8644": "\\u21C4", "8611": "\\u21A3", "8969": "\\u2309", "10215": "\\u27E7", "10589": "\\u295D", "10581": "\\u2955", "8642": "\\u21C2", "8971": "\\u230B", "8641": "\\u21C1", "8640": "\\u21C0", "8644": "\\u21C4", "8652": "\\u21CC", "8649": "\\u21C9", "8605": "\\u219D", "8614": "\\u21A6", "8866": "\\u22A2", "10587": "\\u295B", "8908": "\\u22CC", "10704": "\\u29D0", "8883": "\\u22B3", "8885": "\\u22B5", "10575": "\\u294F", "10588": "\\u295C", "10580": "\\u2954", "8638": "\\u21BE", "10579": "\\u2953", "8640": "\\u21C0", "730": "\\u02DA", "8787": "\\u2253", "8644": "\\u21C4", "8652": "\\u21CC", "8207": "\\u200F", "9137": "\\u23B1", "9137": "\\u23B1", "10990": "\\u2AEE", "10221": "\\u27ED", "8702": "\\u21FE", "10215": "\\u27E7", "10630": "\\u2986", "120163": "\\uD835\\uDD63", "8477": "\\u211D", "10798": "\\u2A2E", "10805": "\\u2A35", "10608": "\\u2970", "41": "\\u0029", "10644": "\\u2994", "10770": "\\u2A12", "8649": "\\u21C9", "8667": "\\u21DB", "8250": "\\u203A", "120007": "\\uD835\\uDCC7", "8475": "\\u211B", "8625": "\\u21B1", "8625": "\\u21B1", "93": "\\u005D", "8217": "\\u2019", "8217": "\\u2019", "8908": "\\u22CC", "8906": "\\u22CA", "9657": "\\u25B9", "8885": "\\u22B5", "9656": "\\u25B8", "10702": "\\u29CE", "10740": "\\u29F4", "10600": "\\u2968", "8478": "\\u211E", "346": "\\u015A", "347": "\\u015B", "8218": "\\u201A", "10936": "\\u2AB8", "352": "\\u0160", "353": "\\u0161", "10940": "\\u2ABC", "8827": "\\u227B", "8829": "\\u227D", "10928": "\\u2AB0", "10932": "\\u2AB4", "350": "\\u015E", "351": "\\u015F", "348": "\\u015C", "349": "\\u015D", "10938": "\\u2ABA", "10934": "\\u2AB6", "8937": "\\u22E9", "10771": "\\u2A13", "8831": "\\u227F", "1057": "\\u0421", "1089": "\\u0441", "8865": "\\u22A1", "8901": "\\u22C5", "10854": "\\u2A66", "10533": "\\u2925", "8600": "\\u2198", "8664": "\\u21D8", "8600": "\\u2198", "167": "\\u00A7", "167": "\\u00A7", "59": "\\u003B", "10537": "\\u2929", "8726": "\\u2216", "8726": "\\u2216", "10038": "\\u2736", "120086": "\\uD835\\uDD16", "120112": "\\uD835\\uDD30", "8994": "\\u2322", "9839": "\\u266F", "1065": "\\u0429", "1097": "\\u0449", "1064": "\\u0428", "1096": "\\u0448", "8595": "\\u2193", "8592": "\\u2190", "8739": "\\u2223", "8741": "\\u2225", "8594": "\\u2192", "8593": "\\u2191", "173": "\\u00AD", "173": "\\u00AD", "931": "\\u03A3", "963": "\\u03C3", "962": "\\u03C2", "962": "\\u03C2", "8764": "\\u223C", "10858": "\\u2A6A", "8771": "\\u2243", "8771": "\\u2243", "10910": "\\u2A9E", "10912": "\\u2AA0", "10909": "\\u2A9D", "10911": "\\u2A9F", "8774": "\\u2246", "10788": "\\u2A24", "10610": "\\u2972", "8592": "\\u2190", "8728": "\\u2218", "8726": "\\u2216", "10803": "\\u2A33", "10724": "\\u29E4", "8739": "\\u2223", "8995": "\\u2323", "10922": "\\u2AAA", "10924": "\\u2AAC", "10924": "\\u2AAC", "65024": "\\uFE00", "1068": "\\u042C", "1100": "\\u044C", "9023": "\\u233F", "10692": "\\u29C4", "47": "\\u002F", "120138": "\\uD835\\uDD4A", "120164": "\\uD835\\uDD64", "9824": "\\u2660", "9824": "\\u2660", "8741": "\\u2225", "8851": "\\u2293", "8851": "\\u2293", "65024": "\\uFE00", "8852": "\\u2294", "8852": "\\u2294", "65024": "\\uFE00", "8730": "\\u221A", "8847": "\\u228F", "8849": "\\u2291", "8847": "\\u228F", "8849": "\\u2291", "8848": "\\u2290", "8850": "\\u2292", "8848": "\\u2290", "8850": "\\u2292", "9633": "\\u25A1", "9633": "\\u25A1", "8851": "\\u2293", "8847": "\\u228F", "8849": "\\u2291", "8848": "\\u2290", "8850": "\\u2292", "8852": "\\u2294", "9642": "\\u25AA", "9633": "\\u25A1", "9642": "\\u25AA", "8594": "\\u2192", "119982": "\\uD835\\uDCAE", "120008": "\\uD835\\uDCC8", "8726": "\\u2216", "8995": "\\u2323", "8902": "\\u22C6", "8902": "\\u22C6", "9734": "\\u2606", "9733": "\\u2605", "1013": "\\u03F5", "981": "\\u03D5", "175": "\\u00AF", "8834": "\\u2282", "8912": "\\u22D0", "10941": "\\u2ABD", "10949": "\\u2AC5", "8838": "\\u2286", "10947": "\\u2AC3", "10945": "\\u2AC1", "10955": "\\u2ACB", "8842": "\\u228A", "10943": "\\u2ABF", "10617": "\\u2979", "8834": "\\u2282", "8912": "\\u22D0", "8838": "\\u2286", "10949": "\\u2AC5", "8838": "\\u2286", "8842": "\\u228A", "10955": "\\u2ACB", "10951": "\\u2AC7", "10965": "\\u2AD5", "10963": "\\u2AD3", "10936": "\\u2AB8", "8827": "\\u227B", "8829": "\\u227D", "8827": "\\u227B", "10928": "\\u2AB0", "8829": "\\u227D", "8831": "\\u227F", "10928": "\\u2AB0", "10938": "\\u2ABA", "10934": "\\u2AB6", "8937": "\\u22E9", "8831": "\\u227F", "8715": "\\u220B", "8721": "\\u2211", "8721": "\\u2211", "9834": "\\u266A", "185": "\\u00B9", "185": "\\u00B9", "178": "\\u00B2", "178": "\\u00B2", "179": "\\u00B3", "179": "\\u00B3", "8835": "\\u2283", "8913": "\\u22D1", "10942": "\\u2ABE", "10968": "\\u2AD8", "10950": "\\u2AC6", "8839": "\\u2287", "10948": "\\u2AC4", "8835": "\\u2283", "8839": "\\u2287", "10185": "\\u27C9", "10967": "\\u2AD7", "10619": "\\u297B", "10946": "\\u2AC2", "10956": "\\u2ACC", "8843": "\\u228B", "10944": "\\u2AC0", "8835": "\\u2283", "8913": "\\u22D1", "8839": "\\u2287", "10950": "\\u2AC6", "8843": "\\u228B", "10956": "\\u2ACC", "10952": "\\u2AC8", "10964": "\\u2AD4", "10966": "\\u2AD6", "10534": "\\u2926", "8601": "\\u2199", "8665": "\\u21D9", "8601": "\\u2199", "10538": "\\u292A", "223": "\\u00DF", "223": "\\u00DF", "9": "\\u0009", "8982": "\\u2316", "932": "\\u03A4", "964": "\\u03C4", "9140": "\\u23B4", "356": "\\u0164", "357": "\\u0165", "354": "\\u0162", "355": "\\u0163", "1058": "\\u0422", "1090": "\\u0442", "8411": "\\u20DB", "8981": "\\u2315", "120087": "\\uD835\\uDD17", "120113": "\\uD835\\uDD31", "8756": "\\u2234", "8756": "\\u2234", "8756": "\\u2234", "920": "\\u0398", "952": "\\u03B8", "977": "\\u03D1", "977": "\\u03D1", "8776": "\\u2248", "8764": "\\u223C", "8287": "\\u205F", "8202": "\\u200A", "8201": "\\u2009", "8201": "\\u2009", "8776": "\\u2248", "8764": "\\u223C", "222": "\\u00DE", "222": "\\u00DE", "254": "\\u00FE", "254": "\\u00FE", "732": "\\u02DC", "8764": "\\u223C", "8771": "\\u2243", "8773": "\\u2245", "8776": "\\u2248", "10801": "\\u2A31", "8864": "\\u22A0", "215": "\\u00D7", "215": "\\u00D7", "10800": "\\u2A30", "8749": "\\u222D", "10536": "\\u2928", "9014": "\\u2336", "10993": "\\u2AF1", "8868": "\\u22A4", "120139": "\\uD835\\uDD4B", "120165": "\\uD835\\uDD65", "10970": "\\u2ADA", "10537": "\\u2929", "8244": "\\u2034", "8482": "\\u2122", "8482": "\\u2122", "9653": "\\u25B5", "9663": "\\u25BF", "9667": "\\u25C3", "8884": "\\u22B4", "8796": "\\u225C", "9657": "\\u25B9", "8885": "\\u22B5", "9708": "\\u25EC", "8796": "\\u225C", "10810": "\\u2A3A", "8411": "\\u20DB", "10809": "\\u2A39", "10701": "\\u29CD", "10811": "\\u2A3B", "9186": "\\u23E2", "119983": "\\uD835\\uDCAF", "120009": "\\uD835\\uDCC9", "1062": "\\u0426", "1094": "\\u0446", "1035": "\\u040B", "1115": "\\u045B", "358": "\\u0166", "359": "\\u0167", "8812": "\\u226C", "8606": "\\u219E", "8608": "\\u21A0", "218": "\\u00DA", "218": "\\u00DA", "250": "\\u00FA", "250": "\\u00FA", "8593": "\\u2191", "8607": "\\u219F", "8657": "\\u21D1", "10569": "\\u2949", "1038": "\\u040E", "1118": "\\u045E", "364": "\\u016C", "365": "\\u016D", "219": "\\u00DB", "219": "\\u00DB", "251": "\\u00FB", "251": "\\u00FB", "1059": "\\u0423", "1091": "\\u0443", "8645": "\\u21C5", "368": "\\u0170", "369": "\\u0171", "10606": "\\u296E", "10622": "\\u297E", "120088": "\\uD835\\uDD18", "120114": "\\uD835\\uDD32", "217": "\\u00D9", "217": "\\u00D9", "249": "\\u00F9", "249": "\\u00F9", "10595": "\\u2963", "8639": "\\u21BF", "8638": "\\u21BE", "9600": "\\u2580", "8988": "\\u231C", "8988": "\\u231C", "8975": "\\u230F", "9720": "\\u25F8", "362": "\\u016A", "363": "\\u016B", "168": "\\u00A8", "168": "\\u00A8", "95": "\\u005F", "9183": "\\u23DF", "9141": "\\u23B5", "9181": "\\u23DD", "8899": "\\u22C3", "8846": "\\u228E", "370": "\\u0172", "371": "\\u0173", "120140": "\\uD835\\uDD4C", "120166": "\\uD835\\uDD66", "10514": "\\u2912", "8593": "\\u2191", "8593": "\\u2191", "8657": "\\u21D1", "8645": "\\u21C5", "8597": "\\u2195", "8597": "\\u2195", "8661": "\\u21D5", "10606": "\\u296E", "8639": "\\u21BF", "8638": "\\u21BE", "8846": "\\u228E", "8598": "\\u2196", "8599": "\\u2197", "965": "\\u03C5", "978": "\\u03D2", "978": "\\u03D2", "933": "\\u03A5", "965": "\\u03C5", "8613": "\\u21A5", "8869": "\\u22A5", "8648": "\\u21C8", "8989": "\\u231D", "8989": "\\u231D", "8974": "\\u230E", "366": "\\u016E", "367": "\\u016F", "9721": "\\u25F9", "119984": "\\uD835\\uDCB0", "120010": "\\uD835\\uDCCA", "8944": "\\u22F0", "360": "\\u0168", "361": "\\u0169", "9653": "\\u25B5", "9652": "\\u25B4", "8648": "\\u21C8", "220": "\\u00DC", "220": "\\u00DC", "252": "\\u00FC", "252": "\\u00FC", "10663": "\\u29A7", "10652": "\\u299C", "1013": "\\u03F5", "1008": "\\u03F0", "8709": "\\u2205", "981": "\\u03D5", "982": "\\u03D6", "8733": "\\u221D", "8597": "\\u2195", "8661": "\\u21D5", "1009": "\\u03F1", "962": "\\u03C2", "8842": "\\u228A", "65024": "\\uFE00", "10955": "\\u2ACB", "65024": "\\uFE00", "8843": "\\u228B", "65024": "\\uFE00", "10956": "\\u2ACC", "65024": "\\uFE00", "977": "\\u03D1", "8882": "\\u22B2", "8883": "\\u22B3", "10984": "\\u2AE8", "10987": "\\u2AEB", "10985": "\\u2AE9", "1042": "\\u0412", "1074": "\\u0432", "8866": "\\u22A2", "8872": "\\u22A8", "8873": "\\u22A9", "8875": "\\u22AB", "10982": "\\u2AE6", "8891": "\\u22BB", "8744": "\\u2228", "8897": "\\u22C1", "8794": "\\u225A", "8942": "\\u22EE", "124": "\\u007C", "8214": "\\u2016", "124": "\\u007C", "8214": "\\u2016", "8739": "\\u2223", "124": "\\u007C", "10072": "\\u2758", "8768": "\\u2240", "8202": "\\u200A", "120089": "\\uD835\\uDD19", "120115": "\\uD835\\uDD33", "8882": "\\u22B2", "8834": "\\u2282", "8402": "\\u20D2", "8835": "\\u2283", "8402": "\\u20D2", "120141": "\\uD835\\uDD4D", "120167": "\\uD835\\uDD67", "8733": "\\u221D", "8883": "\\u22B3", "119985": "\\uD835\\uDCB1", "120011": "\\uD835\\uDCCB", "10955": "\\u2ACB", "65024": "\\uFE00", "8842": "\\u228A", "65024": "\\uFE00", "10956": "\\u2ACC", "65024": "\\uFE00", "8843": "\\u228B", "65024": "\\uFE00", "8874": "\\u22AA", "10650": "\\u299A", "372": "\\u0174", "373": "\\u0175", "10847": "\\u2A5F", "8743": "\\u2227", "8896": "\\u22C0", "8793": "\\u2259", "8472": "\\u2118", "120090": "\\uD835\\uDD1A", "120116": "\\uD835\\uDD34", "120142": "\\uD835\\uDD4E", "120168": "\\uD835\\uDD68", "8472": "\\u2118", "8768": "\\u2240", "8768": "\\u2240", "119986": "\\uD835\\uDCB2", "120012": "\\uD835\\uDCCC", "8898": "\\u22C2", "9711": "\\u25EF", "8899": "\\u22C3", "9661": "\\u25BD", "120091": "\\uD835\\uDD1B", "120117": "\\uD835\\uDD35", "10231": "\\u27F7", "10234": "\\u27FA", "926": "\\u039E", "958": "\\u03BE", "10229": "\\u27F5", "10232": "\\u27F8", "10236": "\\u27FC", "8955": "\\u22FB", "10752": "\\u2A00", "120143": "\\uD835\\uDD4F", "120169": "\\uD835\\uDD69", "10753": "\\u2A01", "10754": "\\u2A02", "10230": "\\u27F6", "10233": "\\u27F9", "119987": "\\uD835\\uDCB3", "120013": "\\uD835\\uDCCD", "10758": "\\u2A06", "10756": "\\u2A04", "9651": "\\u25B3", "8897": "\\u22C1", "8896": "\\u22C0", "221": "\\u00DD", "221": "\\u00DD", "253": "\\u00FD", "253": "\\u00FD", "1071": "\\u042F", "1103": "\\u044F", "374": "\\u0176", "375": "\\u0177", "1067": "\\u042B", "1099": "\\u044B", "165": "\\u00A5", "165": "\\u00A5", "120092": "\\uD835\\uDD1C", "120118": "\\uD835\\uDD36", "1031": "\\u0407", "1111": "\\u0457", "120144": "\\uD835\\uDD50", "120170": "\\uD835\\uDD6A", "119988": "\\uD835\\uDCB4", "120014": "\\uD835\\uDCCE", "1070": "\\u042E", "1102": "\\u044E", "255": "\\u00FF", "255": "\\u00FF", "376": "\\u0178", "377": "\\u0179", "378": "\\u017A", "381": "\\u017D", "382": "\\u017E", "1047": "\\u0417", "1079": "\\u0437", "379": "\\u017B", "380": "\\u017C", "8488": "\\u2128", "8203": "\\u200B", "918": "\\u0396", "950": "\\u03B6", "120119": "\\uD835\\uDD37", "8488": "\\u2128", "1046": "\\u0416", "1078": "\\u0436", "8669": "\\u21DD", "120171": "\\uD835\\uDD6B", "8484": "\\u2124", "119989": "\\uD835\\uDCB5", "120015": "\\uD835\\uDCCF", "8205": "\\u200D", "8204": "\\u200C"}`);

// Diff algorithm
/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos, _fix_unicode) {
  // Check for equality
  if (text1 === text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (cursor_pos != null) {
    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
    if (editdiff) {
      return editdiff;
    }
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs, _fix_unicode);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i !== -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [
      [DIFF_INSERT, longtext.substring(0, i)],
      [DIFF_EQUAL, shorttext],
      [DIFF_INSERT, longtext.substring(i + shorttext.length)]
    ];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length === 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 !== 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (
        x1 < text1_length && y1 < text2_length &&
        text1.charAt(x1) === text2.charAt(y1)
      ) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (
        x2 < text1_length && y2 < text2_length &&
        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)
      ) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)
    ) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
    pointermid--;
  }

  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)
    ) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }

  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
    pointermid--;
  }

  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
      var prefixLength = diff_commonPrefix(
        longtext.substring(i), shorttext.substring(j));
      var suffixLength = diff_commonSuffix(
        longtext.substring(0, i), shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(
          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [
        best_longtext_a, best_longtext_b,
        best_shorttext_a, best_shorttext_b, best_common
      ];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
function diff_cleanupMerge(diffs, fix_unicode) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
      diffs.splice(pointer, 1);
      continue;
    }
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:

        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        var previous_equality = pointer - count_insert - count_delete - 1;
        if (fix_unicode) {
          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,
          // we assume that the old and new text in the diff are complete and correct
          // unicode-encoded JS strings, but the tuple boundaries may fall between
          // surrogate pairs.  we fix this by shaving off stray surrogates from the end
          // of the previous equality and the beginning of this equality.  this may create
          // empty equalities or a common prefix or suffix.  for example, if AB and AC are
          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and
          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this
          // particular case, both equalities go away, we absorb any previous inequalities,
          // and we keep scanning for the next equality before rewriting the tuples.
          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
            var stray = diffs[previous_equality][1].slice(-1);
            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
            text_delete = stray + text_delete;
            text_insert = stray + text_insert;
            if (!diffs[previous_equality][1]) {
              // emptied out previous equality, so delete it and include previous delete/insert
              diffs.splice(previous_equality, 1);
              pointer--;
              var k = previous_equality - 1;
              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                count_insert++;
                text_insert = diffs[k][1] + text_insert;
                k--;
              }
              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                count_delete++;
                text_delete = diffs[k][1] + text_delete;
                k--;
              }
              previous_equality = k;
            }
          }
          if (starts_with_pair_end(diffs[pointer][1])) {
            var stray = diffs[pointer][1].charAt(0);
            diffs[pointer][1] = diffs[pointer][1].slice(1);
            text_delete += stray;
            text_insert += stray;
          }
        }
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          // for empty equality not at end, wait for next equality
          diffs.splice(pointer, 1);
          break;
        }
        if (text_delete.length > 0 || text_insert.length > 0) {
          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware
          if (text_delete.length > 0 && text_insert.length > 0) {
            // Factor out any common prefixes.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (previous_equality >= 0) {
                diffs[previous_equality][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixes.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] =
                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          var n = count_insert + count_delete;
          if (text_delete.length === 0 && text_insert.length === 0) {
            diffs.splice(pointer - n, n);
            pointer = pointer - n;
          } else if (text_delete.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 1;
          } else if (text_insert.length === 0) {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
            pointer = pointer - n + 1;
          } else {
            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
            pointer = pointer - n + 2;
          }
        }
        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL &&
      diffs[pointer + 1][0] === DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
          diffs[pointer][1].substring(0, diffs[pointer][1].length -
            diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
        diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs, fix_unicode);
  }
};

function is_surrogate_pair_start(charCode) {
  return charCode >= 0xD800 && charCode <= 0xDBFF;
}

function is_surrogate_pair_end(charCode) {
  return charCode >= 0xDC00 && charCode <= 0xDFFF;
}

function starts_with_pair_end(str) {
  return is_surrogate_pair_end(str.charCodeAt(0));
}

function ends_with_pair_start(str) {
  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
}

function remove_empty_tuples(tuples) {
  var ret = [];
  for (var i = 0; i < tuples.length; i++) {
    if (tuples[i][1].length > 0) {
      ret.push(tuples[i]);
    }
  }
  return ret;
}

function make_edit_splice(before, oldMiddle, newMiddle, after) {
  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
    return null;
  }
  return remove_empty_tuples([
    [DIFF_EQUAL, before],
    [DIFF_DELETE, oldMiddle],
    [DIFF_INSERT, newMiddle],
    [DIFF_EQUAL, after]
  ]);
}

function find_cursor_edit_diff(oldText, newText, cursor_pos) {
  // note: this runs after equality check has ruled out exact equality
  var oldRange = typeof cursor_pos === 'number' ?
    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
  var newRange = typeof cursor_pos === 'number' ?
    null : cursor_pos.newRange;
  // take into account the old and new selection to generate the best diff
  // possible for a text edit.  for example, a text change from "xxx" to "xx"
  // could be a delete or forwards-delete of any one of the x's, or the
  // result of selecting two of the x's and typing "x".
  var oldLength = oldText.length;
  var newLength = newText.length;
  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
    // see if we have an insert or delete before or after cursor
    var oldCursor = oldRange.index;
    var oldBefore = oldText.slice(0, oldCursor);
    var oldAfter = oldText.slice(oldCursor);
    var maybeNewCursor = newRange ? newRange.index : null;
    editBefore: {
      // is this an insert or delete right before oldCursor?
      var newCursor = oldCursor + newLength - oldLength;
      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
        break editBefore;
      }
      if (newCursor < 0 || newCursor > newLength) {
        break editBefore;
      }
      var newBefore = newText.slice(0, newCursor);
      var newAfter = newText.slice(newCursor);
      if (newAfter !== oldAfter) {
        break editBefore;
      }
      var prefixLength = Math.min(oldCursor, newCursor);
      var oldPrefix = oldBefore.slice(0, prefixLength);
      var newPrefix = newBefore.slice(0, prefixLength);
      if (oldPrefix !== newPrefix) {
        break editBefore;
      }
      var oldMiddle = oldBefore.slice(prefixLength);
      var newMiddle = newBefore.slice(prefixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
    }
    editAfter: {
      // is this an insert or delete right after oldCursor?
      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
        break editAfter;
      }
      var cursor = oldCursor;
      var newBefore = newText.slice(0, cursor);
      var newAfter = newText.slice(cursor);
      if (newBefore !== oldBefore) {
        break editAfter;
      }
      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
      var newSuffix = newAfter.slice(newAfter.length - suffixLength);
      if (oldSuffix !== newSuffix) {
        break editAfter;
      }
      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
    }
  }
  if (oldRange.length > 0 && newRange && newRange.length === 0) {
    replaceRange: {
      // see if diff could be a splice of the old selection range
      var oldPrefix = oldText.slice(0, oldRange.index);
      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
      var prefixLength = oldPrefix.length;
      var suffixLength = oldSuffix.length;
      if (newLength < prefixLength + suffixLength) {
        break replaceRange;
      }
      var newPrefix = newText.slice(0, prefixLength);
      var newSuffix = newText.slice(newLength - suffixLength);
      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
        break replaceRange;
      }
      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
    }
  }

  return null;
}

function diff(text1, text2, cursor_pos) {
  // only pass fix_unicode=true at the top level, not when diff_main is
  // recursively invoked
  return diff_main(text1, text2, cursor_pos, true);
}

diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;

var _user$project$Native_ImpureGoodies = {
    randomFloat : function(_) {
      return Math.random();
    },

    crashToNothing : function(thunk) {
      try {
        // Just (thunk ())
        var result = thunk({ctor: '_Tuple0'});
        return _elm_lang$core$Maybe$Just(result);
      } catch(err) {
        if (err.ctor === undefined) { // Internal crash, not something thrown with ImpureGoodies.throw below.
          // Nothing
          console.log(err);
          return _elm_lang$core$Maybe$Nothing;
        } else {
          throw err;
        }
      }
    },

    stringCharAt : function(index) {
      return function(string) {
        if(index >= string.length || index < 0) {
          return _elm_lang$core$Maybe$Nothing;
        } else {
          return _elm_lang$core$Maybe$Just(string[index]);
        }
      }
    },

    crashToError : function(thunk) {
      try {
        // Ok (thunk ())
        var result = thunk({ctor: '_Tuple0'});
        return _elm_lang$core$Result$Ok(result);
      } catch(err) {
        if (err.ctor === undefined) { // Internal crash, not something thrown with ImpureGoodies.throw below.
          // Err (toString err)
          return _elm_lang$core$Result$Err(err.toString());
        } else {
          throw err;
        }
      }
    },

    throw : function(exception) {
      throw(exception)
    },

    tryCatch : function(exceptionConstructorName) { return function(thunk) { return function(catchThunk) {
      try {
        return thunk({ctor: '_Tuple0'});
      } catch(exception) {
        if (exception.ctor === exceptionConstructorName) {
          return catchThunk(exception);
        } else {
          throw exception;
        }
      }
    }}},

    mutateRecordField : function(record) { return function(fieldName) { return function(newValue) {
      // Sanity check.
      if (typeof record[fieldName] == typeof newValue) {
        record[fieldName] = newValue;
        return record;
      } else {
        throw "ImpureGoodies.mutateRecordField: types do not match" + (typeof record[fieldName]) + " vs " + (typeof newValue);
      }
    }}},

    putCache: function(record) { return function(cacheName) { return function(newValue) {
      if(typeof record == "object") {
        //record[" cache_" + cacheName] = newValue;
        console.log("stored cache " + cacheName, record)
      } else
        throw "ImpureGoodies.putCache: this is not an object";
      return newValue;
    }}},

    getCache: function(record) { return function(cacheName) {
      if(typeof record != "object")
        throw "ImpureGoodies.putCache: this is not an object";
      console.log("getting cache " + cacheName, record)
      var res = record[" cache_" + cacheName];
      if (typeof res == "undefined")
        return _elm_lang$core$Maybe$Nothing;
      else
        return _elm_lang$core$Maybe$Just(res);
    }},

    toggleGlobalBool : function(_) {
      __globalBoolState__ = !__globalBoolState__;
      return __globalBoolState__;
    },

    getCurrentTime : function() {
      return (new Date()).getTime();
    },

    timedRun : function(thunk) {
      var start = (new Date()).getTime();
      var result = thunk(_elm_lang$core$Native_Utils.Tuple0);
      var end = (new Date()).getTime();

      return _elm_lang$core$Native_Utils.Tuple2(result, end-start);
    },

    evaluate : function(string) {
      return eval(string);
    },

    log : function(string) {
      console.log(string);
      return string;
    },

    htmlescape: (function() {
      var tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
      };

      function replaceTag(tag) {
        return tagsToReplace[tag] || tag;
      }
      function safe_tags_replace(str) {
        return str.replace(/[&<>]/g, replaceTag);
      }
      return function(string) {
        return safe_tags_replace(string);
      }
    })(),

    htmlunescape: (function() {
      var tagsToReplace = {
        '&amp;': '&',
         '&lt;': '<',
        '&gt;': '>'
      };

      function replaceTag(tag) {
        return tagsToReplace[tag] || tag;
      }
      function safe_tags_replace(str) {
        return str.replace(/&(amp|lt|gt);/g, replaceTag);
      }
      return function(string) {
        return safe_tags_replace(string);
      }
    })(),

    emptyNativeRecord: function(dummy) {
      return {};
    },

    addPairToNativeRecord: function(key) {
      return function(value) {
        return function(record) {
          record[key] = value;
          return record;
        }
      }
    },

    setValueToNativeRecord: function(key) {
      return function(mbValue) {
        return function(record) {
          if(typeof record  == "object") {
            if(mbValue.ctor == "Nothing") {
              delete record[key];
            } else {
              record[key] = mbValue._0;
            }
          }
          return record;
        }
      }
    },

    keyPairsOfNativeRecord: function(record) {
      var recordKeys = Object.keys(record);
      var acc = _elm_lang$core$Native_List.Nil;
      for(var i = 0; i < recordKeys.length; i ++) {
        var key = recordKeys[i];
        var value = record[key];
        acc = _elm_lang$core$Native_List.Cons(_elm_lang$core$Native_Utils.Tuple2(key, value), acc)
      }
      return acc;
    },

    nativeRecordGet: function(key) {
      return function(record) {
        if(typeof record == "object") {
          if(typeof record[key] == "undefined") {
              return _elm_lang$core$Maybe$Nothing;
          } else {
            return _elm_lang$core$Maybe$Just(record[key]);
          }
        } else return _elm_lang$core$Maybe$Nothing;
      }
    },

    nativeRecordKeys: function(record) {
     var result = Object.keys(record);
     var listResult = {ctor:"[]"};
     for(var i = result.length - 1; i >= 0; i--) {
       listResult = {ctor:"::",_0:result[i],_1:listResult};
     }
     return listResult;
    },

    toNativeArray: function(elmList) {
      var acc = [];
      while(elmList.ctor != "[]") {
        acc.push(elmList._0);
        elmList = elmList._1;
      }
      return acc;
    },

    fromNativeArray: function(v) {
      var result = _elm_lang$core$Native_List.Nil;
      for(var i = v.length - 1; i >= 0; i-- ) {
        result = _elm_lang$core$Native_List.Cons(v[i], result)
      }
      return result;
    },

    fromNative: (() => {
       var rec = v => stringCallback => numCallback => boolCallback => listCallback => listRecordCallback => functionCallback => {
          if(typeof v == "string") return stringCallback(v);
          if(typeof v == "number") return numCallback(v);
          if(typeof v == "boolean") return boolCallback(v);
          if(typeof v == "function") return functionCallback(v);
          if(typeof v == "object") {
            if(Array.isArray(v)) {
              var result = _elm_lang$core$Native_List.Nil;
              for(var i = v.length - 1; i >= 0; i-- ) {
                result = _elm_lang$core$Native_List.Cons(v[i], result)
              }
              return listCallback(result)
            } else {
              return listRecordCallback(_user$project$Native_ImpureGoodies.keyPairsOfNativeRecord(v))
            }
          }
        }
       return rec
      })(),

    hideType: function(v) {
      return v;
    },

    fromHtmlEntity: function(str) { // Accepts full named entities (e.g. &amp; or numbers like 20)
        if(typeof htmlNamedEntities[str] !== "undefined") {
          return _elm_lang$core$Maybe$Just(htmlNamedEntities[str]);
        } else {
          if(str.startsWith("x")) {
            str = str.substring(1);
            var n = parseInt(str, 16);
            str = "" + n;
          }
          if(typeof htmlNumEntities[str] !== "undefined") {
            return _elm_lang$core$Maybe$Just(htmlNumEntities[str]);
          } else { // If the string starts with x, it is a hexadecimal value
            return _elm_lang$core$Maybe$Nothing;
          }
        }
      },

    matchBaseValue: a => boolc => stringc => intc => {
      if(typeof a == "boolean")
        return {ctor: "Ok", _0: boolc(a)};
      if(typeof a == "string")
        return {ctor: "Ok", _0: stringc(a)};
      if(typeof a == "number")
        return {ctor: "Ok", _0: intc(a)};
      else
        return {ctor: "Err", _0: "" + a + " is not a boolean, string or number"};
    },
    whitespaceFromMetadata: metadata => {

      var commentCompatible = JSON.stringify(metadata).replace(/\\/g,"\\\\").replace(/\{-/g,"{\\-").replace(/-\}/g,"-\\}");
      return " {-" + commentCompatible + "-}";
    },
    whitespaceToMetadata: whitespace => {
      var extracted = /^\s*\{-(.*)-}$/g.exec(whitespace);
      if(extracted) {
        var metadata = JSON.parse(extracted[1].replace(/\{\\-/g, "{-").replace(/-\\\}/g, "-}").replace(/\\\\/g,"\\"))
        return metadata;
      } else return {}
    },
    diffString: a => b => {
       var v = diff(a, b);
       var result = _elm_lang$core$Native_List.Nil;
       for(var i = v.length - 1; i >= 0; i-- ) {
         var x = v[i];
         var elem = {ctor: x[0] === 0 ? "DiffEqual" :
                           x[0] === -1 ? "DiffRemoved" :
                                         "DiffAdded", _0: x[1]};
         result = _elm_lang$core$Native_List.Cons(elem, result)
       }
       return result;
    }
};

var _user$project$ImpureGoodies$diffString = _user$project$Native_ImpureGoodies.diffString;
var _user$project$ImpureGoodies$whitespaceToMetadata = _user$project$Native_ImpureGoodies.whitespaceToMetadata;
var _user$project$ImpureGoodies$whitespaceFromMetadata = _user$project$Native_ImpureGoodies.whitespaceFromMetadata;
var _user$project$ImpureGoodies$matchBaseValue = _user$project$Native_ImpureGoodies.matchBaseValue;
var _user$project$ImpureGoodies$fromHtmlEntity = _user$project$Native_ImpureGoodies.fromHtmlEntity;
var _user$project$ImpureGoodies$hideType = _user$project$Native_ImpureGoodies.hideType;
var _user$project$ImpureGoodies$fromNativeArray = _user$project$Native_ImpureGoodies.fromNativeArray;
var _user$project$ImpureGoodies$toNativeArray = _user$project$Native_ImpureGoodies.toNativeArray;
var _user$project$ImpureGoodies$fromNative = _user$project$Native_ImpureGoodies.fromNative;
var _user$project$ImpureGoodies$nativeRecordKeys = _user$project$Native_ImpureGoodies.nativeRecordKeys;
var _user$project$ImpureGoodies$nativeIntRecordGet = _user$project$Native_ImpureGoodies.nativeRecordGet;
var _user$project$ImpureGoodies$nativeRecordGet = _user$project$Native_ImpureGoodies.nativeRecordGet;
var _user$project$ImpureGoodies$keyPairsOfNativeRecord = _user$project$Native_ImpureGoodies.keyPairsOfNativeRecord;
var _user$project$ImpureGoodies$setValueToNativeIntRecord = F3(
	function (key, mbValue, record) {
		return A3(_user$project$Native_ImpureGoodies.setValueToNativeRecord, key, mbValue, record);
	});
var _user$project$ImpureGoodies$updateNativeIntRecord = F3(
	function (key, valueUpdater, record) {
		return A3(
			_user$project$ImpureGoodies$setValueToNativeIntRecord,
			key,
			valueUpdater(
				A2(_user$project$ImpureGoodies$nativeIntRecordGet, key, record)),
			record);
	});
var _user$project$ImpureGoodies$setValueToNativeRecord = F3(
	function (key, mbValue, record) {
		return A3(_user$project$Native_ImpureGoodies.setValueToNativeRecord, key, mbValue, record);
	});
var _user$project$ImpureGoodies$updateNativeRecord = F3(
	function (key, valueUpdater, record) {
		return A3(
			_user$project$ImpureGoodies$setValueToNativeRecord,
			key,
			valueUpdater(
				A2(_user$project$ImpureGoodies$nativeRecordGet, key, record)),
			record);
	});
var _user$project$ImpureGoodies$mapNativeRecord = F2(
	function (transformer, record) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (key, record) {
					return A3(
						_user$project$ImpureGoodies$setValueToNativeRecord,
						key,
						A2(
							_elm_lang$core$Maybe$map,
							transformer(key),
							A2(_user$project$ImpureGoodies$nativeRecordGet, key, record)),
						record);
				}),
			record,
			_user$project$ImpureGoodies$nativeRecordKeys(record));
	});
var _user$project$ImpureGoodies$addPairToNativeRecord = F2(
	function (_p0, c) {
		var _p1 = _p0;
		return A3(_user$project$Native_ImpureGoodies.addPairToNativeRecord, _p1._0, _p1._1, c);
	});
var _user$project$ImpureGoodies$emptyNativeRecord = _user$project$Native_ImpureGoodies.emptyNativeRecord;
var _user$project$ImpureGoodies$keyPairsToNativeRecord = function (l) {
	return A3(
		_elm_lang$core$List$foldl,
		_user$project$ImpureGoodies$addPairToNativeRecord,
		_user$project$ImpureGoodies$emptyNativeRecord(
			{ctor: '_Tuple0'}),
		l);
};
var _user$project$ImpureGoodies$nativeDict = {
	empty: _user$project$ImpureGoodies$emptyNativeRecord,
	get: _user$project$ImpureGoodies$nativeRecordGet,
	update: _user$project$ImpureGoodies$updateNativeRecord,
	insert: F3(
		function (key, v, record) {
			return A3(
				_user$project$ImpureGoodies$setValueToNativeRecord,
				key,
				_elm_lang$core$Maybe$Just(v),
				record);
		}),
	map: _user$project$ImpureGoodies$mapNativeRecord
};
var _user$project$ImpureGoodies$nativeIntDict = {
	empty: _user$project$ImpureGoodies$emptyNativeRecord,
	get: _user$project$ImpureGoodies$nativeIntRecordGet,
	update: _user$project$ImpureGoodies$updateNativeIntRecord,
	insert: F3(
		function (key, v, record) {
			return A3(
				_user$project$ImpureGoodies$setValueToNativeIntRecord,
				key,
				_elm_lang$core$Maybe$Just(v),
				record);
		})
};
var _user$project$ImpureGoodies$htmlescape = function (s) {
	return _user$project$Native_ImpureGoodies.htmlescape(s);
};
var _user$project$ImpureGoodies$htmlunescape = function (s) {
	return _user$project$Native_ImpureGoodies.htmlunescape(s);
};
var _user$project$ImpureGoodies$log = function (s) {
	return _user$project$Native_ImpureGoodies.log(s);
};
var _user$project$ImpureGoodies$evaluate = function (s) {
	return _user$project$Native_ImpureGoodies.evaluate(s);
};
var _user$project$ImpureGoodies$getCache = F2(
	function (record, cacheName) {
		return A2(_user$project$Native_ImpureGoodies.getCache, record, cacheName);
	});
var _user$project$ImpureGoodies$putCache = F3(
	function (record, cacheName, newValue) {
		return A3(_user$project$Native_ImpureGoodies.putCache, record, cacheName, newValue);
	});
var _user$project$ImpureGoodies$getOrUpdateCache = F3(
	function (record, cacheName, $default) {
		var _p2 = A2(_user$project$ImpureGoodies$getCache, record, cacheName);
		if (_p2.ctor === 'Just') {
			return _p2._0;
		} else {
			return A3(
				_user$project$ImpureGoodies$putCache,
				record,
				cacheName,
				$default(
					{ctor: '_Tuple0'}));
		}
	});
var _user$project$ImpureGoodies$stringCharAt = F2(
	function (index, string) {
		return A2(_user$project$Native_ImpureGoodies.stringCharAt, index, string);
	});
var _user$project$ImpureGoodies$timedRun = function (thunk) {
	return _user$project$Native_ImpureGoodies.timedRun(thunk);
};
var _user$project$ImpureGoodies$logTimedRun = F2(
	function (caption, thunk) {
		var _p3 = _user$project$ImpureGoodies$timedRun(thunk);
		var result = _p3._0;
		var time = _p3._1;
		var _p4 = A2(
			_elm_lang$core$Debug$log,
			A2(_elm_lang$core$Basics_ops['++'], caption, ' milliseconds'),
			time);
		return result;
	});
var _user$project$ImpureGoodies$getCurrentTime = function (_p5) {
	var _p6 = _p5;
	return _user$project$Native_ImpureGoodies.getCurrentTime(
		{ctor: '_Tuple0'});
};
var _user$project$ImpureGoodies$toggleGlobalBool = function (_p7) {
	var _p8 = _p7;
	return _user$project$Native_ImpureGoodies.toggleGlobalBool(
		{ctor: '_Tuple0'});
};
var _user$project$ImpureGoodies$mutateRecordField = F3(
	function (record, fieldName, newValue) {
		return A3(_user$project$Native_ImpureGoodies.mutateRecordField, record, fieldName, newValue);
	});
var _user$project$ImpureGoodies$tryCatch = F3(
	function (exceptionConstructorName, thunk, catchThunk) {
		return A3(_user$project$Native_ImpureGoodies.tryCatch, exceptionConstructorName, thunk, catchThunk);
	});
var _user$project$ImpureGoodies$throw = function (exception) {
	return _user$project$Native_ImpureGoodies.throw(exception);
};
var _user$project$ImpureGoodies$crashToError = function (thunk) {
	return _user$project$Native_ImpureGoodies.crashToError(thunk);
};
var _user$project$ImpureGoodies$crashToNothing = function (thunk) {
	return _user$project$Native_ImpureGoodies.crashToNothing(thunk);
};
var _user$project$ImpureGoodies$randomFloat = function (_p9) {
	var _p10 = _p9;
	return _user$project$Native_ImpureGoodies.randomFloat(
		{ctor: '_Tuple0'});
};
var _user$project$ImpureGoodies$randomInt = F2(
	function (low, highNonInclusive) {
		var range = highNonInclusive - low;
		return _elm_lang$core$Basics$floor(
			(_user$project$ImpureGoodies$randomFloat(
				{ctor: '_Tuple0'}) * _elm_lang$core$Basics$toFloat(range)) + _elm_lang$core$Basics$toFloat(low));
	});

var _user$project$LazyList$elemAt = F2(
	function (n, ll) {
		elemAt:
		while (true) {
			var _p0 = ll;
			if (_p0.ctor === 'Nil') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				if (_elm_lang$core$Native_Utils.eq(n, 0)) {
					return _elm_lang$core$Maybe$Just(_p0._0);
				} else {
					var _v1 = n - 1,
						_v2 = _elm_lang$lazy$Lazy$force(_p0._1);
					n = _v1;
					ll = _v2;
					continue elemAt;
				}
			}
		}
	});
var _user$project$LazyList$findFirst = F2(
	function (pred, l) {
		findFirst:
		while (true) {
			var _p1 = l;
			if (_p1.ctor === 'Nil') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p2 = _p1._0;
				if (pred(_p2)) {
					return _elm_lang$core$Maybe$Just(_p2);
				} else {
					var _v4 = pred,
						_v5 = _elm_lang$lazy$Lazy$force(_p1._1);
					pred = _v4;
					l = _v5;
					continue findFirst;
				}
			}
		}
	});
var _user$project$LazyList$toList = function (lazyList) {
	var _p3 = lazyList;
	if (_p3.ctor === 'Nil') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _p3._0,
			_1: _user$project$LazyList$toList(
				_elm_lang$lazy$Lazy$force(_p3._1))
		};
	}
};
var _user$project$LazyList$isEmpty = function (l) {
	var _p4 = l;
	if (_p4.ctor === 'Nil') {
		return true;
	} else {
		return false;
	}
};
var _user$project$LazyList$Cons = F2(
	function (a, b) {
		return {ctor: 'Cons', _0: a, _1: b};
	});
var _user$project$LazyList$cons = F2(
	function (head, tail) {
		return A2(
			_user$project$LazyList$Cons,
			head,
			_elm_lang$lazy$Lazy$lazy(
				function (_p5) {
					var _p6 = _p5;
					return tail;
				}));
	});
var _user$project$LazyList$append = F2(
	function (l1, l2) {
		var _p7 = l1;
		if (_p7.ctor === 'Nil') {
			return l2;
		} else {
			return A2(
				_user$project$LazyList$Cons,
				_p7._0,
				A2(
					_elm_lang$lazy$Lazy$map,
					function (v) {
						return A2(_user$project$LazyList$append, v, l2);
					},
					_p7._1));
		}
	});
var _user$project$LazyList$appendLazy = F2(
	function (l1, l2) {
		var _p8 = l1;
		if (_p8.ctor === 'Nil') {
			return _elm_lang$lazy$Lazy$force(l2);
		} else {
			return A2(
				_user$project$LazyList$Cons,
				_p8._0,
				A2(
					_elm_lang$lazy$Lazy$map,
					function (v) {
						return A2(_user$project$LazyList$appendLazy, v, l2);
					},
					_p8._1));
		}
	});
var _user$project$LazyList$maybeCons = F2(
	function (x, l) {
		var _p9 = x;
		if (_p9.ctor === 'Nothing') {
			return l;
		} else {
			return A2(
				_user$project$LazyList$Cons,
				_p9._0,
				_elm_lang$lazy$Lazy$lazy(
					function (_p10) {
						return l;
					}));
		}
	});
var _user$project$LazyList$Nil = {ctor: 'Nil'};
var _user$project$LazyList$apply1 = function (a) {
	return A2(_user$project$LazyList$cons, a, _user$project$LazyList$Nil);
};
var _user$project$LazyList$map = F2(
	function (f, l) {
		var _p11 = l;
		if (_p11.ctor === 'Nil') {
			return _user$project$LazyList$Nil;
		} else {
			return A2(
				_user$project$LazyList$Cons,
				f(_p11._0),
				A2(
					_elm_lang$lazy$Lazy$map,
					_user$project$LazyList$map(f),
					_p11._1));
		}
	});
var _user$project$LazyList$andThen = F2(
	function (f, l) {
		var _p12 = l;
		if (_p12.ctor === 'Nil') {
			return _user$project$LazyList$Nil;
		} else {
			return A2(
				_user$project$LazyList$appendLazy,
				f(_p12._0),
				A2(
					_elm_lang$lazy$Lazy$map,
					function (v) {
						return A2(_user$project$LazyList$andThen, f, v);
					},
					_p12._1));
		}
	});
var _user$project$LazyList$filter = F2(
	function (isok, l) {
		filter:
		while (true) {
			var _p13 = l;
			if (_p13.ctor === 'Nil') {
				return _user$project$LazyList$Nil;
			} else {
				var _p15 = _p13._1;
				var _p14 = _p13._0;
				if (isok(_p14)) {
					return A2(
						_user$project$LazyList$Cons,
						_p14,
						A2(
							_elm_lang$lazy$Lazy$map,
							_user$project$LazyList$filter(isok),
							_p15));
				} else {
					var _v15 = isok,
						_v16 = _elm_lang$lazy$Lazy$force(_p15);
					isok = _v15;
					l = _v16;
					continue filter;
				}
			}
		}
	});
var _user$project$LazyList$filterMap = F2(
	function (f, l) {
		filterMap:
		while (true) {
			var _p16 = l;
			if (_p16.ctor === 'Nil') {
				return _user$project$LazyList$Nil;
			} else {
				var _p18 = _p16._1;
				var _p17 = f(_p16._0);
				if (_p17.ctor === 'Nothing') {
					var _v19 = f,
						_v20 = _elm_lang$lazy$Lazy$force(_p18);
					f = _v19;
					l = _v20;
					continue filterMap;
				} else {
					return A2(
						_user$project$LazyList$Cons,
						_p17._0,
						A2(
							_elm_lang$lazy$Lazy$map,
							_user$project$LazyList$filterMap(f),
							_p18));
				}
			}
		}
	});
var _user$project$LazyList$flatten = function (l) {
	var _p19 = l;
	if (_p19.ctor === 'Nil') {
		return _user$project$LazyList$Nil;
	} else {
		return A2(
			_user$project$LazyList$appendLazy,
			_p19._0,
			A2(_elm_lang$lazy$Lazy$map, _user$project$LazyList$flatten, _p19._1));
	}
};
var _user$project$LazyList$cartesianProduct = F2(
	function (xs, ys) {
		return _user$project$LazyList$flatten(
			A2(
				_user$project$LazyList$map,
				function (x) {
					return A2(
						_user$project$LazyList$map,
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							})(x),
						ys);
				},
				xs));
	});
var _user$project$LazyList$fromList = function (l) {
	var _p20 = l;
	if (_p20.ctor === '[]') {
		return _user$project$LazyList$Nil;
	} else {
		return A2(
			_user$project$LazyList$Cons,
			_p20._0,
			_elm_lang$lazy$Lazy$lazy(
				function (_p21) {
					var _p22 = _p21;
					return _user$project$LazyList$fromList(_p20._1);
				}));
	}
};
var _user$project$LazyList$takeWhile = F2(
	function (pred, l) {
		var _p23 = l;
		if (_p23.ctor === 'Nil') {
			return _user$project$LazyList$Nil;
		} else {
			var _p24 = _p23._0;
			return pred(_p24) ? A2(
				_user$project$LazyList$Cons,
				_p24,
				A2(
					_elm_lang$lazy$Lazy$map,
					_user$project$LazyList$takeWhile(pred),
					_p23._1)) : _user$project$LazyList$Nil;
		}
	});
var _user$project$LazyList$dropWhile = F2(
	function (pred, l) {
		dropWhile:
		while (true) {
			var _p25 = l;
			if (_p25.ctor === 'Nil') {
				return _user$project$LazyList$Nil;
			} else {
				if (pred(_p25._0)) {
					var _v26 = pred,
						_v27 = _elm_lang$lazy$Lazy$force(_p25._1);
					pred = _v26;
					l = _v27;
					continue dropWhile;
				} else {
					return l;
				}
			}
		}
	});
var _user$project$LazyList$zip = F2(
	function (la, lb) {
		var _p26 = {ctor: '_Tuple2', _0: la, _1: lb};
		if (_p26._0.ctor === 'Nil') {
			return _user$project$LazyList$Nil;
		} else {
			if (_p26._1.ctor === 'Nil') {
				return _user$project$LazyList$Nil;
			} else {
				return A2(
					_user$project$LazyList$Cons,
					{ctor: '_Tuple2', _0: _p26._0._0, _1: _p26._1._0},
					A3(_elm_lang$lazy$Lazy$map2, _user$project$LazyList$zip, _p26._0._1, _p26._1._1));
			}
		}
	});

var _user$project$Results$andAlso = F2(
	function (other, current) {
		var _p0 = {ctor: '_Tuple2', _0: other, _1: current};
		if (_p0._0.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p0._0._0);
		} else {
			if (_p0._1.ctor === 'Err') {
				return _elm_lang$core$Result$Err(_p0._1._0);
			} else {
				return _elm_lang$core$Result$Ok(
					A2(_user$project$LazyList$append, _p0._0._0, _p0._1._0));
			}
		}
	});
var _user$project$Results$force = function (r) {
	var _p1 = r;
	if (_p1.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p1._0);
	} else {
		return _elm_lang$core$Result$Ok(
			_user$project$LazyList$fromList(
				_user$project$LazyList$toList(_p1._0)));
	}
};
var _user$project$Results$toList = function (r) {
	var _p2 = r;
	if (_p2.ctor === 'Err') {
		return {ctor: '[]'};
	} else {
		return _user$project$LazyList$toList(_p2._0);
	}
};
var _user$project$Results$fromMaybe = F2(
	function (err, maybe) {
		var _p3 = maybe;
		if (_p3.ctor === 'Just') {
			return _elm_lang$core$Result$Ok(_p3._0);
		} else {
			return _elm_lang$core$Result$Err(err);
		}
	});
var _user$project$Results$toMaybe = function (results) {
	var _p4 = results;
	if (_p4.ctor === 'Ok') {
		return _elm_lang$core$Maybe$Just(_p4._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Results$mapErrors = F2(
	function (f, results) {
		var _p5 = results;
		if (_p5.ctor === 'Ok') {
			return _elm_lang$core$Result$Ok(_p5._0);
		} else {
			return _elm_lang$core$Result$Err(
				f(_p5._0));
		}
	});
var _user$project$Results$map2withError = F4(
	function (errorFunc, func, ra, rb) {
		var _p6 = {ctor: '_Tuple2', _0: ra, _1: rb};
		if (_p6._0.ctor === 'Err') {
			if (_p6._1.ctor === 'Err') {
				return _elm_lang$core$Result$Err(
					errorFunc(
						{ctor: '_Tuple2', _0: _p6._0._0, _1: _p6._1._0}));
			} else {
				return _elm_lang$core$Result$Err(_p6._0._0);
			}
		} else {
			if (_p6._1.ctor === 'Err') {
				return _elm_lang$core$Result$Err(_p6._1._0);
			} else {
				return _elm_lang$core$Result$Ok(
					A2(
						_user$project$LazyList$map,
						func,
						A2(_user$project$LazyList$cartesianProduct, _p6._0._0, _p6._1._0)));
			}
		}
	});
var _user$project$Results$map = F2(
	function (func, ra) {
		return A2(
			_elm_lang$core$Result$map,
			_user$project$LazyList$map(func),
			ra);
	});
var _user$project$Results$firstResult = function (r) {
	var _p7 = r;
	if (_p7.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p7._0);
	} else {
		if (_p7._0.ctor === 'Nil') {
			return _elm_lang$core$Result$Err('No result');
		} else {
			return _elm_lang$core$Result$Ok(_p7._0._0);
		}
	}
};
var _user$project$Results$withDefault1 = F2(
	function (def, results) {
		var _p8 = results;
		if ((_p8.ctor === 'Ok') && (_p8._0.ctor === 'Cons')) {
			return _p8._0._0;
		} else {
			return def;
		}
	});
var _user$project$Results$fold = F3(
	function (errsMap, oksMap, res) {
		var _p9 = res;
		if (_p9.ctor === 'Err') {
			return errsMap(_p9._0);
		} else {
			return oksMap(_p9._0);
		}
	});
var _user$project$Results$keepOks = function (l) {
	keepOks:
	while (true) {
		var _p10 = l;
		if (_p10.ctor === 'Nil') {
			return _user$project$LazyList$Nil;
		} else {
			if (_p10._0.ctor === 'Err') {
				var _v11 = _elm_lang$lazy$Lazy$force(_p10._1);
				l = _v11;
				continue keepOks;
			} else {
				return A2(
					_user$project$LazyList$appendLazy,
					_p10._0._0,
					A2(_elm_lang$lazy$Lazy$map, _user$project$Results$keepOks, _p10._1));
			}
		}
	}
};
var _user$project$Results$projOks = function (l) {
	projOks:
	while (true) {
		var _p11 = l;
		if (_p11.ctor === 'Nil') {
			return _elm_lang$core$Result$Ok(_user$project$LazyList$Nil);
		} else {
			if (_p11._0.ctor === 'Ok') {
				if (_p11._0._0.ctor === 'Nil') {
					var _v13 = _elm_lang$lazy$Lazy$force(_p11._1);
					l = _v13;
					continue projOks;
				} else {
					return _elm_lang$core$Result$Ok(
						A2(
							_user$project$LazyList$Cons,
							_p11._0._0._0,
							_elm_lang$lazy$Lazy$lazy(
								function (_p12) {
									return A2(
										_user$project$LazyList$appendLazy,
										_elm_lang$lazy$Lazy$force(_p11._0._0._1),
										A2(_elm_lang$lazy$Lazy$map, _user$project$Results$keepOks, _p11._1));
								})));
				}
			} else {
				var _p14 = _p11._0._0;
				var _p13 = _user$project$Results$projOks(
					_elm_lang$lazy$Lazy$force(_p11._1));
				if (_p13.ctor === 'Err') {
					return _elm_lang$core$Result$Err(_p14);
				} else {
					if (_p13._0.ctor === 'Nil') {
						return _elm_lang$core$Result$Err(_p14);
					} else {
						return _p13;
					}
				}
			}
		}
	}
};
var _user$project$Results$flatten = function (r) {
	var _p15 = r;
	if (_p15.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p15._0);
	} else {
		return _user$project$Results$projOks(_p15._0);
	}
};
var _user$project$Results$andThen = F2(
	function (callback, results) {
		var _p16 = results;
		if (_p16.ctor === 'Ok') {
			return _user$project$Results$projOks(
				A2(_user$project$LazyList$map, callback, _p16._0));
		} else {
			return _elm_lang$core$Result$Err(_p16._0);
		}
	});
var _user$project$Results$map2 = F3(
	function (func, ra, rb) {
		return A2(
			_user$project$Results$andThen,
			function (a) {
				return A2(
					_user$project$Results$map,
					func(a),
					rb);
			},
			ra);
	});
var _user$project$Results$filter = F2(
	function (pred, r) {
		var _p17 = r;
		if (_p17.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p17._0);
		} else {
			return _elm_lang$core$Result$Ok(
				A2(_user$project$LazyList$filter, pred, _p17._0));
		}
	});
var _user$project$Results$errs = function (msg) {
	return _elm_lang$core$Result$Err(msg);
};
var _user$project$Results$okLazy = F2(
	function (head, tailLazy) {
		return _elm_lang$core$Result$Ok(
			A2(
				_user$project$LazyList$Cons,
				head,
				_elm_lang$lazy$Lazy$lazy(tailLazy)));
	});
var _user$project$Results$oks = function (a) {
	return _elm_lang$core$Result$Ok(
		_user$project$LazyList$fromList(a));
};
var _user$project$Results$ok1 = function (a) {
	return _elm_lang$core$Result$Ok(
		A2(_user$project$LazyList$cons, a, _user$project$LazyList$Nil));
};
var _user$project$Results$projOk = function (l) {
	var _p18 = l;
	if (_p18.ctor === '[]') {
		return _user$project$Results$ok1(
			{ctor: '[]'});
	} else {
		return A2(
			_user$project$Results$andThen,
			function (a) {
				return A2(
					_user$project$Results$map,
					function (atail) {
						return {ctor: '::', _0: a, _1: atail};
					},
					_user$project$Results$projOk(_p18._1));
			},
			_p18._0);
	}
};
var _user$project$Results$fromResult = function (res) {
	var _p19 = res;
	if (_p19.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p19._0);
	} else {
		return _user$project$Results$ok1(_p19._0);
	}
};

var _user$project$Lang$updatedVal = {
	unapply: function (updatedVal) {
		return {ctor: '_Tuple2', _0: updatedVal.val, _1: updatedVal.changes};
	}
};
var _user$project$Lang$vRecordDiffsUnapply = function (x) {
	var _p0 = x;
	if (_p0.ctor === 'VRecordDiffs') {
		return _elm_lang$core$Maybe$Just(_p0._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vListDiffsUnapply = function (vdiffs) {
	var _p1 = vdiffs;
	if (_p1.ctor === 'VListDiffs') {
		return _elm_lang$core$Maybe$Just(_p1._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$lengthGroup = function (_p2) {
	return _elm_lang$core$List$sum(
		A2(
			_elm_lang$core$List$map,
			function (_p3) {
				return _elm_lang$core$List$length(
					_elm_lang$core$Tuple$second(_p3));
			},
			_p2));
};
var _user$project$Lang$mapGroup = function (_p4) {
	return _elm_lang$core$List$map(
		_elm_lang$core$Tuple$mapSecond(
			_elm_lang$core$List$map(_p4)));
};
var _user$project$Lang$extractGroupInfo = F3(
	function (f, isRec, groups) {
		return A2(
			_elm_lang$core$List$map,
			function (group) {
				var bGroup = A2(_elm_lang$core$List$map, f, group);
				return {
					ctor: '_Tuple2',
					_0: isRec(bGroup),
					_1: bGroup
				};
			},
			groups);
	});
var _user$project$Lang$foldLeftGroup = F3(
	function (acc, elems_, callback) {
		var aux = F2(
			function (acc, elems) {
				aux:
				while (true) {
					var _p5 = elems;
					if (_p5.ctor === '[]') {
						return acc;
					} else {
						var _v3 = A3(callback, acc, _p5._0._1, _p5._0._0),
							_v4 = _p5._1;
						acc = _v3;
						elems = _v4;
						continue aux;
					}
				}
			});
		return A2(aux, acc, elems_);
	});
var _user$project$Lang$foldRightGroup = F3(
	function (elems, acc, callback) {
		return A3(
			_user$project$Lang$foldLeftGroup,
			acc,
			_elm_lang$core$List$reverse(elems),
			F3(
				function (acc, group, isRec) {
					return A3(
						callback,
						_elm_lang$core$List$reverse(group),
						isRec,
						acc);
				}));
	});
var _user$project$Lang$consGroup = F3(
	function (isRec, group, tail) {
		return {
			ctor: '::',
			_0: {ctor: '_Tuple2', _0: isRec, _1: group},
			_1: tail
		};
	});
var _user$project$Lang$unconsGroup = function (groups) {
	var _p6 = groups;
	if (_p6.ctor === '[]') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple3', _0: _p6._0._0, _1: _p6._0._1, _2: _p6._1});
	}
};
var _user$project$Lang$isTypeMutuallyRecursive = function (group) {
	return (_elm_lang$core$Native_Utils.cmp(
		_elm_lang$core$List$length(group),
		2) > -1) || A2(
		_elm_lang$core$List$all,
		function (_p7) {
			var _p8 = _p7;
			return (!_elm_lang$core$Native_Utils.eq(_p8._2, _elm_lang$core$Maybe$Nothing)) && function () {
				var _p9 = _p8._6.val.t__;
				if (_p9.ctor === 'TForall') {
					return true;
				} else {
					return false;
				}
			}();
		},
		group);
};
var _user$project$Lang$groupBoundExps = _elm_lang$core$List$map(
	function (_p10) {
		var _p11 = _p10;
		return _p11._5;
	});
var _user$project$Lang$identifiersListInPat = function (pat) {
	identifiersListInPat:
	while (true) {
		var _p12 = pat.val.p__;
		switch (_p12.ctor) {
			case 'PVar':
				return {
					ctor: '::',
					_0: _p12._1,
					_1: {ctor: '[]'}
				};
			case 'PList':
				if (_p12._3.ctor === 'Just') {
					return A2(
						_elm_lang$core$List$concatMap,
						_user$project$Lang$identifiersListInPat,
						{ctor: '::', _0: _p12._3._0, _1: _p12._1});
				} else {
					return A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, _p12._1);
				}
			case 'PAs':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$identifiersListInPat(_p12._1),
					_user$project$Lang$identifiersListInPat(_p12._3));
			case 'PRecord':
				return A2(
					_elm_lang$core$List$concatMap,
					_user$project$Lang$identifiersListInPat,
					_user$project$Utils$recordValues(_p12._1));
			case 'PConst':
				return {ctor: '[]'};
			case 'PBase':
				return {ctor: '[]'};
			case 'PWildcard':
				return {ctor: '[]'};
			case 'PParens':
				var _v10 = _p12._1;
				pat = _v10;
				continue identifiersListInPat;
			default:
				var _v11 = _p12._1;
				pat = _v11;
				continue identifiersListInPat;
		}
	}
};
var _user$project$Lang$publicIdentifiersListIntPat = function (pat) {
	var _p13 = pat.val.p__;
	switch (_p13.ctor) {
		case 'PVar':
			return {
				ctor: '::',
				_0: _p13._1,
				_1: {ctor: '[]'}
			};
		case 'PList':
			if (_p13._3.ctor === 'Just') {
				return A2(
					_elm_lang$core$List$concatMap,
					_user$project$Lang$identifiersListInPat,
					{ctor: '::', _0: _p13._3._0, _1: _p13._1});
			} else {
				return A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, _p13._1);
			}
		case 'PAs':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$identifiersListInPat(_p13._1),
				_user$project$Lang$identifiersListInPat(_p13._3));
		case 'PRecord':
			return A2(
				_elm_lang$core$List$concatMap,
				_user$project$Lang$identifiersListInPat,
				_user$project$Utils$recordValues(_p13._1));
		case 'PConst':
			return {ctor: '[]'};
		case 'PBase':
			return {ctor: '[]'};
		case 'PWildcard':
			return {ctor: '[]'};
		case 'PParens':
			return {ctor: '[]'};
		default:
			return _user$project$Lang$identifiersListInPat(_p13._1);
	}
};
var _user$project$Lang$identifiersListInPats = function (pats) {
	return A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, pats);
};
var _user$project$Lang$identifiersSetInPat = function (pat) {
	return _elm_lang$core$Set$fromList(
		_user$project$Lang$identifiersListInPat(pat));
};
var _user$project$Lang$identifiersSetInPats = function (pats) {
	return _user$project$Utils$unionAll(
		A2(_elm_lang$core$List$map, _user$project$Lang$identifiersSetInPat, pats));
};
var _user$project$Lang$groupIdentifiers = _elm_lang$core$List$concatMap(
	function (_p14) {
		var _p15 = _p14;
		return _user$project$Lang$identifiersListInPat(_p15._2);
	});
var _user$project$Lang$branchPatExps = function (branches) {
	return A2(
		_elm_lang$core$List$map,
		function (_p16) {
			return function (_p17) {
				var _p18 = _p17;
				return {ctor: '_Tuple2', _0: _p18._1, _1: _p18._2};
			}(
				function (_) {
					return _.val;
				}(_p16));
		},
		branches);
};
var _user$project$Lang$tagPatList = function (_p19) {
	var _p20 = _p19;
	return function (_p21) {
		return _elm_lang$core$List$concat(
			A2(
				_elm_lang$core$List$indexedMap,
				F2(
					function (index, pat) {
						return A2(
							_user$project$Lang$tagSinglePat,
							{
								ctor: '_Tuple2',
								_0: _p20._0,
								_1: A2(
									_elm_lang$core$Basics_ops['++'],
									_p20._1,
									{
										ctor: '::',
										_0: index + 1,
										_1: {ctor: '[]'}
									})
							},
							pat);
					}),
				_p21));
	};
};
var _user$project$Lang$tagSinglePat = F2(
	function (ppid, pat) {
		var childPPID = function (index) {
			return A2(
				_elm_lang$core$Tuple$mapSecond,
				function (path) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						path,
						{
							ctor: '::',
							_0: index,
							_1: {ctor: '[]'}
						});
				},
				ppid);
		};
		return {
			ctor: '::',
			_0: {ctor: '_Tuple2', _0: pat.val.pid, _1: ppid},
			_1: function () {
				var _p22 = pat.val.p__;
				switch (_p22.ctor) {
					case 'PConst':
						return {ctor: '[]'};
					case 'PBase':
						return {ctor: '[]'};
					case 'PVar':
						return {ctor: '[]'};
					case 'PWildcard':
						return {ctor: '[]'};
					case 'PAs':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_user$project$Lang$tagSinglePat,
								childPPID(1),
								_p22._1),
							A2(
								_user$project$Lang$tagSinglePat,
								childPPID(2),
								_p22._3));
					case 'PList':
						if (_p22._3.ctor === 'Nothing') {
							return A2(_user$project$Lang$tagPatList, ppid, _p22._1);
						} else {
							return A2(
								_user$project$Lang$tagPatList,
								ppid,
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p22._1,
									{
										ctor: '::',
										_0: _p22._3._0,
										_1: {ctor: '[]'}
									}));
						}
					case 'PParens':
						return A2(
							_user$project$Lang$tagSinglePat,
							childPPID(1),
							_p22._1);
					case 'PRecord':
						return A2(
							_user$project$Lang$tagPatList,
							ppid,
							_user$project$Utils$recordValues(_p22._1));
					default:
						return A2(
							_user$project$Lang$tagSinglePat,
							childPPID(1),
							_p22._1);
				}
			}()
		};
	});
var _user$project$Lang$rootPathedPatternId = function (scopeId) {
	return {
		ctor: '_Tuple2',
		_0: scopeId,
		_1: {ctor: '[]'}
	};
};
var _user$project$Lang$tagBranchList = function (eid) {
	return function (_p23) {
		return _elm_lang$core$List$concat(
			A2(
				_elm_lang$core$List$indexedMap,
				F2(
					function (index, branch) {
						var _p24 = branch.val;
						return A2(
							_user$project$Lang$tagSinglePat,
							_user$project$Lang$rootPathedPatternId(
								{ctor: '_Tuple2', _0: eid, _1: index}),
							_p24._1);
					}),
				_p23));
	};
};
var _user$project$Lang$hasPid = F2(
	function (pid, codeObject) {
		var _p25 = codeObject;
		if (_p25.ctor === 'P') {
			return _elm_lang$core$Native_Utils.eq(_p25._1.val.pid, pid);
		} else {
			return false;
		}
	});
var _user$project$Lang$splitBeforeWhitespace = function (e1Ws) {
	if (_elm_lang$core$Native_Utils.eq(e1Ws.start.line, e1Ws.end.line)) {
		return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: e1Ws};
	} else {
		var breakpoint = {line: e1Ws.start.line + 1, col: 1};
		return {
			ctor: '_Tuple2',
			_0: _elm_lang$core$Maybe$Just(
				_elm_lang$core$Native_Utils.update(
					e1Ws,
					{
						end: _elm_lang$core$Native_Utils.update(
							breakpoint,
							{col: 0})
					})),
			_1: _elm_lang$core$Native_Utils.update(
				e1Ws,
				{start: breakpoint})
		};
	}
};
var _user$project$Lang$isTarget = function (codeObject) {
	var _p26 = codeObject;
	switch (_p26.ctor) {
		case 'DT':
			return true;
		case 'ET':
			return true;
		case 'PT':
			return true;
		case 'TT':
			return true;
		default:
			return false;
	}
};
var _user$project$Lang$isTextSelectable = function (codeObject) {
	return !_user$project$Lang$isTarget(codeObject);
};
var _user$project$Lang$extractInfoFromCodeObject = function (codeObject) {
	var _p27 = codeObject;
	switch (_p27.ctor) {
		case 'E':
			return A2(_user$project$Info$replaceInfo, _p27._0._0, codeObject);
		case 'P':
			return A2(_user$project$Info$replaceInfo, _p27._1, codeObject);
		case 'T':
			return A2(_user$project$Info$replaceInfo, _p27._0, codeObject);
		case 'D':
			return A2(_user$project$Info$replaceInfo, _p27._0, codeObject);
		case 'DT':
			return A2(_user$project$Info$replaceInfo, _p27._1, codeObject);
		case 'ET':
			return A2(_user$project$Info$replaceInfo, _p27._1, codeObject);
		case 'PT':
			return A2(_user$project$Info$replaceInfo, _p27._1, codeObject);
		default:
			return A2(_user$project$Info$replaceInfo, _p27._1, codeObject);
	}
};
var _user$project$Lang$regroup = F2(
	function (groups, newElems) {
		return _elm_lang$core$List$reverse(
			_elm_lang$core$Tuple$first(
				A3(
					_user$project$Utils$foldLeft,
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: newElems
					},
					groups,
					F2(
						function (_p29, _p28) {
							var _p30 = _p29;
							var _p31 = _p28;
							var _p32 = A2(
								_user$project$Utils$split,
								_elm_lang$core$List$length(_p31._1),
								_p30._1);
							var newGroup = _p32._0;
							var newTail = _p32._1;
							return {
								ctor: '_Tuple2',
								_0: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _p31._0, _1: newGroup},
									_1: _p30._0
								},
								_1: newTail
							};
						}))));
	});
var _user$project$Lang$elemsOf = function (groups) {
	return A2(
		_elm_lang$core$List$concatMap,
		function (_p33) {
			var _p34 = _p33;
			return _p34._1;
		},
		groups);
};
var _user$project$Lang$indent = F2(
	function (spaces, ws) {
		return _elm_lang$core$String$reverse(
			A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$AtMost(1),
				_elm_lang$core$Regex$regex('\n'),
				function (_p35) {
					return A2(_elm_lang$core$Basics_ops['++'], spaces, '\n');
				},
				_elm_lang$core$String$reverse(ws)));
	});
var _user$project$Lang$indentWs = F2(
	function (spaces, ws) {
		return A2(
			_user$project$Info$replaceInfo,
			ws,
			A2(_user$project$Lang$indent, spaces, ws.val));
	});
var _user$project$Lang$indentMaybeWS = function (spaces) {
	return _elm_lang$core$Maybe$map(
		_user$project$Lang$indentWs(spaces));
};
var _user$project$Lang$removeIndentation = F2(
	function (smallestIndentation, ws) {
		return A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex(
				A2(_elm_lang$core$Basics_ops['++'], '\n', smallestIndentation)),
			function (_p36) {
				return '\n';
			},
			ws);
	});
var _user$project$Lang$minString = F2(
	function (s1, s2) {
		return (_elm_lang$core$Native_Utils.cmp(
			_elm_lang$core$String$length(s1),
			_elm_lang$core$String$length(s2)) < 0) ? s1 : s2;
	});
var _user$project$Lang$minIndentation = F2(
	function (prevMinIndent, ws) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (mba, minIndent) {
					var _p37 = mba;
					if (_p37.ctor === 'Nothing') {
						return minIndent;
					} else {
						var _p39 = _p37._0;
						var _p38 = minIndent;
						if (_p38.ctor === 'Just') {
							return _elm_lang$core$Maybe$Just(
								A2(_user$project$Lang$minString, _p38._0, _p39));
						} else {
							return _elm_lang$core$Maybe$Just(_p39);
						}
					}
				}),
			prevMinIndent,
			_elm_lang$core$List$concat(
				A2(
					_elm_lang$core$List$map,
					function (_) {
						return _.submatches;
					},
					A3(
						_elm_lang$core$Regex$find,
						_elm_lang$core$Regex$All,
						_elm_lang$core$Regex$regex('\n( *)(?=$|\\S)'),
						ws))));
	});
var _user$project$Lang$minIndentationListMaybeWS = F2(
	function (prevMinIndent, l) {
		minIndentationListMaybeWS:
		while (true) {
			var _p40 = l;
			if (_p40.ctor === '[]') {
				return prevMinIndent;
			} else {
				if (_p40._0.ctor === 'Just') {
					var _v27 = A2(_user$project$Lang$minIndentation, prevMinIndent, _p40._0._0.val),
						_v28 = _p40._1;
					prevMinIndent = _v27;
					l = _v28;
					continue minIndentationListMaybeWS;
				} else {
					var _v29 = prevMinIndent,
						_v30 = _p40._1;
					prevMinIndent = _v29;
					l = _v30;
					continue minIndentationListMaybeWS;
				}
			}
		}
	});
var _user$project$Lang$tabsToSpaces = function (ws) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$All,
		_elm_lang$core$Regex$regex('\t'),
		function (_p41) {
			return 'Â Â Â Â ';
		},
		ws);
};
var _user$project$Lang$ensureNNewlines = F3(
	function (n, indentationIfNoPreviousNewlines, ws) {
		var previousNewlineCount = _elm_lang$core$List$length(
			A2(_elm_lang$core$String$split, '\n', ws)) - 1;
		return _elm_lang$core$Native_Utils.eq(previousNewlineCount, 0) ? A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$String$repeat, n, '\n'),
			A2(_elm_lang$core$Basics_ops['++'], indentationIfNoPreviousNewlines, ws)) : ((_elm_lang$core$Native_Utils.cmp(previousNewlineCount, n) < 0) ? A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$String$repeat, n, '\n'),
			A2(
				_user$project$Lang$indent,
				indentationIfNoPreviousNewlines,
				A2(
					_user$project$Lang$removeIndentation,
					A2(
						_elm_lang$core$Maybe$withDefault,
						'',
						A2(_user$project$Lang$minIndentation, _elm_lang$core$Maybe$Nothing, ws)),
					ws))) : ws);
	});
var _user$project$Lang$ensureWhitespace = function (s) {
	return _elm_lang$core$Native_Utils.eq(s, '') ? ' ' : s;
};
var _user$project$Lang$allWhitespacesType_ = function (tipe) {
	var allWhitespacesForTPat = function (tpat) {
		var _p42 = tpat.val;
		return {
			ctor: '::',
			_0: _p42._0,
			_1: {ctor: '[]'}
		};
	};
	var _p43 = tipe.val.t__;
	switch (_p43.ctor) {
		case 'TNum':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		case 'TBool':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		case 'TString':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		case 'TNull':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		case 'TList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesType_(_p43._1),
					{
						ctor: '::',
						_0: _p43._2,
						_1: {ctor: '[]'}
					}));
		case 'TRecord':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					function () {
						var _p44 = _p43._1;
						if (_p44.ctor === 'Nothing') {
							return {ctor: '[]'};
						} else {
							return {
								ctor: '::',
								_0: _p44._0._1,
								_1: {ctor: '[]'}
							};
						}
					}(),
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$List$concatMap,
							_user$project$Lang$allWhitespacesType_,
							_user$project$Utils$recordValues(_p43._2)),
						{
							ctor: '::',
							_0: _p43._3,
							_1: {ctor: '[]'}
						})));
		case 'TDict':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesType_(_p43._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$allWhitespacesType_(_p43._2),
						{
							ctor: '::',
							_0: _p43._3,
							_1: {ctor: '[]'}
						})));
		case 'TTuple':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesType_, _p43._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p43._2,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								{ctor: '[]'},
								A2(_elm_lang$core$Maybe$map, _user$project$Lang$allWhitespacesType_, _p43._3)),
							{
								ctor: '::',
								_0: _p43._4,
								_1: {ctor: '[]'}
							}))));
		case 'TArrow':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesType_, _p43._1),
					{
						ctor: '::',
						_0: _p43._2,
						_1: {ctor: '[]'}
					}));
		case 'TUnion':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesType_, _p43._1),
					{
						ctor: '::',
						_0: _p43._2,
						_1: {ctor: '[]'}
					}));
		case 'TApp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesType_, _p43._2));
		case 'TVar':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		case 'TForall':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, allWhitespacesForTPat, _p43._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$allWhitespacesType_(_p43._2),
						{
							ctor: '::',
							_0: _p43._3,
							_1: {ctor: '[]'}
						})));
		case 'TWildcard':
			return {
				ctor: '::',
				_0: _p43._0,
				_1: {ctor: '[]'}
			};
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p43._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesType_(_p43._1),
					{
						ctor: '::',
						_0: _p43._2,
						_1: {ctor: '[]'}
					}));
	}
};
var _user$project$Lang$minIndentationType = F2(
	function (prevMinIndent, tpe) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p45, minIndent) {
					var _p46 = _p45;
					return A2(_user$project$Lang$minIndentation, minIndent, _p46.val);
				}),
			prevMinIndent,
			_user$project$Lang$allWhitespacesType_(tpe));
	});
var _user$project$Lang$allWhitespacesPat_ = function (pat) {
	var _p47 = pat.val.p__;
	switch (_p47.ctor) {
		case 'PVar':
			return {
				ctor: '::',
				_0: _p47._0,
				_1: {ctor: '[]'}
			};
		case 'PConst':
			return {
				ctor: '::',
				_0: _p47._0,
				_1: {ctor: '[]'}
			};
		case 'PBase':
			return {
				ctor: '::',
				_0: _p47._0,
				_1: {ctor: '[]'}
			};
		case 'PWildcard':
			return {
				ctor: '::',
				_0: _p47._0,
				_1: {ctor: '[]'}
			};
		case 'PList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p47._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesPat_, _p47._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p47._2,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								{ctor: '[]'},
								A2(_elm_lang$core$Maybe$map, _user$project$Lang$allWhitespacesPat_, _p47._3)),
							{
								ctor: '::',
								_0: _p47._4,
								_1: {ctor: '[]'}
							}))));
		case 'PRecord':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p47._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$List$concatMap,
						_user$project$Lang$allWhitespacesPat_,
						_user$project$Utils$recordValues(_p47._1)),
					{
						ctor: '::',
						_0: _p47._2,
						_1: {ctor: '[]'}
					}));
		case 'PAs':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p47._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesPat_(_p47._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p47._2,
							_1: {ctor: '[]'}
						},
						_user$project$Lang$allWhitespacesPat_(_p47._3))));
		case 'PParens':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p47._0,
					_1: {
						ctor: '::',
						_0: _p47._2,
						_1: {ctor: '[]'}
					}
				},
				_user$project$Lang$allWhitespacesPat_(_p47._1));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p47._0,
					_1: {
						ctor: '::',
						_0: _p47._2,
						_1: {ctor: '[]'}
					}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesPat_(_p47._1),
					_user$project$Lang$allWhitespacesType_(_p47._3)));
	}
};
var _user$project$Lang$allWhitespacesPat = function (pat) {
	return A2(
		_elm_lang$core$List$map,
		function (_) {
			return _.val;
		},
		_user$project$Lang$allWhitespacesPat_(pat));
};
var _user$project$Lang$patHasNewlines = function (pat) {
	return A2(
		_elm_lang$core$List$any,
		_elm_lang$core$String$contains('\n'),
		_user$project$Lang$allWhitespacesPat(pat));
};
var _user$project$Lang$maybeToList = function (p) {
	var _p48 = p;
	if (_p48.ctor === 'Just') {
		return {
			ctor: '::',
			_0: _p48._0,
			_1: {ctor: '[]'}
		};
	} else {
		return {ctor: '[]'};
	}
};
var _user$project$Lang$precedingWhitespaceWithInfoType = function (t) {
	var _p49 = t.val.t__;
	switch (_p49.ctor) {
		case 'TNum':
			return _p49._0;
		case 'TBool':
			return _p49._0;
		case 'TString':
			return _p49._0;
		case 'TNull':
			return _p49._0;
		case 'TList':
			return _p49._0;
		case 'TDict':
			return _p49._0;
		case 'TTuple':
			return _p49._0;
		case 'TRecord':
			return _p49._0;
		case 'TArrow':
			return _p49._0;
		case 'TUnion':
			return _p49._0;
		case 'TApp':
			return _p49._0;
		case 'TVar':
			return _p49._0;
		case 'TForall':
			return _p49._0;
		case 'TWildcard':
			return _p49._0;
		default:
			return _p49._0;
	}
};
var _user$project$Lang$precedingWhitespaceWithInfoExp__ = function (e__) {
	var _p50 = e__;
	switch (_p50.ctor) {
		case 'EBase':
			return _p50._0;
		case 'EConst':
			return _p50._0;
		case 'EVar':
			return _p50._0;
		case 'EFun':
			return _p50._0;
		case 'EApp':
			return _p50._0;
		case 'EList':
			return _p50._0;
		case 'ERecord':
			return _p50._0;
		case 'ESelect':
			return _p50._0;
		case 'EOp':
			return _p50._0;
		case 'EIf':
			return _p50._0;
		case 'ELet':
			return _p50._0;
		case 'ECase':
			return _p50._0;
		case 'EColonType':
			return _p50._0;
		case 'EParens':
			return _p50._0;
		default:
			return _p50._0;
	}
};
var _user$project$Lang$precedingWhitespaceExp__ = function (e__) {
	return _user$project$Lang$precedingWhitespaceWithInfoExp__(e__).val;
};
var _user$project$Lang$precedingWhitespaceWithInfoPat = function (pat) {
	var _p51 = pat.val.p__;
	switch (_p51.ctor) {
		case 'PVar':
			return _p51._0;
		case 'PConst':
			return _p51._0;
		case 'PBase':
			return _p51._0;
		case 'PWildcard':
			return _p51._0;
		case 'PList':
			return _p51._0;
		case 'PRecord':
			return _p51._0;
		case 'PAs':
			return _p51._0;
		case 'PParens':
			return _p51._0;
		default:
			return _p51._0;
	}
};
var _user$project$Lang$precedingWhitespacePat = function (pat) {
	return function (_) {
		return _.val;
	}(
		_user$project$Lang$precedingWhitespaceWithInfoPat(pat));
};
var _user$project$Lang$mapWs = F2(
	function (f, ws) {
		return A2(
			_user$project$Info$replaceInfo,
			ws,
			f(ws.val));
	});
var _user$project$Lang$removeIndentationWS = F2(
	function (smallestIndentation, ws) {
		return A2(
			_user$project$Lang$mapWs,
			_user$project$Lang$removeIndentation(smallestIndentation),
			ws);
	});
var _user$project$Lang$removeIndentationMaybeWS = function (smallestIndentation) {
	return _elm_lang$core$Maybe$map(
		_user$project$Lang$removeIndentationWS(smallestIndentation));
};
var _user$project$Lang$precedingWhitespaceDeclarationWithInfo = function (decl) {
	var _p52 = decl;
	switch (_p52.ctor) {
		case 'DeclExp':
			return _p52._0._1;
		case 'DeclType':
			return _p52._0._1;
		default:
			return _p52._0._1;
	}
};
var _user$project$Lang$precedingWhitespaceBranch = function (branch) {
	var _p53 = branch.val;
	var wsb = _p53._0;
	return wsb.val;
};
var _user$project$Lang$extractIndentation = function (string) {
	return _user$project$Lang$tabsToSpaces(
		A2(
			_elm_lang$core$Maybe$withDefault,
			'',
			_user$project$Utils$maybeLast(
				A2(
					_elm_lang$core$List$drop,
					1,
					A2(_elm_lang$core$String$split, '\n', string)))));
};
var _user$project$Lang$indentationOfBranch = function (branch) {
	return _user$project$Lang$extractIndentation(
		_user$project$Lang$precedingWhitespaceBranch(branch));
};
var _user$project$Lang$newlineCount = function (s) {
	return _elm_lang$core$List$length(
		A2(_elm_lang$core$String$split, '\n', s)) - 1;
};
var _user$project$Lang$ensureWhitespaceNNewlines = F2(
	function (n, s) {
		var nlCount = _user$project$Lang$newlineCount(s);
		return _user$project$Lang$ensureWhitespace(
			A2(
				_elm_lang$core$Basics_ops['++'],
				A2(_elm_lang$core$String$repeat, n - nlCount, '\n'),
				s));
	});
var _user$project$Lang$zeroWidthWSAfter = function (wi) {
	return A3(_user$project$Info$withInfo, '', wi.end, wi.end);
};
var _user$project$Lang$maxNumTr = F2(
	function (_p55, _p54) {
		var _p56 = _p55;
		var _p59 = _p56._0;
		var _p57 = _p54;
		var _p58 = _p57._0;
		return (_elm_lang$core$Native_Utils.cmp(_p59, _p58) > -1) ? {ctor: '_Tuple2', _0: _p59, _1: _p56._1} : {ctor: '_Tuple2', _0: _p58, _1: _p57._1};
	});
var _user$project$Lang$minNumTr = F2(
	function (_p61, _p60) {
		var _p62 = _p61;
		var _p65 = _p62._0;
		var _p63 = _p60;
		var _p64 = _p63._0;
		return (_elm_lang$core$Native_Utils.cmp(_p65, _p64) < 1) ? {ctor: '_Tuple2', _0: _p65, _1: _p62._1} : {ctor: '_Tuple2', _0: _p64, _1: _p63._1};
	});
var _user$project$Lang$minMaxNumTr = F2(
	function (nt1, nt2) {
		return {
			ctor: '_Tuple2',
			_0: A2(_user$project$Lang$minNumTr, nt1, nt2),
			_1: A2(_user$project$Lang$maxNumTr, nt1, nt2)
		};
	});
var _user$project$Lang$minMax = F2(
	function (x, y) {
		return {
			ctor: '_Tuple2',
			_0: A2(_elm_lang$core$Basics$min, x, y),
			_1: A2(_elm_lang$core$Basics$max, x, y)
		};
	});
var _user$project$Lang$unwrapVBaseString_ = F2(
	function (s, v_) {
		var _p66 = v_;
		if ((_p66.ctor === 'VBase') && (_p66._0.ctor === 'VString')) {
			return _p66._0._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Lang',
				{
					start: {line: 2749, column: 27},
					end: {line: 2751, column: 66}
				},
				_p66)(
				A2(_elm_lang$core$Basics_ops['++'], 'unwrapVBaseString_: ', s));
		}
	});
var _user$project$Lang$vListToVals = F2(
	function (s, v) {
		var _p68 = v.v_;
		if (_p68.ctor === 'VList') {
			return _p68._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Lang',
				{
					start: {line: 2744, column: 19},
					end: {line: 2746, column: 50}
				},
				_p68)(
				A2(_elm_lang$core$Basics_ops['++'], 'vListToVals: ', s));
		}
	});
var _user$project$Lang$unwrapVList_ = F2(
	function (s, v) {
		return A2(
			_elm_lang$core$List$map,
			function (_) {
				return _.v_;
			},
			A2(_user$project$Lang$vListToVals, s, v));
	});
var _user$project$Lang$unwrapVList = function (v) {
	var _p70 = v.v_;
	if (_p70.ctor === 'VList') {
		return _elm_lang$core$Maybe$Just(
			A2(
				_elm_lang$core$List$map,
				function (_) {
					return _.v_;
				},
				_p70._0));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$tpVarUnapply = function (p) {
	var _p71 = p.val;
	return _elm_lang$core$Maybe$Just(_p71._1);
};
var _user$project$Lang$pVarUnapply = function (p) {
	var _p72 = p.val.p__;
	if (_p72.ctor === 'PVar') {
		return _elm_lang$core$Maybe$Just(_p72._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vHtmlTextDiffsUnapply = function (d) {
	var _p73 = d;
	if (_p73.ctor === 'VListDiffs') {
		var _p74 = _p73._0;
		if (_p74.ctor === '::') {
			if (((((_p74._0.ctor === '_Tuple2') && (_p74._0._0 === 1)) && (_p74._0._1.ctor === 'ListElemUpdate')) && (_p74._0._1._0.ctor === 'VStringDiffs')) && (_p74._1.ctor === '[]')) {
				return _elm_lang$core$Maybe$Just(_p74._0._1._0._0);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Just(
				{ctor: '[]'});
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$encoding_implicitelem = '    ';
var _user$project$Lang$encoding_forgotclosing = '   ';
var _user$project$Lang$encoding_voidclosing = '  ';
var _user$project$Lang$encoding_autoclosing = ' ';
var _user$project$Lang$vHtmlTextUnapply = function (v) {
	var _p75 = v.v_;
	if ((((_p75.ctor === 'VList') && (_p75._0.ctor === '::')) && (_p75._0._1.ctor === '::')) && (_p75._0._1._1.ctor === '[]')) {
		var _p76 = {ctor: '_Tuple2', _0: _p75._0._0.v_, _1: _p75._0._1._0.v_};
		if ((((((_p76.ctor === '_Tuple2') && (_p76._0.ctor === 'VBase')) && (_p76._0._0.ctor === 'VString')) && (_p76._0._0._0 === 'TEXT')) && (_p76._1.ctor === 'VBase')) && (_p76._1._0.ctor === 'VString')) {
			return _elm_lang$core$Maybe$Just(_p76._1._0._0);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vRecordUnapplyField = F2(
	function (field, v) {
		var _p77 = v.v_;
		if (_p77.ctor === 'VRecord') {
			return A2(_elm_lang$core$Dict$get, field, _p77._0);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$vRecordUnapply = function (v) {
	var _p78 = v.v_;
	if (_p78.ctor === 'VRecord') {
		return _elm_lang$core$Maybe$Just(_p78._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vTupleViewUnapply = function (v) {
	var _p79 = v.v_;
	if ((((_p79.ctor === 'VList') && (_p79._0.ctor === '::')) && (_p79._0._1.ctor === '::')) && (_p79._0._1._1.ctor === '[]')) {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple2', _0: _p79._0._0, _1: _p79._0._1._0});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vListUnapply = function (v) {
	var _p80 = v.v_;
	if (_p80.ctor === 'VList') {
		return _elm_lang$core$Maybe$Just(_p80._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vConstUnapply = function (v) {
	var _p81 = v.v_;
	if ((_p81.ctor === 'VConst') && (_p81._1.ctor === '_Tuple2')) {
		return _elm_lang$core$Maybe$Just(_p81._1._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vBoolUnapply = function (v) {
	var _p82 = v.v_;
	if ((_p82.ctor === 'VBase') && (_p82._0.ctor === 'VBool')) {
		return _elm_lang$core$Maybe$Just(_p82._0._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vStrUnapply = function (v) {
	var _p83 = v.v_;
	if ((_p83.ctor === 'VBase') && (_p83._0.ctor === 'VString')) {
		return _elm_lang$core$Maybe$Just(_p83._0._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vStringUnapply = _user$project$Lang$vStrUnapply;
var _user$project$Lang$vHtmlNodeUnapply = function (v) {
	var _p84 = _user$project$Lang$vListUnapply(v);
	if (((((_p84.ctor === 'Just') && (_p84._0.ctor === '::')) && (_p84._0._1.ctor === '::')) && (_p84._0._1._1.ctor === '::')) && (_p84._0._1._1._1.ctor === '[]')) {
		var _p85 = _user$project$Lang$vStringUnapply(_p84._0._0);
		if (_p85.ctor === 'Just') {
			var _p86 = _user$project$Lang$vListUnapply(_p84._0._1._0);
			if (_p86.ctor === 'Just') {
				var _p87 = _user$project$Lang$vListUnapply(_p84._0._1._1._0);
				if (_p87.ctor === 'Just') {
					return _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple3', _0: _p85._0, _1: _p86._0, _2: _p87._0});
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$vFunUnapply = function (v) {
	var _p88 = v.v_;
	if (_p88.ctor === 'VFun') {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple4', _0: _p88._0, _1: _p88._1, _2: _p88._2, _3: _p88._3});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eRecord__Unapply = function (e__) {
	var _p89 = e__;
	if (((_p89.ctor === 'ERecord') && (_p89._2._1.ctor === '[]')) && (_p89._2._2.ctor === '[]')) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (x) {
				return {ctor: '_Tuple3', _0: _p89._0, _1: x, _2: _p89._3};
			},
			_user$project$Utils$projJusts(
				A2(
					_elm_lang$core$List$map,
					function (_p90) {
						var _p91 = _p90;
						var _p92 = _p91._1;
						if (((_p92.ctor === '::') && (_p92._0._3.ctor === 'FunArgAsPats')) && (_p92._1.ctor === '[]')) {
							var _p93 = _user$project$Lang$pVarUnapply(_p92._0._2);
							if (_p93.ctor === 'Just') {
								return _elm_lang$core$Maybe$Just(
									{ctor: '_Tuple5', _0: _p92._0._0, _1: _p92._0._1, _2: _p93._0, _3: _p92._0._4, _4: _p92._0._5});
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					},
					_p89._2._3)));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$recordKeys = function (_p94) {
	var _p95 = _p94;
	return A2(
		_elm_lang$core$List$concatMap,
		function (_p96) {
			var _p97 = _p96;
			return A2(
				_elm_lang$core$List$concatMap,
				function (_p98) {
					var _p99 = _p98;
					return _user$project$Lang$identifiersListInPat(_p99._2);
				},
				_p97._1);
		},
		_p95._3);
};
var _user$project$Lang$recordEntriesFromDeclarations = function (_p100) {
	var _p101 = _p100;
	return _user$project$Utils$projJusts(
		A2(
			_elm_lang$core$List$map,
			function (_p102) {
				var _p103 = _p102;
				var _p104 = _p103._2.val.p__;
				if (_p104.ctor === 'PVar') {
					return _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple5', _0: _p103._0, _1: _p103._1, _2: _p104._1, _3: _p103._4, _4: _p103._5});
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			_user$project$Lang$elemsOf(_p101._3)));
};
var _user$project$Lang$dummyLocWithDebugInfo = F2(
	function (b, n) {
		return {ctor: '_Tuple3', _0: 0, _1: b, _2: ''};
	});
var _user$project$Lang$dummyLoc_ = function (b) {
	return {ctor: '_Tuple3', _0: 0, _1: b, _2: ''};
};
var _user$project$Lang$setTId = F2(
	function (tid, t) {
		var t_ = t.val;
		return _elm_lang$core$Native_Utils.update(
			t,
			{
				val: _elm_lang$core$Native_Utils.update(
					t_,
					{tid: tid})
			});
	});
var _user$project$Lang$setPId = F2(
	function (pid, p) {
		var p_ = p.val;
		return _elm_lang$core$Native_Utils.update(
			p,
			{
				val: _elm_lang$core$Native_Utils.update(
					p_,
					{pid: pid})
			});
	});
var _user$project$Lang$clearPId = function (p) {
	return A2(_user$project$Lang$setPId, -1, p);
};
var _user$project$Lang$replaceT__ = F2(
	function (t, t__) {
		var t_ = t.val;
		return _elm_lang$core$Native_Utils.update(
			t,
			{
				val: _elm_lang$core$Native_Utils.update(
					t_,
					{t__: t__})
			});
	});
var _user$project$Lang$replaceTB__ = F2(
	function (b, b_) {
		return _elm_lang$core$Native_Utils.update(
			b,
			{val: b_});
	});
var _user$project$Lang$replaceB__ = F2(
	function (b, b_) {
		return _elm_lang$core$Native_Utils.update(
			b,
			{val: b_});
	});
var _user$project$Lang$replaceP__ = F2(
	function (p, p__) {
		var p_ = p.val;
		return _elm_lang$core$Native_Utils.update(
			p,
			{
				val: _elm_lang$core$Native_Utils.update(
					p_,
					{p__: p__})
			});
	});
var _user$project$Lang$mapNodeP__ = F2(
	function (f, p) {
		return A2(
			_user$project$Lang$replaceP__,
			p,
			f(p.val.p__));
	});
var _user$project$Lang$withDummyBranchInfo = function (b_) {
	return A3(_user$project$Info$WithInfo, b_, _user$project$Pos$dummyPos, _user$project$Pos$dummyPos);
};
var _user$project$Lang$withDummyRange = function (x) {
	return A3(_user$project$Info$WithInfo, x, _user$project$Pos$dummyPos, _user$project$Pos$dummyPos);
};
var _user$project$Lang$rangeSlider = F3(
	function (kind, a, b) {
		return _user$project$Lang$withDummyRange(
			A5(
				kind,
				_user$project$Lang$withDummyRange(a),
				_user$project$Lang$withDummyRange('-'),
				_user$project$Lang$withDummyRange(b),
				_elm_lang$core$Maybe$Nothing,
				false));
	});
var _user$project$Lang$strPos = function (p) {
	var _p105 = {
		ctor: '_Tuple2',
		_0: _elm_lang$core$Basics$toString(p.line),
		_1: _elm_lang$core$Basics$toString(p.col)
	};
	var i = _p105._0;
	var j = _p105._1;
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'(Line:',
		A2(
			_elm_lang$core$Basics_ops['++'],
			i,
			A2(
				_elm_lang$core$Basics_ops['++'],
				' Col:',
				A2(_elm_lang$core$Basics_ops['++'], j, ')'))));
};
var _user$project$Lang$optionRegex = _elm_lang$core$Regex$regex('#\\s*(\\w+)\\s*:\\s*(\\w+)');
var _user$project$Lang$getOptionsFromString = function (whitespace) {
	return A2(
		_elm_lang$core$List$concatMap,
		function (m) {
			var _p106 = m.submatches;
			if (((((_p106.ctor === '::') && (_p106._0.ctor === 'Just')) && (_p106._1.ctor === '::')) && (_p106._1._0.ctor === 'Just')) && (_p106._1._1.ctor === '[]')) {
				return {
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: _p106._0._0, _1: _p106._1._0._0},
					_1: {ctor: '[]'}
				};
			} else {
				return {ctor: '[]'};
			}
		},
		A3(_elm_lang$core$Regex$find, _elm_lang$core$Regex$All, _user$project$Lang$optionRegex, whitespace));
};
var _user$project$Lang$childTypes = function (typ) {
	var _p107 = typ.val.t__;
	switch (_p107.ctor) {
		case 'TNum':
			return {ctor: '[]'};
		case 'TBool':
			return {ctor: '[]'};
		case 'TString':
			return {ctor: '[]'};
		case 'TNull':
			return {ctor: '[]'};
		case 'TList':
			return {
				ctor: '::',
				_0: _p107._1,
				_1: {ctor: '[]'}
			};
		case 'TDict':
			return {
				ctor: '::',
				_0: _p107._1,
				_1: {
					ctor: '::',
					_0: _p107._2,
					_1: {ctor: '[]'}
				}
			};
		case 'TRecord':
			return A2(
				_elm_lang$core$List$map,
				function (_p108) {
					var _p109 = _p108;
					return _p109._4;
				},
				_p107._2);
		case 'TTuple':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p107._1,
				function (_p110) {
					return A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						A2(_elm_lang$core$Maybe$map, _elm_lang$core$List$singleton, _p110));
				}(_p107._3));
		case 'TArrow':
			return _p107._1;
		case 'TUnion':
			return _p107._1;
		case 'TApp':
			return {ctor: '::', _0: _p107._1, _1: _p107._2};
		case 'TVar':
			return {ctor: '[]'};
		case 'TForall':
			return {ctor: '[]'};
		case 'TParens':
			return {
				ctor: '::',
				_0: _p107._1,
				_1: {ctor: '[]'}
			};
		default:
			return {ctor: '[]'};
	}
};
var _user$project$Lang$flattenTypeTree = function (typ) {
	return {
		ctor: '::',
		_0: typ,
		_1: A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$flattenTypeTree,
			_user$project$Lang$childTypes(typ))
	};
};
var _user$project$Lang$childPats = function (pat) {
	var _p111 = pat.val.p__;
	switch (_p111.ctor) {
		case 'PConst':
			return {ctor: '[]'};
		case 'PBase':
			return {ctor: '[]'};
		case 'PVar':
			return {ctor: '[]'};
		case 'PWildcard':
			return {ctor: '[]'};
		case 'PRecord':
			return _user$project$Utils$recordValues(_p111._1);
		case 'PColonType':
			return {
				ctor: '::',
				_0: _p111._1,
				_1: {ctor: '[]'}
			};
		case 'PList':
			if (_p111._3.ctor === 'Nothing') {
				return _p111._1;
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p111._1,
					{
						ctor: '::',
						_0: _p111._3._0,
						_1: {ctor: '[]'}
					});
			}
		case 'PAs':
			return {
				ctor: '::',
				_0: _p111._1,
				_1: {
					ctor: '::',
					_0: _p111._3,
					_1: {ctor: '[]'}
				}
			};
		default:
			return {
				ctor: '::',
				_0: _p111._1,
				_1: {ctor: '[]'}
			};
	}
};
var _user$project$Lang$flattenPatTree = function (pat) {
	return {
		ctor: '::',
		_0: pat,
		_1: A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$flattenPatTree,
			_user$project$Lang$childPats(pat))
	};
};
var _user$project$Lang$varsOfPat = function (pat) {
	var _p112 = pat.val.p__;
	if (_p112.ctor === 'PVar') {
		return {
			ctor: '::',
			_0: _p112._1,
			_1: {ctor: '[]'}
		};
	} else {
		return A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$varsOfPat,
			_user$project$Lang$childPats(pat));
	}
};
var _user$project$Lang$tbranchType = function (tbranch) {
	var _p113 = tbranch.val;
	var tipe = _p113._1;
	return tipe;
};
var _user$project$Lang$tbranchTypes = function (tbranches) {
	return A2(_elm_lang$core$List$map, _user$project$Lang$tbranchType, tbranches);
};
var _user$project$Lang$branchPat = function (branch) {
	var _p114 = branch.val;
	var pat = _p114._1;
	return pat;
};
var _user$project$Lang$branchPats = function (branches) {
	return A2(_elm_lang$core$List$map, _user$project$Lang$branchPat, branches);
};
var _user$project$Lang$tbranchExp = function (tbranch) {
	var _p115 = tbranch.val;
	var exp = _p115._2;
	return exp;
};
var _user$project$Lang$tbranchExps = function (tbranches) {
	return A2(_elm_lang$core$List$map, _user$project$Lang$tbranchExp, tbranches);
};
var _user$project$Lang$branchExp = function (branch) {
	var _p116 = branch.val;
	var exp = _p116._2;
	return exp;
};
var _user$project$Lang$branchExps = function (branches) {
	return A2(_elm_lang$core$List$map, _user$project$Lang$branchExp, branches);
};
var _user$project$Lang$valIsNum = function (v) {
	var _p117 = v.v_;
	if (_p117.ctor === 'VConst') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$valToTrace = function (v) {
	var _p118 = v.v_;
	if ((_p118.ctor === 'VConst') && (_p118._1.ctor === '_Tuple2')) {
		return _p118._1._1;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Lang',
			{
				start: {line: 1917, column: 16},
				end: {line: 1919, column: 53}
			},
			_p118)('Lang.valToTrace');
	}
};
var _user$project$Lang$valToNum = function (v) {
	var _p120 = v.v_;
	if ((_p120.ctor === 'VConst') && (_p120._1.ctor === '_Tuple2')) {
		return _p120._1._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Lang',
			{
				start: {line: 1912, column: 14},
				end: {line: 1914, column: 50}
			},
			_p120)('Lang.valToNum');
	}
};
var _user$project$Lang$groupsOfExtractors = function (groups) {
	var _p122 = groups;
	if (_p122.ctor === '[]') {
		return {
			ctor: '_Tuple2',
			_0: {ctor: '[]'},
			_1: function (x) {
				return {ctor: '[]'};
			}
		};
	} else {
		var _p125 = _p122._0._1;
		var _p123 = _user$project$Lang$groupsOfExtractors(_p122._1);
		var tailA = _p123._0;
		var tailABuilder = _p123._1;
		var rebuilder = function (newList) {
			var _p124 = A2(
				_user$project$Utils$split,
				_elm_lang$core$List$length(_p125),
				newList);
			var newGroup1 = _p124._0;
			var newTailA = _p124._1;
			return {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: _p122._0._0, _1: newGroup1},
				_1: tailABuilder(newTailA)
			};
		};
		return {
			ctor: '_Tuple2',
			_0: A2(_elm_lang$core$Basics_ops['++'], _p125, tailA),
			_1: rebuilder
		};
	}
};
var _user$project$Lang$locToLocId = function (_p126) {
	var _p127 = _p126;
	return _p127._0;
};
var _user$project$Lang$findPatInPat = F2(
	function (targetPId, pat) {
		return A2(
			_user$project$Utils$findFirst,
			function (_p128) {
				return A2(
					F2(
						function (x, y) {
							return _elm_lang$core$Native_Utils.eq(x, y);
						}),
					targetPId,
					function (_) {
						return _.pid;
					}(
						function (_) {
							return _.val;
						}(_p128)));
			},
			_user$project$Lang$flattenPatTree(pat));
	});
var _user$project$Lang$foldType = F3(
	function (f, tipe, acc) {
		foldType:
		while (true) {
			var foldTypes = F3(
				function (f, tipes, acc) {
					return A3(
						_elm_lang$core$List$foldl,
						F2(
							function (t, acc) {
								return A3(_user$project$Lang$foldType, f, t, acc);
							}),
						acc,
						tipes);
				});
			var _p129 = tipe.val.t__;
			switch (_p129.ctor) {
				case 'TNum':
					return A2(f, tipe, acc);
				case 'TBool':
					return A2(f, tipe, acc);
				case 'TString':
					return A2(f, tipe, acc);
				case 'TNull':
					return A2(f, tipe, acc);
				case 'TVar':
					return A2(f, tipe, acc);
				case 'TWildcard':
					return A2(f, tipe, acc);
				case 'TList':
					return A2(
						f,
						tipe,
						A3(_user$project$Lang$foldType, f, _p129._1, acc));
				case 'TDict':
					return A2(
						f,
						tipe,
						A3(
							_user$project$Lang$foldType,
							f,
							_p129._2,
							A3(_user$project$Lang$foldType, f, _p129._1, acc)));
				case 'TForall':
					return A2(
						f,
						tipe,
						A3(_user$project$Lang$foldType, f, _p129._2, acc));
				case 'TArrow':
					return A2(
						f,
						tipe,
						A3(foldTypes, f, _p129._1, acc));
				case 'TUnion':
					return A2(
						f,
						tipe,
						A3(foldTypes, f, _p129._1, acc));
				case 'TApp':
					return A2(
						f,
						tipe,
						A3(
							foldTypes,
							f,
							_p129._2,
							A2(f, tipe, acc)));
				case 'TTuple':
					if (_p129._3.ctor === 'Nothing') {
						return A2(
							f,
							tipe,
							A3(foldTypes, f, _p129._1, acc));
					} else {
						return A2(
							f,
							tipe,
							A3(
								foldTypes,
								f,
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p129._1,
									{
										ctor: '::',
										_0: _p129._3._0,
										_1: {ctor: '[]'}
									}),
								acc));
					}
				case 'TRecord':
					return A2(
						f,
						tipe,
						A3(
							foldTypes,
							f,
							_user$project$Utils$recordValues(_p129._2),
							acc));
				default:
					var _v87 = f,
						_v88 = _p129._1,
						_v89 = acc;
					f = _v87;
					tipe = _v88;
					acc = _v89;
					continue foldType;
			}
		}
	});
var _user$project$Lang$childVals = function (val) {
	var _p130 = val.v_;
	switch (_p130.ctor) {
		case 'VList':
			return _p130._0;
		case 'VDict':
			return _elm_lang$core$Dict$values(_p130._0);
		case 'VRecord':
			return _elm_lang$core$Dict$values(_p130._0);
		case 'VConst':
			return {ctor: '[]'};
		case 'VBase':
			return {ctor: '[]'};
		case 'VClosure':
			return {ctor: '[]'};
		default:
			return {ctor: '[]'};
	}
};
var _user$project$Lang$flattenValTree = function (val) {
	return {
		ctor: '::',
		_0: val,
		_1: A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$flattenValTree,
			_user$project$Lang$childVals(val))
	};
};
var _user$project$Lang$foldVal = F3(
	function (f, v, a) {
		var _p131 = v.v_;
		switch (_p131.ctor) {
			case 'VList':
				return A2(
					f,
					v,
					A3(
						_elm_lang$core$List$foldl,
						_user$project$Lang$foldVal(f),
						a,
						_p131._0));
			case 'VDict':
				return A2(
					f,
					v,
					A3(
						_elm_lang$core$List$foldl,
						_user$project$Lang$foldVal(f),
						a,
						_elm_lang$core$Dict$values(_p131._0)));
			case 'VRecord':
				return A2(
					f,
					v,
					A3(
						_elm_lang$core$List$foldl,
						_user$project$Lang$foldVal(f),
						a,
						_elm_lang$core$Dict$values(_p131._0)));
			case 'VConst':
				return A2(f, v, a);
			case 'VBase':
				return A2(f, v, a);
			case 'VClosure':
				return A2(f, v, a);
			default:
				return A2(f, v, a);
		}
	});
var _user$project$Lang$replaceV_ = F2(
	function (v, v_) {
		return _elm_lang$core$Native_Utils.update(
			v,
			{v_: v_});
	});
var _user$project$Lang$startBindingNumLetAnnotation = function (_p132) {
	var _p133 = _p132;
	return _elm_lang$core$List$sum(
		A2(
			_elm_lang$core$List$map,
			function (_p134) {
				return _elm_lang$core$List$length(
					_elm_lang$core$Tuple$second(_p134));
			},
			_p133._1));
};
var _user$project$Lang$startBindingNumLetExp = function (_p135) {
	var _p136 = _p135;
	return _user$project$Lang$startBindingNumLetAnnotation(_p136) + _elm_lang$core$List$length(_p136._2);
};
var _user$project$Lang$startBindingNumLetType = function (_p137) {
	return 0;
};
var _user$project$Lang$mapValField = F2(
	function (f, r) {
		return _elm_lang$core$Native_Utils.update(
			r,
			{
				val: f(r.val)
			});
	});
var _user$project$Lang$patEffectivePats = function (pat) {
	var _p138 = pat.val.p__;
	if (_p138.ctor === 'PParens') {
		return {
			ctor: '::',
			_0: pat,
			_1: _user$project$Lang$patEffectivePats(_p138._1)
		};
	} else {
		return {
			ctor: '::',
			_0: pat,
			_1: {ctor: '[]'}
		};
	}
};
var _user$project$Lang$patEffectivePat = function (pat) {
	return A2(
		_user$project$Utils$last,
		'patEffectivePat shouldn\'t happen',
		_user$project$Lang$patEffectivePats(pat));
};
var _user$project$Lang$isPVar = function (p) {
	var _p139 = p.val.p__;
	if (_p139.ctor === 'PVar') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$fitsOnLine = function (s) {
	return (_elm_lang$core$Native_Utils.cmp(
		_elm_lang$core$String$length(s),
		70) > 0) ? false : (A2(
		_elm_lang$core$List$member,
		_elm_lang$core$Native_Utils.chr('\n'),
		_elm_lang$core$String$toList(s)) ? false : true);
};
var _user$project$Lang$tab = function (k) {
	return A2(_elm_lang$core$String$repeat, k, 'Â Â ');
};
var _user$project$Lang$patOfDecl = function (decl) {
	var _p140 = decl;
	switch (_p140.ctor) {
		case 'DeclExp':
			return _p140._0._2;
		case 'DeclAnnotation':
			return _p140._0._2;
		default:
			return _p140._0._3;
	}
};
var _user$project$Lang$letExpOf = function (decl) {
	var _p141 = decl;
	if (_p141.ctor === 'DeclExp') {
		return _elm_lang$core$Maybe$Just(_p141._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$bindLetExpsToLetAnnotation = function (_p142) {
	var _p143 = _p142;
	var _p157 = _p143._3;
	var _p156 = _p143._2;
	var uselessAnnotations = A2(
		_elm_lang$core$List$filter,
		function (_p144) {
			var _p145 = _p144;
			return A2(
				_elm_lang$core$List$all,
				function (id) {
					return A2(
						_elm_lang$core$List$all,
						function (_p146) {
							var _p147 = _p146;
							return A2(
								_elm_lang$core$List$all,
								function (_p148) {
									var _p149 = _p148;
									return !A2(
										_elm_lang$core$List$member,
										id,
										_user$project$Lang$identifiersListInPat(_p149._2));
								},
								_p147._1);
						},
						_p157);
				},
				_user$project$Lang$identifiersListInPat(_p145._0._2));
		},
		_user$project$Utils$zipWithIndex(_p156));
	var annotationsWithPats = A2(
		_elm_lang$core$List$concatMap,
		function (_p150) {
			var _p151 = _p150;
			return A2(
				_elm_lang$core$List$map,
				function (id) {
					return {ctor: '_Tuple2', _0: id, _1: _p151};
				},
				_user$project$Lang$identifiersListInPat(_p151._2));
		},
		_p156);
	var annotationsForId = function (id) {
		return A2(
			_elm_lang$core$List$filterMap,
			function (_p152) {
				var _p153 = _p152;
				return _elm_lang$core$Native_Utils.eq(_p153._0, id) ? _elm_lang$core$Maybe$Just(_p153._1) : _elm_lang$core$Maybe$Nothing;
			},
			annotationsWithPats);
	};
	var result = _elm_lang$core$List$map(
		_elm_lang$core$Tuple$mapSecond(
			_elm_lang$core$List$map(
				function (_p154) {
					var _p155 = _p154;
					return A2(
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							}),
						_p155,
						A2(
							_elm_lang$core$List$concatMap,
							annotationsForId,
							_user$project$Lang$identifiersListInPat(_p155._2)));
				})))(_p157);
	return {ctor: '_Tuple2', _0: result, _1: uselessAnnotations};
};
var _user$project$Lang$pathAfterElementRemoved = F2(
	function (removedPath, path) {
		var _p158 = {ctor: '_Tuple2', _0: removedPath, _1: path};
		if (_p158._0.ctor === '::') {
			if (_p158._1.ctor === '::') {
				if (_p158._0._1.ctor === '[]') {
					if (_p158._1._1.ctor === '[]') {
						var _p159 = _p158._1._0;
						return (_elm_lang$core$Native_Utils.cmp(_p158._0._0, _p159) < 0) ? _elm_lang$core$Maybe$Just(
							{
								ctor: '::',
								_0: _p159 - 1,
								_1: {ctor: '[]'}
							}) : _elm_lang$core$Maybe$Just(
							{
								ctor: '::',
								_0: _p159,
								_1: {ctor: '[]'}
							});
					} else {
						var _p162 = _p158._0._0;
						var _p161 = _p158._1._0;
						if (_elm_lang$core$Native_Utils.eq(_p162, _p161)) {
							var _p160 = _elm_lang$core$Debug$log(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'removed pat path is supertree of target path ',
									_elm_lang$core$Basics$toString(
										{ctor: '_Tuple2', _0: removedPath, _1: path})));
							return _elm_lang$core$Maybe$Nothing;
						} else {
							if (_elm_lang$core$Native_Utils.cmp(_p162, _p161) < 0) {
								return _elm_lang$core$Maybe$Just(
									{ctor: '::', _0: _p161 - 1, _1: _p158._1._1});
							} else {
								return _elm_lang$core$Maybe$Just(path);
							}
						}
					}
				} else {
					var _p163 = _p158._1._0;
					return _elm_lang$core$Native_Utils.eq(_p158._0._0, _p163) ? A2(
						_elm_lang$core$Maybe$map,
						F2(
							function (x, y) {
								return {ctor: '::', _0: x, _1: y};
							})(_p163),
						A2(_user$project$Lang$pathAfterElementRemoved, _p158._0._1, _p158._1._1)) : _elm_lang$core$Maybe$Just(path);
				}
			} else {
				return _elm_lang$core$Maybe$Just(path);
			}
		} else {
			if (_p158._1.ctor === '::') {
				var _p164 = _elm_lang$core$Debug$log(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'removed pat path is supertree of target path ',
						_elm_lang$core$Basics$toString(
							{ctor: '_Tuple2', _0: removedPath, _1: path})));
				return _elm_lang$core$Maybe$Nothing;
			} else {
				return _elm_lang$core$Native_Utils.crashCase(
					'Lang',
					{
						start: {line: 903, column: 3},
						end: {line: 934, column: 110}
					},
					_p158)(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Lang.pathAfterElementRemoved why did this get called?!',
						_elm_lang$core$Basics$toString(
							{ctor: '_Tuple2', _0: removedPath, _1: path})));
			}
		}
	});
var _user$project$Lang$pathRightSibling = function (path) {
	return A2(
		_user$project$Utils$maybeMapLast,
		F2(
			function (x, y) {
				return x + y;
			})(1),
		path);
};
var _user$project$Lang$patTargetPositionToTargetPathedPatId = function (_p166) {
	var _p167 = _p166;
	var _p172 = _p167._1;
	var _p171 = _p167._0;
	var _p168 = _p172;
	var referenceScopeId = _p168._0;
	var referencePath = _p168._1;
	var targetPath = function () {
		var referencePathAsPList = function () {
			var _p169 = referencePath;
			if (_p169.ctor === '[]') {
				return {
					ctor: '::',
					_0: 1,
					_1: {ctor: '[]'}
				};
			} else {
				return referencePath;
			}
		}();
		var _p170 = _p171;
		if (_p170.ctor === 'Before') {
			return referencePathAsPList;
		} else {
			return A2(
				_user$project$Utils$fromJust_,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'invalid target pattern id path of [] in target path position: ',
					_elm_lang$core$Basics$toString(
						{ctor: '_Tuple2', _0: _p171, _1: _p172})),
				_user$project$Lang$pathRightSibling(referencePathAsPList));
		}
	}();
	return {ctor: '_Tuple2', _0: referenceScopeId, _1: targetPath};
};
var _user$project$Lang$pathedPatIdRightSibling = function (_p173) {
	var _p174 = _p173;
	return A2(
		_elm_lang$core$Maybe$map,
		function (newPath) {
			return {ctor: '_Tuple2', _0: _p174._0, _1: newPath};
		},
		_user$project$Lang$pathRightSibling(_p174._1));
};
var _user$project$Lang$pathedPatIdToPath = function (_p175) {
	var _p176 = _p175;
	return _p176._1;
};
var _user$project$Lang$pathedPatIdToScopeId = function (_p177) {
	var _p178 = _p177;
	return _p178._0;
};
var _user$project$Lang$scopeIdToScopeEId = function (_p179) {
	var _p180 = _p179;
	return _p180._0;
};
var _user$project$Lang$pathedPatIdToScopeEId = function (pathedPatId) {
	return _user$project$Lang$scopeIdToScopeEId(
		_user$project$Lang$pathedPatIdToScopeId(pathedPatId));
};
var _user$project$Lang$predicateImpossible = function (pred) {
	var _p181 = pred.value;
	switch (_p181.ctor) {
		case 'FullySatisfied':
			return false;
		case 'Satisfied':
			return false;
		case 'Possible':
			return false;
		default:
			return true;
	}
};
var _user$project$Lang$predicatePossible = function (pred) {
	var _p182 = pred.value;
	switch (_p182.ctor) {
		case 'FullySatisfied':
			return true;
		case 'Satisfied':
			return true;
		case 'Possible':
			return true;
		default:
			return false;
	}
};
var _user$project$Lang$predicateSatisfied = function (pred) {
	var _p183 = pred.value;
	switch (_p183.ctor) {
		case 'FullySatisfied':
			return true;
		case 'Satisfied':
			return true;
		case 'Possible':
			return false;
		default:
			return false;
	}
};
var _user$project$Lang$predicateFullySatisfied = function (pred) {
	var _p184 = pred.value;
	switch (_p184.ctor) {
		case 'FullySatisfied':
			return true;
		case 'Satisfied':
			return false;
		case 'Possible':
			return false;
		default:
			return false;
	}
};
var _user$project$Lang$resultTextToString = function (rt) {
	var _p185 = rt;
	switch (_p185.ctor) {
		case 'PlainText':
			return _p185._0;
		case 'HeaderText':
			return _p185._0;
		case 'ErrorHeaderText':
			return _p185._0;
		case 'CodeText':
			return _p185._0;
		case 'TypeText':
			return _p185._0;
		default:
			return _p185._0;
	}
};
var _user$project$Lang$transformationResultToString = function (tr) {
	var _p186 = tr;
	switch (_p186.ctor) {
		case 'Basic':
			return _p186._0._0.description;
		case 'Fancy':
			return _user$project$Lang$resultTextToString(_p186._1);
		default:
			return _user$project$Lang$resultTextToString(_p186._0);
	}
};
var _user$project$Lang$extractSynthesisResultWith = F2(
	function (f, tr) {
		var _p187 = tr;
		switch (_p187.ctor) {
			case 'Basic':
				return _elm_lang$core$Maybe$Just(
					f(_p187._0));
			case 'Fancy':
				return _elm_lang$core$Maybe$Just(
					f(_p187._0));
			default:
				return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$extractSynthesisResult = _user$project$Lang$extractSynthesisResultWith(_elm_lang$core$Basics$identity);
var _user$project$Lang$transformationToSynthesisResult = function (tr) {
	var _p188 = tr;
	switch (_p188.ctor) {
		case 'Basic':
			return _elm_lang$core$Maybe$Just(_p188._0);
		case 'Fancy':
			return _elm_lang$core$Maybe$Just(_p188._0);
		default:
			return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$synthesisResults = function (_p189) {
	return _user$project$Utils$filterJusts(
		A2(_elm_lang$core$List$map, _user$project$Lang$transformationToSynthesisResult, _p189));
};
var _user$project$Lang$provenanceBasedOn = function (_p190) {
	var _p191 = _p190;
	return _p191._2;
};
var _user$project$Lang$provenanceExp = function (_p192) {
	var _p193 = _p192;
	return _p193._1;
};
var _user$project$Lang$valExp = function (val) {
	return _user$project$Lang$provenanceExp(val.provenance);
};
var _user$project$Lang$provenanceEnv = function (_p194) {
	var _p195 = _p194;
	return _p195._0;
};
var _user$project$Lang$allTraceLocs = function (trace) {
	var _p196 = trace;
	if (_p196.ctor === 'TrLoc') {
		return {
			ctor: '::',
			_0: _p196._0,
			_1: {ctor: '[]'}
		};
	} else {
		return A2(_elm_lang$core$List$concatMap, _user$project$Lang$allTraceLocs, _p196._1);
	}
};
var _user$project$Lang$bindingOfLetExp = function (_p197) {
	var _p198 = _p197;
	return _p198._5;
};
var _user$project$Lang$patOfLetExp = function (_p199) {
	var _p200 = _p199;
	return _p200._2;
};
var _user$project$Lang$endPosLetExp = function (def) {
	var _p201 = def;
	return _p201._5._0.end;
};
var _user$project$Lang$eBaseValsEqual = F2(
	function (ebv1, ebv2) {
		var _p202 = {ctor: '_Tuple2', _0: ebv1, _1: ebv2};
		_v128_3:
		do {
			if (_p202.ctor === '_Tuple2') {
				switch (_p202._0.ctor) {
					case 'EBool':
						if (_p202._1.ctor === 'EBool') {
							return _elm_lang$core$Native_Utils.eq(_p202._0._0, _p202._1._0);
						} else {
							break _v128_3;
						}
					case 'EString':
						if (_p202._1.ctor === 'EString') {
							return _elm_lang$core$Native_Utils.eq(_p202._0._1, _p202._1._1);
						} else {
							break _v128_3;
						}
					default:
						if (_p202._1.ctor === 'ENull') {
							return true;
						} else {
							break _v128_3;
						}
				}
			} else {
				break _v128_3;
			}
		} while(false);
		return false;
	});
var _user$project$Lang$defaultQuoteChar = '\"';
var _user$project$Lang$valParents = function (val) {
	var _p203 = val.parents;
	var parents = _p203._0;
	return parents;
};
var _user$project$Lang$unwrapExp = function (_p204) {
	var _p205 = _p204;
	return _p205._0.val.e__;
};
var _user$project$Lang$isLet = function (e) {
	var _p206 = _user$project$Lang$unwrapExp(e);
	if (_p206.ctor === 'ELet') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isList = function (e) {
	var _p207 = _user$project$Lang$unwrapExp(e);
	if (_p207.ctor === 'EList') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isSingletonList = function (e) {
	var _p208 = _user$project$Lang$unwrapExp(e);
	if ((((_p208.ctor === 'EList') && (_p208._1.ctor === '::')) && (_p208._1._1.ctor === '[]')) && (_p208._3.ctor === 'Nothing')) {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isPair = function (e) {
	var _p209 = _user$project$Lang$unwrapExp(e);
	if (((((_p209.ctor === 'EList') && (_p209._1.ctor === '::')) && (_p209._1._1.ctor === '::')) && (_p209._1._1._1.ctor === '[]')) && (_p209._3.ctor === 'Nothing')) {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isVar = function (e) {
	var _p210 = _user$project$Lang$unwrapExp(e);
	if (_p210.ctor === 'EVar') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isFunc = function (e) {
	var _p211 = _user$project$Lang$unwrapExp(e);
	if (_p211.ctor === 'EFun') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$isScope = F2(
	function (maybeParent, exp) {
		var isObviouslyScope = function () {
			var _p212 = _user$project$Lang$unwrapExp(exp);
			switch (_p212.ctor) {
				case 'ELet':
					return true;
				case 'EFun':
					return true;
				default:
					return false;
			}
		}();
		var _p213 = maybeParent;
		if (_p213.ctor === 'Just') {
			var _p214 = _user$project$Lang$unwrapExp(_p213._0);
			if (_p214.ctor === 'ECase') {
				return !_elm_lang$core$Native_Utils.eq(_p214._1, exp);
			} else {
				return isObviouslyScope;
			}
		} else {
			return isObviouslyScope;
		}
	});
var _user$project$Lang$isNumber = function (exp) {
	var _p215 = _user$project$Lang$unwrapExp(exp);
	if (_p215.ctor === 'EConst') {
		return true;
	} else {
		return false;
	}
};
var _user$project$Lang$eLetUnapply = function (e) {
	var _p216 = _user$project$Lang$unwrapExp(e);
	if (_p216.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple5', _0: _p216._0, _1: _p216._1, _2: _p216._2, _3: _p216._3, _4: _p216._4});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eFunUnapply = function (e) {
	var _p217 = _user$project$Lang$unwrapExp(e);
	if (_p217.ctor === 'EFun') {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple2', _0: _p217._1, _1: _p217._2});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$isBodyPossiblyRecursive = function (e) {
	return !_elm_lang$core$Native_Utils.eq(
		_user$project$Lang$eFunUnapply(e),
		_elm_lang$core$Maybe$Nothing);
};
var _user$project$Lang$isMutuallyRecursive = function (group) {
	return (_elm_lang$core$Native_Utils.cmp(
		_elm_lang$core$List$length(group),
		2) > -1) || A2(
		_elm_lang$core$List$all,
		function (_p218) {
			var _p219 = _p218;
			return _user$project$Lang$isBodyPossiblyRecursive(_p219._5);
		},
		group);
};
var _user$project$Lang$eVarUnapply = function (e) {
	var _p220 = _user$project$Lang$unwrapExp(e);
	if (_p220.ctor === 'EVar') {
		return _elm_lang$core$Maybe$Just(_p220._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eStrUnapply = function (e) {
	var _p221 = _user$project$Lang$unwrapExp(e);
	if ((_p221.ctor === 'EBase') && (_p221._1.ctor === 'EString')) {
		return _elm_lang$core$Maybe$Just(_p221._1._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eConstUnapply = function (e) {
	var _p222 = _user$project$Lang$unwrapExp(e);
	if (_p222.ctor === 'EConst') {
		return _elm_lang$core$Maybe$Just(_p222._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eListUnapply = function (e) {
	var _p223 = _user$project$Lang$unwrapExp(e);
	if ((_p223.ctor === 'EList') && (_p223._3.ctor === 'Nothing')) {
		return _elm_lang$core$Maybe$Just(
			A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$second, _p223._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eListUnapplyWS = function (e) {
	var _p224 = _user$project$Lang$unwrapExp(e);
	if ((_p224.ctor === 'EList') && (_p224._3.ctor === 'Nothing')) {
		return _elm_lang$core$Maybe$Just(_p224._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eOpUnapply1 = F2(
	function (expectedOp, e) {
		var _p225 = _user$project$Lang$unwrapExp(e);
		if (((_p225.ctor === 'EOp') && (_p225._3.ctor === '::')) && (_p225._3._1.ctor === '[]')) {
			return _elm_lang$core$Native_Utils.eq(_p225._2.val, expectedOp) ? _elm_lang$core$Maybe$Just(_p225._3._0) : _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$eOpUnapply2 = F2(
	function (expectedOp, e) {
		var _p226 = _user$project$Lang$unwrapExp(e);
		if ((((_p226.ctor === 'EOp') && (_p226._3.ctor === '::')) && (_p226._3._1.ctor === '::')) && (_p226._3._1._1.ctor === '[]')) {
			return _elm_lang$core$Native_Utils.eq(_p226._2.val, expectedOp) ? _elm_lang$core$Maybe$Just(
				{ctor: '_Tuple2', _0: _p226._3._0, _1: _p226._3._1._0}) : _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$eAppUnapply1 = function (e) {
	var _p227 = _user$project$Lang$unwrapExp(e);
	if (((_p227.ctor === 'EApp') && (_p227._2.ctor === '::')) && (_p227._2._1.ctor === '[]')) {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple2', _0: _p227._1, _1: _p227._2._0});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eAppUnapply2 = function (e) {
	var _p228 = _user$project$Lang$unwrapExp(e);
	if ((((_p228.ctor === 'EApp') && (_p228._2.ctor === '::')) && (_p228._2._1.ctor === '::')) && (_p228._2._1._1.ctor === '[]')) {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple3', _0: _p228._1, _1: _p228._2._0, _2: _p228._2._1._0});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eAppUnapply = function (e) {
	var _p229 = _user$project$Lang$unwrapExp(e);
	if (_p229.ctor === 'EApp') {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple2', _0: _p229._1, _1: _p229._2});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eParensUnapplyIf = F2(
	function (syntax, e) {
		var _p230 = _user$project$Lang$unwrapExp(e);
		if (_p230.ctor === 'EParens') {
			return _elm_lang$core$Native_Utils.eq(_p230._2, syntax) ? _elm_lang$core$Maybe$Just(_p230._1) : _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$precedingWhitespace = function (exp) {
	return _user$project$Lang$precedingWhitespaceExp__(
		_user$project$Lang$unwrapExp(exp));
};
var _user$project$Lang$indentationOf = function (exp) {
	return _user$project$Lang$extractIndentation(
		_user$project$Lang$precedingWhitespace(exp));
};
var _user$project$Lang$precedingWhitespaceWithInfoExp = function (e) {
	return _user$project$Lang$precedingWhitespaceWithInfoExp__(
		_user$project$Lang$unwrapExp(e));
};
var _user$project$Lang$wsBefore = function (codeObject) {
	var _p231 = codeObject;
	switch (_p231.ctor) {
		case 'E':
			return _user$project$Lang$precedingWhitespaceWithInfoExp(_p231._0);
		case 'P':
			return _user$project$Lang$precedingWhitespaceWithInfoPat(_p231._1);
		case 'T':
			return _user$project$Lang$precedingWhitespaceWithInfoType(_p231._0);
		case 'D':
			var _p232 = _p231._0;
			return A3(_user$project$Info$withInfo, '', _p232.start, _p232.end);
		case 'DT':
			return _p231._1;
		case 'ET':
			return _p231._1;
		case 'PT':
			return _p231._1;
		default:
			return _p231._1;
	}
};
var _user$project$Lang$isWord = function (codeObject) {
	var _p233 = codeObject;
	switch (_p233.ctor) {
		case 'E':
			var _p234 = _user$project$Lang$unwrapExp(_p233._0);
			_v156_4:
			do {
				switch (_p234.ctor) {
					case 'EConst':
						return true;
					case 'EBase':
						return true;
					case 'EVar':
						return true;
					case 'EHole':
						if (_p234._1.ctor === 'EEmptyHole') {
							return true;
						} else {
							break _v156_4;
						}
					default:
						break _v156_4;
				}
			} while(false);
			return false;
		case 'P':
			var _p235 = _p233._1.val.p__;
			switch (_p235.ctor) {
				case 'PVar':
					return true;
				case 'PConst':
					return true;
				case 'PBase':
					return true;
				case 'PWildcard':
					return true;
				default:
					return false;
			}
		default:
			return false;
	}
};
var _user$project$Lang$isImplicitMain = function (e) {
	var _p236 = _user$project$Lang$unwrapExp(e);
	if ((((((((_p236.ctor === 'ELet') && (_p236._2._1.ctor === '[]')) && (_p236._2._2.ctor === '[]')) && (_p236._2._3.ctor === '::')) && (_p236._2._3._0.ctor === '_Tuple2')) && (_p236._2._3._0._1.ctor === '::')) && (_p236._2._3._0._1._1.ctor === '[]')) && (_p236._2._3._1.ctor === '[]')) {
		var _p237 = _p236._2._3._0._1._0._2.val.p__;
		if ((_p237.ctor === 'PVar') && (_p237._1 === '_IMPLICIT_MAIN')) {
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
var _user$project$Lang$isHiddenCodeObject = function (codeObject) {
	var _p238 = codeObject;
	switch (_p238.ctor) {
		case 'E':
			return _user$project$Lang$isImplicitMain(_p238._0);
		case 'ET':
			return _user$project$Lang$isImplicitMain(_p238._2);
		case 'DT':
			return _user$project$Lang$isImplicitMain(_p238._2);
		default:
			return false;
	}
};
var _user$project$Lang$firstNestedExp = function (e) {
	firstNestedExp:
	while (true) {
		var _p239 = _user$project$Lang$unwrapExp(e);
		if ((_p239.ctor === 'ELet') && (_p239._1.ctor === 'Def')) {
			var _v162 = _p239._4;
			e = _v162;
			continue firstNestedExp;
		} else {
			return e;
		}
	}
};
var _user$project$Lang$expToMaybeIdent = function (exp) {
	var _p240 = _user$project$Lang$unwrapExp(exp);
	if (_p240.ctor === 'EVar') {
		return _elm_lang$core$Maybe$Just(_p240._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$unExpr = function (_p241) {
	var _p242 = _p241;
	return _p242._0;
};
var _user$project$Lang$expEId = function (_p243) {
	var _p244 = _p243;
	return _p244._0.val.eid;
};
var _user$project$Lang$valEId = function (val) {
	return _user$project$Lang$expEId(
		_user$project$Lang$valExp(val));
};
var _user$project$Lang$eidIs = F2(
	function (targetEId, exp) {
		return _elm_lang$core$Native_Utils.eq(
			_user$project$Lang$expEId(exp),
			targetEId);
	});
var _user$project$Lang$setExtraDeuceTypeInfoForThing = F2(
	function (info, thing) {
		var thing_ = thing.val;
		return _elm_lang$core$Native_Utils.update(
			thing,
			{
				val: _elm_lang$core$Native_Utils.update(
					thing_,
					{
						extraDeuceTypeInfo: _elm_lang$core$Maybe$Just(info)
					})
			});
	});
var _user$project$Lang$setPatExtraDeuceTypeInfo = _user$project$Lang$setExtraDeuceTypeInfoForThing;
var _user$project$Lang$setDeuceTypeInfoForThing = F2(
	function (info, thing) {
		var thing_ = thing.val;
		return _elm_lang$core$Native_Utils.update(
			thing,
			{
				val: _elm_lang$core$Native_Utils.update(
					thing_,
					{
						deuceTypeInfo: _elm_lang$core$Maybe$Just(info)
					})
			});
	});
var _user$project$Lang$setPatDeuceTypeInfo = _user$project$Lang$setDeuceTypeInfoForThing;
var _user$project$Lang$setTypeForThing = F2(
	function (typ, thing) {
		var thing_ = thing.val;
		return _elm_lang$core$Native_Utils.update(
			thing,
			{
				val: _elm_lang$core$Native_Utils.update(
					thing_,
					{typ: typ})
			});
	});
var _user$project$Lang$setPatType = _user$project$Lang$setTypeForThing;
var _user$project$Lang$makeType_ = F2(
	function (t__, tid) {
		return {t__: t__, tid: tid, deuceTypeInfo: _elm_lang$core$Maybe$Nothing, extraDeuceTypeInfo: _elm_lang$core$Maybe$Nothing};
	});
var _user$project$Lang$type_ = function (t__) {
	return A2(_user$project$Lang$makeType_, t__, -1);
};
var _user$project$Lang$withDummyTypeInfo = function (t__) {
	return A3(
		_user$project$Info$WithInfo,
		_user$project$Lang$type_(t__),
		_user$project$Pos$dummyPos,
		_user$project$Pos$dummyPos);
};
var _user$project$Lang$makePat_ = F2(
	function (p__, pid) {
		return {p__: p__, pid: pid, typ: _elm_lang$core$Maybe$Nothing, deuceTypeInfo: _elm_lang$core$Maybe$Nothing, extraDeuceTypeInfo: _elm_lang$core$Maybe$Nothing};
	});
var _user$project$Lang$pat_ = function (p__) {
	return A2(_user$project$Lang$makePat_, p__, -1);
};
var _user$project$Lang$withDummyPatInfo = function (p__) {
	return A3(
		_user$project$Info$WithInfo,
		_user$project$Lang$pat_(p__),
		_user$project$Pos$dummyPos,
		_user$project$Pos$dummyPos);
};
var _user$project$Lang$withDummyPatInfoPId = F2(
	function (pid, p__) {
		return A3(
			_user$project$Info$WithInfo,
			A2(_user$project$Lang$makePat_, p__, pid),
			_user$project$Pos$dummyPos,
			_user$project$Pos$dummyPos);
	});
var _user$project$Lang$makeExp_ = F2(
	function (e__, eid) {
		return {e__: e__, eid: eid, typ: _elm_lang$core$Maybe$Nothing, deuceTypeInfo: _elm_lang$core$Maybe$Nothing, extraDeuceTypeInfo: _elm_lang$core$Maybe$Nothing};
	});
var _user$project$Lang$exp_ = function (e__) {
	return A2(_user$project$Lang$makeExp_, e__, -1);
};
var _user$project$Lang$withDummyExp_Info = function (e__) {
	return A3(
		_user$project$Info$WithInfo,
		_user$project$Lang$exp_(e__),
		_user$project$Pos$dummyPos,
		_user$project$Pos$dummyPos);
};
var _user$project$Lang$withDummyExpInfoEId = F2(
	function (eid, e__) {
		return _user$project$Lang$withDummyRange(
			A2(_user$project$Lang$makeExp_, e__, eid));
	});
var _user$project$Lang$opArity = function (op) {
	var _p245 = op.val;
	switch (_p245.ctor) {
		case 'Pi':
			return 0;
		case 'DictEmpty':
			return 0;
		case 'CurrentEnv':
			return 0;
		case 'DictFromList':
			return 1;
		case 'Cos':
			return 1;
		case 'Sin':
			return 1;
		case 'ArcCos':
			return 1;
		case 'ArcSin':
			return 1;
		case 'Floor':
			return 1;
		case 'Ceil':
			return 1;
		case 'Round':
			return 1;
		case 'ToStr':
			return 1;
		case 'ToStrExceptStr':
			return 1;
		case 'StrLength':
			return 1;
		case 'Sqrt':
			return 1;
		case 'Explode':
			return 1;
		case 'DebugLog':
			return 1;
		case 'NoWidgets':
			return 1;
		case 'Plus':
			return 2;
		case 'Minus':
			return 2;
		case 'Mult':
			return 2;
		case 'Div':
			return 2;
		case 'Lt':
			return 2;
		case 'Eq':
			return 2;
		case 'Mod':
			return 2;
		case 'Pow':
			return 2;
		case 'ArcTan2':
			return 2;
		case 'DictGet':
			return 2;
		case 'DictRemove':
			return 2;
		case 'DictInsert':
			return 3;
		default:
			return 3;
	}
};
var _user$project$Lang$maybeEvalMathOp = F2(
	function (op_, operands) {
		var _p246 = {ctor: '_Tuple2', _0: op_, _1: operands};
		_v167_16:
		do {
			if (_p246.ctor === '_Tuple2') {
				if (_p246._1.ctor === '::') {
					if (_p246._1._1.ctor === '::') {
						if (_p246._1._1._1.ctor === '[]') {
							switch (_p246._0.ctor) {
								case 'Plus':
									return _elm_lang$core$Maybe$Just(
										A2(
											F2(
												function (x, y) {
													return x + y;
												}),
											_p246._1._0,
											_p246._1._1._0));
								case 'Minus':
									return _elm_lang$core$Maybe$Just(
										A2(
											F2(
												function (x, y) {
													return x - y;
												}),
											_p246._1._0,
											_p246._1._1._0));
								case 'Mult':
									return _elm_lang$core$Maybe$Just(
										A2(
											F2(
												function (x, y) {
													return x * y;
												}),
											_p246._1._0,
											_p246._1._1._0));
								case 'Div':
									return _elm_lang$core$Maybe$Just(
										A2(
											F2(
												function (x, y) {
													return x / y;
												}),
											_p246._1._0,
											_p246._1._1._0));
								case 'Pow':
									return _elm_lang$core$Maybe$Just(
										A2(
											F2(
												function (x, y) {
													return Math.pow(x, y);
												}),
											_p246._1._0,
											_p246._1._1._0));
								case 'Mod':
									return _elm_lang$core$Maybe$Just(
										_elm_lang$core$Basics$toFloat(
											A2(
												F2(
													function (x, y) {
														return A2(_elm_lang$core$Basics_ops['%'], x, y);
													}),
												_elm_lang$core$Basics$floor(_p246._1._0),
												_elm_lang$core$Basics$floor(_p246._1._1._0))));
								case 'ArcTan2':
									return _elm_lang$core$Maybe$Just(
										A2(_elm_lang$core$Basics$atan2, _p246._1._0, _p246._1._1._0));
								default:
									break _v167_16;
							}
						} else {
							break _v167_16;
						}
					} else {
						switch (_p246._0.ctor) {
							case 'Cos':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$cos(_p246._1._0));
							case 'Sin':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$sin(_p246._1._0));
							case 'ArcCos':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$acos(_p246._1._0));
							case 'ArcSin':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$asin(_p246._1._0));
							case 'Floor':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$toFloat(
										_elm_lang$core$Basics$floor(_p246._1._0)));
							case 'Ceil':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$toFloat(
										_elm_lang$core$Basics$ceiling(_p246._1._0)));
							case 'Round':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$toFloat(
										_elm_lang$core$Basics$round(_p246._1._0)));
							case 'Sqrt':
								return _elm_lang$core$Maybe$Just(
									_elm_lang$core$Basics$sqrt(_p246._1._0));
							default:
								break _v167_16;
						}
					}
				} else {
					if (_p246._0.ctor === 'Pi') {
						return _elm_lang$core$Maybe$Just(_elm_lang$core$Basics$pi);
					} else {
						break _v167_16;
					}
				}
			} else {
				break _v167_16;
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	});
var _user$project$Lang$getViewDatatypeName = function (v) {
	var _p247 = _user$project$Lang$vListUnapply(v);
	if (((((_p247.ctor === 'Just') && (_p247._0.ctor === '::')) && (_p247._0._1.ctor === '::')) && (_p247._0._1._1.ctor === '::')) && (_p247._0._1._1._1.ctor === '[]')) {
		var isAttrCorrect = function () {
			var _p248 = _p247._0._1._0.v_;
			if (_p248.ctor === 'VList') {
				return true;
			} else {
				return false;
			}
		}();
		var isChildrenCorrect = function () {
			var _p249 = _p247._0._1._1._0.v_;
			if (_p249.ctor === 'VList') {
				return true;
			} else {
				return false;
			}
		}();
		return (isAttrCorrect && isChildrenCorrect) ? _user$project$Lang$vStringUnapply(_p247._0._0) : _elm_lang$core$Maybe$Nothing;
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$nameToArg = function (s) {
	var _p250 = _elm_lang$core$String$uncons(s);
	if (((_p250.ctor === 'Just') && (_p250._0.ctor === '_Tuple2')) && (_p250._0._0.valueOf() === '_')) {
		return _elm_lang$core$String$toInt(_p250._0._1);
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'This cannot be an argument\'s name for data constructors and tuples: \'',
				A2(_elm_lang$core$Basics_ops['++'], s, '\'. It should be _[number].')));
	}
};
var _user$project$Lang$argName = function (index) {
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'_',
		_elm_lang$core$Basics$toString(index));
};
var _user$project$Lang$numericalValEntry = F2(
	function (index, binding) {
		return {
			ctor: '_Tuple2',
			_0: _user$project$Lang$argName(index),
			_1: binding
		};
	});
var _user$project$Lang$ctorTupleName = function (i) {
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'Tuple',
		_elm_lang$core$Basics$toString(i));
};
var _user$project$Lang$ctorDataType = '$d_ctor';
var _user$project$Lang$getDatatypeName = function (v) {
	return A2(
		_elm_lang$core$Maybe$andThen,
		_user$project$Lang$vStringUnapply,
		A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorDataType, v));
};
var _user$project$Lang$ctorTuple = '$t_ctor';
var _user$project$Lang$stringifyCtorKind = function (ctorKind) {
	var _p251 = ctorKind;
	if (_p251.ctor === 'TupleCtor') {
		return _user$project$Lang$ctorTuple;
	} else {
		return _user$project$Lang$ctorDataType;
	}
};
var _user$project$Lang$ctorVal = F3(
	function (tagger, ctorKind, name) {
		return {
			ctor: '_Tuple2',
			_0: _user$project$Lang$stringifyCtorKind(ctorKind),
			_1: tagger(name)
		};
	});
var _user$project$Lang$vRecordTupleUnapply = function (v) {
	var _p252 = v.v_;
	if (_p252.ctor === 'VRecord') {
		var keyValues = _elm_lang$core$Dict$toList(_p252._0);
		return function (x) {
			var _p253 = x;
			if (_p253.ctor === 'Nothing') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var orderedKeyValues = A2(
					_elm_lang$core$List$sortBy,
					function (_p254) {
						var _p255 = _p254;
						return A2(
							_elm_lang$core$Result$withDefault,
							-1,
							_elm_lang$core$String$toInt(
								A2(_elm_lang$core$String$dropLeft, 1, _p255._0)));
					},
					A2(
						_elm_lang$core$List$filter,
						function (_p256) {
							var _p257 = _p256;
							return A2(_elm_lang$core$String$startsWith, '_', _p257._0);
						},
						keyValues));
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: {ctor: '_Tuple2', _0: _user$project$Lang$ctorTuple, _1: _p253._0},
						_1: orderedKeyValues
					});
			}
		}(
			A2(_user$project$Utils$maybeFind, _user$project$Lang$ctorTuple, keyValues));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$ctorArgs = 'args';
var _user$project$Lang$vDatatypeDiffsGet = F2(
	function (n, d) {
		return A2(
			_elm_lang$core$Maybe$andThen,
			_elm_lang$core$Dict$get(n),
			A2(
				_elm_lang$core$Maybe$andThen,
				_user$project$Lang$vRecordDiffsUnapply,
				A2(
					_elm_lang$core$Maybe$andThen,
					_elm_lang$core$Dict$get(_user$project$Lang$ctorArgs),
					_user$project$Lang$vRecordDiffsUnapply(d))));
	});
var _user$project$Lang$_p258 = {ctor: '_Tuple4', _0: '!', _1: '', _2: '?', _3: '~'};
var _user$project$Lang$frozen = _user$project$Lang$_p258._0;
var _user$project$Lang$unann = _user$project$Lang$_p258._1;
var _user$project$Lang$thawed = _user$project$Lang$_p258._2;
var _user$project$Lang$assignOnlyOnce = _user$project$Lang$_p258._3;
var _user$project$Lang$isFrozenNumber = function (exp) {
	var _p259 = _user$project$Lang$unwrapExp(exp);
	if ((_p259.ctor === 'EConst') && (_p259._2.ctor === '_Tuple3')) {
		return _elm_lang$core$Native_Utils.eq(_p259._2._1, _user$project$Lang$frozen);
	} else {
		return false;
	}
};
var _user$project$Lang$dummyLoc = _user$project$Lang$dummyLoc_(_user$project$Lang$unann);
var _user$project$Lang$ws = _user$project$Info$withDummyInfo;
var _user$project$Lang$space0 = _user$project$Lang$ws('');
var _user$project$Lang$ctor = F3(
	function (tagger, ctorKind, name) {
		return {
			ctor: '_Tuple5',
			_0: _elm_lang$core$Maybe$Nothing,
			_1: _user$project$Lang$space0,
			_2: _user$project$Lang$stringifyCtorKind(ctorKind),
			_3: _user$project$Lang$space0,
			_4: tagger(name)
		};
	});
var _user$project$Lang$numericalEntry = F2(
	function (index, _p260) {
		var _p261 = _p260;
		return {
			ctor: '_Tuple5',
			_0: _p261._0,
			_1: _user$project$Lang$space0,
			_2: _user$project$Lang$argName(index),
			_3: _user$project$Lang$space0,
			_4: _p261._1
		};
	});
var _user$project$Lang$space1 = _user$project$Lang$ws(' ');
var _user$project$Lang$newline1 = _user$project$Lang$ws('\n');
var _user$project$Lang$newline2 = _user$project$Lang$ws('\n\n');
var _user$project$Lang$Val = F3(
	function (a, b, c) {
		return {v_: a, provenance: b, parents: c};
	});
var _user$project$Lang$Predicate = F2(
	function (a, b) {
		return {description: a, value: b};
	});
var _user$project$Lang$DeuceTool = F4(
	function (a, b, c, d) {
		return {name: a, func: b, reqs: c, id: d};
	});
var _user$project$Lang$TwoSubsts = F2(
	function (a, b) {
		return {lsubst: a, esubst: b};
	});
var _user$project$Lang$UpdatedExp = F2(
	function (a, b) {
		return {val: a, changes: b};
	});
var _user$project$Lang$UpdatedExpTuple = F2(
	function (a, b) {
		return {val: a, changes: b};
	});
var _user$project$Lang$UpdatedDeclarations = F2(
	function (a, b) {
		return {val: a, changes: b};
	});
var _user$project$Lang$UpdatedVal = F2(
	function (a, b) {
		return {val: a, changes: b};
	});
var _user$project$Lang$UpdatedEnv = F2(
	function (a, b) {
		return {val: a, changes: b};
	});
var _user$project$Lang$Expr = function (a) {
	return {ctor: 'Expr', _0: a};
};
var _user$project$Lang$setType = function (typ) {
	return function (_p262) {
		return _user$project$Lang$Expr(
			A2(
				_user$project$Lang$setTypeForThing,
				typ,
				_user$project$Lang$unExpr(_p262)));
	};
};
var _user$project$Lang$setDeuceTypeInfo = function (info) {
	return function (_p263) {
		return _user$project$Lang$Expr(
			A2(
				_user$project$Lang$setDeuceTypeInfoForThing,
				info,
				_user$project$Lang$unExpr(_p263)));
	};
};
var _user$project$Lang$setExtraDeuceTypeInfo = function (info) {
	return function (_p264) {
		return _user$project$Lang$Expr(
			A2(
				_user$project$Lang$setExtraDeuceTypeInfoForThing,
				info,
				_user$project$Lang$unExpr(_p264)));
	};
};
var _user$project$Lang$withDummyExpInfo = function (e__) {
	return _user$project$Lang$Expr(
		_user$project$Lang$withDummyExp_Info(e__));
};
var _user$project$Lang$replaceE__ = F2(
	function (_p265, e__) {
		var _p266 = _p265;
		var _p267 = _p266._0;
		var e_ = _p267.val;
		return _user$project$Lang$Expr(
			_elm_lang$core$Native_Utils.update(
				_p267,
				{
					val: _elm_lang$core$Native_Utils.update(
						e_,
						{e__: e__})
				}));
	});
var _user$project$Lang$singleArgExtractor = F4(
	function (msg, exp, f, l) {
		var _p268 = l;
		if (_p268.ctor === '::') {
			return A2(
				_user$project$Lang$replaceE__,
				exp,
				f(_p268._0));
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Lang',
				{
					start: {line: 1826, column: 34},
					end: {line: 1828, column: 75}
				},
				_p268)(
				A2(_elm_lang$core$Basics_ops['++'], '[internal error] Unespected empty list for ', msg));
		}
	});
var _user$project$Lang$multiArgExtractor = F4(
	function (msg, exp, f, l) {
		return A2(
			_user$project$Lang$replaceE__,
			exp,
			f(l));
	});
var _user$project$Lang$mapNodeE__ = F2(
	function (f, e) {
		return A2(
			_user$project$Lang$replaceE__,
			e,
			f(
				_user$project$Lang$unwrapExp(e)));
	});
var _user$project$Lang$setEId = F2(
	function (eid, _p270) {
		var _p271 = _p270;
		var _p272 = _p271._0;
		var e_ = _p272.val;
		return _user$project$Lang$Expr(
			_elm_lang$core$Native_Utils.update(
				_p272,
				{
					val: _elm_lang$core$Native_Utils.update(
						e_,
						{eid: eid})
				}));
	});
var _user$project$Lang$clearEId = function (e) {
	return A2(_user$project$Lang$setEId, -1, e);
};
var _user$project$Lang$DataTypeCtor = {ctor: 'DataTypeCtor'};
var _user$project$Lang$TupleCtor = {ctor: 'TupleCtor'};
var _user$project$Lang$ctorKind = function (s) {
	var _p273 = s;
	switch (_p273) {
		case '$t_ctor':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$TupleCtor);
		case '$d_ctor':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DataTypeCtor);
		default:
			return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$recordEntriesToCtorKind = function (entries) {
	recordEntriesToCtorKind:
	while (true) {
		var _p274 = entries;
		if (_p274.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var entryKind = _user$project$Lang$ctorKind(_p274._0._2);
			var _p275 = entryKind;
			if (_p275.ctor === 'Nothing') {
				var _v185 = _p274._1;
				entries = _v185;
				continue recordEntriesToCtorKind;
			} else {
				return entryKind;
			}
		}
	}
};
var _user$project$Lang$expToCtorKind = function (e) {
	var _p276 = _user$project$Lang$unwrapExp(e);
	if (_p276.ctor === 'ERecord') {
		return A2(
			_elm_lang$core$Maybe$andThen,
			_user$project$Lang$recordEntriesToCtorKind,
			_user$project$Lang$recordEntriesFromDeclarations(_p276._2));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$tupleEncodingApply = F2(
	function (ctorEncoding, values) {
		return A2(
			_elm_lang$core$List$map,
			function (_p277) {
				var _p278 = _p277;
				return {ctor: '_Tuple5', _0: _p278._1._0, _1: _user$project$Lang$space0, _2: _p278._0, _3: _user$project$Lang$space0, _4: _p278._1._1};
			},
			{
				ctor: '::',
				_0: A3(
					_user$project$Lang$ctorVal,
					function (_p279) {
						return A2(
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								}),
							_elm_lang$core$Maybe$Nothing,
							ctorEncoding(_p279));
					},
					_user$project$Lang$TupleCtor,
					_user$project$Lang$ctorTupleName(
						_elm_lang$core$List$length(values))),
				_1: A3(_user$project$Utils$indexedMapFrom, 1, _user$project$Lang$numericalValEntry, values)
			});
	});
var _user$project$Lang$tupleEncodingUnapply = function (keyValues) {
	return _elm_lang$core$Native_Utils.eq(
		_user$project$Lang$recordEntriesToCtorKind(keyValues),
		_elm_lang$core$Maybe$Just(_user$project$Lang$TupleCtor)) ? _elm_lang$core$Maybe$Just(
		A2(
			_user$project$Utils$mapHead,
			function (_p280) {
				var _p281 = _p280;
				return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p281._1};
			},
			A2(
				_elm_lang$core$List$map,
				function (_p282) {
					var _p283 = _p282;
					return {ctor: '_Tuple2', _0: _p283._0, _1: _p283._4};
				},
				A2(
					_elm_lang$core$List$sortBy,
					function (_p284) {
						var _p285 = _p284;
						return A2(
							_elm_lang$core$Result$withDefault,
							-1,
							_elm_lang$core$String$toInt(
								A2(_elm_lang$core$String$dropLeft, 1, _p285._2)));
					},
					A2(
						_elm_lang$core$List$filter,
						function (_p286) {
							var _p287 = _p286;
							return A2(_elm_lang$core$String$startsWith, '_', _p287._2);
						},
						keyValues))))) : _elm_lang$core$Maybe$Nothing;
};
var _user$project$Lang$pTupleUnapply = function (pat) {
	var _p288 = pat.val.p__;
	switch (_p288.ctor) {
		case 'PParens':
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple3',
					_0: _p288._0,
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p288._1},
						_1: {ctor: '[]'}
					},
					_2: _p288._2
				});
		case 'PRecord':
			var _p289 = _user$project$Lang$tupleEncodingUnapply(_p288._1);
			if (_p289.ctor === 'Nothing') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				return _elm_lang$core$Maybe$Just(
					{ctor: '_Tuple3', _0: _p288._0, _1: _p289._0, _2: _p288._2});
			}
		default:
			return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$eTupleUnapply = function (e) {
	var _p290 = _user$project$Lang$unwrapExp(e);
	_v194_2:
	do {
		switch (_p290.ctor) {
			case 'EParens':
				if (_p290._2.ctor === 'Parens') {
					return _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple3',
							_0: _p290._0,
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p290._1},
								_1: {ctor: '[]'}
							},
							_2: _p290._3
						});
				} else {
					break _v194_2;
				}
			case 'ERecord':
				if (_p290._1.ctor === 'Nothing') {
					var _p291 = _user$project$Lang$eRecord__Unapply(_p290);
					if (_p291.ctor === 'Just') {
						var _p292 = _user$project$Lang$tupleEncodingUnapply(_p291._0._1);
						if (_p292.ctor === 'Just') {
							return _elm_lang$core$Maybe$Just(
								{ctor: '_Tuple3', _0: _p291._0._0, _1: _p292._0, _2: _p291._0._2});
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				} else {
					break _v194_2;
				}
			default:
				break _v194_2;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$Lang$PColonType = F4(
	function (a, b, c, d) {
		return {ctor: 'PColonType', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$PRecord = F3(
	function (a, b, c) {
		return {ctor: 'PRecord', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$PParens = F3(
	function (a, b, c) {
		return {ctor: 'PParens', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$PAs = F4(
	function (a, b, c, d) {
		return {ctor: 'PAs', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$PList = F5(
	function (a, b, c, d, e) {
		return {ctor: 'PList', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$mapFoldPat = F3(
	function (f, initAcc, p) {
		var recurse = _user$project$Lang$mapFoldPat(f);
		var wrap = function (p__) {
			return A2(_user$project$Lang$replaceP__, p, p__);
		};
		var wrapAndMap = function (_p293) {
			return f(
				wrap(_p293));
		};
		var recurseAll = F2(
			function (initAcc, pats) {
				return A3(
					_elm_lang$core$List$foldr,
					F2(
						function (pat, _p294) {
							var _p295 = _p294;
							var _p296 = A2(recurse, _p295._1, pat);
							var newPat = _p296._0;
							var newAcc = _p296._1;
							return {
								ctor: '_Tuple2',
								_0: {ctor: '::', _0: newPat, _1: _p295._0},
								_1: newAcc
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: initAcc
					},
					pats);
			});
		var _p297 = p.val.p__;
		switch (_p297.ctor) {
			case 'PVar':
				return A2(f, p, initAcc);
			case 'PConst':
				return A2(f, p, initAcc);
			case 'PBase':
				return A2(f, p, initAcc);
			case 'PWildcard':
				return A2(f, p, initAcc);
			case 'PList':
				if (_p297._3.ctor === 'Nothing') {
					var _p298 = A2(recurseAll, initAcc, _p297._1);
					var newPs = _p298._0;
					var newAcc = _p298._1;
					return A2(
						wrapAndMap,
						A5(_user$project$Lang$PList, _p297._0, newPs, _p297._2, _elm_lang$core$Maybe$Nothing, _p297._4),
						newAcc);
				} else {
					var _p299 = A2(recurse, initAcc, _p297._3._0);
					var newPTail = _p299._0;
					var newAcc = _p299._1;
					var _p300 = A2(recurseAll, newAcc, _p297._1);
					var newPs = _p300._0;
					var newAcc2 = _p300._1;
					return A2(
						wrapAndMap,
						A5(
							_user$project$Lang$PList,
							_p297._0,
							newPs,
							_p297._2,
							_elm_lang$core$Maybe$Just(newPTail),
							_p297._4),
						newAcc2);
				}
			case 'PRecord':
				var _p302 = _p297._1;
				var _p301 = A2(
					recurseAll,
					initAcc,
					_user$project$Utils$recordValues(_p302));
				var newPs = _p301._0;
				var newAcc = _p301._1;
				return A2(
					wrapAndMap,
					A3(
						_user$project$Lang$PRecord,
						_p297._0,
						A2(_user$project$Utils$recordValuesMake, _p302, newPs),
						_p297._2),
					newAcc);
			case 'PAs':
				var _p303 = A2(recurse, initAcc, _p297._3);
				var newPChild2 = _p303._0;
				var newAcc = _p303._1;
				var _p304 = A2(recurse, newAcc, _p297._1);
				var newPChild1 = _p304._0;
				var newAcc2 = _p304._1;
				return A2(
					wrapAndMap,
					A4(_user$project$Lang$PAs, _p297._0, newPChild1, _p297._2, newPChild2),
					newAcc2);
			case 'PParens':
				var _p305 = A2(recurse, initAcc, _p297._1);
				var newPChild = _p305._0;
				var newAcc = _p305._1;
				return A2(
					wrapAndMap,
					A3(_user$project$Lang$PParens, _p297._0, newPChild, _p297._2),
					newAcc);
			default:
				var _p306 = A2(recurse, initAcc, _p297._1);
				var newPChild = _p306._0;
				var newAcc = _p306._1;
				return A2(
					wrapAndMap,
					A4(_user$project$Lang$PColonType, _p297._0, newPChild, _p297._2, _p297._3),
					newAcc);
		}
	});
var _user$project$Lang$mapPat = F2(
	function (f, p) {
		var _p307 = A3(
			_user$project$Lang$mapFoldPat,
			F2(
				function (pat, _p308) {
					return {
						ctor: '_Tuple2',
						_0: f(pat),
						_1: {ctor: '_Tuple0'}
					};
				}),
			{ctor: '_Tuple0'},
			p);
		var newPat = _p307._0;
		return newPat;
	});
var _user$project$Lang$mapPatNodePat = F3(
	function (pid, f, rootPat) {
		return A2(
			_user$project$Lang$mapPat,
			function (pat) {
				return _elm_lang$core$Native_Utils.eq(pat.val.pid, pid) ? f(pat) : pat;
			},
			rootPat);
	});
var _user$project$Lang$mapFoldPatTopDown = F3(
	function (f, initAcc, p) {
		var _p309 = A2(f, p, initAcc);
		var newP = _p309._0;
		var newAcc = _p309._1;
		var ret = F2(
			function (p__, acc) {
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Lang$replaceP__, newP, p__),
					_1: acc
				};
			});
		var recurse = F2(
			function (acc, child) {
				return A3(_user$project$Lang$mapFoldPatTopDown, f, acc, child);
			});
		var recurseAll = F2(
			function (acc, pats) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (pat, _p310) {
							var _p311 = _p310;
							var _p312 = A2(recurse, _p311._1, pat);
							var newPat = _p312._0;
							var newAcc = _p312._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p311._0,
									{
										ctor: '::',
										_0: newPat,
										_1: {ctor: '[]'}
									}),
								_1: newAcc
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: acc
					},
					pats);
			});
		var _p313 = newP.val.p__;
		switch (_p313.ctor) {
			case 'PVar':
				return {ctor: '_Tuple2', _0: newP, _1: newAcc};
			case 'PConst':
				return {ctor: '_Tuple2', _0: newP, _1: newAcc};
			case 'PBase':
				return {ctor: '_Tuple2', _0: newP, _1: newAcc};
			case 'PWildcard':
				return {ctor: '_Tuple2', _0: newP, _1: newAcc};
			case 'PList':
				if (_p313._3.ctor === 'Nothing') {
					var _p314 = A2(recurseAll, newAcc, _p313._1);
					var newPs = _p314._0;
					var newAcc2 = _p314._1;
					return A2(
						ret,
						A5(_user$project$Lang$PList, _p313._0, newPs, _p313._2, _elm_lang$core$Maybe$Nothing, _p313._4),
						newAcc2);
				} else {
					var _p315 = A2(recurseAll, newAcc, _p313._1);
					var newPs = _p315._0;
					var newAcc2 = _p315._1;
					var _p316 = A2(recurse, newAcc2, _p313._3._0);
					var newPTail = _p316._0;
					var newAcc3 = _p316._1;
					return A2(
						ret,
						A5(
							_user$project$Lang$PList,
							_p313._0,
							newPs,
							_p313._2,
							_elm_lang$core$Maybe$Just(newPTail),
							_p313._4),
						newAcc3);
				}
			case 'PRecord':
				var _p318 = _p313._1;
				var _p317 = A2(
					recurseAll,
					newAcc,
					_user$project$Utils$recordValues(_p318));
				var newPsvalues = _p317._0;
				var newAcc2 = _p317._1;
				return A2(
					ret,
					A3(
						_user$project$Lang$PRecord,
						_p313._0,
						A2(_user$project$Utils$recordValuesMake, _p318, newPsvalues),
						_p313._2),
					newAcc2);
			case 'PAs':
				var _p319 = A2(recurse, newAcc, _p313._1);
				var newPChild1 = _p319._0;
				var newAcc2 = _p319._1;
				var _p320 = A2(recurse, newAcc2, _p313._3);
				var newPChild2 = _p320._0;
				var newAcc3 = _p320._1;
				return A2(
					ret,
					A4(_user$project$Lang$PAs, _p313._0, newPChild1, _p313._2, newPChild2),
					newAcc3);
			case 'PParens':
				var _p321 = A2(recurse, newAcc, _p313._1);
				var newPChild = _p321._0;
				var newAcc2 = _p321._1;
				return A2(
					ret,
					A3(_user$project$Lang$PParens, _p313._0, newPChild, _p313._2),
					newAcc2);
			default:
				var _p322 = A2(recurse, newAcc, _p313._1);
				var newPChild = _p322._0;
				var newAcc2 = _p322._1;
				return A2(
					ret,
					A4(_user$project$Lang$PColonType, _p313._0, newPChild, _p313._2, _p313._3),
					newAcc2);
		}
	});
var _user$project$Lang$mapPatTopDown = F2(
	function (f, p) {
		var _p323 = A3(
			_user$project$Lang$mapFoldPatTopDown,
			F2(
				function (pat, _p324) {
					return {
						ctor: '_Tuple2',
						_0: f(pat),
						_1: {ctor: '_Tuple0'}
					};
				}),
			{ctor: '_Tuple0'},
			p);
		var newPat = _p323._0;
		return newPat;
	});
var _user$project$Lang$clearPIds = function (p) {
	return A2(_user$project$Lang$mapPatTopDown, _user$project$Lang$clearPId, p);
};
var _user$project$Lang$pList0 = function (ps) {
	return _user$project$Lang$withDummyPatInfo(
		A5(_user$project$Lang$PList, _user$project$Lang$space0, ps, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0));
};
var _user$project$Lang$pList = function (ps) {
	return _user$project$Lang$withDummyPatInfo(
		A5(_user$project$Lang$PList, _user$project$Lang$space1, ps, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0));
};
var _user$project$Lang$PWildcard = function (a) {
	return {ctor: 'PWildcard', _0: a};
};
var _user$project$Lang$pWildcard0 = _user$project$Lang$withDummyPatInfo(
	_user$project$Lang$PWildcard(_user$project$Lang$space0));
var _user$project$Lang$pWildcard1 = _user$project$Lang$withDummyPatInfo(
	_user$project$Lang$PWildcard(_user$project$Lang$space1));
var _user$project$Lang$pWildcard = function (ps) {
	return _user$project$Lang$withDummyPatInfo(
		_user$project$Lang$PWildcard(_user$project$Lang$space0));
};
var _user$project$Lang$PBase = F2(
	function (a, b) {
		return {ctor: 'PBase', _0: a, _1: b};
	});
var _user$project$Lang$PConst = F2(
	function (a, b) {
		return {ctor: 'PConst', _0: a, _1: b};
	});
var _user$project$Lang$PVar = F3(
	function (a, b, c) {
		return {ctor: 'PVar', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$mapPrecedingWhitespacePatWS = F2(
	function (mapWs, pat) {
		var p__ = function () {
			var _p325 = pat.val.p__;
			switch (_p325.ctor) {
				case 'PVar':
					return A3(
						_user$project$Lang$PVar,
						mapWs(_p325._0),
						_p325._1,
						_p325._2);
				case 'PConst':
					return A2(
						_user$project$Lang$PConst,
						mapWs(_p325._0),
						_p325._1);
				case 'PBase':
					return A2(
						_user$project$Lang$PBase,
						mapWs(_p325._0),
						_p325._1);
				case 'PWildcard':
					return _user$project$Lang$PWildcard(
						mapWs(_p325._0));
				case 'PList':
					return A5(
						_user$project$Lang$PList,
						mapWs(_p325._0),
						_p325._1,
						_p325._2,
						_p325._3,
						_p325._4);
				case 'PRecord':
					return A3(
						_user$project$Lang$PRecord,
						mapWs(_p325._0),
						_p325._1,
						_p325._2);
				case 'PAs':
					return A4(
						_user$project$Lang$PAs,
						mapWs(_p325._0),
						_p325._1,
						_p325._2,
						_p325._3);
				case 'PParens':
					return A3(
						_user$project$Lang$PParens,
						mapWs(_p325._0),
						_p325._1,
						_p325._2);
				default:
					return A4(
						_user$project$Lang$PColonType,
						mapWs(_p325._0),
						_p325._1,
						_p325._2,
						_p325._3);
			}
		}();
		return A2(_user$project$Lang$replaceP__, pat, p__);
	});
var _user$project$Lang$mapPrecedingWhitespacePat = F2(
	function (stringMap, pat) {
		var mapWs = function (s) {
			return _user$project$Lang$ws(
				stringMap(s.val));
		};
		return A2(_user$project$Lang$mapPrecedingWhitespacePatWS, mapWs, pat);
	});
var _user$project$Lang$replacePrecedingWhitespacePat = F2(
	function (newWs, pat) {
		return A2(
			_user$project$Lang$mapPrecedingWhitespacePat,
			function (_p326) {
				return newWs;
			},
			pat);
	});
var _user$project$Lang$replaceP__PreservingPrecedingWhitespace = F2(
	function (p, p__) {
		return A2(
			_user$project$Lang$replacePrecedingWhitespacePat,
			_user$project$Lang$precedingWhitespacePat(p),
			A2(_user$project$Lang$replaceP__, p, p__));
	});
var _user$project$Lang$copyPrecedingWhitespacePat = F2(
	function (source, target) {
		return A2(
			_user$project$Lang$replacePrecedingWhitespacePat,
			_user$project$Lang$precedingWhitespacePat(source),
			target);
	});
var _user$project$Lang$setPatListWhitespace = F3(
	function (firstWs, sepWs, pats) {
		var _p327 = pats;
		if (_p327.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: A2(_user$project$Lang$replacePrecedingWhitespacePat, firstWs, _p327._0),
				_1: A2(
					_elm_lang$core$List$map,
					_user$project$Lang$replacePrecedingWhitespacePat(sepWs),
					_p327._1)
			};
		}
	});
var _user$project$Lang$imitatePatListWhitespace = F2(
	function (oldPats, newPats) {
		var _p328 = function () {
			var _p329 = oldPats;
			if (_p329.ctor === '::') {
				if (_p329._1.ctor === '::') {
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$precedingWhitespacePat(_p329._0),
						_1: _user$project$Lang$precedingWhitespacePat(_p329._1._0)
					};
				} else {
					var _p330 = _p329._0;
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$precedingWhitespacePat(_p330),
						_1: _elm_lang$core$Native_Utils.eq(
							_user$project$Lang$precedingWhitespacePat(_p330),
							'') ? ' ' : _user$project$Lang$precedingWhitespacePat(_p330)
					};
				}
			} else {
				return {ctor: '_Tuple2', _0: '', _1: ' '};
			}
		}();
		var firstWs = _p328._0;
		var sepWs = _p328._1;
		var _p331 = newPats;
		if (_p331.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var firstWithNewWs = A2(_user$project$Lang$replacePrecedingWhitespacePat, firstWs, _p331._0);
			var restWithNewWs = A2(
				_elm_lang$core$List$map,
				function (p) {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$precedingWhitespacePat(p),
						'') ? A2(_user$project$Lang$replacePrecedingWhitespacePat, sepWs, p) : (A2(_elm_lang$core$List$member, p, oldPats) ? p : A2(_user$project$Lang$replacePrecedingWhitespacePat, sepWs, p));
				},
				_p331._1);
			return {ctor: '::', _0: firstWithNewWs, _1: restWithNewWs};
		}
	});
var _user$project$Lang$ensureWhitespacePat = function (pat) {
	return A2(_user$project$Lang$mapPrecedingWhitespacePat, _user$project$Lang$ensureWhitespace, pat);
};
var _user$project$Lang$ensureNoWhitespacePat = function (pat) {
	return A2(
		_user$project$Lang$mapPrecedingWhitespacePat,
		function (_p332) {
			return '';
		},
		pat);
};
var _user$project$Lang$RegexExtractFirstIn = {ctor: 'RegexExtractFirstIn'};
var _user$project$Lang$DictInsert = {ctor: 'DictInsert'};
var _user$project$Lang$DictRemove = {ctor: 'DictRemove'};
var _user$project$Lang$DictGet = {ctor: 'DictGet'};
var _user$project$Lang$ArcTan2 = {ctor: 'ArcTan2'};
var _user$project$Lang$Pow = {ctor: 'Pow'};
var _user$project$Lang$Mod = {ctor: 'Mod'};
var _user$project$Lang$Eq = {ctor: 'Eq'};
var _user$project$Lang$Lt = {ctor: 'Lt'};
var _user$project$Lang$Div = {ctor: 'Div'};
var _user$project$Lang$Mult = {ctor: 'Mult'};
var _user$project$Lang$Minus = {ctor: 'Minus'};
var _user$project$Lang$Plus = {ctor: 'Plus'};
var _user$project$Lang$NoWidgets = {ctor: 'NoWidgets'};
var _user$project$Lang$DebugLog = {ctor: 'DebugLog'};
var _user$project$Lang$expEffectiveExps = function (exp) {
	var _p333 = _user$project$Lang$unwrapExp(exp);
	_v205_4:
	do {
		switch (_p333.ctor) {
			case 'EColonType':
				return {
					ctor: '::',
					_0: exp,
					_1: _user$project$Lang$expEffectiveExps(_p333._1)
				};
			case 'ELet':
				return {
					ctor: '::',
					_0: exp,
					_1: _user$project$Lang$expEffectiveExps(_p333._4)
				};
			case 'EParens':
				return {
					ctor: '::',
					_0: exp,
					_1: _user$project$Lang$expEffectiveExps(_p333._1)
				};
			case 'EOp':
				if ((_p333._3.ctor === '::') && (_p333._3._1.ctor === '[]')) {
					var _p334 = _p333._2.val;
					return (_elm_lang$core$Native_Utils.eq(_p334, _user$project$Lang$DebugLog) || _elm_lang$core$Native_Utils.eq(_p334, _user$project$Lang$NoWidgets)) ? {
						ctor: '::',
						_0: exp,
						_1: _user$project$Lang$expEffectiveExps(_p333._3._0)
					} : {
						ctor: '::',
						_0: exp,
						_1: {ctor: '[]'}
					};
				} else {
					break _v205_4;
				}
			default:
				break _v205_4;
		}
	} while(false);
	return {
		ctor: '::',
		_0: exp,
		_1: {ctor: '[]'}
	};
};
var _user$project$Lang$expEffectiveExp = function (exp) {
	return A2(
		_user$project$Utils$last,
		'expEffectiveExp shouldn\'t happen',
		_user$project$Lang$expEffectiveExps(exp));
};
var _user$project$Lang$StrLength = {ctor: 'StrLength'};
var _user$project$Lang$Explode = {ctor: 'Explode'};
var _user$project$Lang$Sqrt = {ctor: 'Sqrt'};
var _user$project$Lang$ToStrExceptStr = {ctor: 'ToStrExceptStr'};
var _user$project$Lang$ToStr = {ctor: 'ToStr'};
var _user$project$Lang$Round = {ctor: 'Round'};
var _user$project$Lang$Ceil = {ctor: 'Ceil'};
var _user$project$Lang$Floor = {ctor: 'Floor'};
var _user$project$Lang$ArcSin = {ctor: 'ArcSin'};
var _user$project$Lang$ArcCos = {ctor: 'ArcCos'};
var _user$project$Lang$Sin = {ctor: 'Sin'};
var _user$project$Lang$Cos = {ctor: 'Cos'};
var _user$project$Lang$DictFromList = {ctor: 'DictFromList'};
var _user$project$Lang$CurrentEnv = {ctor: 'CurrentEnv'};
var _user$project$Lang$DictEmpty = {ctor: 'DictEmpty'};
var _user$project$Lang$Pi = {ctor: 'Pi'};
var _user$project$Lang$InfixApp = {ctor: 'InfixApp'};
var _user$project$Lang$RightApp = function (a) {
	return {ctor: 'RightApp', _0: a};
};
var _user$project$Lang$LeftApp = function (a) {
	return {ctor: 'LeftApp', _0: a};
};
var _user$project$Lang$SpaceApp = {ctor: 'SpaceApp'};
var _user$project$Lang$FunArgsAfterEqual = {ctor: 'FunArgsAfterEqual'};
var _user$project$Lang$FunArgAsPats = {ctor: 'FunArgAsPats'};
var _user$project$Lang$LetExp = F6(
	function (a, b, c, d, e, f) {
		return {ctor: 'LetExp', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f};
	});
var _user$project$Lang$mapLetPats = F2(
	function (f, _p335) {
		var _p336 = _p335;
		return A6(
			_user$project$Lang$LetExp,
			_p336._0,
			_p336._1,
			f(_p336._2),
			_p336._3,
			_p336._4,
			_p336._5);
	});
var _user$project$Lang$LetType = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'LetType', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$Lang$LetAnnotation = F6(
	function (a, b, c, d, e, f) {
		return {ctor: 'LetAnnotation', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f};
	});
var _user$project$Lang$mapAnnotPat = F2(
	function (f, _p337) {
		var _p338 = _p337;
		return A6(
			_user$project$Lang$LetAnnotation,
			_p338._0,
			_p338._1,
			f(_p338._2),
			_p338._3,
			_p338._4,
			_p338._5);
	});
var _user$project$Lang$Declarations = F4(
	function (a, b, c, d) {
		return {ctor: 'Declarations', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$declExtractors = function (_p339) {
	var _p340 = _p339;
	var _p341 = _user$project$Lang$groupsOfExtractors(_p340._3);
	var letexps = _p341._0;
	var letexpsBuilder = _p341._1;
	return {
		ctor: '_Tuple2',
		_0: A2(
			_elm_lang$core$List$map,
			function (_p342) {
				var _p343 = _p342;
				return _p343._5;
			},
			letexps),
		_1: function (newExps) {
			var newLetExpsGroups = letexpsBuilder(
				A3(
					_elm_lang$core$List$map2,
					F2(
						function (_p344, newE1) {
							var _p345 = _p344;
							return A6(_user$project$Lang$LetExp, _p345._0, _p345._1, _p345._2, _p345._3, _p345._4, newE1);
						}),
					letexps,
					newExps));
			return A4(_user$project$Lang$Declarations, _p340._0, _p340._1, _p340._2, newLetExpsGroups);
		}
	};
};
var _user$project$Lang$DeclAnnotation = function (a) {
	return {ctor: 'DeclAnnotation', _0: a};
};
var _user$project$Lang$DeclType = function (a) {
	return {ctor: 'DeclType', _0: a};
};
var _user$project$Lang$DeclExp = function (a) {
	return {ctor: 'DeclExp', _0: a};
};
var _user$project$Lang$getDeclarations = function (_p346) {
	var _p347 = _p346;
	var _p348 = _p347._3;
	return _elm_lang$core$List$isEmpty(_p347._0) ? A2(
		_elm_lang$core$List$map,
		_user$project$Lang$DeclExp,
		_user$project$Lang$elemsOf(_p348)) : A2(
		_elm_lang$core$Basics_ops['++'],
		A2(
			_elm_lang$core$List$map,
			_user$project$Lang$DeclType,
			_user$project$Lang$elemsOf(_p347._1)),
		A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$List$map, _user$project$Lang$DeclAnnotation, _p347._2),
			A2(
				_elm_lang$core$List$map,
				_user$project$Lang$DeclExp,
				_user$project$Lang$elemsOf(_p348))));
};
var _user$project$Lang$getDeclarationsInOrderWithIndex = function (_p349) {
	var _p350 = _p349;
	return A2(
		_user$project$Utils$reorder,
		_p350._0,
		_user$project$Utils$zipWithIndex(
			_user$project$Lang$getDeclarations(_p350)));
};
var _user$project$Lang$getDeclarationsInOrder = function (decls) {
	return _elm_lang$core$Tuple$first(
		_elm_lang$core$List$unzip(
			_user$project$Lang$getDeclarationsInOrderWithIndex(decls)));
};
var _user$project$Lang$findLetexpByBindingNumber = F2(
	function (program, targetBinding) {
		var _p351 = _user$project$Lang$unwrapExp(program);
		if (_p351.ctor === 'ELet') {
			var _p352 = A3(
				_elm_lang$core$Basics$flip,
				_user$project$Utils$nth,
				targetBinding,
				_user$project$Lang$getDeclarationsInOrder(_p351._2));
			if ((_p352.ctor === 'Ok') && (_p352._0.ctor === 'DeclExp')) {
				return _elm_lang$core$Maybe$Just(_p352._0._0);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Lang$allWhitespacesDecls = function (decls) {
	return A2(
		_elm_lang$core$List$concatMap,
		function (def) {
			var _p353 = def;
			switch (_p353.ctor) {
				case 'DeclAnnotation':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$maybeToList(_p353._0._0),
						A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _p353._0._1,
								_1: {ctor: '[]'}
							},
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$allWhitespacesPat_(_p353._0._2),
								A2(
									_elm_lang$core$Basics_ops['++'],
									{
										ctor: '::',
										_0: _p353._0._4,
										_1: {ctor: '[]'}
									},
									_user$project$Lang$allWhitespacesType_(_p353._0._5)))));
				case 'DeclExp':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$maybeToList(_p353._0._0),
						A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _p353._0._1,
								_1: {ctor: '[]'}
							},
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$allWhitespacesPat_(_p353._0._2),
								A2(
									_elm_lang$core$Basics_ops['++'],
									{
										ctor: '::',
										_0: _p353._0._4,
										_1: {ctor: '[]'}
									},
									_user$project$Lang$allWhitespaces_(_p353._0._5)))));
				default:
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$maybeToList(_p353._0._0),
						A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _p353._0._1,
								_1: {ctor: '[]'}
							},
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$maybeToList(_p353._0._2),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$allWhitespacesPat_(_p353._0._3),
									A2(
										_elm_lang$core$Basics_ops['++'],
										{
											ctor: '::',
											_0: _p353._0._5,
											_1: {ctor: '[]'}
										},
										_user$project$Lang$allWhitespacesType_(_p353._0._6))))));
			}
		},
		_user$project$Lang$getDeclarationsInOrder(decls));
};
var _user$project$Lang$allWhitespaces_ = function (exp) {
	var allWhitespacesBranch = function (branch) {
		var _p354 = branch.val;
		var ws1 = _p354._0;
		var pat = _p354._1;
		var e = _p354._2;
		var ws2 = _p354._3;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			{
				ctor: '::',
				_0: ws1,
				_1: {ctor: '[]'}
			},
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$allWhitespacesPat_(pat),
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(e),
					{
						ctor: '::',
						_0: ws2,
						_1: {ctor: '[]'}
					})));
	};
	var allWhitespacesTBranch = function (tbranch) {
		var _p355 = tbranch.val;
		var ws1 = _p355._0;
		var tipe = _p355._1;
		var e = _p355._2;
		var ws2 = _p355._3;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			{
				ctor: '::',
				_0: ws1,
				_1: {ctor: '[]'}
			},
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$allWhitespacesType_(tipe),
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(e),
					{
						ctor: '::',
						_0: ws2,
						_1: {ctor: '[]'}
					})));
	};
	var _p356 = _user$project$Lang$unwrapExp(exp);
	switch (_p356.ctor) {
		case 'EBase':
			return {
				ctor: '::',
				_0: _p356._0,
				_1: {ctor: '[]'}
			};
		case 'EConst':
			return {
				ctor: '::',
				_0: _p356._0,
				_1: {ctor: '[]'}
			};
		case 'EVar':
			return {
				ctor: '::',
				_0: _p356._0,
				_1: {ctor: '[]'}
			};
		case 'EFun':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespacesPat_, _p356._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$allWhitespaces_(_p356._2),
						{
							ctor: '::',
							_0: _p356._3,
							_1: {ctor: '[]'}
						})));
		case 'EApp':
			switch (_p356._3.ctor) {
				case 'SpaceApp':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._0,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$List$concatMap,
								_user$project$Lang$allWhitespaces_,
								{ctor: '::', _0: _p356._1, _1: _p356._2}),
							{
								ctor: '::',
								_0: _p356._4,
								_1: {ctor: '[]'}
							}));
				case 'LeftApp':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._0,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$Lang$allWhitespaces_(_p356._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								{
									ctor: '::',
									_0: _p356._3._0,
									_1: {ctor: '[]'}
								},
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespaces_, _p356._2),
									{
										ctor: '::',
										_0: _p356._4,
										_1: {ctor: '[]'}
									}))));
				case 'RightApp':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._0,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespaces_, _p356._2),
							A2(
								_elm_lang$core$Basics_ops['++'],
								{
									ctor: '::',
									_0: _p356._3._0,
									_1: {ctor: '[]'}
								},
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$allWhitespaces_(_p356._1),
									{
										ctor: '::',
										_0: _p356._4,
										_1: {ctor: '[]'}
									}))));
				default:
					if (((_p356._2.ctor === '::') && (_p356._2._1.ctor === '::')) && (_p356._2._1._1.ctor === '[]')) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _p356._0,
								_1: {ctor: '[]'}
							},
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$allWhitespaces_(_p356._2._0),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$allWhitespaces_(_p356._1),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$Lang$allWhitespaces_(_p356._2._1._0),
										{
											ctor: '::',
											_0: _p356._4,
											_1: {ctor: '[]'}
										}))));
					} else {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _p356._0,
								_1: {ctor: '[]'}
							},
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$List$concatMap,
									_user$project$Lang$allWhitespaces_,
									{ctor: '::', _0: _p356._1, _1: _p356._2}),
								{
									ctor: '::',
									_0: _p356._4,
									_1: {ctor: '[]'}
								}));
					}
			}
		case 'EList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$List$concatMap,
						function (_p357) {
							var _p358 = _p357;
							return {
								ctor: '::',
								_0: _p358._0,
								_1: _user$project$Lang$allWhitespaces_(_p358._1)
							};
						},
						_p356._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._2,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								{ctor: '[]'},
								A2(_elm_lang$core$Maybe$map, _user$project$Lang$allWhitespaces_, _p356._3)),
							{
								ctor: '::',
								_0: _p356._4,
								_1: {ctor: '[]'}
							}))));
		case 'ERecord':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						A2(
							_elm_lang$core$Maybe$map,
							function (_p359) {
								return _user$project$Lang$allWhitespaces_(
									_elm_lang$core$Tuple$first(_p359));
							},
							_p356._1)),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$allWhitespacesDecls(_p356._2),
						{
							ctor: '::',
							_0: _p356._3,
							_1: {ctor: '[]'}
						})));
		case 'ESelect':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$allWhitespaces_(_p356._1),
				{
					ctor: '::',
					_0: _p356._2,
					_1: {
						ctor: '::',
						_0: _p356._3,
						_1: {ctor: '[]'}
					}
				});
		case 'EOp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					{
						ctor: '::',
						_0: _p356._1,
						_1: {ctor: '[]'}
					},
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, _user$project$Lang$allWhitespaces_, _p356._3),
						{
							ctor: '::',
							_0: _p356._4,
							_1: {ctor: '[]'}
						})));
		case 'EIf':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(_p356._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._2,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$Lang$allWhitespaces_(_p356._3),
							A2(
								_elm_lang$core$Basics_ops['++'],
								{
									ctor: '::',
									_0: _p356._4,
									_1: {ctor: '[]'}
								},
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$allWhitespaces_(_p356._5),
									{
										ctor: '::',
										_0: _p356._6,
										_1: {ctor: '[]'}
									}))))));
		case 'ELet':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespacesDecls(_p356._2),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p356._3,
							_1: {ctor: '[]'}
						},
						_user$project$Lang$allWhitespaces_(_p356._4))));
		case 'ECase':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(_p356._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, allWhitespacesBranch, _p356._2),
						{
							ctor: '::',
							_0: _p356._3,
							_1: {ctor: '[]'}
						})));
		case 'EColonType':
			var _p360 = _p356._2;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(_p356._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _p360,
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$Lang$allWhitespacesType_(_p356._3),
							{
								ctor: '::',
								_0: _p360,
								_1: {ctor: '[]'}
							}))));
		case 'EParens':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: _p356._0,
					_1: {ctor: '[]'}
				},
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$Lang$allWhitespaces_(_p356._1),
					{
						ctor: '::',
						_0: _p356._3,
						_1: {ctor: '[]'}
					}));
		default:
			return {
				ctor: '::',
				_0: _p356._0,
				_1: {ctor: '[]'}
			};
	}
};
var _user$project$Lang$allWhitespaces = function (exp) {
	return A2(
		_elm_lang$core$List$map,
		function (_) {
			return _.val;
		},
		_user$project$Lang$allWhitespaces_(exp));
};
var _user$project$Lang$expHasNewlines = function (exp) {
	return A2(
		_elm_lang$core$List$any,
		_elm_lang$core$String$contains('\n'),
		_user$project$Lang$allWhitespaces(exp));
};
var _user$project$Lang$getDeclarationsExtractors = function (_p361) {
	var _p362 = _p361;
	return {
		ctor: '_Tuple2',
		_0: _user$project$Lang$getDeclarations(_p362),
		_1: function (newDeclarations) {
			var newTypes = A2(
				_elm_lang$core$List$filterMap,
				function (def) {
					var _p363 = def;
					if (_p363.ctor === 'DeclType') {
						return _elm_lang$core$Maybe$Just(_p363._0);
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				},
				newDeclarations);
			var newAnnotations = A2(
				_elm_lang$core$List$filterMap,
				function (def) {
					var _p364 = def;
					if (_p364.ctor === 'DeclAnnotation') {
						return _elm_lang$core$Maybe$Just(_p364._0);
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				},
				newDeclarations);
			var newExps = A2(
				_elm_lang$core$List$filterMap,
				function (def) {
					var _p365 = def;
					if (_p365.ctor === 'DeclExp') {
						return _elm_lang$core$Maybe$Just(_p365._0);
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				},
				newDeclarations);
			return A4(
				_user$project$Lang$Declarations,
				_p362._0,
				A2(_user$project$Lang$regroup, _p362._1, newTypes),
				newAnnotations,
				A2(_user$project$Lang$regroup, _p362._3, newExps));
		}
	};
};
var _user$project$Lang$getOptions = function (e) {
	var _p366 = _user$project$Lang$unwrapExp(e);
	if ((_p366.ctor === 'ELet') && (_p366._1.ctor === 'Def')) {
		var mbFirstDeclNumber = A2(_user$project$Utils$maybeGeti0, 0, _p366._2._0);
		var mbFirstSpace = A2(
			_user$project$Utils$mapFirstSuccess,
			function (_p367) {
				var _p368 = _p367;
				return _elm_lang$core$Native_Utils.eq(
					_elm_lang$core$Maybe$Just(_p368._1),
					mbFirstDeclNumber) ? _elm_lang$core$Maybe$Just(
					function (_) {
						return _.val;
					}(
						_user$project$Lang$precedingWhitespaceDeclarationWithInfo(_p368._0))) : _elm_lang$core$Maybe$Nothing;
			},
			_user$project$Utils$zipWithIndex(
				_user$project$Lang$getDeclarations(_p366._2)));
		var _p369 = mbFirstSpace;
		if (_p369.ctor === 'Nothing') {
			return _user$project$Lang$getOptionsFromString(
				_user$project$Lang$precedingWhitespace(e));
		} else {
			return _user$project$Lang$getOptionsFromString(_p369._0);
		}
	} else {
		return _user$project$Lang$getOptionsFromString(
			_user$project$Lang$precedingWhitespace(e));
	}
};
var _user$project$Lang$getTopLevelOptions = function (e) {
	return _user$project$Lang$getOptions(e);
};
var _user$project$Lang$taggedExpPats = function (exp) {
	var _p370 = _user$project$Lang$unwrapExp(exp);
	switch (_p370.ctor) {
		case 'EFun':
			return A2(
				_elm_lang$core$List$concatMap,
				_elm_lang$core$Basics$identity,
				A2(
					_elm_lang$core$List$indexedMap,
					F2(
						function (i, p) {
							return A2(
								_user$project$Lang$tagSinglePat,
								_user$project$Lang$rootPathedPatternId(
									{
										ctor: '_Tuple2',
										_0: _user$project$Lang$expEId(exp),
										_1: i
									}),
								p);
						}),
					_p370._1));
		case 'ECase':
			return A2(
				_user$project$Lang$tagBranchList,
				_user$project$Lang$expEId(exp),
				_p370._2);
		case 'ELet':
			return A2(
				_elm_lang$core$List$concatMap,
				function (_p371) {
					var _p372 = _p371;
					var _p374 = _p372._1;
					var _p373 = _p372._0;
					switch (_p373.ctor) {
						case 'DeclAnnotation':
							return A2(
								_user$project$Lang$tagSinglePat,
								_user$project$Lang$rootPathedPatternId(
									{
										ctor: '_Tuple2',
										_0: _user$project$Lang$expEId(exp),
										_1: _p374
									}),
								_p373._0._2);
						case 'DeclExp':
							return A2(
								_user$project$Lang$tagSinglePat,
								_user$project$Lang$rootPathedPatternId(
									{
										ctor: '_Tuple2',
										_0: _user$project$Lang$expEId(exp),
										_1: _p374
									}),
								_p373._0._2);
						default:
							return A2(
								_user$project$Lang$tagSinglePat,
								_user$project$Lang$rootPathedPatternId(
									{
										ctor: '_Tuple2',
										_0: _user$project$Lang$expEId(exp),
										_1: _p374
									}),
								_p373._0._3);
					}
				},
				_user$project$Utils$zipWithIndex(
					_user$project$Lang$getDeclarations(_p370._2)));
		default:
			return {ctor: '[]'};
	}
};
var _user$project$Lang$mapPrecedingWhitespaceDeclaration = F2(
	function (f, decl) {
		var _p375 = decl;
		switch (_p375.ctor) {
			case 'DeclExp':
				return _user$project$Lang$DeclExp(
					A6(
						_user$project$Lang$LetExp,
						_p375._0._0,
						A2(_user$project$Lang$mapWs, f, _p375._0._1),
						_p375._0._2,
						_p375._0._3,
						_p375._0._4,
						_p375._0._5));
			case 'DeclType':
				return _user$project$Lang$DeclType(
					A7(
						_user$project$Lang$LetType,
						_p375._0._0,
						A2(_user$project$Lang$mapWs, f, _p375._0._1),
						_p375._0._2,
						_p375._0._3,
						_p375._0._4,
						_p375._0._5,
						_p375._0._6));
			default:
				return _user$project$Lang$DeclAnnotation(
					A6(
						_user$project$Lang$LetAnnotation,
						_p375._0._0,
						A2(_user$project$Lang$mapWs, f, _p375._0._1),
						_p375._0._2,
						_p375._0._3,
						_p375._0._4,
						_p375._0._5));
		}
	});
var _user$project$Lang$ESelect = F5(
	function (a, b, c, d, e) {
		return {ctor: 'ESelect', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$eSelect = F2(
	function (e, name) {
		return _user$project$Lang$withDummyExpInfo(
			A5(_user$project$Lang$ESelect, _user$project$Lang$space0, e, _user$project$Lang$space0, _user$project$Lang$space0, name));
	});
var _user$project$Lang$ERecord = F4(
	function (a, b, c, d) {
		return {ctor: 'ERecord', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$EHole = F2(
	function (a, b) {
		return {ctor: 'EHole', _0: a, _1: b};
	});
var _user$project$Lang$EParens = F4(
	function (a, b, c, d) {
		return {ctor: 'EParens', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$EColonType = F5(
	function (a, b, c, d, e) {
		return {ctor: 'EColonType', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$eColonType = F2(
	function (_p376, t) {
		var _p377 = _p376;
		var _p378 = _p377._0;
		return A3(
			_user$project$Info$withInfo,
			_user$project$Lang$exp_(
				A5(
					_user$project$Lang$EColonType,
					_user$project$Lang$space1,
					_user$project$Lang$Expr(_p378),
					_user$project$Lang$space1,
					t,
					_user$project$Lang$space0)),
			_p378.start,
			t.end);
	});
var _user$project$Lang$ELet = F5(
	function (a, b, c, d, e) {
		return {ctor: 'ELet', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$eLet__ = F9(
	function (wsStart, letOrDef, isRec, name, spEq, binding, spIn, rest, wsEnd) {
		return A5(
			_user$project$Lang$ELet,
			wsStart,
			letOrDef,
			A4(
				_user$project$Lang$Declarations,
				{
					ctor: '::',
					_0: 0,
					_1: {ctor: '[]'}
				},
				{ctor: '[]'},
				{ctor: '[]'},
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: _user$project$Lang$isBodyPossiblyRecursive(binding),
						_1: {
							ctor: '::',
							_0: A6(_user$project$Lang$LetExp, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0, name, _user$project$Lang$FunArgAsPats, spEq, binding),
							_1: {ctor: '[]'}
						}
					},
					_1: {ctor: '[]'}
				}),
			spIn,
			rest);
	});
var _user$project$Lang$ECase = F4(
	function (a, b, c, d) {
		return {ctor: 'ECase', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$EIf = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'EIf', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$Lang$eIf = F3(
	function (c, t, e) {
		return _user$project$Lang$withDummyExpInfo(
			A7(_user$project$Lang$EIf, _user$project$Lang$space0, c, _user$project$Lang$space1, t, _user$project$Lang$space1, e, _user$project$Lang$space0));
	});
var _user$project$Lang$EList = F5(
	function (a, b, c, d, e) {
		return {ctor: 'EList', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$ePair = F2(
	function (e1, e2) {
		return _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$EList,
				_user$project$Lang$space1,
				{
					ctor: '::',
					_0: e1,
					_1: {
						ctor: '::',
						_0: e2,
						_1: {ctor: '[]'}
					}
				},
				_user$project$Lang$space0,
				_elm_lang$core$Maybe$Nothing,
				_user$project$Lang$space0));
	});
var _user$project$Lang$eList0 = F2(
	function (a, b) {
		return _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$EList,
				_user$project$Lang$space0,
				A2(
					_elm_lang$core$List$map,
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})(_user$project$Lang$space0),
					a),
				_user$project$Lang$space0,
				b,
				_user$project$Lang$space0));
	});
var _user$project$Lang$eList = F2(
	function (a, b) {
		return _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$EList,
				_user$project$Lang$space1,
				A2(
					_elm_lang$core$List$map,
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})(_user$project$Lang$space0),
					a),
				_user$project$Lang$space0,
				b,
				_user$project$Lang$space0));
	});
var _user$project$Lang$eListWs = F2(
	function (a, b) {
		return _user$project$Lang$withDummyExpInfo(
			A5(_user$project$Lang$EList, _user$project$Lang$space1, a, _user$project$Lang$space0, b, _user$project$Lang$space0));
	});
var _user$project$Lang$EOp = F5(
	function (a, b, c, d, e) {
		return {ctor: 'EOp', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$eOp = F2(
	function (op_, es) {
		return _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$EOp,
				_user$project$Lang$space1,
				_user$project$Lang$space1,
				_user$project$Lang$withDummyRange(op_),
				es,
				_user$project$Lang$space0));
	});
var _user$project$Lang$ePlus = F2(
	function (e1, e2) {
		return A2(
			_user$project$Lang$eOp,
			_user$project$Lang$Plus,
			{
				ctor: '::',
				_0: e1,
				_1: {
					ctor: '::',
					_0: e2,
					_1: {ctor: '[]'}
				}
			});
	});
var _user$project$Lang$eMinus = F2(
	function (e1, e2) {
		return A2(
			_user$project$Lang$eOp,
			_user$project$Lang$Minus,
			{
				ctor: '::',
				_0: e1,
				_1: {
					ctor: '::',
					_0: e2,
					_1: {ctor: '[]'}
				}
			});
	});
var _user$project$Lang$EApp = F5(
	function (a, b, c, d, e) {
		return {ctor: 'EApp', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$eApp = F2(
	function (_p379, es) {
		var _p380 = _p379;
		var _p383 = _p380._0;
		return _user$project$Lang$Expr(
			A3(
				_user$project$Info$withInfo,
				_user$project$Lang$exp_(
					A5(
						_user$project$Lang$EApp,
						_user$project$Lang$space1,
						_user$project$Lang$Expr(_p383),
						es,
						_user$project$Lang$SpaceApp,
						_user$project$Lang$space0)),
				_p383.start,
				A2(
					_elm_lang$core$Maybe$withDefault,
					_p383.end,
					A2(
						_elm_lang$core$Maybe$map,
						function (_p381) {
							var _p382 = _p381;
							return _p382._0.end;
						},
						_user$project$Utils$maybeLast(es)))));
	});
var _user$project$Lang$desugarEApp = F2(
	function (e, es) {
		desugarEApp:
		while (true) {
			var _p384 = es;
			if (_p384.ctor === '[]') {
				return _elm_lang$core$Native_Utils.crashCase(
					'Lang',
					{
						start: {line: 2378, column: 20},
						end: {line: 2381, column: 43}
					},
					_p384)('desugarEApp');
			} else {
				if (_p384._1.ctor === '[]') {
					return A2(
						_user$project$Lang$eApp,
						e,
						{
							ctor: '::',
							_0: _p384._0,
							_1: {ctor: '[]'}
						});
				} else {
					var _v233 = A2(
						_user$project$Lang$eApp,
						e,
						{
							ctor: '::',
							_0: _p384._0,
							_1: {ctor: '[]'}
						}),
						_v234 = _p384._1;
					e = _v233;
					es = _v234;
					continue desugarEApp;
				}
			}
		}
	});
var _user$project$Lang$EFun = F4(
	function (a, b, c, d) {
		return {ctor: 'EFun', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$eFun = F2(
	function (ps, e) {
		return _user$project$Lang$withDummyExpInfo(
			A4(_user$project$Lang$EFun, _user$project$Lang$space1, ps, e, _user$project$Lang$space0));
	});
var _user$project$Lang$desugarEFun = F2(
	function (ps, e) {
		var _p386 = ps;
		if (_p386.ctor === '[]') {
			return _elm_lang$core$Native_Utils.crashCase(
				'Lang',
				{
					start: {line: 2383, column: 20},
					end: {line: 2386, column: 42}
				},
				_p386)('desugarEFun');
		} else {
			if (_p386._1.ctor === '[]') {
				return A2(
					_user$project$Lang$eFun,
					{
						ctor: '::',
						_0: _p386._0,
						_1: {ctor: '[]'}
					},
					e);
			} else {
				return A2(
					_user$project$Lang$eFun,
					{
						ctor: '::',
						_0: _p386._0,
						_1: {ctor: '[]'}
					},
					A2(_user$project$Lang$desugarEFun, _p386._1, e));
			}
		}
	});
var _user$project$Lang$EVar = F2(
	function (a, b) {
		return {ctor: 'EVar', _0: a, _1: b};
	});
var _user$project$Lang$eVar0 = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A2(_user$project$Lang$EVar, _user$project$Lang$space0, a));
};
var _user$project$Lang$eCall = F2(
	function (fName, es) {
		return A2(
			_user$project$Lang$eApp,
			_user$project$Lang$eVar0(fName),
			es);
	});
var _user$project$Lang$eRaw0 = _user$project$Lang$eVar0;
var _user$project$Lang$eVar = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A2(_user$project$Lang$EVar, _user$project$Lang$space1, a));
};
var _user$project$Lang$traceToExp = F2(
	function (locIdToExp, trace) {
		var _p388 = trace;
		if (_p388.ctor === 'TrLoc') {
			var _p390 = _p388._0._0;
			var _p389 = A2(_elm_lang$core$Dict$get, _p390, locIdToExp);
			if (_p389.ctor === 'Just') {
				return _p389._0;
			} else {
				return _user$project$Lang$eVar(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'couldNotFindLocId',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(_p390),
							'InLocIdToExpDict')));
			}
		} else {
			var childExps = A2(
				_elm_lang$core$List$map,
				_user$project$Lang$traceToExp(locIdToExp),
				_p388._1);
			return A2(_user$project$Lang$eOp, _p388._0, childExps);
		}
	});
var _user$project$Lang$eRaw = _user$project$Lang$eVar;
var _user$project$Lang$listOfVars = function (xs) {
	var _p391 = xs;
	if (_p391.ctor === '[]') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _user$project$Lang$eVar0(_p391._0),
			_1: A2(_elm_lang$core$List$map, _user$project$Lang$eVar, _p391._1)
		};
	}
};
var _user$project$Lang$listOfRaw = _user$project$Lang$listOfVars;
var _user$project$Lang$eVarAt = F2(
	function (pos, a) {
		return A3(
			_user$project$Info$withInfo,
			_user$project$Lang$exp_(
				A2(_user$project$Lang$EVar, _user$project$Lang$space1, a)),
			pos,
			_elm_lang$core$Native_Utils.update(
				pos,
				{
					col: pos.col + _elm_lang$core$String$length(a)
				}));
	});
var _user$project$Lang$eRaw__ = _user$project$Lang$EVar;
var _user$project$Lang$EBase = F2(
	function (a, b) {
		return {ctor: 'EBase', _0: a, _1: b};
	});
var _user$project$Lang$EConst = F4(
	function (a, b, c, d) {
		return {ctor: 'EConst', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$listOfAnnotatedNums1 = _elm_lang$core$List$map(
	function (_p392) {
		var _p393 = _p392;
		return _user$project$Lang$withDummyExpInfo(
			A4(
				_user$project$Lang$EConst,
				_user$project$Lang$space1,
				_p393._0,
				_user$project$Lang$dummyLoc_(_p393._1),
				_p393._2));
	});
var _user$project$Lang$listOfAnnotatedNums = function (list) {
	var _p394 = list;
	if (_p394.ctor === '[]') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _user$project$Lang$withDummyExpInfo(
				A4(
					_user$project$Lang$EConst,
					_user$project$Lang$space0,
					_p394._0._0,
					_user$project$Lang$dummyLoc_(_p394._0._1),
					_p394._0._2)),
			_1: _user$project$Lang$listOfAnnotatedNums1(_p394._1)
		};
	}
};
var _user$project$Lang$mapPrecedingWhitespaceWS = F2(
	function (mapWs, exp) {
		var e__New = function () {
			var _p395 = _user$project$Lang$unwrapExp(exp);
			switch (_p395.ctor) {
				case 'EBase':
					return A2(
						_user$project$Lang$EBase,
						mapWs(_p395._0),
						_p395._1);
				case 'EConst':
					return A4(
						_user$project$Lang$EConst,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3);
				case 'EVar':
					return A2(
						_user$project$Lang$EVar,
						mapWs(_p395._0),
						_p395._1);
				case 'EFun':
					return A4(
						_user$project$Lang$EFun,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3);
				case 'EApp':
					return A5(
						_user$project$Lang$EApp,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'EList':
					return A5(
						_user$project$Lang$EList,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'ERecord':
					return A4(
						_user$project$Lang$ERecord,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3);
				case 'ESelect':
					return A5(
						_user$project$Lang$ESelect,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'EOp':
					return A5(
						_user$project$Lang$EOp,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'EIf':
					return A7(
						_user$project$Lang$EIf,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4,
						_p395._5,
						_p395._6);
				case 'ELet':
					return A5(
						_user$project$Lang$ELet,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'ECase':
					return A4(
						_user$project$Lang$ECase,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3);
				case 'EColonType':
					return A5(
						_user$project$Lang$EColonType,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3,
						_p395._4);
				case 'EParens':
					return A4(
						_user$project$Lang$EParens,
						mapWs(_p395._0),
						_p395._1,
						_p395._2,
						_p395._3);
				default:
					return A2(
						_user$project$Lang$EHole,
						mapWs(_p395._0),
						_p395._1);
			}
		}();
		return A2(_user$project$Lang$replaceE__, exp, e__New);
	});
var _user$project$Lang$mapPrecedingWhitespace = F2(
	function (stringMap, exp) {
		var mapWs = function (s) {
			return _user$project$Lang$ws(
				stringMap(s.val));
		};
		return A2(_user$project$Lang$mapPrecedingWhitespaceWS, mapWs, exp);
	});
var _user$project$Lang$addPrecedingWhitespace = F2(
	function (newWs, exp) {
		return A2(
			_user$project$Lang$mapPrecedingWhitespace,
			function (oldWs) {
				return A2(_elm_lang$core$Basics_ops['++'], oldWs, newWs);
			},
			exp);
	});
var _user$project$Lang$replacePrecedingWhitespace = F2(
	function (newWs, exp) {
		return A2(
			_user$project$Lang$mapPrecedingWhitespace,
			function (_p396) {
				return newWs;
			},
			exp);
	});
var _user$project$Lang$replaceE__PreservingPrecedingWhitespace = F2(
	function (e, e__) {
		return A2(
			_user$project$Lang$replacePrecedingWhitespace,
			_user$project$Lang$precedingWhitespace(e),
			A2(_user$project$Lang$replaceE__, e, e__));
	});
var _user$project$Lang$copyPrecedingWhitespace = F2(
	function (source, target) {
		return A2(
			_user$project$Lang$replacePrecedingWhitespace,
			_user$project$Lang$precedingWhitespace(source),
			target);
	});
var _user$project$Lang$setExpListWhitespace = F3(
	function (firstWs, sepWs, exps) {
		var _p397 = exps;
		if (_p397.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: A2(_user$project$Lang$replacePrecedingWhitespace, firstWs, _p397._0),
				_1: A2(
					_elm_lang$core$List$map,
					_user$project$Lang$replacePrecedingWhitespace(sepWs),
					_p397._1)
			};
		}
	});
var _user$project$Lang$imitateExpListWhitespace_ = F3(
	function (oldExps, nextWs, newExps) {
		var _p398 = function () {
			var _p399 = oldExps;
			if (_p399.ctor === '::') {
				if (_p399._1.ctor === '::') {
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$precedingWhitespace(_p399._0),
						_1: _user$project$Lang$precedingWhitespace(_p399._1._0)
					};
				} else {
					var _p400 = _p399._0;
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$precedingWhitespace(_p400),
						_1: _elm_lang$core$Native_Utils.eq(
							_user$project$Lang$precedingWhitespace(_p400),
							'') ? ' ' : _user$project$Lang$precedingWhitespace(_p400)
					};
				}
			} else {
				return A2(_elm_lang$core$String$contains, '\n', nextWs) ? {
					ctor: '_Tuple2',
					_0: A2(_user$project$Lang$indent, '  ', nextWs),
					_1: A2(_user$project$Lang$indent, '  ', nextWs)
				} : {ctor: '_Tuple2', _0: '', _1: ' '};
			}
		}();
		var firstWs = _p398._0;
		var sepWs = _p398._1;
		var _p401 = newExps;
		if (_p401.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			var firstWithNewWs = A2(_user$project$Lang$replacePrecedingWhitespace, firstWs, _p401._0);
			var restWithNewWs = A2(
				_elm_lang$core$List$map,
				function (e) {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$precedingWhitespace(e),
						'') ? A2(_user$project$Lang$replacePrecedingWhitespace, sepWs, e) : (A2(_elm_lang$core$List$member, e, oldExps) ? e : A2(_user$project$Lang$replacePrecedingWhitespace, sepWs, e));
				},
				_p401._1);
			return {ctor: '::', _0: firstWithNewWs, _1: restWithNewWs};
		}
	});
var _user$project$Lang$imitateExpListWhitespace = F2(
	function (oldExps, newExps) {
		return A3(_user$project$Lang$imitateExpListWhitespace_, oldExps, '', newExps);
	});
var _user$project$Lang$ensureWhitespaceExp = function (exp) {
	return A2(_user$project$Lang$mapPrecedingWhitespace, _user$project$Lang$ensureWhitespace, exp);
};
var _user$project$Lang$ensureWhitespaceNNewlinesExp = F2(
	function (n, exp) {
		return A2(
			_user$project$Lang$mapPrecedingWhitespace,
			_user$project$Lang$ensureWhitespaceNNewlines(n),
			exp);
	});
var _user$project$Lang$ensureWhitespaceNewlineExp = function (exp) {
	return A2(_user$project$Lang$ensureWhitespaceNNewlinesExp, 1, exp);
};
var _user$project$Lang$ensureNNewlinesExp = F3(
	function (n, indentationIfNoPreviousNewlines, exp) {
		return A2(
			_user$project$Lang$mapPrecedingWhitespace,
			A2(_user$project$Lang$ensureNNewlines, n, indentationIfNoPreviousNewlines),
			exp);
	});
var _user$project$Lang$CustomSyntax = function (a) {
	return {ctor: 'CustomSyntax', _0: a};
};
var _user$project$Lang$HtmlSyntax = {ctor: 'HtmlSyntax'};
var _user$project$Lang$LeoSyntax = {ctor: 'LeoSyntax'};
var _user$project$Lang$LongStringSyntax = {ctor: 'LongStringSyntax'};
var _user$project$Lang$Parens = {ctor: 'Parens'};
var _user$project$Lang$ESnapHole = function (a) {
	return {ctor: 'ESnapHole', _0: a};
};
var _user$project$Lang$eSnapHoleVal0 = function (v) {
	return _user$project$Lang$withDummyExpInfo(
		A2(
			_user$project$Lang$EHole,
			_user$project$Lang$space0,
			_user$project$Lang$ESnapHole(v)));
};
var _user$project$Lang$eSnapHoleVal = function (v) {
	return _user$project$Lang$withDummyExpInfo(
		A2(
			_user$project$Lang$EHole,
			_user$project$Lang$space1,
			_user$project$Lang$ESnapHole(v)));
};
var _user$project$Lang$EEmptyHole = {ctor: 'EEmptyHole'};
var _user$project$Lang$eEmptyHoleVal0 = _user$project$Lang$withDummyExpInfo(
	A2(_user$project$Lang$EHole, _user$project$Lang$space0, _user$project$Lang$EEmptyHole));
var _user$project$Lang$eEmptyHoleVal = _user$project$Lang$withDummyExpInfo(
	A2(_user$project$Lang$EHole, _user$project$Lang$space1, _user$project$Lang$EEmptyHole));
var _user$project$Lang$TWildcard = function (a) {
	return {ctor: 'TWildcard', _0: a};
};
var _user$project$Lang$dummyType0 = _user$project$Lang$withDummyTypeInfo(
	_user$project$Lang$TWildcard(_user$project$Lang$space0));
var _user$project$Lang$dummyType = function (wsb) {
	return _user$project$Lang$withDummyTypeInfo(
		_user$project$Lang$TWildcard(wsb));
};
var _user$project$Lang$TParens = F3(
	function (a, b, c) {
		return {ctor: 'TParens', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$TForall = F4(
	function (a, b, c, d) {
		return {ctor: 'TForall', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$TVar = F2(
	function (a, b) {
		return {ctor: 'TVar', _0: a, _1: b};
	});
var _user$project$Lang$TApp = F4(
	function (a, b, c, d) {
		return {ctor: 'TApp', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$tApp = F4(
	function (a, b, c, d) {
		return _user$project$Lang$withDummyTypeInfo(
			A4(_user$project$Lang$TApp, a, b, c, d));
	});
var _user$project$Lang$TUnion = F3(
	function (a, b, c) {
		return {ctor: 'TUnion', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$TArrow = F3(
	function (a, b, c) {
		return {ctor: 'TArrow', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$TTuple = F5(
	function (a, b, c, d, e) {
		return {ctor: 'TTuple', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$TRecord = F4(
	function (a, b, c, d) {
		return {ctor: 'TRecord', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$TDict = F4(
	function (a, b, c, d) {
		return {ctor: 'TDict', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$TList = F3(
	function (a, b, c) {
		return {ctor: 'TList', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$mapFoldTypeTopDown = F3(
	function (f, initAcc, t) {
		var _p402 = A2(f, t, initAcc);
		var newT = _p402._0;
		var newAcc = _p402._1;
		var ret = F2(
			function (t__, acc) {
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Lang$replaceT__, newT, t__),
					_1: acc
				};
			});
		var recurse = F2(
			function (acc, child) {
				return A3(_user$project$Lang$mapFoldTypeTopDown, f, acc, child);
			});
		var recurseAll = F2(
			function (acc, typs) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (typ, _p403) {
							var _p404 = _p403;
							var _p405 = A2(recurse, _p404._1, typ);
							var newTyp = _p405._0;
							var newAcc = _p405._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p404._0,
									{
										ctor: '::',
										_0: newTyp,
										_1: {ctor: '[]'}
									}),
								_1: newAcc
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: acc
					},
					typs);
			});
		var _p406 = newT.val.t__;
		switch (_p406.ctor) {
			case 'TNum':
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
			case 'TBool':
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
			case 'TString':
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
			case 'TNull':
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
			case 'TList':
				var _p407 = A2(recurse, newAcc, _p406._1);
				var newTChild1 = _p407._0;
				var newAcc2 = _p407._1;
				return A2(
					ret,
					A3(_user$project$Lang$TList, _p406._0, newTChild1, _p406._2),
					newAcc2);
			case 'TDict':
				var _p408 = A2(recurse, newAcc, _p406._1);
				var newTChild1 = _p408._0;
				var newAcc2 = _p408._1;
				var _p409 = A2(recurse, newAcc2, _p406._2);
				var newTChild2 = _p409._0;
				var newAcc3 = _p409._1;
				return A2(
					ret,
					A4(_user$project$Lang$TDict, _p406._0, newTChild1, newTChild2, _p406._3),
					newAcc3);
			case 'TRecord':
				var _p411 = _p406._2;
				var _p410 = A2(
					recurseAll,
					newAcc,
					_user$project$Utils$recordValues(_p411));
				var newTsvalues = _p410._0;
				var newAcc2 = _p410._1;
				return A2(
					ret,
					A4(
						_user$project$Lang$TRecord,
						_p406._0,
						_p406._1,
						A2(_user$project$Utils$recordValuesMake, _p411, newTsvalues),
						_p406._3),
					newAcc2);
			case 'TTuple':
				if (_p406._3.ctor === 'Nothing') {
					var _p412 = A2(recurseAll, newAcc, _p406._1);
					var newTs = _p412._0;
					var newAcc2 = _p412._1;
					return A2(
						ret,
						A5(_user$project$Lang$TTuple, _p406._0, newTs, _p406._2, _elm_lang$core$Maybe$Nothing, _p406._4),
						newAcc2);
				} else {
					var _p413 = A2(recurseAll, newAcc, _p406._1);
					var newTs = _p413._0;
					var newAcc2 = _p413._1;
					var _p414 = A2(recurse, newAcc2, _p406._3._0);
					var newTTail = _p414._0;
					var newAcc3 = _p414._1;
					return A2(
						ret,
						A5(
							_user$project$Lang$TTuple,
							_p406._0,
							newTs,
							_p406._2,
							_elm_lang$core$Maybe$Just(newTTail),
							_p406._4),
						newAcc3);
				}
			case 'TArrow':
				var _p415 = A2(recurseAll, newAcc, _p406._1);
				var newTs = _p415._0;
				var newAcc2 = _p415._1;
				return A2(
					ret,
					A3(_user$project$Lang$TArrow, _p406._0, newTs, _p406._2),
					newAcc2);
			case 'TUnion':
				var _p416 = A2(recurseAll, newAcc, _p406._1);
				var newTs = _p416._0;
				var newAcc2 = _p416._1;
				return A2(
					ret,
					A3(_user$project$Lang$TUnion, _p406._0, newTs, _p406._2),
					newAcc2);
			case 'TApp':
				var _p417 = A2(recurse, newAcc, _p406._1);
				var newTChild1 = _p417._0;
				var newAcc2 = _p417._1;
				var _p418 = A2(recurseAll, newAcc2, _p406._2);
				var newTs = _p418._0;
				var newAcc3 = _p418._1;
				return A2(
					ret,
					A4(_user$project$Lang$TApp, _p406._0, newTChild1, newTs, _p406._3),
					newAcc3);
			case 'TVar':
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
			case 'TForall':
				var _p419 = A2(recurse, newAcc, _p406._2);
				var newTChild1 = _p419._0;
				var newAcc2 = _p419._1;
				return A2(
					ret,
					A4(_user$project$Lang$TForall, _p406._0, _p406._1, newTChild1, _p406._3),
					newAcc2);
			case 'TParens':
				var _p420 = A2(recurse, newAcc, _p406._1);
				var newTChild1 = _p420._0;
				var newAcc2 = _p420._1;
				return A2(
					ret,
					A3(_user$project$Lang$TParens, _p406._0, newTChild1, _p406._2),
					newAcc2);
			default:
				return {ctor: '_Tuple2', _0: newT, _1: newAcc};
		}
	});
var _user$project$Lang$mapType = F2(
	function (f, tipe) {
		var recurse = _user$project$Lang$mapType(f);
		var wrap = _user$project$Lang$replaceT__(tipe);
		var _p421 = tipe.val.t__;
		switch (_p421.ctor) {
			case 'TNum':
				return f(tipe);
			case 'TBool':
				return f(tipe);
			case 'TString':
				return f(tipe);
			case 'TNull':
				return f(tipe);
			case 'TVar':
				return f(tipe);
			case 'TWildcard':
				return f(tipe);
			case 'TList':
				return f(
					wrap(
						A3(
							_user$project$Lang$TList,
							_p421._0,
							recurse(_p421._1),
							_p421._2)));
			case 'TDict':
				return f(
					wrap(
						A4(
							_user$project$Lang$TDict,
							_p421._0,
							recurse(_p421._1),
							recurse(_p421._2),
							_p421._3)));
			case 'TArrow':
				return f(
					wrap(
						A3(
							_user$project$Lang$TArrow,
							_p421._0,
							A2(_elm_lang$core$List$map, recurse, _p421._1),
							_p421._2)));
			case 'TUnion':
				return f(
					wrap(
						A3(
							_user$project$Lang$TUnion,
							_p421._0,
							A2(_elm_lang$core$List$map, recurse, _p421._1),
							_p421._2)));
			case 'TApp':
				return f(
					wrap(
						A4(
							_user$project$Lang$TApp,
							_p421._0,
							recurse(_p421._1),
							A2(_elm_lang$core$List$map, recurse, _p421._2),
							_p421._3)));
			case 'TForall':
				return f(
					wrap(
						A4(
							_user$project$Lang$TForall,
							_p421._0,
							_p421._1,
							recurse(_p421._2),
							_p421._3)));
			case 'TTuple':
				return f(
					wrap(
						A5(
							_user$project$Lang$TTuple,
							_p421._0,
							A2(_elm_lang$core$List$map, recurse, _p421._1),
							_p421._2,
							A2(_elm_lang$core$Maybe$map, recurse, _p421._3),
							_p421._4)));
			case 'TRecord':
				return f(
					wrap(
						A4(
							_user$project$Lang$TRecord,
							_p421._0,
							_p421._1,
							A2(_user$project$Utils$recordValuesMap, recurse, _p421._2),
							_p421._3)));
			default:
				return f(
					wrap(
						A3(
							_user$project$Lang$TParens,
							_p421._0,
							recurse(_p421._1),
							_p421._2)));
		}
	});
var _user$project$Lang$TNull = function (a) {
	return {ctor: 'TNull', _0: a};
};
var _user$project$Lang$TString = function (a) {
	return {ctor: 'TString', _0: a};
};
var _user$project$Lang$TBool = function (a) {
	return {ctor: 'TBool', _0: a};
};
var _user$project$Lang$TNum = function (a) {
	return {ctor: 'TNum', _0: a};
};
var _user$project$Lang$mapPrecedingWhitespaceTypeWS = F2(
	function (f, tp) {
		var t__ = function () {
			var _p422 = tp.val.t__;
			switch (_p422.ctor) {
				case 'TNum':
					return _user$project$Lang$TNum(
						f(_p422._0));
				case 'TBool':
					return _user$project$Lang$TBool(
						f(_p422._0));
				case 'TString':
					return _user$project$Lang$TString(
						f(_p422._0));
				case 'TNull':
					return _user$project$Lang$TNull(
						f(_p422._0));
				case 'TList':
					return A3(
						_user$project$Lang$TList,
						f(_p422._0),
						_p422._1,
						_p422._2);
				case 'TDict':
					return A4(
						_user$project$Lang$TDict,
						f(_p422._0),
						_p422._1,
						_p422._2,
						_p422._3);
				case 'TTuple':
					return A5(
						_user$project$Lang$TTuple,
						f(_p422._0),
						_p422._1,
						_p422._2,
						_p422._3,
						_p422._4);
				case 'TRecord':
					return A4(
						_user$project$Lang$TRecord,
						f(_p422._0),
						_p422._1,
						_p422._2,
						_p422._3);
				case 'TArrow':
					return A3(
						_user$project$Lang$TArrow,
						f(_p422._0),
						_p422._1,
						_p422._2);
				case 'TUnion':
					return A3(
						_user$project$Lang$TUnion,
						f(_p422._0),
						_p422._1,
						_p422._2);
				case 'TApp':
					return A4(
						_user$project$Lang$TApp,
						f(_p422._0),
						_p422._1,
						_p422._2,
						_p422._3);
				case 'TVar':
					return A2(
						_user$project$Lang$TVar,
						f(_p422._0),
						_p422._1);
				case 'TForall':
					return A4(
						_user$project$Lang$TForall,
						f(_p422._0),
						_p422._1,
						_p422._2,
						_p422._3);
				case 'TWildcard':
					return _user$project$Lang$TWildcard(
						f(_p422._0));
				default:
					return A3(
						_user$project$Lang$TParens,
						f(_p422._0),
						_p422._1,
						_p422._2);
			}
		}();
		return A2(_user$project$Lang$replaceT__, tp, t__);
	});
var _user$project$Lang$mapPrecedingWhitespaceType = F2(
	function (stringMap, tpe) {
		var mapWs = function (s) {
			return _user$project$Lang$ws(
				stringMap(s.val));
		};
		return A2(_user$project$Lang$mapPrecedingWhitespaceTypeWS, mapWs, tpe);
	});
var _user$project$Lang$removeIndentationType = F2(
	function (smallestIndentation, tpe) {
		return A2(
			_user$project$Lang$mapType,
			_user$project$Lang$mapPrecedingWhitespaceType(
				_user$project$Lang$removeIndentation(smallestIndentation)),
			tpe);
	});
var _user$project$Lang$indentType = F2(
	function (spaces, t) {
		return A2(
			_user$project$Lang$mapType,
			_user$project$Lang$mapPrecedingWhitespaceTypeWS(
				_user$project$Lang$indentWs(spaces)),
			t);
	});
var _user$project$Lang$DeuceTypeInfo = function (a) {
	return {ctor: 'DeuceTypeInfo', _0: a};
};
var _user$project$Lang$HighlightWhenSelected = function (a) {
	return {ctor: 'HighlightWhenSelected', _0: a};
};
var _user$project$Lang$TPatVar = F2(
	function (a, b) {
		return {ctor: 'TPatVar', _0: a, _1: b};
	});
var _user$project$Lang$patToTPat = function (pat) {
	var _p423 = pat.val.p__;
	if (_p423.ctor === 'PVar') {
		return _elm_lang$core$Maybe$Just(
			A2(
				_user$project$Info$replaceInfo,
				pat,
				A2(_user$project$Lang$TPatVar, _p423._0, _p423._1)));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Lang$Branch_ = F4(
	function (a, b, c, d) {
		return {ctor: 'Branch_', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$mapFoldExpTopDownWithScope = F7(
	function (f, handleLetExp, handleEFun, handleCaseBranch, initGlobalAcc, initScopeTempAcc, e) {
		var _p424 = A3(f, e, initGlobalAcc, initScopeTempAcc);
		var newE = _p424._0;
		var newGlobalAcc = _p424._1;
		var newScopeTempAcc = _p424._2;
		var ret = F2(
			function (e__, globalAcc) {
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Lang$replaceE__, newE, e__),
					_1: globalAcc
				};
			});
		var recurse = F3(
			function (globalAcc, scopeTempAcc, child) {
				return A7(_user$project$Lang$mapFoldExpTopDownWithScope, f, handleLetExp, handleEFun, handleCaseBranch, globalAcc, scopeTempAcc, child);
			});
		var recurseAll = F3(
			function (globalAcc, scopeTempAcc, exps) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (exp, _p425) {
							var _p426 = _p425;
							var _p427 = A3(recurse, _p426._1, scopeTempAcc, exp);
							var newExp = _p427._0;
							var newGlobalAcc = _p427._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p426._0,
									{
										ctor: '::',
										_0: newExp,
										_1: {ctor: '[]'}
									}),
								_1: newGlobalAcc
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: globalAcc
					},
					exps);
			});
		var mapDeclarations = F3(
			function (globalAcc, scopeTempAcc, _p428) {
				var _p429 = _p428;
				var _p430 = A3(
					_user$project$Utils$foldLeft,
					{
						ctor: '_Tuple4',
						_0: _user$project$Lang$startBindingNumLetExp(_p429),
						_1: {ctor: '[]'},
						_2: globalAcc,
						_3: scopeTempAcc
					},
					_p429._3,
					F2(
						function (_p432, _p431) {
							var _p433 = _p432;
							var _p445 = _p433._0;
							var _p444 = _p433._3;
							var _p434 = _p431;
							var _p443 = _p434._1;
							var _p442 = _p434._0;
							var _p435 = A6(handleLetExp, newE, _p442, _p443, _p445, _p433._2, _p444);
							var updatedAccGlobal = _p435._0;
							var nextScope = _p435._1;
							var bindingScope = _p442 ? nextScope : _p444;
							var _p436 = A2(
								_elm_lang$core$Tuple$mapSecond,
								_elm_lang$core$List$reverse,
								A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: updatedAccGlobal,
										_1: {ctor: '[]'}
									},
									_p443,
									F2(
										function (_p438, _p437) {
											var _p439 = _p438;
											var _p440 = _p437;
											var _p441 = A3(recurse, _p439._0, bindingScope, _p440._5);
											var newE1 = _p441._0;
											var newAccGlobal = _p441._1;
											return {
												ctor: '_Tuple2',
												_0: newAccGlobal,
												_1: {
													ctor: '::',
													_0: A6(_user$project$Lang$LetExp, _p440._0, _p440._1, _p440._2, _p440._3, _p440._4, newE1),
													_1: _p439._1
												}
											};
										})));
							var finalAccGlobal = _p436._0;
							var newLetExps = _p436._1;
							return {
								ctor: '_Tuple4',
								_0: _p445 + _elm_lang$core$List$length(_p443),
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _p442, _1: newLetExps},
									_1: _p433._1
								},
								_2: finalAccGlobal,
								_3: nextScope
							};
						}));
				var newRevGroups = _p430._1;
				var newGlobalAcc = _p430._2;
				var newAccScope = _p430._3;
				return {
					ctor: '_Tuple3',
					_0: A4(
						_user$project$Lang$Declarations,
						_p429._0,
						_p429._1,
						_p429._2,
						_elm_lang$core$List$reverse(newRevGroups)),
					_1: newGlobalAcc,
					_2: newAccScope
				};
			});
		var _p446 = _user$project$Lang$unwrapExp(newE);
		switch (_p446.ctor) {
			case 'EConst':
				return {ctor: '_Tuple2', _0: newE, _1: newGlobalAcc};
			case 'EBase':
				return {ctor: '_Tuple2', _0: newE, _1: newGlobalAcc};
			case 'EVar':
				return {ctor: '_Tuple2', _0: newE, _1: newGlobalAcc};
			case 'EFun':
				var newScopeTempAcc2 = A2(handleEFun, newE, newScopeTempAcc);
				var _p447 = A3(recurse, newGlobalAcc, newScopeTempAcc2, _p446._2);
				var newE1 = _p447._0;
				var newGlobalAcc2 = _p447._1;
				return A2(
					ret,
					A4(_user$project$Lang$EFun, _p446._0, _p446._1, newE1, _p446._3),
					newGlobalAcc2);
			case 'EApp':
				var _p448 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1);
				var newE1 = _p448._0;
				var newGlobalAcc2 = _p448._1;
				var _p449 = A3(recurseAll, newGlobalAcc2, newScopeTempAcc, _p446._2);
				var newEs = _p449._0;
				var newGlobalAcc3 = _p449._1;
				return A2(
					ret,
					A5(_user$project$Lang$EApp, _p446._0, newE1, newEs, _p446._3, _p446._4),
					newGlobalAcc3);
			case 'EOp':
				var _p450 = A3(recurseAll, newGlobalAcc, newScopeTempAcc, _p446._3);
				var newEs = _p450._0;
				var newGlobalAcc2 = _p450._1;
				return A2(
					ret,
					A5(_user$project$Lang$EOp, _p446._0, _p446._1, _p446._2, newEs, _p446._4),
					newGlobalAcc2);
			case 'EList':
				if (_p446._3.ctor === 'Nothing') {
					var _p452 = _p446._1;
					var _p451 = A3(
						recurseAll,
						newGlobalAcc,
						newScopeTempAcc,
						_user$project$Utils$listValues(_p452));
					var newEs = _p451._0;
					var newGlobalAcc2 = _p451._1;
					return A2(
						ret,
						A5(
							_user$project$Lang$EList,
							_p446._0,
							A2(_user$project$Utils$listValuesMake, _p452, newEs),
							_p446._2,
							_elm_lang$core$Maybe$Nothing,
							_p446._4),
						newGlobalAcc2);
				} else {
					var _p455 = _p446._1;
					var _p453 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._3._0);
					var newE1 = _p453._0;
					var newGlobalAcc2 = _p453._1;
					var _p454 = A3(
						recurseAll,
						newGlobalAcc2,
						newScopeTempAcc,
						_user$project$Utils$listValues(_p455));
					var newEs = _p454._0;
					var newGlobalAcc3 = _p454._1;
					return A2(
						ret,
						A5(
							_user$project$Lang$EList,
							_p446._0,
							A2(_user$project$Utils$listValuesMake, _p455, newEs),
							_p446._2,
							_elm_lang$core$Maybe$Just(newE1),
							_p446._4),
						newGlobalAcc3);
				}
			case 'ERecord':
				if (_p446._1.ctor === 'Nothing') {
					var _p456 = A3(mapDeclarations, newGlobalAcc, newScopeTempAcc, _p446._2);
					var newDecls = _p456._0;
					var newGlobalAcc2 = _p456._1;
					return A2(
						ret,
						A4(_user$project$Lang$ERecord, _p446._0, _elm_lang$core$Maybe$Nothing, newDecls, _p446._3),
						newGlobalAcc2);
				} else {
					var _p457 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1._0._0);
					var newMi = _p457._0;
					var newGlobalAcc2 = _p457._1;
					var _p458 = A3(mapDeclarations, newGlobalAcc2, newScopeTempAcc, _p446._2);
					var newDecls = _p458._0;
					var newGlobalAcc3 = _p458._1;
					return A2(
						ret,
						A4(
							_user$project$Lang$ERecord,
							_p446._0,
							_elm_lang$core$Maybe$Just(
								{ctor: '_Tuple2', _0: newMi, _1: _p446._1._0._1}),
							newDecls,
							_p446._3),
						newGlobalAcc3);
				}
			case 'ESelect':
				var _p459 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1);
				var newE = _p459._0;
				var newGlobalAcc2 = _p459._1;
				return A2(
					ret,
					A5(_user$project$Lang$ESelect, _p446._0, newE, _p446._2, _p446._3, _p446._4),
					newGlobalAcc2);
			case 'EIf':
				var _p460 = A3(
					recurseAll,
					newGlobalAcc,
					newScopeTempAcc,
					{
						ctor: '::',
						_0: _p446._1,
						_1: {
							ctor: '::',
							_0: _p446._3,
							_1: {
								ctor: '::',
								_0: _p446._5,
								_1: {ctor: '[]'}
							}
						}
					});
				if (((((_p460.ctor === '_Tuple2') && (_p460._0.ctor === '::')) && (_p460._0._1.ctor === '::')) && (_p460._0._1._1.ctor === '::')) && (_p460._0._1._1._1.ctor === '[]')) {
					return A2(
						ret,
						A7(_user$project$Lang$EIf, _p446._0, _p460._0._0, _p446._2, _p460._0._1._0, _p446._4, _p460._0._1._1._0, _p446._6),
						_p460._1);
				} else {
					return _elm_lang$core$Native_Utils.crashCase(
						'Lang',
						{
							start: {line: 1404, column: 7},
							end: {line: 1406, column: 123}
						},
						_p460)('I\'ll buy you a beer if this line of code executes. - Brian');
				}
			case 'ECase':
				var _p462 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1);
				var newE1 = _p462._0;
				var newGlobalAcc2 = _p462._1;
				var _p463 = A3(
					_user$project$Utils$foldli1,
					F2(
						function (_p465, _p464) {
							var _p466 = _p465;
							var _p470 = _p466._1;
							var _p467 = _p464;
							var newScopeTempAcc2 = A4(handleCaseBranch, newE, _p470, _p466._0, newScopeTempAcc);
							var _p468 = _p470.val;
							var bws1 = _p468._0;
							var p = _p468._1;
							var ei = _p468._2;
							var bws2 = _p468._3;
							var _p469 = A3(recurse, _p467._1, newScopeTempAcc2, ei);
							var newEi = _p469._0;
							var newGlobalAcc3 = _p469._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p467._0,
									{
										ctor: '::',
										_0: _elm_lang$core$Native_Utils.update(
											_p470,
											{
												val: A4(_user$project$Lang$Branch_, bws1, p, newEi, bws2)
											}),
										_1: {ctor: '[]'}
									}),
								_1: newGlobalAcc3
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: newGlobalAcc2
					},
					_p446._2);
				var newBranches = _p463._0;
				var newGlobalAcc3 = _p463._1;
				return A2(
					ret,
					A4(_user$project$Lang$ECase, _p446._0, newE1, newBranches, _p446._3),
					newGlobalAcc3);
			case 'ELet':
				var _p471 = A3(mapDeclarations, newGlobalAcc, newScopeTempAcc, _p446._2);
				var newDecls = _p471._0;
				var newGlobalAcc2 = _p471._1;
				var newScopeAcc = _p471._2;
				var _p472 = A3(recurse, newGlobalAcc2, newScopeAcc, _p446._4);
				var newBody = _p472._0;
				var newGlobalAcc3 = _p472._1;
				return A2(
					ret,
					A5(_user$project$Lang$ELet, _p446._0, _p446._1, newDecls, _p446._3, newBody),
					newGlobalAcc3);
			case 'EColonType':
				var _p473 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1);
				var newE1 = _p473._0;
				var newGlobalAcc2 = _p473._1;
				return A2(
					ret,
					A5(_user$project$Lang$EColonType, _p446._0, newE1, _p446._2, _p446._3, _p446._4),
					newGlobalAcc2);
			case 'EParens':
				var _p474 = A3(recurse, newGlobalAcc, newScopeTempAcc, _p446._1);
				var newE1 = _p474._0;
				var newGlobalAcc2 = _p474._1;
				return A2(
					ret,
					A4(_user$project$Lang$EParens, _p446._0, newE1, _p446._2, _p446._3),
					newGlobalAcc2);
			default:
				return {ctor: '_Tuple2', _0: newE, _1: newGlobalAcc};
		}
	});
var _user$project$Lang$mapFoldExpTopDown = F3(
	function (f, initAcc, e) {
		return A7(
			_user$project$Lang$mapFoldExpTopDownWithScope,
			F3(
				function (e, a, b) {
					var _p475 = A2(f, e, a);
					var f1 = _p475._0;
					var f2 = _p475._1;
					return {ctor: '_Tuple3', _0: f1, _1: f2, _2: b};
				}),
			F6(
				function (e, r, g, bn, a, b) {
					return {ctor: '_Tuple2', _0: a, _1: b};
				}),
			F2(
				function (e, b) {
					return b;
				}),
			F4(
				function (e, br, i, b) {
					return b;
				}),
			initAcc,
			{ctor: '_Tuple0'},
			e);
	});
var _user$project$Lang$mapExpTopDown = F2(
	function (f, e) {
		var _p476 = A3(
			_user$project$Lang$mapFoldExpTopDown,
			F2(
				function (exp, _p477) {
					return {
						ctor: '_Tuple2',
						_0: f(exp),
						_1: {ctor: '_Tuple0'}
					};
				}),
			{ctor: '_Tuple0'},
			e);
		var newExp = _p476._0;
		return newExp;
	});
var _user$project$Lang$replaceExpNodes = F2(
	function (eidToNewNode, root) {
		return A2(
			_user$project$Lang$mapExpTopDown,
			function (exp) {
				var _p478 = A2(
					_elm_lang$core$Dict$get,
					_user$project$Lang$expEId(exp),
					eidToNewNode);
				if (_p478.ctor === 'Just') {
					return _p478._0;
				} else {
					return exp;
				}
			},
			root);
	});
var _user$project$Lang$replaceExpNodesPreservingPrecedingWhitespace = F2(
	function (eidToNewNode, root) {
		return A2(
			_user$project$Lang$mapExpTopDown,
			function (exp) {
				var _p479 = A2(
					_elm_lang$core$Dict$get,
					_user$project$Lang$expEId(exp),
					eidToNewNode);
				if (_p479.ctor === 'Just') {
					return A2(
						_user$project$Lang$replacePrecedingWhitespace,
						_user$project$Lang$precedingWhitespace(exp),
						_p479._0);
				} else {
					return exp;
				}
			},
			root);
	});
var _user$project$Lang$foldExpTopDownWithScope = F7(
	function (f, handleLetExps, handleEFun, handleCaseBranch, initGlobalAcc, initScopeTempAcc, e) {
		var _p480 = A7(
			_user$project$Lang$mapFoldExpTopDownWithScope,
			F3(
				function (e, globalAcc, scopeTempAcc) {
					return {
						ctor: '_Tuple3',
						_0: e,
						_1: A3(f, e, globalAcc, scopeTempAcc),
						_2: scopeTempAcc
					};
				}),
			handleLetExps,
			handleEFun,
			handleCaseBranch,
			initGlobalAcc,
			initScopeTempAcc,
			e);
		var finalGlobalAcc = _p480._1;
		return finalGlobalAcc;
	});
var _user$project$Lang$branchExpExtractor = function (branch) {
	var _p481 = branch.val;
	return {
		ctor: '_Tuple2',
		_0: _p481._2,
		_1: function (newExp) {
			return A2(
				_user$project$Lang$replaceB__,
				branch,
				A4(_user$project$Lang$Branch_, _p481._0, _p481._1, newExp, _p481._3));
		}
	};
};
var _user$project$Lang$branchExpsExtractor = function (branches) {
	return A2(
		_elm_lang$core$Tuple$mapSecond,
		F2(
			function (expsToBranch, newExps) {
				return A3(
					_elm_lang$core$List$map2,
					F2(
						function (toBranch, newExp) {
							return toBranch(newExp);
						}),
					expsToBranch,
					newExps);
			}),
		_elm_lang$core$List$unzip(
			A2(_elm_lang$core$List$map, _user$project$Lang$branchExpExtractor, branches)));
};
var _user$project$Lang$childExpsExtractors = function (e) {
	var _p482 = _user$project$Lang$unwrapExp(e);
	switch (_p482.ctor) {
		case 'EConst':
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: function (_p483) {
					return e;
				}
			};
		case 'EBase':
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: function (_p484) {
					return e;
				}
			};
		case 'EVar':
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: function (_p485) {
					return e;
				}
			};
		case 'EFun':
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '::',
					_0: _p482._2,
					_1: {ctor: '[]'}
				},
				_1: A3(
					_user$project$Lang$singleArgExtractor,
					'EFun-unexp',
					e,
					function (newE) {
						return A4(_user$project$Lang$EFun, _p482._0, _p482._1, newE, _p482._3);
					})
			};
		case 'EOp':
			return {
				ctor: '_Tuple2',
				_0: _p482._3,
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'EOp-unexp',
					e,
					function (newEs) {
						return A5(_user$project$Lang$EOp, _p482._0, _p482._1, _p482._2, newEs, _p482._4);
					})
			};
		case 'EList':
			var _p490 = _p482._4;
			var _p489 = _p482._2;
			var _p488 = _p482._0;
			var _p487 = _p482._1;
			var _p486 = _p482._3;
			if (_p486.ctor === 'Just') {
				return {
					ctor: '_Tuple2',
					_0: A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Utils$listValues(_p487),
						{
							ctor: '::',
							_0: _p486._0,
							_1: {ctor: '[]'}
						}),
					_1: A3(
						_user$project$Lang$multiArgExtractor,
						'EList-unexp',
						e,
						function (newEs) {
							return A5(
								_user$project$Lang$EList,
								_p488,
								A2(
									_user$project$Utils$listValuesMake,
									_p487,
									A2(_user$project$Utils$dropLast, 1, newEs)),
								_p489,
								_elm_lang$core$Maybe$Just(
									A2(_user$project$Utils$last, 'childExps-EList', newEs)),
								_p490);
						})
				};
			} else {
				return {
					ctor: '_Tuple2',
					_0: _user$project$Utils$listValues(_p487),
					_1: A3(
						_user$project$Lang$multiArgExtractor,
						'EList-unexp',
						e,
						function (newEs) {
							return A5(
								_user$project$Lang$EList,
								_p488,
								A2(_user$project$Utils$listValuesMake, _p487, newEs),
								_p489,
								_elm_lang$core$Maybe$Nothing,
								_p490);
						})
				};
			}
		case 'ERecord':
			var _p496 = _p482._3;
			var _p495 = _p482._0;
			var _p491 = _user$project$Lang$declExtractors(_p482._2);
			var declExps = _p491._0;
			var declRebuilder = _p491._1;
			var _p492 = _p482._1;
			if (_p492.ctor === 'Just') {
				return {
					ctor: '_Tuple2',
					_0: {ctor: '::', _0: _p492._0._0, _1: declExps},
					_1: A3(
						_user$project$Lang$multiArgExtractor,
						'ERecord-unexp',
						e,
						function (newExps) {
							var _p493 = newExps;
							if (_p493.ctor === '::') {
								var newDecls = declRebuilder(_p493._1);
								return A4(
									_user$project$Lang$ERecord,
									_p495,
									_elm_lang$core$Maybe$Just(
										{ctor: '_Tuple2', _0: _p493._0, _1: _p492._0._1}),
									newDecls,
									_p496);
							} else {
								return _elm_lang$core$Native_Utils.crashCase(
									'Lang',
									{
										start: {line: 1874, column: 14},
										end: {line: 1878, column: 98}
									},
									_p493)('[Internal Error] Unexpected rebuild of ERecord, missing fields');
							}
						})
				};
			} else {
				return {
					ctor: '_Tuple2',
					_0: declExps,
					_1: A3(
						_user$project$Lang$multiArgExtractor,
						'ERecord-unexp',
						e,
						function (newDefExps) {
							var newDecls = declRebuilder(newDefExps);
							return A4(_user$project$Lang$ERecord, _p495, _elm_lang$core$Maybe$Nothing, newDecls, _p496);
						})
				};
			}
		case 'ESelect':
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '::',
					_0: _p482._1,
					_1: {ctor: '[]'}
				},
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'ESelect-unexp',
					e,
					function (newEs) {
						return A5(
							_user$project$Lang$ESelect,
							_p482._0,
							A2(_user$project$Utils$head, 'childExps-ESelect', newEs),
							_p482._2,
							_p482._3,
							_p482._4);
					})
			};
		case 'EApp':
			return {
				ctor: '_Tuple2',
				_0: {ctor: '::', _0: _p482._1, _1: _p482._2},
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'EApp-unexp',
					e,
					function (newEs) {
						return A5(
							_user$project$Lang$EApp,
							_p482._0,
							A2(_user$project$Utils$head, 'childExps-EApp', newEs),
							A2(_user$project$Utils$tail, 'childExps-Eapp', newEs),
							_p482._3,
							_p482._4);
					})
			};
		case 'ELet':
			var _p497 = _user$project$Lang$declExtractors(_p482._2);
			var declExps = _p497._0;
			var declRebuilder = _p497._1;
			return {
				ctor: '_Tuple2',
				_0: A2(
					_elm_lang$core$Basics_ops['++'],
					declExps,
					{
						ctor: '::',
						_0: _p482._4,
						_1: {ctor: '[]'}
					}),
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'ELet-unexp',
					e,
					function (newExps) {
						var _p498 = _user$project$Utils$snocUnapply(newExps);
						if ((_p498.ctor === 'Just') && (_p498._0.ctor === '_Tuple2')) {
							var newDecls = declRebuilder(_p498._0._0);
							return A5(_user$project$Lang$ELet, _p482._0, _p482._1, newDecls, _p482._3, _p498._0._1);
						} else {
							return _elm_lang$core$Native_Utils.crashCase(
								'Lang',
								{
									start: {line: 1888, column: 9},
									end: {line: 1892, column: 99}
								},
								_p498)('Expected at least one expression for the body of ELet, got Nothing');
						}
					})
			};
		case 'EIf':
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '::',
					_0: _p482._1,
					_1: {
						ctor: '::',
						_0: _p482._3,
						_1: {
							ctor: '::',
							_0: _p482._5,
							_1: {ctor: '[]'}
						}
					}
				},
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'EIf-unexp',
					e,
					function (newEs) {
						var _p500 = newEs;
						if ((((_p500.ctor === '::') && (_p500._1.ctor === '::')) && (_p500._1._1.ctor === '::')) && (_p500._1._1._1.ctor === '[]')) {
							return A7(_user$project$Lang$EIf, _p482._0, _p500._0, _p482._2, _p500._1._0, _p482._4, _p500._1._1._0, _p482._6);
						} else {
							return _elm_lang$core$Native_Utils.crashCase(
								'Lang',
								{
									start: {line: 1894, column: 101},
									end: {line: 1896, column: 41}
								},
								_p500)('childExps-EIf');
						}
					})
			};
		case 'ECase':
			var _p502 = _user$project$Lang$branchExpsExtractor(_p482._2);
			var es = _p502._0;
			var esExtractor = _p502._1;
			return {
				ctor: '_Tuple2',
				_0: {ctor: '::', _0: _p482._1, _1: es},
				_1: A3(
					_user$project$Lang$multiArgExtractor,
					'ECase-unexp',
					e,
					function (newEs) {
						return A4(
							_user$project$Lang$ECase,
							_p482._0,
							A2(_user$project$Utils$head, 'childExps-ECase', newEs),
							esExtractor(
								A2(_user$project$Utils$tail, 'childExps-ECAse', newEs)),
							_p482._3);
					})
			};
		case 'EColonType':
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '::',
					_0: _p482._1,
					_1: {ctor: '[]'}
				},
				_1: A3(
					_user$project$Lang$singleArgExtractor,
					'EColonType-unexp',
					e,
					function (newE) {
						return A5(_user$project$Lang$EColonType, _p482._0, newE, _p482._2, _p482._3, _p482._4);
					})
			};
		case 'EParens':
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '::',
					_0: _p482._1,
					_1: {ctor: '[]'}
				},
				_1: A3(
					_user$project$Lang$singleArgExtractor,
					'EParens-unexp',
					e,
					function (newE) {
						return A4(_user$project$Lang$EParens, _p482._0, newE, _p482._2, _p482._3);
					})
			};
		default:
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: function (_p503) {
					return e;
				}
			};
	}
};
var _user$project$Lang$mapFoldExp = F3(
	function (f, initAcc, e) {
		var _p504 = _user$project$Lang$childExpsExtractors(e);
		var children = _p504._0;
		var rebuilder = _p504._1;
		var _p505 = A3(
			_user$project$Utils$foldLeft,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: initAcc
			},
			_elm_lang$core$List$reverse(children),
			F2(
				function (_p506, child) {
					var _p507 = _p506;
					var _p508 = A3(_user$project$Lang$mapFoldExp, f, _p507._1, child);
					var newChild = _p508._0;
					var newAcc = _p508._1;
					return {
						ctor: '_Tuple2',
						_0: {ctor: '::', _0: newChild, _1: _p507._0},
						_1: newAcc
					};
				}));
		var newChildren = _p505._0;
		var accAfterChildren = _p505._1;
		var newE = rebuilder(newChildren);
		return A2(f, newE, accAfterChildren);
	});
var _user$project$Lang$mapExp = F2(
	function (f, e) {
		var _p509 = A3(
			_user$project$Lang$mapFoldExp,
			F2(
				function (exp, _p510) {
					return {
						ctor: '_Tuple2',
						_0: f(exp),
						_1: {ctor: '_Tuple0'}
					};
				}),
			{ctor: '_Tuple0'},
			e);
		var newExp = _p509._0;
		return newExp;
	});
var _user$project$Lang$mapExpViaExp__ = F2(
	function (f, e) {
		var f_ = function (exp) {
			return A2(
				_user$project$Lang$replaceE__,
				exp,
				f(
					_user$project$Lang$unwrapExp(exp)));
		};
		return A2(_user$project$Lang$mapExp, f_, e);
	});
var _user$project$Lang$mapExpNode = F3(
	function (eid, f, root) {
		return A2(
			_user$project$Lang$mapExp,
			function (exp) {
				return _elm_lang$core$Native_Utils.eq(
					_user$project$Lang$expEId(exp),
					eid) ? f(exp) : exp;
			},
			root);
	});
var _user$project$Lang$replaceExpNode = F3(
	function (eid, newNode, root) {
		return A3(
			_user$project$Lang$mapExpNode,
			eid,
			_elm_lang$core$Basics$always(newNode),
			root);
	});
var _user$project$Lang$replaceExpNodePreservingPrecedingWhitespace = F3(
	function (eid, newNode, root) {
		return A3(
			_user$project$Lang$mapExpNode,
			eid,
			function (exp) {
				return A2(
					_user$project$Lang$replacePrecedingWhitespace,
					_user$project$Lang$precedingWhitespace(exp),
					newNode);
			},
			root);
	});
var _user$project$Lang$applySubst = F2(
	function (subst, exp) {
		var replacer = function (e) {
			var e__ConstReplaced = function () {
				var e__ = _user$project$Lang$unwrapExp(e);
				var _p511 = e__;
				if (_p511.ctor === 'EConst') {
					var _p513 = _p511._2;
					var locId = _user$project$Utils$fst3(_p513);
					var _p512 = A2(_elm_lang$core$Dict$get, locId, subst.lsubst);
					if (_p512.ctor === 'Just') {
						return A4(_user$project$Lang$EConst, _p511._0, _p512._0, _p513, _p511._3);
					} else {
						return e__;
					}
				} else {
					return e__;
				}
			}();
			var e__New = function () {
				var _p514 = A2(
					_elm_lang$core$Dict$get,
					_user$project$Lang$expEId(e),
					subst.esubst);
				if (_p514.ctor === 'Just') {
					return _p514._0;
				} else {
					return e__ConstReplaced;
				}
			}();
			return A2(_user$project$Lang$replaceE__, e, e__New);
		};
		return A2(_user$project$Lang$mapExp, replacer, exp);
	});
var _user$project$Lang$applyLocSubst = function (s) {
	return _user$project$Lang$applySubst(
		{lsubst: s, esubst: _elm_lang$core$Dict$empty});
};
var _user$project$Lang$applyESubst = function (s) {
	return _user$project$Lang$applySubst(
		{lsubst: _elm_lang$core$Dict$empty, esubst: s});
};
var _user$project$Lang$replaceExpNodeE__ByEId = F3(
	function (eid, newE__, root) {
		var esubst = A2(_elm_lang$core$Dict$singleton, eid, newE__);
		return A2(_user$project$Lang$applyESubst, esubst, root);
	});
var _user$project$Lang$replaceExpNodeE__ = F3(
	function (oldNode, newE__, root) {
		return A3(
			_user$project$Lang$replaceExpNodeE__ByEId,
			_user$project$Lang$expEId(oldNode),
			newE__,
			root);
	});
var _user$project$Lang$applyESubstPreservingPrecedingWhitespace = F2(
	function (esubst, exp) {
		var replacer = function (e) {
			var _p515 = A2(
				_elm_lang$core$Dict$get,
				_user$project$Lang$expEId(e),
				esubst);
			if (_p515.ctor === 'Just') {
				return A2(_user$project$Lang$replaceE__PreservingPrecedingWhitespace, e, _p515._0);
			} else {
				return e;
			}
		};
		return A2(_user$project$Lang$mapExp, replacer, exp);
	});
var _user$project$Lang$applyIndentationDelta = F2(
	function (delta, exp) {
		var processWS = function (ws) {
			return A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$AtMost(1),
				_elm_lang$core$Regex$regex('\n[ \t]*$'),
				function (match) {
					var priorSpacesCount = _elm_lang$core$String$length(
						_user$project$Lang$tabsToSpaces(
							A2(_elm_lang$core$String$dropLeft, 1, match.match)));
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(_elm_lang$core$String$repeat, priorSpacesCount + delta, ' '));
				},
				ws);
		};
		return A2(
			_user$project$Lang$mapExp,
			_user$project$Lang$mapPrecedingWhitespace(processWS),
			exp);
	});
var _user$project$Lang$copyIndentationChange = F3(
	function (exp1, exp2, exp) {
		var delta = _elm_lang$core$String$length(
			_user$project$Lang$tabsToSpaces(
				_user$project$Lang$indentationOf(exp2))) - _elm_lang$core$String$length(
			_user$project$Lang$tabsToSpaces(
				_user$project$Lang$indentationOf(exp1)));
		return A2(_user$project$Lang$applyIndentationDelta, delta, exp);
	});
var _user$project$Lang$removeTabs = _user$project$Lang$mapExp(
	_user$project$Lang$mapPrecedingWhitespace(_user$project$Lang$tabsToSpaces));
var _user$project$Lang$removeIndentationExp = F2(
	function (smallestIndentation, exp) {
		return A2(
			_user$project$Lang$mapExp,
			_user$project$Lang$mapPrecedingWhitespace(
				_user$project$Lang$removeIndentation(smallestIndentation)),
			exp);
	});
var _user$project$Lang$removeIndentationDeclaration = F2(
	function (si, decl) {
		var _p516 = decl;
		switch (_p516.ctor) {
			case 'DeclExp':
				return _user$project$Lang$DeclExp(
					A6(
						_user$project$Lang$LetExp,
						A2(_user$project$Lang$removeIndentationMaybeWS, si, _p516._0._0),
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._1),
						_p516._0._2,
						_p516._0._3,
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._4),
						A2(_user$project$Lang$removeIndentationExp, si, _p516._0._5)));
			case 'DeclAnnotation':
				return _user$project$Lang$DeclAnnotation(
					A6(
						_user$project$Lang$LetAnnotation,
						A2(_user$project$Lang$removeIndentationMaybeWS, si, _p516._0._0),
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._1),
						_p516._0._2,
						_p516._0._3,
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._4),
						A2(_user$project$Lang$removeIndentationType, si, _p516._0._5)));
			default:
				return _user$project$Lang$DeclType(
					A7(
						_user$project$Lang$LetType,
						A2(_user$project$Lang$removeIndentationMaybeWS, si, _p516._0._0),
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._1),
						A2(_user$project$Lang$removeIndentationMaybeWS, si, _p516._0._2),
						_p516._0._3,
						_p516._0._4,
						A2(_user$project$Lang$removeIndentationWS, si, _p516._0._5),
						A2(_user$project$Lang$removeIndentationType, si, _p516._0._6)));
		}
	});
var _user$project$Lang$indentExp = F2(
	function (spaces, e) {
		return A2(
			_user$project$Lang$mapExp,
			_user$project$Lang$mapPrecedingWhitespaceWS(
				_user$project$Lang$indentWs(spaces)),
			e);
	});
var _user$project$Lang$indentDeclaration = F2(
	function (spaces, decl) {
		var _p517 = decl;
		switch (_p517.ctor) {
			case 'DeclExp':
				return _user$project$Lang$DeclExp(
					A6(
						_user$project$Lang$LetExp,
						A2(_user$project$Lang$indentMaybeWS, spaces, _p517._0._0),
						A2(_user$project$Lang$indentWs, spaces, _p517._0._1),
						_p517._0._2,
						_p517._0._3,
						A2(_user$project$Lang$indentWs, spaces, _p517._0._4),
						A2(_user$project$Lang$indentExp, spaces, _p517._0._5)));
			case 'DeclAnnotation':
				return _user$project$Lang$DeclAnnotation(
					A6(
						_user$project$Lang$LetAnnotation,
						A2(_user$project$Lang$indentMaybeWS, spaces, _p517._0._0),
						A2(_user$project$Lang$indentWs, spaces, _p517._0._1),
						_p517._0._2,
						_p517._0._3,
						A2(_user$project$Lang$indentWs, spaces, _p517._0._4),
						A2(_user$project$Lang$indentType, spaces, _p517._0._5)));
			default:
				return _user$project$Lang$DeclType(
					A7(
						_user$project$Lang$LetType,
						A2(_user$project$Lang$indentMaybeWS, spaces, _p517._0._0),
						A2(_user$project$Lang$indentWs, spaces, _p517._0._1),
						A2(_user$project$Lang$indentMaybeWS, spaces, _p517._0._2),
						_p517._0._3,
						_p517._0._4,
						A2(_user$project$Lang$indentWs, spaces, _p517._0._5),
						A2(_user$project$Lang$indentType, spaces, _p517._0._6)));
		}
	});
var _user$project$Lang$pushRight = F2(
	function (spaces, e) {
		return A2(
			_user$project$Lang$replacePrecedingWhitespace,
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$precedingWhitespace(e),
				spaces),
			A2(_user$project$Lang$indentExp, spaces, e));
	});
var _user$project$Lang$childExps = function (e) {
	return _elm_lang$core$Tuple$first(
		_user$project$Lang$childExpsExtractors(e));
};
var _user$project$Lang$flattenExpTree = function (exp) {
	return {
		ctor: '::',
		_0: exp,
		_1: A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$flattenExpTree,
			_user$project$Lang$childExps(exp))
	};
};
var _user$project$Lang$foldExp = F3(
	function (f, acc, exp) {
		return A3(
			_elm_lang$core$List$foldl,
			f,
			acc,
			_user$project$Lang$flattenExpTree(exp));
	});
var _user$project$Lang$foldExpViaE__ = F3(
	function (f, acc, exp) {
		var f_ = function (exp) {
			return f(
				_user$project$Lang$unwrapExp(exp));
		};
		return A3(_user$project$Lang$foldExp, f_, acc, exp);
	});
var _user$project$Lang$minIndentationExp = F2(
	function (prevMinIndent, exp) {
		return A3(
			_user$project$Lang$foldExpViaE__,
			F2(
				function (e__, smallest) {
					return A2(
						_user$project$Lang$minIndentation,
						smallest,
						_user$project$Lang$precedingWhitespaceExp__(e__));
				}),
			prevMinIndent,
			exp);
	});
var _user$project$Lang$minIndentationDeclaration = F2(
	function (prevMinIndent, decl) {
		var newPrevMinIndent = A2(
			_user$project$Lang$minIndentation,
			prevMinIndent,
			function (_) {
				return _.val;
			}(
				_user$project$Lang$precedingWhitespaceDeclarationWithInfo(decl)));
		var _p518 = decl;
		switch (_p518.ctor) {
			case 'DeclExp':
				return A2(
					_user$project$Lang$minIndentationExp,
					A2(
						_user$project$Lang$minIndentationListMaybeWS,
						newPrevMinIndent,
						{
							ctor: '::',
							_0: _p518._0._0,
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Maybe$Just(_p518._0._1),
								_1: {
									ctor: '::',
									_0: _elm_lang$core$Maybe$Just(_p518._0._4),
									_1: {ctor: '[]'}
								}
							}
						}),
					_p518._0._5);
			case 'DeclAnnotation':
				return A2(
					_user$project$Lang$minIndentationType,
					A2(
						_user$project$Lang$minIndentationListMaybeWS,
						newPrevMinIndent,
						{
							ctor: '::',
							_0: _p518._0._0,
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Maybe$Just(_p518._0._1),
								_1: {
									ctor: '::',
									_0: _elm_lang$core$Maybe$Just(_p518._0._4),
									_1: {ctor: '[]'}
								}
							}
						}),
					_p518._0._5);
			default:
				return A2(
					_user$project$Lang$minIndentationType,
					A2(
						_user$project$Lang$minIndentationListMaybeWS,
						newPrevMinIndent,
						{
							ctor: '::',
							_0: _p518._0._0,
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Maybe$Just(_p518._0._1),
								_1: {
									ctor: '::',
									_0: _p518._0._2,
									_1: {
										ctor: '::',
										_0: _elm_lang$core$Maybe$Just(_p518._0._5),
										_1: {ctor: '[]'}
									}
								}
							}
						}),
					_p518._0._6);
		}
	});
var _user$project$Lang$unindentDeclaration = function (decl) {
	var _p519 = A2(_user$project$Lang$minIndentationDeclaration, _elm_lang$core$Maybe$Nothing, decl);
	if (_p519.ctor === 'Nothing') {
		return decl;
	} else {
		return A2(_user$project$Lang$removeIndentationDeclaration, _p519._0, decl);
	}
};
var _user$project$Lang$replaceIndentationDeclaration = F2(
	function (spaces, decl) {
		return A2(
			_user$project$Lang$indentDeclaration,
			spaces,
			_user$project$Lang$unindentDeclaration(decl));
	});
var _user$project$Lang$unindent = function (exp) {
	var expWsAsSpaces = _user$project$Lang$removeTabs(exp);
	var _p520 = A2(_user$project$Lang$minIndentationExp, _elm_lang$core$Maybe$Nothing, expWsAsSpaces);
	if (_p520.ctor === 'Nothing') {
		return exp;
	} else {
		return A2(_user$project$Lang$removeIndentationExp, _p520._0, expWsAsSpaces);
	}
};
var _user$project$Lang$replaceIndentation = F2(
	function (spaces, exp) {
		return A2(
			_user$project$Lang$indentExp,
			spaces,
			_user$project$Lang$unindent(exp));
	});
var _user$project$Lang$ensureWhitespaceSmartExp = F3(
	function (newlineCountIfMultiline, indentationIfMultiline, exp) {
		return (_user$project$Lang$isLet(exp) || _user$project$Lang$expHasNewlines(exp)) ? A2(
			_user$project$Lang$replaceIndentation,
			indentationIfMultiline,
			A2(_user$project$Lang$ensureWhitespaceNNewlinesExp, newlineCountIfMultiline, exp)) : _user$project$Lang$ensureWhitespaceExp(exp);
	});
var _user$project$Lang$identifiersList = function (exp) {
	var folder = F2(
		function (e__, acc) {
			var _p521 = e__;
			switch (_p521.ctor) {
				case 'EVar':
					return {ctor: '::', _0: _p521._1, _1: acc};
				case 'EFun':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, _p521._1),
						acc);
				case 'ECase':
					var pats = _user$project$Lang$branchPats(_p521._2);
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, pats),
						acc);
				case 'ELet':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$List$concatMap,
							function (def) {
								var _p522 = def;
								switch (_p522.ctor) {
									case 'DeclExp':
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$identifiersListInPat(_p522._0._2),
											acc);
									case 'DeclType':
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$identifiersListInPat(_p522._0._3),
											acc);
									default:
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$identifiersListInPat(_p522._0._2),
											acc);
								}
							},
							_user$project$Lang$getDeclarations(_p521._2)),
						acc);
				default:
					return acc;
			}
		});
	return A3(
		_user$project$Lang$foldExpViaE__,
		folder,
		{ctor: '[]'},
		exp);
};
var _user$project$Lang$identifiersSet = function (exp) {
	return _elm_lang$core$Set$fromList(
		_user$project$Lang$identifiersList(exp));
};
var _user$project$Lang$allEIds = function (exp) {
	return A2(
		_elm_lang$core$List$map,
		_user$project$Lang$expEId,
		_user$project$Lang$flattenExpTree(exp));
};
var _user$project$Lang$computePatMap = function (_p523) {
	return _elm_lang$core$Dict$fromList(
		A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$taggedExpPats,
			_user$project$Lang$flattenExpTree(_p523)));
};
var _user$project$Lang$findFirstNode = F2(
	function (predicate, exp) {
		return predicate(exp) ? _elm_lang$core$Maybe$Just(exp) : A2(
			_user$project$Utils$mapFirstSuccess,
			_user$project$Lang$findFirstNode(predicate),
			_user$project$Lang$childExps(exp));
	});
var _user$project$Lang$findExpByEId = F2(
	function (program, targetEId) {
		return A2(
			_user$project$Lang$findFirstNode,
			_user$project$Lang$eidIs(targetEId),
			program);
	});
var _user$project$Lang$findExpByLocId = F2(
	function (program, targetLocId) {
		var isTarget = function (exp) {
			var _p524 = _user$project$Lang$unwrapExp(exp);
			if ((_p524.ctor === 'EConst') && (_p524._2.ctor === '_Tuple3')) {
				return _elm_lang$core$Native_Utils.eq(_p524._2._0, targetLocId);
			} else {
				return false;
			}
		};
		return A2(_user$project$Lang$findFirstNode, isTarget, program);
	});
var _user$project$Lang$locIdToEId = F2(
	function (program, locId) {
		return A2(
			_elm_lang$core$Maybe$map,
			_user$project$Lang$expEId,
			A2(_user$project$Lang$findExpByLocId, program, locId));
	});
var _user$project$Lang$mapFirstSuccessNode = F2(
	function (f, exp) {
		var _p525 = f(exp);
		if (_p525.ctor === 'Just') {
			return _elm_lang$core$Maybe$Just(_p525._0);
		} else {
			return A2(
				_user$project$Utils$mapFirstSuccess,
				_user$project$Lang$mapFirstSuccessNode(f),
				_user$project$Lang$childExps(exp));
		}
	});
var _user$project$Lang$findScopeExpAndPatByPId = F2(
	function (program, targetPId) {
		return A2(
			_user$project$Lang$mapFirstSuccessNode,
			function (e) {
				var maybeTargetPat = function () {
					var _p526 = _user$project$Lang$unwrapExp(e);
					switch (_p526.ctor) {
						case 'ELet':
							return A2(
								_user$project$Utils$mapFirstSuccess,
								function (_p527) {
									var _p528 = _p527;
									var _p530 = _p528._1;
									var _p529 = _p528._0;
									switch (_p529.ctor) {
										case 'DeclExp':
											return A2(
												_elm_lang$core$Maybe$map,
												F2(
													function (v0, v1) {
														return {ctor: '_Tuple2', _0: v0, _1: v1};
													})(_p530),
												A2(_user$project$Lang$findPatInPat, targetPId, _p529._0._2));
										case 'DeclType':
											return A2(
												_elm_lang$core$Maybe$map,
												F2(
													function (v0, v1) {
														return {ctor: '_Tuple2', _0: v0, _1: v1};
													})(_p530),
												A2(_user$project$Lang$findPatInPat, targetPId, _p529._0._3));
										default:
											return A2(
												_elm_lang$core$Maybe$map,
												F2(
													function (v0, v1) {
														return {ctor: '_Tuple2', _0: v0, _1: v1};
													})(_p530),
												A2(_user$project$Lang$findPatInPat, targetPId, _p529._0._2));
									}
								},
								_user$project$Lang$getDeclarationsInOrderWithIndex(_p526._2));
						case 'EFun':
							return A2(
								_user$project$Utils$mapFirstSuccess,
								function (_p531) {
									var _p532 = _p531;
									return A2(
										_elm_lang$core$Maybe$map,
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})(_p532._1),
										A2(_user$project$Lang$findPatInPat, targetPId, _p532._0));
								},
								_user$project$Utils$zipWithIndex(_p526._1));
						case 'ECase':
							return A2(
								_user$project$Utils$mapFirstSuccess,
								function (_p533) {
									var _p534 = _p533;
									return A2(
										_elm_lang$core$Maybe$map,
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})(_p534._1),
										A2(_user$project$Lang$findPatInPat, targetPId, _p534._0));
								},
								_user$project$Utils$zipWithIndex(
									_user$project$Lang$branchPats(_p526._2)));
						default:
							return _elm_lang$core$Maybe$Nothing;
					}
				}();
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p535) {
						var _p536 = _p535;
						return {
							ctor: '_Tuple2',
							_0: {ctor: '_Tuple2', _0: e, _1: _p536._0},
							_1: _p536._1
						};
					},
					maybeTargetPat);
			},
			program);
	});
var _user$project$Lang$findPatByPId = F2(
	function (program, targetPId) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p537) {
				var _p538 = _p537;
				return _p538._1;
			},
			A2(_user$project$Lang$findScopeExpAndPatByPId, program, targetPId));
	});
var _user$project$Lang$pidToPathedPatternId = F2(
	function (program, pid) {
		return A2(
			_user$project$Lang$mapFirstSuccessNode,
			function (_p539) {
				return A2(
					_user$project$Utils$maybeFind,
					pid,
					_user$project$Lang$taggedExpPats(_p539));
			},
			program);
	});
var _user$project$Lang$findAllWithAncestors_ = F3(
	function (predicate, ancestors, exp) {
		var ancestorsAndThis = A2(
			_elm_lang$core$Basics_ops['++'],
			ancestors,
			{
				ctor: '::',
				_0: exp,
				_1: {ctor: '[]'}
			});
		var thisResult = predicate(exp) ? {
			ctor: '::',
			_0: ancestorsAndThis,
			_1: {ctor: '[]'}
		} : {ctor: '[]'};
		var recurse = function (exp) {
			return A3(_user$project$Lang$findAllWithAncestors_, predicate, ancestorsAndThis, exp);
		};
		return A2(
			_elm_lang$core$Basics_ops['++'],
			thisResult,
			A2(
				_elm_lang$core$List$concatMap,
				recurse,
				_user$project$Lang$childExps(exp)));
	});
var _user$project$Lang$findAllWithAncestors = F2(
	function (predicate, exp) {
		return A3(
			_user$project$Lang$findAllWithAncestors_,
			predicate,
			{ctor: '[]'},
			exp);
	});
var _user$project$Lang$commonAncestors = F2(
	function (pred, exp) {
		return _user$project$Utils$commonPrefix(
			A2(
				_elm_lang$core$List$map,
				_user$project$Utils$dropLast(1),
				A2(_user$project$Lang$findAllWithAncestors, pred, exp)));
	});
var _user$project$Lang$findWithAncestorsByEId = F2(
	function (exp, targetEId) {
		return _elm_lang$core$Native_Utils.eq(
			_user$project$Lang$expEId(exp),
			targetEId) ? _elm_lang$core$Maybe$Just(
			{
				ctor: '::',
				_0: exp,
				_1: {ctor: '[]'}
			}) : A2(
			_elm_lang$core$Maybe$map,
			function (descendents) {
				return {ctor: '::', _0: exp, _1: descendents};
			},
			A2(
				_user$project$Utils$mapFirstSuccess,
				function (child) {
					return A2(_user$project$Lang$findWithAncestorsByEId, child, targetEId);
				},
				_user$project$Lang$childExps(exp)));
	});
var _user$project$Lang$parentByEId = F2(
	function (program, targetEId) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p540) {
				return _elm_lang$core$List$head(
					A2(
						_user$project$Utils$dropLast,
						1,
						A2(_user$project$Utils$takeLast, 2, _p540)));
			},
			A2(_user$project$Lang$findWithAncestorsByEId, program, targetEId));
	});
var _user$project$Lang$indentationAt = F2(
	function (eid, program) {
		var _p541 = A2(_user$project$Lang$findWithAncestorsByEId, program, eid);
		if (_p541.ctor === 'Just') {
			return A2(
				_elm_lang$core$Maybe$withDefault,
				'',
				A2(
					_user$project$Utils$mapFirstSuccess,
					function (ws) {
						return A2(_elm_lang$core$String$contains, '\n', ws) ? _elm_lang$core$Maybe$Just(
							_user$project$Lang$extractIndentation(ws)) : _elm_lang$core$Maybe$Nothing;
					},
					A2(
						_elm_lang$core$List$map,
						_user$project$Lang$precedingWhitespace,
						_elm_lang$core$List$reverse(_p541._0))));
		} else {
			return '';
		}
	});
var _user$project$Lang$visibleIdents = F2(
	function (root, e) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (eWithAncestors) {
				var eAndAncestorEIds = _elm_lang$core$Set$fromList(
					A2(_elm_lang$core$List$map, _user$project$Lang$expEId, eWithAncestors));
				return A2(
					_elm_lang$core$List$concatMap,
					function (ancestor) {
						var _p542 = _user$project$Lang$unwrapExp(ancestor);
						switch (_p542.ctor) {
							case 'EFun':
								return _user$project$Lang$identifiersListInPats(_p542._1);
							case 'ECase':
								var mbAncestorBranch = A2(
									_user$project$Utils$findFirst,
									function (branch) {
										return A2(
											_elm_lang$core$Set$member,
											_user$project$Lang$expEId(
												_user$project$Lang$branchExp(branch)),
											eAndAncestorEIds);
									},
									_p542._2);
								var _p543 = mbAncestorBranch;
								if (_p543.ctor === 'Nothing') {
									return {ctor: '[]'};
								} else {
									return _user$project$Lang$identifiersListInPat(
										_user$project$Lang$branchPat(_p543._0));
								}
							case 'ELet':
								var accumulate = function (remainingGroupedExps) {
									var _p544 = remainingGroupedExps;
									if (_p544.ctor === '[]') {
										return {ctor: '[]'};
									} else {
										var _p545 = _p544._0._1;
										var eIsPartOfThisGroup = A2(
											_elm_lang$core$List$any,
											function (boundExp) {
												return A2(
													_elm_lang$core$Set$member,
													_user$project$Lang$expEId(boundExp),
													eAndAncestorEIds);
											},
											_user$project$Lang$groupBoundExps(_p545));
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$groupIdentifiers(_p545),
											eIsPartOfThisGroup ? {ctor: '[]'} : accumulate(_p544._1));
									}
								};
								return accumulate(_p542._2._3);
							default:
								return {ctor: '[]'};
						}
					},
					_user$project$Utils$removeLastElement(eWithAncestors));
			},
			A2(
				_user$project$Lang$findWithAncestorsByEId,
				root,
				_user$project$Lang$expEId(e)));
	});
var _user$project$Lang$freeVars = function (exp) {
	var removeIntroducedBy = F2(
		function (pats, vars) {
			var introduced = _user$project$Lang$identifiersListInPats(pats);
			return A2(
				_elm_lang$core$List$filter,
				function ($var) {
					return !A2(
						_elm_lang$core$List$member,
						A2(
							_user$project$Utils$fromJust_,
							'freeVars',
							_user$project$Lang$expToMaybeIdent($var)),
						introduced);
				},
				vars);
		});
	var _p546 = _user$project$Lang$unwrapExp(exp);
	switch (_p546.ctor) {
		case 'EVar':
			return {
				ctor: '::',
				_0: exp,
				_1: {ctor: '[]'}
			};
		case 'EFun':
			return A2(
				removeIntroducedBy,
				_p546._1,
				_user$project$Lang$freeVars(_p546._2));
		case 'ECase':
			var freeInEachBranch = A2(
				_elm_lang$core$List$concatMap,
				function (_p547) {
					var _p548 = _p547;
					return A2(
						removeIntroducedBy,
						{
							ctor: '::',
							_0: _p548._0,
							_1: {ctor: '[]'}
						},
						_user$project$Lang$freeVars(_p548._1));
				},
				_user$project$Lang$branchPatExps(_p546._2));
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$Lang$freeVars(_p546._1),
				freeInEachBranch);
		case 'ERecord':
			return A3(
				_user$project$Lang$foldRightGroup,
				_p546._2._3,
				{ctor: '[]'},
				F3(
					function (expGroup, isRec, subsequentFreeVars) {
						var _p549 = _elm_lang$core$List$unzip(
							A2(
								_elm_lang$core$List$map,
								function (_p550) {
									var _p551 = _p550;
									var _p552 = _p551._2;
									return {
										ctor: '_Tuple2',
										_0: _p552,
										_1: A2(
											removeIntroducedBy,
											{
												ctor: '::',
												_0: _p552,
												_1: {ctor: '[]'}
											},
											_user$project$Lang$freeVars(_p551._5))
									};
								},
								expGroup));
						var pats = _p549._0;
						var freeVarsBoundExps = _p549._1;
						var freeVarsBoundExpsFlat = _elm_lang$core$List$concat(freeVarsBoundExps);
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(removeIntroducedBy, pats, subsequentFreeVars),
							isRec ? A2(removeIntroducedBy, pats, freeVarsBoundExpsFlat) : freeVarsBoundExpsFlat);
					}));
		case 'ELet':
			return A3(
				_user$project$Lang$foldRightGroup,
				_p546._2._3,
				_user$project$Lang$freeVars(_p546._4),
				F3(
					function (expGroup, isRec, subsequentFreeVars) {
						var _p553 = _elm_lang$core$List$unzip(
							A2(
								_elm_lang$core$List$map,
								function (_p554) {
									var _p555 = _p554;
									var _p556 = _p555._2;
									return {
										ctor: '_Tuple2',
										_0: _p556,
										_1: A2(
											removeIntroducedBy,
											{
												ctor: '::',
												_0: _p556,
												_1: {ctor: '[]'}
											},
											_user$project$Lang$freeVars(_p555._5))
									};
								},
								expGroup));
						var pats = _p553._0;
						var freeVarsBoundExps = _p553._1;
						var freeVarsBoundExpsFlat = _elm_lang$core$List$concat(freeVarsBoundExps);
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(removeIntroducedBy, pats, subsequentFreeVars),
							isRec ? A2(removeIntroducedBy, pats, freeVarsBoundExpsFlat) : freeVarsBoundExpsFlat);
					}));
		default:
			return A2(
				_elm_lang$core$List$concatMap,
				_user$project$Lang$freeVars,
				_user$project$Lang$childExps(exp));
	}
};
var _user$project$Lang$freeIdentifiersList = function (exp) {
	return A2(
		_user$project$Utils$fromJust_,
		'LangTools.freeIdentifiersList',
		_user$project$Utils$projJusts(
			A2(
				_elm_lang$core$List$map,
				_user$project$Lang$expToMaybeIdent,
				_user$project$Lang$freeVars(exp))));
};
var _user$project$Lang$freeIdentifiers = function (exp) {
	return _elm_lang$core$Set$fromList(
		_user$project$Lang$freeIdentifiersList(exp));
};
var _user$project$Lang$mapBranchPats = F2(
	function (f, branches) {
		return A2(
			_elm_lang$core$List$map,
			function (branch) {
				var _p557 = branch.val;
				var ws1 = _p557._0;
				var pat = _p557._1;
				var exp = _p557._2;
				var ws2 = _p557._3;
				return _elm_lang$core$Native_Utils.update(
					branch,
					{
						val: A4(
							_user$project$Lang$Branch_,
							ws1,
							f(pat),
							exp,
							ws2)
					});
			},
			branches);
	});
var _user$project$Lang$mapPatNode = F3(
	function (pid, f, root) {
		return A2(
			_user$project$Lang$mapExpViaExp__,
			function (e__) {
				var _p558 = e__;
				switch (_p558.ctor) {
					case 'ELet':
						var _p561 = _p558._2._3;
						var newExps = A2(
							_elm_lang$core$List$map,
							function (_p559) {
								var _p560 = _p559;
								return A6(
									_user$project$Lang$LetExp,
									_p560._0,
									_p560._1,
									A3(_user$project$Lang$mapPatNodePat, pid, f, _p560._2),
									_p560._3,
									_p560._4,
									_p560._5);
							},
							_user$project$Lang$elemsOf(_p561));
						return A5(
							_user$project$Lang$ELet,
							_p558._0,
							_p558._1,
							A4(
								_user$project$Lang$Declarations,
								_p558._2._0,
								_p558._2._1,
								_p558._2._2,
								A2(_user$project$Lang$regroup, _p561, newExps)),
							_p558._3,
							_p558._4);
					case 'EFun':
						return A4(
							_user$project$Lang$EFun,
							_p558._0,
							A2(
								_elm_lang$core$List$map,
								A2(_user$project$Lang$mapPatNodePat, pid, f),
								_p558._1),
							_p558._2,
							_p558._3);
					case 'ECase':
						return A4(
							_user$project$Lang$ECase,
							_p558._0,
							_p558._1,
							A2(
								_user$project$Lang$mapBranchPats,
								A2(_user$project$Lang$mapPatNodePat, pid, f),
								_p558._2),
							_p558._3);
					default:
						return e__;
				}
			},
			root);
	});
var _user$project$Lang$replacePatNodePreservingPrecedingWhitespace = F3(
	function (pid, newPat, root) {
		return A3(
			_user$project$Lang$mapPatNode,
			pid,
			function (pat) {
				return A2(
					_user$project$Lang$replacePrecedingWhitespacePat,
					_user$project$Lang$precedingWhitespacePat(pat),
					newPat);
			},
			root);
	});
var _user$project$Lang$clearNodeIds = function (e) {
	var eidCleared = _user$project$Lang$clearEId(e);
	var _p562 = _user$project$Lang$unwrapExp(eidCleared);
	_v300_4:
	do {
		switch (_p562.ctor) {
			case 'EConst':
				if (_p562._2.ctor === '_Tuple3') {
					return A2(
						_user$project$Lang$replaceE__,
						eidCleared,
						A4(
							_user$project$Lang$EConst,
							_p562._0,
							_p562._1,
							{ctor: '_Tuple3', _0: 0, _1: _p562._2._1, _2: ''},
							_p562._3));
				} else {
					break _v300_4;
				}
			case 'ELet':
				var _p563 = _p562._2._3;
				return A2(
					_user$project$Lang$replaceE__,
					eidCleared,
					A5(
						_user$project$Lang$ELet,
						_p562._0,
						_p562._1,
						A4(
							_user$project$Lang$Declarations,
							_p562._2._0,
							_p562._2._1,
							A2(
								_elm_lang$core$List$map,
								_user$project$Lang$mapAnnotPat(_user$project$Lang$clearPIds),
								_p562._2._2),
							A2(
								_user$project$Lang$regroup,
								_p563,
								A2(
									_elm_lang$core$List$map,
									_user$project$Lang$mapLetPats(_user$project$Lang$clearPIds),
									_user$project$Lang$elemsOf(_p563)))),
						_p562._3,
						_p562._4));
			case 'EFun':
				return A2(
					_user$project$Lang$replaceE__,
					eidCleared,
					A4(
						_user$project$Lang$EFun,
						_p562._0,
						A2(_elm_lang$core$List$map, _user$project$Lang$clearPIds, _p562._1),
						_p562._2,
						_p562._3));
			case 'ECase':
				return A2(
					_user$project$Lang$replaceE__,
					eidCleared,
					A4(
						_user$project$Lang$ECase,
						_p562._0,
						_p562._1,
						A2(_user$project$Lang$mapBranchPats, _user$project$Lang$clearPIds, _p562._2),
						_p562._3));
			default:
				break _v300_4;
		}
	} while(false);
	return eidCleared;
};
var _user$project$Lang$replaceBranchExp = F2(
	function (branch, exp) {
		var _p564 = branch.val;
		var bws1 = _p564._0;
		var p = _p564._1;
		var bws2 = _p564._3;
		return _elm_lang$core$Native_Utils.update(
			branch,
			{
				val: A4(_user$project$Lang$Branch_, bws1, p, exp, bws2)
			});
	});
var _user$project$Lang$TBranch_ = F4(
	function (a, b, c, d) {
		return {ctor: 'TBranch_', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$tbranchExpExtractor = function (tbranch) {
	var _p565 = tbranch.val;
	return {
		ctor: '_Tuple2',
		_0: _p565._2,
		_1: function (newExp) {
			return A2(
				_user$project$Lang$replaceTB__,
				tbranch,
				A4(_user$project$Lang$TBranch_, _p565._0, _p565._1, newExp, _p565._3));
		}
	};
};
var _user$project$Lang$tbranchExpsExtractor = function (tbranches) {
	return A2(
		_elm_lang$core$Tuple$mapSecond,
		F2(
			function (expsToBranch, newExps) {
				return A3(
					_elm_lang$core$List$map2,
					F2(
						function (toBranch, newExp) {
							return toBranch(newExp);
						}),
					expsToBranch,
					newExps);
			}),
		_elm_lang$core$List$unzip(
			A2(_elm_lang$core$List$map, _user$project$Lang$tbranchExpExtractor, tbranches)));
};
var _user$project$Lang$replaceTBranchExp = F2(
	function (tbranch, exp) {
		var _p566 = tbranch.val;
		var tbws1 = _p566._0;
		var tipe = _p566._1;
		var tbws2 = _p566._3;
		return _elm_lang$core$Native_Utils.update(
			tbranch,
			{
				val: A4(_user$project$Lang$TBranch_, tbws1, tipe, exp, tbws2)
			});
	});
var _user$project$Lang$Def = {ctor: 'Def'};
var _user$project$Lang$eTypeAlias__ = F5(
	function (ws1, pat, t, rest, wsEnd) {
		return A5(
			_user$project$Lang$ELet,
			_user$project$Lang$newline1,
			_user$project$Lang$Def,
			A4(
				_user$project$Lang$Declarations,
				{
					ctor: '::',
					_0: 0,
					_1: {ctor: '[]'}
				},
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: false,
						_1: {
							ctor: '::',
							_0: A7(
								_user$project$Lang$LetType,
								_elm_lang$core$Maybe$Nothing,
								ws1,
								_elm_lang$core$Maybe$Just(_user$project$Lang$space1),
								pat,
								_user$project$Lang$FunArgAsPats,
								_user$project$Lang$space1,
								t),
							_1: {ctor: '[]'}
						}
					},
					_1: {ctor: '[]'}
				},
				{ctor: '[]'},
				{ctor: '[]'}),
			_user$project$Lang$space1,
			rest);
	});
var _user$project$Lang$eTyp_ = F5(
	function (wsStart, pat, t, rest, wsEnd) {
		return A5(
			_user$project$Lang$ELet,
			_user$project$Lang$newline1,
			_user$project$Lang$Def,
			A4(
				_user$project$Lang$Declarations,
				{
					ctor: '::',
					_0: 0,
					_1: {ctor: '[]'}
				},
				{ctor: '[]'},
				{
					ctor: '::',
					_0: A6(_user$project$Lang$LetAnnotation, _elm_lang$core$Maybe$Nothing, wsStart, pat, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, t),
					_1: {ctor: '[]'}
				},
				{ctor: '[]'}),
			_user$project$Lang$space1,
			rest);
	});
var _user$project$Lang$Let = {ctor: 'Let'};
var _user$project$Lang$NoWidgetDecl = {ctor: 'NoWidgetDecl'};
var _user$project$Lang$noWidgetDecl = _user$project$Lang$withDummyRange(_user$project$Lang$NoWidgetDecl);
var _user$project$Lang$eConst0 = F2(
	function (a, b) {
		return _user$project$Lang$withDummyExpInfo(
			A4(_user$project$Lang$EConst, _user$project$Lang$space0, a, b, _user$project$Lang$noWidgetDecl));
	});
var _user$project$Lang$eConst = F2(
	function (a, b) {
		return _user$project$Lang$withDummyExpInfo(
			A4(_user$project$Lang$EConst, _user$project$Lang$space1, a, b, _user$project$Lang$noWidgetDecl));
	});
var _user$project$Lang$locIdToExpFromFrozenSubstAndNewNames = F2(
	function (locIdToFrozenNum, locIdToIdent) {
		return A6(
			_elm_lang$core$Dict$merge,
			F3(
				function (locId, n, locIdToExp) {
					return A3(
						_elm_lang$core$Dict$insert,
						locId,
						A2(
							_user$project$Lang$eConst,
							n,
							_user$project$Lang$dummyLoc_(_user$project$Lang$frozen)),
						locIdToExp);
				}),
			F4(
				function (locId, n, ident, locIdToExp) {
					return A3(
						_elm_lang$core$Dict$insert,
						locId,
						_user$project$Lang$eVar(ident),
						locIdToExp);
				}),
			F3(
				function (locId, ident, locIdToExp) {
					return A3(
						_elm_lang$core$Dict$insert,
						locId,
						_user$project$Lang$eVar(ident),
						locIdToExp);
				}),
			locIdToFrozenNum,
			locIdToIdent,
			_elm_lang$core$Dict$empty);
	});
var _user$project$Lang$listOfNums = function (ns) {
	var _p567 = ns;
	if (_p567.ctor === '[]') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: A2(_user$project$Lang$eConst0, _p567._0, _user$project$Lang$dummyLoc),
			_1: A2(
				_elm_lang$core$List$map,
				A2(_elm_lang$core$Basics$flip, _user$project$Lang$eConst, _user$project$Lang$dummyLoc),
				_p567._1)
		};
	}
};
var _user$project$Lang$eConstDummyLoc0 = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A4(_user$project$Lang$EConst, _user$project$Lang$space0, a, _user$project$Lang$dummyLoc, _user$project$Lang$noWidgetDecl));
};
var _user$project$Lang$eConstDummyLoc = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A4(_user$project$Lang$EConst, _user$project$Lang$space1, a, _user$project$Lang$dummyLoc, _user$project$Lang$noWidgetDecl));
};
var _user$project$Lang$pVar0 = function (a) {
	return _user$project$Lang$withDummyPatInfo(
		A3(_user$project$Lang$PVar, _user$project$Lang$space0, a, _user$project$Lang$noWidgetDecl));
};
var _user$project$Lang$pVar = function (a) {
	return _user$project$Lang$withDummyPatInfo(
		A3(_user$project$Lang$PVar, _user$project$Lang$space1, a, _user$project$Lang$noWidgetDecl));
};
var _user$project$Lang$eRecord__ = F4(
	function (wsBefore, mbInit, keyValues, wsBeforeEnd) {
		return A4(
			_user$project$Lang$ERecord,
			wsBefore,
			mbInit,
			A4(
				_user$project$Lang$Declarations,
				A2(
					_elm_lang$core$List$range,
					0,
					_elm_lang$core$List$length(keyValues) - 1),
				{ctor: '[]'},
				{ctor: '[]'},
				A2(
					_elm_lang$core$List$map,
					function (_p568) {
						var _p569 = _p568;
						var _p570 = _p569._4;
						return {
							ctor: '_Tuple2',
							_0: _user$project$Lang$isBodyPossiblyRecursive(_p570),
							_1: {
								ctor: '::',
								_0: A6(
									_user$project$Lang$LetExp,
									_p569._0,
									_p569._1,
									_user$project$Lang$pVar(_p569._2),
									_user$project$Lang$FunArgAsPats,
									_p569._3,
									_p570),
								_1: {ctor: '[]'}
							}
						};
					},
					keyValues)),
			wsBeforeEnd);
	});
var _user$project$Lang$eRecord = function (kvs) {
	return _user$project$Lang$withDummyExpInfo(
		A4(
			_user$project$Lang$eRecord__,
			_user$project$Lang$space1,
			_elm_lang$core$Maybe$Nothing,
			A2(
				_elm_lang$core$List$map,
				function (_p571) {
					var _p572 = _p571;
					return {
						ctor: '_Tuple5',
						_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
						_1: _user$project$Lang$space1,
						_2: _p572._0,
						_3: _user$project$Lang$space1,
						_4: _p572._1
					};
				},
				kvs),
			_user$project$Lang$space1));
};
var _user$project$Lang$listOfPVars = function (xs) {
	var _p573 = xs;
	if (_p573.ctor === '[]') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _user$project$Lang$pVar0(_p573._0),
			_1: A2(_elm_lang$core$List$map, _user$project$Lang$pVar, _p573._1)
		};
	}
};
var _user$project$Lang$pListOfPVars = function (names) {
	return _user$project$Lang$pList(
		_user$project$Lang$listOfPVars(names));
};
var _user$project$Lang$patBoundExpOf = function (namesAndAssigns) {
	var _p574 = _elm_lang$core$List$unzip(namesAndAssigns);
	if ((((_p574._0.ctor === '::') && (_p574._0._1.ctor === '[]')) && (_p574._1.ctor === '::')) && (_p574._1._1.ctor === '[]')) {
		return {
			ctor: '_Tuple2',
			_0: _user$project$Lang$pVar(_p574._0._0),
			_1: A2(_user$project$Lang$replacePrecedingWhitespace, ' ', _p574._1._0)
		};
	} else {
		return {
			ctor: '_Tuple2',
			_0: _user$project$Lang$pListOfPVars(_p574._0),
			_1: A2(
				_user$project$Lang$eList,
				A3(_user$project$Lang$setExpListWhitespace, '', ' ', _p574._1),
				_elm_lang$core$Maybe$Nothing)
		};
	}
};
var _user$project$Lang$eLetOrDef = F3(
	function (letKind, namesAndAssigns, bodyExp) {
		var _p575 = _user$project$Lang$patBoundExpOf(namesAndAssigns);
		var pat = _p575._0;
		var assign = _p575._1;
		return _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$ELet,
				_user$project$Lang$newline1,
				letKind,
				A4(
					_user$project$Lang$Declarations,
					{
						ctor: '::',
						_0: 0,
						_1: {ctor: '[]'}
					},
					{ctor: '[]'},
					{ctor: '[]'},
					{
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _user$project$Lang$isBodyPossiblyRecursive(assign),
							_1: {
								ctor: '::',
								_0: A6(_user$project$Lang$LetExp, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space1, pat, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, assign),
								_1: {ctor: '[]'}
							}
						},
						_1: {ctor: '[]'}
					}),
				_user$project$Lang$space1,
				bodyExp));
	});
var _user$project$Lang$eLet = _user$project$Lang$eLetOrDef(_user$project$Lang$Let);
var _user$project$Lang$eLets = F2(
	function (xes, eBody) {
		var _p576 = xes;
		if (_p576.ctor === '::') {
			return A2(
				_user$project$Lang$eLet,
				{
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: _p576._0._0, _1: _p576._0._1},
					_1: {ctor: '[]'}
				},
				A2(_user$project$Lang$eLets, _p576._1, eBody));
		} else {
			return eBody;
		}
	});
var _user$project$Lang$eDef = _user$project$Lang$eLetOrDef(_user$project$Lang$Def);
var _user$project$Lang$pAs = F2(
	function (x, p) {
		return _user$project$Lang$withDummyPatInfo(
			A4(
				_user$project$Lang$PAs,
				_user$project$Lang$space0,
				p,
				_user$project$Lang$space1,
				_user$project$Lang$withDummyPatInfo(
					A3(_user$project$Lang$PVar, _user$project$Lang$space1, x, _user$project$Lang$noWidgetDecl))));
	});
var _user$project$Lang$NumSlider = F5(
	function (a, b, c, d, e) {
		return {ctor: 'NumSlider', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$numSlider = _user$project$Lang$rangeSlider(_user$project$Lang$NumSlider);
var _user$project$Lang$IntSlider = F5(
	function (a, b, c, d, e) {
		return {ctor: 'IntSlider', _0: a, _1: b, _2: c, _3: d, _4: e};
	});
var _user$project$Lang$intSlider = _user$project$Lang$rangeSlider(_user$project$Lang$IntSlider);
var _user$project$Lang$colorNumberSlider = A2(_user$project$Lang$intSlider, 0, 499);
var _user$project$Lang$Y = {ctor: 'Y'};
var _user$project$Lang$X = {ctor: 'X'};
var _user$project$Lang$Negative = {ctor: 'Negative'};
var _user$project$Lang$Positive = {ctor: 'Positive'};
var _user$project$Lang$WCall = F4(
	function (a, b, c, d) {
		return {ctor: 'WCall', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$WOffset1D = F8(
	function (a, b, c, d, e, f, g, h) {
		return {ctor: 'WOffset1D', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g, _7: h};
	});
var _user$project$Lang$WPoint = F4(
	function (a, b, c, d) {
		return {ctor: 'WPoint', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$WNumSlider = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'WNumSlider', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$Lang$WIntSlider = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'WIntSlider', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$Lang$Parents = function (a) {
	return {ctor: 'Parents', _0: a};
};
var _user$project$Lang$VFun = F4(
	function (a, b, c, d) {
		return {ctor: 'VFun', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$VDict = function (a) {
	return {ctor: 'VDict', _0: a};
};
var _user$project$Lang$VRecord = function (a) {
	return {ctor: 'VRecord', _0: a};
};
var _user$project$Lang$VList = function (a) {
	return {ctor: 'VList', _0: a};
};
var _user$project$Lang$mapVal = F2(
	function (f, v) {
		var _p577 = v.v_;
		switch (_p577.ctor) {
			case 'VList':
				return f(
					_elm_lang$core$Native_Utils.update(
						v,
						{
							v_: _user$project$Lang$VList(
								A2(
									_elm_lang$core$List$map,
									_user$project$Lang$mapVal(f),
									_p577._0))
						}));
			case 'VDict':
				return f(
					_elm_lang$core$Native_Utils.update(
						v,
						{
							v_: _user$project$Lang$VDict(
								A2(
									_elm_lang$core$Dict$map,
									F2(
										function (_p578, v) {
											return A2(_user$project$Lang$mapVal, f, v);
										}),
									_p577._0))
						}));
			case 'VRecord':
				return f(
					_elm_lang$core$Native_Utils.update(
						v,
						{
							v_: _user$project$Lang$VRecord(
								A2(
									_elm_lang$core$Dict$map,
									F2(
										function (_p579, v) {
											return A2(_user$project$Lang$mapVal, f, v);
										}),
									_p577._0))
						}));
			case 'VConst':
				return f(v);
			case 'VBase':
				return f(v);
			case 'VClosure':
				return f(v);
			default:
				return f(v);
		}
	});
var _user$project$Lang$VClosure = F4(
	function (a, b, c, d) {
		return {ctor: 'VClosure', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$expandRecEnv = F2(
	function (recNames, closureEnv) {
		var _p580 = A2(
			_user$project$Utils$split,
			_elm_lang$core$List$length(recNames),
			closureEnv);
		var nonRecEnv = _p580._0;
		var remainingEnv = _p580._1;
		var recEnv2 = A2(
			_elm_lang$core$List$map,
			function (_p581) {
				var _p582 = _p581;
				var _p584 = _p582._1;
				var _p583 = _p584.v_;
				if ((_p583.ctor === 'VClosure') && (_p583._0.ctor === '[]')) {
					return {
						ctor: '_Tuple2',
						_0: _p582._0,
						_1: A2(
							_user$project$Lang$replaceV_,
							_p584,
							A4(
								_user$project$Lang$VClosure,
								recNames,
								_p583._1,
								_p583._2,
								A2(_elm_lang$core$Basics_ops['++'], nonRecEnv, _p583._3)))
					};
				} else {
					return _p582;
				}
			},
			nonRecEnv);
		return A2(_elm_lang$core$Basics_ops['++'], recEnv2, remainingEnv);
	});
var _user$project$Lang$VBase = function (a) {
	return {ctor: 'VBase', _0: a};
};
var _user$project$Lang$VConst = F2(
	function (a, b) {
		return {ctor: 'VConst', _0: a, _1: b};
	});
var _user$project$Lang$VNull = {ctor: 'VNull'};
var _user$project$Lang$VString = function (a) {
	return {ctor: 'VString', _0: a};
};
var _user$project$Lang$VBool = function (a) {
	return {ctor: 'VBool', _0: a};
};
var _user$project$Lang$ENull = {ctor: 'ENull'};
var _user$project$Lang$eNull = _user$project$Lang$withDummyExpInfo(
	A2(_user$project$Lang$EBase, _user$project$Lang$space1, _user$project$Lang$ENull));
var _user$project$Lang$EString = F2(
	function (a, b) {
		return {ctor: 'EString', _0: a, _1: b};
	});
var _user$project$Lang$eStr = function (_p585) {
	return _user$project$Lang$withDummyExpInfo(
		A2(
			_user$project$Lang$EBase,
			_user$project$Lang$space1,
			A2(_user$project$Lang$EString, '\"', _p585)));
};
var _user$project$Lang$eStr0 = function (_p586) {
	return _user$project$Lang$withDummyExpInfo(
		A2(
			_user$project$Lang$EBase,
			_user$project$Lang$space0,
			A2(_user$project$Lang$EString, '\"', _p586)));
};
var _user$project$Lang$pTuple__ = F3(
	function (spBeforeOpenParen, keyValues, spBeforeCloseParen) {
		var _p587 = keyValues;
		if (((_p587.ctor === '::') && (_p587._0.ctor === '_Tuple2')) && (_p587._1.ctor === '[]')) {
			return A3(_user$project$Lang$PParens, spBeforeOpenParen, _p587._0._1, spBeforeCloseParen);
		} else {
			var patternList = A2(
				_user$project$Lang$tupleEncodingApply,
				function (_p588) {
					return _user$project$Lang$withDummyPatInfo(
						A2(
							_user$project$Lang$PBase,
							_user$project$Lang$space0,
							A2(_user$project$Lang$EString, '\"', _p588)));
				},
				keyValues);
			return A3(_user$project$Lang$PRecord, spBeforeOpenParen, patternList, spBeforeCloseParen);
		}
	});
var _user$project$Lang$pTuple = F3(
	function (spBeforeOpenParen, keyValues, spBeforeCloseParen) {
		return _user$project$Lang$withDummyPatInfo(
			A3(_user$project$Lang$pTuple__, spBeforeOpenParen, keyValues, spBeforeCloseParen));
	});
var _user$project$Lang$eTuple__ = F3(
	function (spBeforeOpenParen, keyValues, spBeforeCloseParen) {
		var _p589 = keyValues;
		if (((_p589.ctor === '::') && (_p589._0.ctor === '_Tuple2')) && (_p589._1.ctor === '[]')) {
			return A4(_user$project$Lang$EParens, spBeforeOpenParen, _p589._0._1, _user$project$Lang$Parens, spBeforeCloseParen);
		} else {
			var elemList = A2(
				_user$project$Lang$tupleEncodingApply,
				function (_p590) {
					return _user$project$Lang$withDummyExpInfo(
						A2(
							_user$project$Lang$EBase,
							_user$project$Lang$space0,
							A2(_user$project$Lang$EString, '\"', _p590)));
				},
				keyValues);
			return A4(_user$project$Lang$eRecord__, spBeforeOpenParen, _elm_lang$core$Maybe$Nothing, elemList, spBeforeCloseParen);
		}
	});
var _user$project$Lang$eTuple0 = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A3(
			_user$project$Lang$eTuple__,
			_user$project$Lang$space0,
			A2(
				_elm_lang$core$List$indexedMap,
				F2(
					function (i, x) {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$Native_Utils.eq(i, 0) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
							_1: x
						};
					}),
				a),
			_user$project$Lang$space0));
};
var _user$project$Lang$eTuple = function (a) {
	return _user$project$Lang$withDummyExpInfo(
		A3(
			_user$project$Lang$eTuple__,
			_user$project$Lang$space1,
			A2(
				_elm_lang$core$List$indexedMap,
				F2(
					function (i, x) {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$Native_Utils.eq(i, 0) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
							_1: x
						};
					}),
				a),
			_user$project$Lang$space0));
};
var _user$project$Lang$EBool = function (a) {
	return {ctor: 'EBool', _0: a};
};
var _user$project$Lang$eBool = function (_p591) {
	return _user$project$Lang$withDummyExpInfo(
		A2(
			_user$project$Lang$EBase,
			_user$project$Lang$space1,
			_user$project$Lang$EBool(_p591)));
};
var _user$project$Lang$eTrue = _user$project$Lang$eBool(true);
var _user$project$Lang$eFalse = _user$project$Lang$eBool(false);
var _user$project$Lang$TrOp = F2(
	function (a, b) {
		return {ctor: 'TrOp', _0: a, _1: b};
	});
var _user$project$Lang$offsetWidget1DEffectiveAmountAndEndPoint = F4(
	function (_p593, axis, sign, _p592) {
		var _p594 = _p593;
		var _p605 = _p594._1._1;
		var _p604 = _p594._1._0;
		var _p603 = _p594._0._1;
		var _p602 = _p594._0._0;
		var _p595 = _p592;
		var _p601 = _p595._1;
		var _p600 = _p595._0;
		var _p596 = function () {
			var _p597 = sign;
			if (_p597.ctor === 'Positive') {
				return {ctor: '_Tuple2', _0: _p600, _1: _user$project$Lang$Plus};
			} else {
				return {ctor: '_Tuple2', _0: 0 - _p600, _1: _user$project$Lang$Minus};
			}
		}();
		var effectiveAmount = _p596._0;
		var op = _p596._1;
		var _p598 = function () {
			var _p599 = axis;
			if (_p599.ctor === 'X') {
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: _p602 + effectiveAmount,
						_1: A2(
							_user$project$Lang$TrOp,
							op,
							{
								ctor: '::',
								_0: _p603,
								_1: {
									ctor: '::',
									_0: _p601,
									_1: {ctor: '[]'}
								}
							})
					},
					_1: {ctor: '_Tuple2', _0: _p604, _1: _p605}
				};
			} else {
				return {
					ctor: '_Tuple2',
					_0: {ctor: '_Tuple2', _0: _p602, _1: _p603},
					_1: {
						ctor: '_Tuple2',
						_0: _p604 + effectiveAmount,
						_1: A2(
							_user$project$Lang$TrOp,
							op,
							{
								ctor: '::',
								_0: _p605,
								_1: {
									ctor: '::',
									_0: _p601,
									_1: {ctor: '[]'}
								}
							})
					}
				};
			}
		}();
		var endX = _p598._0._0;
		var endXTr = _p598._0._1;
		var endY = _p598._1._0;
		var endYTr = _p598._1._1;
		return {
			ctor: '_Tuple2',
			_0: effectiveAmount,
			_1: {
				ctor: '_Tuple2',
				_0: {ctor: '_Tuple2', _0: endX, _1: endXTr},
				_1: {ctor: '_Tuple2', _0: endY, _1: endYTr}
			}
		};
	});
var _user$project$Lang$plusNumTr = F2(
	function (_p607, _p606) {
		var _p608 = _p607;
		var _p609 = _p606;
		return {
			ctor: '_Tuple2',
			_0: _p608._0 + _p609._0,
			_1: A2(
				_user$project$Lang$TrOp,
				_user$project$Lang$Plus,
				{
					ctor: '::',
					_0: _p608._1,
					_1: {
						ctor: '::',
						_0: _p609._1,
						_1: {ctor: '[]'}
					}
				})
		};
	});
var _user$project$Lang$minusNumTr = F2(
	function (_p611, _p610) {
		var _p612 = _p611;
		var _p613 = _p610;
		return {
			ctor: '_Tuple2',
			_0: _p612._0 + _p613._0,
			_1: A2(
				_user$project$Lang$TrOp,
				_user$project$Lang$Minus,
				{
					ctor: '::',
					_0: _p612._1,
					_1: {
						ctor: '::',
						_0: _p613._1,
						_1: {ctor: '[]'}
					}
				})
		};
	});
var _user$project$Lang$TrLoc = function (a) {
	return {ctor: 'TrLoc', _0: a};
};
var _user$project$Lang$dummyTrace_ = function (b) {
	return _user$project$Lang$TrLoc(
		_user$project$Lang$dummyLoc_(b));
};
var _user$project$Lang$dummyTrace = _user$project$Lang$dummyTrace_(_user$project$Lang$unann);
var _user$project$Lang$Provenance = F3(
	function (a, b, c) {
		return {ctor: 'Provenance', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$builtinVal = F2(
	function (msg, x) {
		return A3(
			_user$project$Lang$Val,
			x,
			A3(
				_user$project$Lang$Provenance,
				{ctor: '[]'},
				_user$project$Lang$withDummyExpInfo(
					A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'msg')),
				{ctor: '[]'}),
			_user$project$Lang$Parents(
				{ctor: '[]'}));
	});
var _user$project$Lang$vTuple = function (vals) {
	return _user$project$Lang$VRecord(
		_elm_lang$core$Dict$fromList(
			{
				ctor: '::',
				_0: A3(
					_user$project$Lang$ctorVal,
					function (_p614) {
						return A2(
							_user$project$Lang$builtinVal,
							'Lang.vTuple',
							_user$project$Lang$VBase(
								_user$project$Lang$VString(_p614)));
					},
					_user$project$Lang$TupleCtor,
					_user$project$Lang$ctorTupleName(
						_elm_lang$core$List$length(vals))),
				_1: A3(_user$project$Utils$indexedMapFrom, 1, _user$project$Lang$numericalValEntry, vals)
			}));
};
var _user$project$Lang$dummyProvenance = A3(
	_user$project$Lang$Provenance,
	{ctor: '[]'},
	_user$project$Lang$eTuple0(
		{ctor: '[]'}),
	{ctor: '[]'});
var _user$project$Lang$SynthesisResult = function (a) {
	return {ctor: 'SynthesisResult', _0: a};
};
var _user$project$Lang$synthesisResult = F2(
	function (description, exp) {
		return _user$project$Lang$SynthesisResult(
			{
				description: description,
				exp: exp,
				diffs: {ctor: '[]'},
				isSafe: true,
				sortKey: {ctor: '[]'},
				children: _elm_lang$core$Maybe$Nothing,
				nextLazy: _elm_lang$core$Maybe$Nothing
			});
	});
var _user$project$Lang$HintText = function (a) {
	return {ctor: 'HintText', _0: a};
};
var _user$project$Lang$TypeText = function (a) {
	return {ctor: 'TypeText', _0: a};
};
var _user$project$Lang$CodeText = function (a) {
	return {ctor: 'CodeText', _0: a};
};
var _user$project$Lang$ErrorHeaderText = function (a) {
	return {ctor: 'ErrorHeaderText', _0: a};
};
var _user$project$Lang$HeaderText = function (a) {
	return {ctor: 'HeaderText', _0: a};
};
var _user$project$Lang$PlainText = function (a) {
	return {ctor: 'PlainText', _0: a};
};
var _user$project$Lang$Label = function (a) {
	return {ctor: 'Label', _0: a};
};
var _user$project$Lang$Fancy = F2(
	function (a, b) {
		return {ctor: 'Fancy', _0: a, _1: b};
	});
var _user$project$Lang$Basic = function (a) {
	return {ctor: 'Basic', _0: a};
};
var _user$project$Lang$basicTransformationResult = F2(
	function (description, exp) {
		return _user$project$Lang$Basic(
			A2(_user$project$Lang$synthesisResult, description, exp));
	});
var _user$project$Lang$mapSynthesisResult = F2(
	function (f, tr) {
		var _p615 = tr;
		switch (_p615.ctor) {
			case 'Basic':
				return _user$project$Lang$Basic(
					f(_p615._0));
			case 'Fancy':
				return A2(
					_user$project$Lang$Fancy,
					f(_p615._0),
					_p615._1);
			default:
				return _user$project$Lang$Label(_p615._0);
		}
	});
var _user$project$Lang$Impossible = {ctor: 'Impossible'};
var _user$project$Lang$Possible = {ctor: 'Possible'};
var _user$project$Lang$Satisfied = {ctor: 'Satisfied'};
var _user$project$Lang$FullySatisfied = {ctor: 'FullySatisfied'};
var _user$project$Lang$SmartCompleteDeuceTransform = function (a) {
	return {ctor: 'SmartCompleteDeuceTransform', _0: a};
};
var _user$project$Lang$RenameDeuceTransform = function (a) {
	return {ctor: 'RenameDeuceTransform', _0: a};
};
var _user$project$Lang$NoInputDeuceTransform = function (a) {
	return {ctor: 'NoInputDeuceTransform', _0: a};
};
var _user$project$Lang$InactiveDeuceTransform = {ctor: 'InactiveDeuceTransform'};
var _user$project$Lang$After = {ctor: 'After'};
var _user$project$Lang$Before = {ctor: 'Before'};
var _user$project$Lang$InsertPatternLevel = F2(
	function (a, b) {
		return {ctor: 'InsertPatternLevel', _0: a, _1: b};
	});
var _user$project$Lang$InsertDeclarationLevel = function (a) {
	return {ctor: 'InsertDeclarationLevel', _0: a};
};
var _user$project$Lang$DeclarationTargetPosition = function (a) {
	return {ctor: 'DeclarationTargetPosition', _0: a};
};
var _user$project$Lang$PatTargetPosition = function (a) {
	return {ctor: 'PatTargetPosition', _0: a};
};
var _user$project$Lang$ExpTargetPosition = function (a) {
	return {ctor: 'ExpTargetPosition', _0: a};
};
var _user$project$Lang$TT = F3(
	function (a, b, c) {
		return {ctor: 'TT', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$PT = F4(
	function (a, b, c, d) {
		return {ctor: 'PT', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$ET = F3(
	function (a, b, c) {
		return {ctor: 'ET', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$DT = F4(
	function (a, b, c, d) {
		return {ctor: 'DT', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Lang$D = F2(
	function (a, b) {
		return {ctor: 'D', _0: a, _1: b};
	});
var _user$project$Lang$T = function (a) {
	return {ctor: 'T', _0: a};
};
var _user$project$Lang$P = F2(
	function (a, b) {
		return {ctor: 'P', _0: a, _1: b};
	});
var _user$project$Lang$E = function (a) {
	return {ctor: 'E', _0: a};
};
var _user$project$Lang$modifyWsBefore = F2(
	function (f, codeObject) {
		var _p616 = codeObject;
		switch (_p616.ctor) {
			case 'E':
				var _p617 = _p616._0._0;
				var newE__ = _user$project$Lang$unwrapExp(
					A2(
						_user$project$Lang$mapPrecedingWhitespaceWS,
						f,
						_user$project$Lang$Expr(_p617)));
				var eVal = _p617.val;
				return _user$project$Lang$E(
					_user$project$Lang$Expr(
						_elm_lang$core$Native_Utils.update(
							_p617,
							{
								val: _elm_lang$core$Native_Utils.update(
									eVal,
									{e__: newE__})
							})));
			case 'P':
				var _p618 = _p616._1;
				var newP__ = function (_) {
					return _.p__;
				}(
					function (_) {
						return _.val;
					}(
						A2(_user$project$Lang$mapPrecedingWhitespacePatWS, f, _p618)));
				var pVal = _p618.val;
				return A2(
					_user$project$Lang$P,
					_p616._0,
					_elm_lang$core$Native_Utils.update(
						_p618,
						{
							val: _elm_lang$core$Native_Utils.update(
								pVal,
								{p__: newP__})
						}));
			case 'T':
				var _p619 = _p616._0;
				var newVal = function (_) {
					return _.val;
				}(
					A2(_user$project$Lang$mapPrecedingWhitespaceTypeWS, f, _p619));
				return _user$project$Lang$T(
					_elm_lang$core$Native_Utils.update(
						_p619,
						{val: newVal}));
			case 'D':
				return A2(_user$project$Lang$D, _p616._0, _p616._1);
			case 'DT':
				return A4(
					_user$project$Lang$DT,
					_p616._0,
					f(_p616._1),
					_p616._2,
					_p616._3);
			case 'ET':
				return A3(
					_user$project$Lang$ET,
					_p616._0,
					f(_p616._1),
					_p616._2);
			case 'PT':
				return A4(
					_user$project$Lang$PT,
					_p616._0,
					f(_p616._1),
					_p616._2,
					_p616._3);
			default:
				return A3(
					_user$project$Lang$TT,
					_p616._0,
					f(_p616._1),
					_p616._2);
		}
	});
var _user$project$Lang$declarationsCodeObjects = F2(
	function (e, declarations) {
		var isTupleOrDatatype = _user$project$Utils$maybeToBool(
			_user$project$Lang$expToCtorKind(e));
		return A2(
			_elm_lang$core$List$concatMap,
			function (_p620) {
				var _p621 = _p620;
				var _p637 = _p621._1;
				var _p622 = _p621._0;
				switch (_p622.ctor) {
					case 'DeclType':
						var _p628 = _p622._0._6;
						var _p627 = _p622._0._1;
						var _p626 = _p622._0._3;
						var _p625 = _p622._0._0;
						var _p623 = function () {
							if (_elm_lang$core$Native_Utils.eq(_p637, 0)) {
								return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p627};
							} else {
								var _p624 = _p625;
								if (_p624.ctor === 'Nothing') {
									return _user$project$Lang$splitBeforeWhitespace(_p627);
								} else {
									return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p627};
								}
							}
						}();
						var spAfterPreviousDecl = _p623._0;
						var spBeforeThisDecl = _p623._1;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								{ctor: '[]'},
								A2(
									_elm_lang$core$Maybe$map,
									function (spc) {
										return {
											ctor: '::',
											_0: A4(_user$project$Lang$DT, _user$project$Lang$After, spc, e, _p637 - 1),
											_1: {ctor: '[]'}
										};
									},
									_p625)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$Maybe$withDefault,
									{ctor: '[]'},
									A2(
										_elm_lang$core$Maybe$map,
										function (sp) {
											return {
												ctor: '::',
												_0: A4(_user$project$Lang$DT, _user$project$Lang$After, sp, e, _p637 - 1),
												_1: {ctor: '[]'}
											};
										},
										spAfterPreviousDecl)),
								{
									ctor: '::',
									_0: A4(_user$project$Lang$DT, _user$project$Lang$Before, spBeforeThisDecl, e, _p637),
									_1: {
										ctor: '::',
										_0: A2(
											_user$project$Lang$D,
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$expEId(e),
												_p626.start,
												_p628.end),
											_p637),
										_1: {
											ctor: '::',
											_0: A2(
												_user$project$Lang$P,
												{ctor: '_Tuple2', _0: e, _1: _p637},
												_p626),
											_1: {
												ctor: '::',
												_0: _user$project$Lang$T(_p628),
												_1: {
													ctor: '::',
													_0: A3(
														_user$project$Lang$TT,
														_user$project$Lang$After,
														A3(_user$project$Info$withInfo, '', _p628.end, _p628.end),
														_p628),
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}));
					case 'DeclAnnotation':
						var _p632 = _p622._0._5;
						var _p631 = _p622._0._1;
						var _p630 = _p622._0._2;
						var _p629 = _elm_lang$core$Native_Utils.eq(_p637, 0) ? {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p631} : _user$project$Lang$splitBeforeWhitespace(_p631);
						var spAfterPreviousDecl = _p629._0;
						var spBeforeThisDecl = _p629._1;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								{ctor: '[]'},
								A2(
									_elm_lang$core$Maybe$map,
									function (spc) {
										return {
											ctor: '::',
											_0: A4(_user$project$Lang$DT, _user$project$Lang$After, spc, e, _p637 - 1),
											_1: {ctor: '[]'}
										};
									},
									_p622._0._0)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$Maybe$withDefault,
									{ctor: '[]'},
									A2(
										_elm_lang$core$Maybe$map,
										function (sp) {
											return {
												ctor: '::',
												_0: A4(_user$project$Lang$DT, _user$project$Lang$After, sp, e, _p637 - 1),
												_1: {ctor: '[]'}
											};
										},
										spAfterPreviousDecl)),
								{
									ctor: '::',
									_0: A4(_user$project$Lang$DT, _user$project$Lang$Before, spBeforeThisDecl, e, _p637),
									_1: {
										ctor: '::',
										_0: A2(
											_user$project$Lang$D,
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$expEId(e),
												_p630.start,
												_p632.end),
											_p637),
										_1: {
											ctor: '::',
											_0: A2(
												_user$project$Lang$P,
												{ctor: '_Tuple2', _0: e, _1: _p637},
												_p630),
											_1: {
												ctor: '::',
												_0: A4(
													_user$project$Lang$PT,
													_user$project$Lang$After,
													_p622._0._4,
													{ctor: '_Tuple2', _0: e, _1: _p637},
													_p630),
												_1: {
													ctor: '::',
													_0: _user$project$Lang$T(_p632),
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}));
					default:
						var _p636 = _p622._0._1;
						var _p635 = _p622._0._2;
						var _p634 = _p622._0._5._0;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							function () {
								if (isTupleOrDatatype) {
									return {ctor: '[]'};
								} else {
									var _p633 = _elm_lang$core$Native_Utils.eq(_p637, 0) ? {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p636} : _user$project$Lang$splitBeforeWhitespace(_p636);
									var spAfterPreviousDecl = _p633._0;
									var spBeforeThisDecl = _p633._1;
									return A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$Maybe$withDefault,
											{ctor: '[]'},
											A2(
												_elm_lang$core$Maybe$map,
												function (spc) {
													return {
														ctor: '::',
														_0: A4(_user$project$Lang$DT, _user$project$Lang$After, spc, e, _p637 - 1),
														_1: {ctor: '[]'}
													};
												},
												_p622._0._0)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											A2(
												_elm_lang$core$Maybe$withDefault,
												{ctor: '[]'},
												A2(
													_elm_lang$core$Maybe$map,
													function (sp) {
														return {
															ctor: '::',
															_0: A4(_user$project$Lang$DT, _user$project$Lang$After, sp, e, _p637 - 1),
															_1: {ctor: '[]'}
														};
													},
													spAfterPreviousDecl)),
											A2(
												_elm_lang$core$Basics_ops['++'],
												{
													ctor: '::',
													_0: A4(_user$project$Lang$DT, _user$project$Lang$Before, spBeforeThisDecl, e, _p637),
													_1: {ctor: '[]'}
												},
												A2(
													_elm_lang$core$Basics_ops['++'],
													(!_elm_lang$core$Native_Utils.eq(_p635.start, _user$project$Pos$dummyPos)) ? {
														ctor: '::',
														_0: A2(
															_user$project$Lang$D,
															A3(
																_user$project$Info$withInfo,
																_user$project$Lang$expEId(e),
																_p635.start,
																_p634.end),
															_p637),
														_1: {ctor: '[]'}
													} : {ctor: '[]'},
													{
														ctor: '::',
														_0: A2(
															_user$project$Lang$P,
															{ctor: '_Tuple2', _0: e, _1: _p637},
															_p635),
														_1: {
															ctor: '::',
															_0: A4(
																_user$project$Lang$PT,
																_user$project$Lang$After,
																_p622._0._4,
																{ctor: '_Tuple2', _0: e, _1: _p637},
																_p635),
															_1: {ctor: '[]'}
														}
													}))));
								}
							}(),
							{
								ctor: '::',
								_0: _user$project$Lang$E(
									_user$project$Lang$Expr(_p634)),
								_1: {
									ctor: '::',
									_0: A3(
										_user$project$Lang$ET,
										_user$project$Lang$After,
										_user$project$Lang$zeroWidthWSAfter(_p634),
										_user$project$Lang$Expr(_p634)),
									_1: {ctor: '[]'}
								}
							});
				}
			},
			_user$project$Lang$getDeclarationsInOrderWithIndex(declarations));
	});
var _user$project$Lang$GetterWS_ = function (a) {
	return {ctor: 'GetterWS_', _0: a};
};
var _user$project$Lang$ActualWS_ = function (a) {
	return {ctor: 'ActualWS_', _0: a};
};
var _user$project$Lang$childCodeObjects = function (co) {
	var mbWSToWSBeforeComma = function (mbWS) {
		var _p638 = mbWS;
		if (_p638.ctor === 'Nothing') {
			return _user$project$Lang$GetterWS_(_user$project$Lang$zeroWidthWSAfter);
		} else {
			return _user$project$Lang$ActualWS_(_p638._0);
		}
	};
	var genericListLike = F3(
		function (toCodeObject, toAfterTarget, itemsWithMBWSBeforeCommas) {
			return A2(
				_elm_lang$core$Tuple$mapFirst,
				_elm_lang$core$List$reverse,
				A3(
					_elm_lang$core$List$foldl,
					F2(
						function (_p640, _p639) {
							var _p641 = _p640;
							var _p645 = _p641._1;
							var _p642 = _p639;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									{
										ctor: '::',
										_0: toCodeObject(_p645),
										_1: {ctor: '[]'}
									},
									A2(
										_elm_lang$core$Basics_ops['++'],
										function () {
											var _p643 = {ctor: '_Tuple2', _0: _p642._1, _1: _p641._0};
											if (_p643._0.ctor === 'Nothing') {
												return {ctor: '[]'};
											} else {
												if (_p643._1.ctor === 'ActualWS_') {
													return {
														ctor: '::',
														_0: A2(toAfterTarget, _p643._1._0, _p643._0._0),
														_1: {ctor: '[]'}
													};
												} else {
													var _p644 = _p643._0._0;
													return {
														ctor: '::',
														_0: A2(
															toAfterTarget,
															_p643._1._0(_p644),
															_p644),
														_1: {ctor: '[]'}
													};
												}
											}
										}(),
										_p642._0)),
								_1: _elm_lang$core$Maybe$Just(_p645)
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: _elm_lang$core$Maybe$Nothing
					},
					itemsWithMBWSBeforeCommas));
		});
	var genericListLikeWithLastTarget = F4(
		function (toCodeObject, toAfterTarget, itemsWithMBWSBeforeCommas, wsa) {
			var _p646 = A3(genericListLike, toCodeObject, toAfterTarget, itemsWithMBWSBeforeCommas);
			var valueCOs = _p646._0;
			var mbLastValue = _p646._1;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				valueCOs,
				function () {
					var _p647 = mbLastValue;
					if (_p647.ctor === 'Nothing') {
						return {ctor: '[]'};
					} else {
						return {
							ctor: '::',
							_0: A2(toAfterTarget, wsa, _p647._0),
							_1: {ctor: '[]'}
						};
					}
				}());
		});
	var genericRecord = F3(
		function (toCodeObject, toAfterTarget, recs) {
			return A3(
				genericListLikeWithLastTarget,
				toCodeObject,
				toAfterTarget,
				A2(
					_elm_lang$core$List$map,
					function (_p648) {
						var _p649 = _p648;
						return {
							ctor: '_Tuple2',
							_0: mbWSToWSBeforeComma(_p649._0),
							_1: _p649._4
						};
					},
					recs));
		});
	var genericList = F6(
		function (toCodeObject, toAfterTarget, headsWithMBWSBeforeCommas, ws2, mbTail, ws3) {
			var _p650 = A3(genericListLike, toCodeObject, toAfterTarget, headsWithMBWSBeforeCommas);
			var headsWithSucceedingWhitespace = _p650._0;
			var lastHead = _p650._1;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				headsWithSucceedingWhitespace,
				function () {
					var _p651 = {ctor: '_Tuple2', _0: mbTail, _1: lastHead};
					if (_p651._0.ctor === 'Nothing') {
						if (_p651._1.ctor === 'Nothing') {
							return {ctor: '[]'};
						} else {
							return {
								ctor: '::',
								_0: A2(toAfterTarget, ws3, _p651._1._0),
								_1: {ctor: '[]'}
							};
						}
					} else {
						if (_p651._1.ctor === 'Nothing') {
							return {
								ctor: '::',
								_0: toCodeObject(_p651._0._0),
								_1: {ctor: '[]'}
							};
						} else {
							return {
								ctor: '::',
								_0: A2(toAfterTarget, ws2, _p651._1._0),
								_1: {
									ctor: '::',
									_0: toCodeObject(_p651._0._0),
									_1: {ctor: '[]'}
								}
							};
						}
					}
				}());
		});
	var insertPrecedingWhitespaceTargetBeforeEachChild = _elm_lang$core$List$concatMap(
		function (child) {
			var wsb = _user$project$Lang$wsBefore(child);
			return A2(
				_elm_lang$core$Basics_ops['++'],
				function () {
					var _p652 = child;
					switch (_p652.ctor) {
						case 'E':
							return {
								ctor: '::',
								_0: A3(_user$project$Lang$ET, _user$project$Lang$Before, wsb, _p652._0),
								_1: {ctor: '[]'}
							};
						case 'P':
							return {
								ctor: '::',
								_0: A4(_user$project$Lang$PT, _user$project$Lang$Before, wsb, _p652._0, _p652._1),
								_1: {ctor: '[]'}
							};
						case 'T':
							return {
								ctor: '::',
								_0: A3(_user$project$Lang$TT, _user$project$Lang$Before, wsb, _p652._0),
								_1: {ctor: '[]'}
							};
						default:
							return {ctor: '[]'};
					}
				}(),
				{
					ctor: '::',
					_0: child,
					_1: {ctor: '[]'}
				});
		});
	return A2(
		_elm_lang$core$List$filter,
		function (_p653) {
			return !_user$project$Lang$isHiddenCodeObject(_p653);
		},
		function () {
			var _p654 = co;
			switch (_p654.ctor) {
				case 'E':
					var _p679 = _p654._0;
					return insertPrecedingWhitespaceTargetBeforeEachChild(
						function () {
							var _p655 = _user$project$Lang$unwrapExp(_p679);
							switch (_p655.ctor) {
								case 'EFun':
									var _p660 = _p655._1;
									return A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$List$map,
											function (_p656) {
												var _p657 = _p656;
												return A2(
													_user$project$Lang$P,
													{ctor: '_Tuple2', _0: _p679, _1: _p657._1},
													_p657._0);
											},
											_user$project$Utils$zipWithIndex(_p660)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											function () {
												var _p658 = _user$project$Utils$maybeLast(_p660);
												if (_p658.ctor === 'Just') {
													var _p659 = _p658._0;
													return {
														ctor: '::',
														_0: A4(
															_user$project$Lang$PT,
															_user$project$Lang$After,
															_user$project$Lang$zeroWidthWSAfter(_p659),
															{
																ctor: '_Tuple2',
																_0: _p679,
																_1: _elm_lang$core$List$length(_p660) - 1
															},
															_p659),
														_1: {ctor: '[]'}
													};
												} else {
													return {ctor: '[]'};
												}
											}(),
											{
												ctor: '::',
												_0: _user$project$Lang$E(_p655._2),
												_1: {ctor: '[]'}
											}));
								case 'EApp':
									return A2(
										_elm_lang$core$Basics_ops['++'],
										{
											ctor: '::',
											_0: _user$project$Lang$E(_p655._1),
											_1: {ctor: '[]'}
										},
										A2(_elm_lang$core$List$map, _user$project$Lang$E, _p655._2));
								case 'EOp':
									return A2(
										_elm_lang$core$List$concatMap,
										function (_p661) {
											var _p662 = _p661;
											var _p663 = _p662._0;
											return {
												ctor: '::',
												_0: _user$project$Lang$E(
													_user$project$Lang$Expr(_p663)),
												_1: {
													ctor: '::',
													_0: A3(
														_user$project$Lang$ET,
														_user$project$Lang$After,
														_user$project$Lang$zeroWidthWSAfter(_p663),
														_user$project$Lang$Expr(_p663)),
													_1: {ctor: '[]'}
												}
											};
										},
										_p655._3);
								case 'EList':
									return A6(
										genericList,
										_user$project$Lang$E,
										_user$project$Lang$ET(_user$project$Lang$After),
										A2(
											_elm_lang$core$List$map,
											_elm_lang$core$Tuple$mapFirst(_user$project$Lang$ActualWS_),
											_p655._1),
										_p655._2,
										_p655._3,
										_p655._4);
								case 'ERecord':
									return A2(
										_elm_lang$core$Basics_ops['++'],
										function () {
											var _p664 = _p655._1;
											if (_p664.ctor === 'Just') {
												var _p665 = _p664._0._0;
												return {
													ctor: '::',
													_0: _user$project$Lang$E(_p665),
													_1: {
														ctor: '::',
														_0: A3(_user$project$Lang$ET, _user$project$Lang$After, _p664._0._1, _p665),
														_1: {ctor: '[]'}
													}
												};
											} else {
												return {ctor: '[]'};
											}
										}(),
										A2(_user$project$Lang$declarationsCodeObjects, _p679, _p655._2));
								case 'ESelect':
									return {
										ctor: '::',
										_0: _user$project$Lang$E(_p655._1),
										_1: {ctor: '[]'}
									};
								case 'EIf':
									var _p667 = _p655._3._0;
									var _p666 = _p655._1._0;
									return {
										ctor: '::',
										_0: _user$project$Lang$E(
											_user$project$Lang$Expr(_p666)),
										_1: {
											ctor: '::',
											_0: A3(
												_user$project$Lang$ET,
												_user$project$Lang$After,
												_user$project$Lang$zeroWidthWSAfter(_p666),
												_user$project$Lang$Expr(_p666)),
											_1: {
												ctor: '::',
												_0: _user$project$Lang$E(
													_user$project$Lang$Expr(_p667)),
												_1: {
													ctor: '::',
													_0: A3(
														_user$project$Lang$ET,
														_user$project$Lang$After,
														_user$project$Lang$zeroWidthWSAfter(_p667),
														_user$project$Lang$Expr(_p667)),
													_1: {
														ctor: '::',
														_0: _user$project$Lang$E(_p655._5),
														_1: {ctor: '[]'}
													}
												}
											}
										}
									};
								case 'ECase':
									var _p676 = _p655._1._0;
									return A2(
										_elm_lang$core$Basics_ops['++'],
										{
											ctor: '::',
											_0: _user$project$Lang$E(
												_user$project$Lang$Expr(_p676)),
											_1: {
												ctor: '::',
												_0: A3(
													_user$project$Lang$ET,
													_user$project$Lang$After,
													_user$project$Lang$zeroWidthWSAfter(_p676),
													_user$project$Lang$Expr(_p676)),
												_1: {ctor: '[]'}
											}
										},
										A2(
											_elm_lang$core$List$concatMap,
											function (_p668) {
												var _p669 = _p668;
												var _p675 = _p669._1;
												return function (_p670) {
													var _p671 = _p670;
													var _p674 = _p671._1;
													var _p673 = _p671._2;
													var _p672 = _p673;
													var branchE_ = _p672._0;
													return {
														ctor: '::',
														_0: A2(
															_user$project$Lang$P,
															{ctor: '_Tuple2', _0: _p679, _1: _p675},
															_p674),
														_1: {
															ctor: '::',
															_0: A4(
																_user$project$Lang$PT,
																_user$project$Lang$After,
																_p671._3,
																{ctor: '_Tuple2', _0: _p679, _1: _p675},
																_p674),
															_1: {
																ctor: '::',
																_0: _user$project$Lang$E(_p673),
																_1: {
																	ctor: '::',
																	_0: A3(
																		_user$project$Lang$ET,
																		_user$project$Lang$After,
																		_user$project$Lang$zeroWidthWSAfter(branchE_),
																		_p673),
																	_1: {ctor: '[]'}
																}
															}
														}
													};
												}(_p669._0.val);
											},
											_user$project$Utils$zipWithIndex(_p655._2)));
								case 'ELet':
									return A2(
										_elm_lang$core$Basics_ops['++'],
										A2(_user$project$Lang$declarationsCodeObjects, _p679, _p655._2),
										{
											ctor: '::',
											_0: _user$project$Lang$E(_p655._4),
											_1: {ctor: '[]'}
										});
								case 'EColonType':
									var _p677 = _p655._1;
									return {
										ctor: '::',
										_0: _user$project$Lang$E(_p677),
										_1: {
											ctor: '::',
											_0: A3(_user$project$Lang$ET, _user$project$Lang$After, _p655._2, _p677),
											_1: {
												ctor: '::',
												_0: _user$project$Lang$T(_p655._3),
												_1: {ctor: '[]'}
											}
										}
									};
								case 'EParens':
									var _p678 = _p655._1;
									return {
										ctor: '::',
										_0: _user$project$Lang$E(_p678),
										_1: {
											ctor: '::',
											_0: A3(_user$project$Lang$ET, _user$project$Lang$After, _p655._3, _p678),
											_1: {ctor: '[]'}
										}
									};
								default:
									return {ctor: '[]'};
							}
						}());
				case 'P':
					var _p684 = _p654._0;
					return insertPrecedingWhitespaceTargetBeforeEachChild(
						function () {
							var _p680 = _p654._1.val.p__;
							switch (_p680.ctor) {
								case 'PList':
									return A6(
										genericList,
										_user$project$Lang$P(_p684),
										function (ws) {
											return A3(_user$project$Lang$PT, _user$project$Lang$After, ws, _p684);
										},
										A2(
											_elm_lang$core$List$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(
												_user$project$Lang$GetterWS_(_user$project$Lang$zeroWidthWSAfter)),
											_p680._1),
										_p680._2,
										_p680._3,
										_p680._4);
								case 'PRecord':
									return A4(
										genericRecord,
										_user$project$Lang$P(_p684),
										function (ws) {
											return A3(_user$project$Lang$PT, _user$project$Lang$After, ws, _p684);
										},
										_p680._1,
										_p680._2);
								case 'PAs':
									var _p681 = _p680._1;
									return {
										ctor: '::',
										_0: A2(_user$project$Lang$P, _p684, _p681),
										_1: {
											ctor: '::',
											_0: A4(
												_user$project$Lang$PT,
												_user$project$Lang$After,
												_user$project$Lang$zeroWidthWSAfter(_p681),
												_p684,
												_p681),
											_1: {
												ctor: '::',
												_0: A2(_user$project$Lang$P, _p684, _p680._3),
												_1: {ctor: '[]'}
											}
										}
									};
								case 'PParens':
									var _p682 = _p680._1;
									return {
										ctor: '::',
										_0: A2(_user$project$Lang$P, _p684, _p682),
										_1: {
											ctor: '::',
											_0: A4(_user$project$Lang$PT, _user$project$Lang$After, _p680._2, _p684, _p682),
											_1: {ctor: '[]'}
										}
									};
								case 'PColonType':
									var _p683 = _p680._1;
									return {
										ctor: '::',
										_0: A2(_user$project$Lang$P, _p684, _p683),
										_1: {
											ctor: '::',
											_0: A4(_user$project$Lang$PT, _user$project$Lang$After, _p680._2, _p684, _p683),
											_1: {
												ctor: '::',
												_0: _user$project$Lang$T(_p680._3),
												_1: {ctor: '[]'}
											}
										}
									};
								default:
									return {ctor: '[]'};
							}
						}());
				case 'T':
					var _p687 = _p654._0;
					return insertPrecedingWhitespaceTargetBeforeEachChild(
						function () {
							var _p685 = _p687.val.t__;
							switch (_p685.ctor) {
								case 'TList':
									return {
										ctor: '::',
										_0: _user$project$Lang$T(_p685._1),
										_1: {ctor: '[]'}
									};
								case 'TDict':
									return {
										ctor: '::',
										_0: _user$project$Lang$T(_p685._1),
										_1: {
											ctor: '::',
											_0: _user$project$Lang$T(_p685._2),
											_1: {ctor: '[]'}
										}
									};
								case 'TTuple':
									return A6(
										genericList,
										_user$project$Lang$T,
										_user$project$Lang$TT(_user$project$Lang$After),
										A2(
											_elm_lang$core$List$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(
												_user$project$Lang$GetterWS_(_user$project$Lang$zeroWidthWSAfter)),
											_p685._1),
										_p685._2,
										_p685._3,
										_p685._4);
								case 'TRecord':
									return A4(
										genericRecord,
										_user$project$Lang$T,
										_user$project$Lang$TT(_user$project$Lang$After),
										_p685._2,
										_p685._3);
								case 'TArrow':
									return A4(
										genericListLikeWithLastTarget,
										_user$project$Lang$T,
										_user$project$Lang$TT(_user$project$Lang$After),
										A2(
											_elm_lang$core$List$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(
												_user$project$Lang$GetterWS_(_user$project$Lang$zeroWidthWSAfter)),
											_p685._1),
										_p685._2);
								case 'TUnion':
									return A4(
										genericListLikeWithLastTarget,
										_user$project$Lang$T,
										_user$project$Lang$TT(_user$project$Lang$After),
										A2(
											_elm_lang$core$List$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(
												_user$project$Lang$GetterWS_(_user$project$Lang$zeroWidthWSAfter)),
											_p685._1),
										_p685._2);
								case 'TApp':
									return A2(_elm_lang$core$List$map, _user$project$Lang$T, _p685._2);
								case 'TForall':
									var _p686 = _p685._2;
									return {
										ctor: '::',
										_0: _user$project$Lang$T(_p686),
										_1: {
											ctor: '::',
											_0: A3(_user$project$Lang$TT, _user$project$Lang$After, _p685._3, _p686),
											_1: {ctor: '[]'}
										}
									};
								case 'TParens':
									return {
										ctor: '::',
										_0: _user$project$Lang$T(_p685._1),
										_1: {
											ctor: '::',
											_0: A3(_user$project$Lang$TT, _user$project$Lang$After, _p685._2, _p687),
											_1: {ctor: '[]'}
										}
									};
								default:
									return {ctor: '[]'};
							}
						}());
				case 'D':
					return {ctor: '[]'};
				case 'DT':
					return {ctor: '[]'};
				case 'ET':
					return {ctor: '[]'};
				case 'PT':
					return {ctor: '[]'};
				default:
					return {ctor: '[]'};
			}
		}());
};
var _user$project$Lang$flattenToCodeObjects = function (codeObject) {
	return {
		ctor: '::',
		_0: codeObject,
		_1: A2(
			_elm_lang$core$List$concatMap,
			_user$project$Lang$flattenToCodeObjects,
			_user$project$Lang$childCodeObjects(codeObject))
	};
};
var _user$project$Lang$foldCode = F3(
	function (f, acc, code) {
		return A3(
			_elm_lang$core$List$foldl,
			f,
			acc,
			_user$project$Lang$flattenToCodeObjects(code));
	});
var _user$project$Lang$ListElemDelete = function (a) {
	return {ctor: 'ListElemDelete', _0: a};
};
var _user$project$Lang$ListElemInsert = function (a) {
	return {ctor: 'ListElemInsert', _0: a};
};
var _user$project$Lang$ListElemUpdate = function (a) {
	return {ctor: 'ListElemUpdate', _0: a};
};
var _user$project$Lang$VDictElemUpdate = function (a) {
	return {ctor: 'VDictElemUpdate', _0: a};
};
var _user$project$Lang$VDictElemInsert = {ctor: 'VDictElemInsert'};
var _user$project$Lang$VDictElemDelete = {ctor: 'VDictElemDelete'};
var _user$project$Lang$StringUpdate = F3(
	function (a, b, c) {
		return {ctor: 'StringUpdate', _0: a, _1: b, _2: c};
	});
var _user$project$Lang$offsetStr = F2(
	function (n, diffs) {
		return A2(
			_elm_lang$core$List$map,
			function (sd) {
				var _p688 = sd;
				return A3(_user$project$Lang$StringUpdate, _p688._0 + n, _p688._1 + n, _p688._2);
			},
			diffs);
	});
var _user$project$Lang$VConstDiffs = {ctor: 'VConstDiffs'};
var _user$project$Lang$VRecordDiffs = function (a) {
	return {ctor: 'VRecordDiffs', _0: a};
};
var _user$project$Lang$VDictDiffs = function (a) {
	return {ctor: 'VDictDiffs', _0: a};
};
var _user$project$Lang$VStringDiffs = function (a) {
	return {ctor: 'VStringDiffs', _0: a};
};
var _user$project$Lang$VListDiffs = function (a) {
	return {ctor: 'VListDiffs', _0: a};
};
var _user$project$Lang$vHtmlTextDiffs = function (d) {
	return _user$project$Lang$VListDiffs(
		{
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 1,
				_1: _user$project$Lang$ListElemUpdate(d)
			},
			_1: {ctor: '[]'}
		});
};
var _user$project$Lang$VClosureDiffs = F2(
	function (a, b) {
		return {ctor: 'VClosureDiffs', _0: a, _1: b};
	});
var _user$project$Lang$diffOps = {
	mbVClosureDiffs: F2(
		function (envDiffs, mbBodyDiffs) {
			return ((!_elm_lang$core$Native_Utils.eq(
				envDiffs,
				{ctor: '[]'})) || (!_elm_lang$core$Native_Utils.eq(mbBodyDiffs, _elm_lang$core$Maybe$Nothing))) ? _elm_lang$core$Maybe$Just(
				A2(_user$project$Lang$VClosureDiffs, envDiffs, mbBodyDiffs)) : _elm_lang$core$Maybe$Nothing;
		})
};
var _user$project$Lang$updated = {
	vClosure: F5(
		function (valBuilder, recNames, p, updatedExp, updatedEnv) {
			return A2(
				_user$project$Lang$UpdatedVal,
				valBuilder(
					A4(_user$project$Lang$VClosure, recNames, p, updatedExp.val, updatedEnv.val)),
				A2(_user$project$Lang$diffOps.mbVClosureDiffs, updatedEnv.changes, updatedExp.changes));
		}),
	env: function (namesUpdatedVals) {
		var _p689 = A3(
			_user$project$Utils$foldLeftWithIndex,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'}
			},
			namesUpdatedVals,
			F3(
				function (_p691, index, _p690) {
					var _p692 = _p691;
					var _p698 = _p692._0;
					var _p697 = _p692._1;
					var _p693 = _p690;
					var _p696 = _p693._1.val;
					var _p695 = _p693._0;
					var _p694 = _p693._1.changes;
					if (_p694.ctor === 'Nothing') {
						return {
							ctor: '_Tuple2',
							_0: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p695, _1: _p696},
								_1: _p698
							},
							_1: _p697
						};
					} else {
						return {
							ctor: '_Tuple2',
							_0: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p695, _1: _p696},
								_1: _p698
							},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: index, _1: _p694._0},
								_1: _p697
							}
						};
					}
				}));
		var revEnv = _p689._0;
		var revDiffs = _p689._1;
		return A2(
			_user$project$Lang$UpdatedEnv,
			_elm_lang$core$List$reverse(revEnv),
			_elm_lang$core$List$reverse(revDiffs));
	}
};
var _user$project$Lang$EChildDiffs = function (a) {
	return {ctor: 'EChildDiffs', _0: a};
};
var _user$project$Lang$eChildDiffs = _elm_lang$core$Maybe$map(_user$project$Lang$EChildDiffs);
var _user$project$Lang$EStringDiffs = function (a) {
	return {ctor: 'EStringDiffs', _0: a};
};
var _user$project$Lang$EListDiffs = function (a) {
	return {ctor: 'EListDiffs', _0: a};
};
var _user$project$Lang$EConstDiffs = function (a) {
	return {ctor: 'EConstDiffs', _0: a};
};
var _user$project$Lang$EAnyDiffs = {ctor: 'EAnyDiffs'};
var _user$project$Lang$EOnlyWhitespaceDiffs = {ctor: 'EOnlyWhitespaceDiffs'};
var _user$project$Lang$InputsWithDiffs = function (a) {
	return {ctor: 'InputsWithDiffs', _0: a};
};
var _user$project$Lang$Inputs = function (a) {
	return {ctor: 'Inputs', _0: a};
};

var _user$project$Record$nth = F3(
	function (bv, index, labelMatcher) {
		return A2(
			_user$project$Utils$count,
			labelMatcher,
			A2(_elm_lang$core$List$drop, index + 1, bv)) + 1;
	});
var _user$project$Record$nthIndexWhere = F3(
	function (a, nth, f) {
		var aux = F3(
			function (it, index, n) {
				aux:
				while (true) {
					var _p0 = it;
					if (_p0.ctor === '[]') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						var _p2 = _p0._1;
						var _p1 = _p0._0;
						if (f(_p1)) {
							if (_elm_lang$core$Native_Utils.eq(n + 1, nth)) {
								return _elm_lang$core$Maybe$Just(
									{ctor: '_Tuple2', _0: _p1, _1: index});
							} else {
								var _v1 = _p2,
									_v2 = index + 1,
									_v3 = n + 1;
								it = _v1;
								index = _v2;
								n = _v3;
								continue aux;
							}
						} else {
							var _v4 = _p2,
								_v5 = index + 1,
								_v6 = n;
							it = _v4;
							index = _v5;
							n = _v6;
							continue aux;
						}
					}
				}
			});
		return A3(aux, a, 0, 0);
	});
var _user$project$Record$nthlastIndexWhere = F3(
	function (a, nth, f) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p3) {
				var _p4 = _p3;
				return {
					ctor: '_Tuple2',
					_0: _p4._0,
					_1: (_elm_lang$core$List$length(a) - 1) - _p4._1
				};
			},
			A3(
				_user$project$Record$nthIndexWhere,
				_elm_lang$core$List$reverse(a),
				nth,
				f));
	});
var _user$project$Record$mapWithNth = F2(
	function (sameKeys, labelValues) {
		return A2(
			_elm_lang$core$List$indexedMap,
			F2(
				function (i, lv) {
					var n = A3(
						_user$project$Record$nth,
						labelValues,
						i,
						sameKeys(lv));
					return {ctor: '_Tuple2', _0: lv, _1: n};
				}),
			labelValues);
	});
var _user$project$Record$ReplaceAtPos = F3(
	function (a, b, c) {
		return {ctor: 'ReplaceAtPos', _0: a, _1: b, _2: c};
	});
var _user$project$Record$InsertAtPos = F4(
	function (a, b, c, d) {
		return {ctor: 'InsertAtPos', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Record$getMergeOperations = F4(
	function (keyA, keyB, av, bv) {
		var lastIndex = {value: -2};
		var lastIndexSet = A2(_user$project$ImpureGoodies$mutateRecordField, lastIndex, 'value');
		var sorter = F2(
			function (x, y) {
				var _p5 = {ctor: '_Tuple2', _0: x, _1: y};
				_v8_1:
				do {
					_v8_0:
					do {
						if (_p5._0.ctor === 'InsertAtPos') {
							if (_p5._1.ctor === 'InsertAtPos') {
								if (_p5._0._0 === -1) {
									break _v8_0;
								} else {
									if (_p5._1._0 === -1) {
										break _v8_1;
									} else {
										var _p9 = _p5._1._1;
										var _p8 = _p5._0._1;
										var _p7 = _p5._1._0;
										var _p6 = _p5._0._0;
										return ((_elm_lang$core$Native_Utils.cmp(_p6, _p7) > 0) || (_elm_lang$core$Native_Utils.eq(_p6, _p7) && (_elm_lang$core$Native_Utils.cmp(_p8, _p9) < 0))) ? _elm_lang$core$Basics$LT : ((_elm_lang$core$Native_Utils.eq(_p6, _p7) && _elm_lang$core$Native_Utils.eq(_p8, _p9)) ? _elm_lang$core$Basics$EQ : _elm_lang$core$Basics$GT);
									}
								}
							} else {
								if (_p5._0._0 === -1) {
									break _v8_0;
								} else {
									return (_elm_lang$core$Native_Utils.cmp(_p5._0._0, _p5._1._0) > 0) ? _elm_lang$core$Basics$LT : _elm_lang$core$Basics$GT;
								}
							}
						} else {
							if (_p5._1.ctor === 'ReplaceAtPos') {
								var _p11 = _p5._1._0;
								var _p10 = _p5._0._0;
								return (_elm_lang$core$Native_Utils.cmp(_p10, _p11) > 0) ? _elm_lang$core$Basics$LT : (_elm_lang$core$Native_Utils.eq(_p10, _p11) ? _elm_lang$core$Basics$EQ : _elm_lang$core$Basics$GT);
							} else {
								if (_p5._1._0 === -1) {
									break _v8_1;
								} else {
									return (_elm_lang$core$Native_Utils.cmp(_p5._0._0, _p5._1._0) > -1) ? _elm_lang$core$Basics$LT : _elm_lang$core$Basics$GT;
								}
							}
						}
					} while(false);
					return _elm_lang$core$Basics$LT;
				} while(false);
				return _elm_lang$core$Basics$GT;
			});
		var bvIndexed = _user$project$Utils$zipWithIndex(bv);
		var sameBB = F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(
					keyB(x),
					keyB(y));
			});
		var sameBA = F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.eq(
					keyB(x),
					keyA(y));
			});
		return A2(
			_elm_lang$core$List$sortWith,
			sorter,
			A2(
				_elm_lang$core$List$map,
				function (_p12) {
					var _p13 = _p12;
					var _p22 = _p13._0;
					var _p21 = _p13._1;
					var n = A3(
						_user$project$Record$nth,
						bv,
						_p21,
						sameBB(_p22));
					var _p14 = A3(
						_user$project$Record$nthlastIndexWhere,
						av,
						n,
						sameBA(_p22));
					if (_p14.ctor === 'Nothing') {
						if (_elm_lang$core$Native_Utils.eq(lastIndex.value, -2)) {
							var possibilities = A2(
								_elm_lang$core$List$filterMap,
								function (_p15) {
									var _p16 = _p15;
									var _p17 = _p16._0;
									var n2 = A3(
										_user$project$Record$nth,
										bv,
										_p16._1,
										sameBB(_p17));
									return A2(
										_elm_lang$core$Maybe$map,
										_elm_lang$core$Tuple$second,
										A3(
											_user$project$Record$nthlastIndexWhere,
											av,
											n2,
											sameBA(_p17)));
								},
								A2(_elm_lang$core$List$drop, _p21 + 1, bvIndexed));
							var headOfPossibilities = function () {
								var _p18 = possibilities;
								if (_p18.ctor === '::') {
									return _p18._0;
								} else {
									return -1;
								}
							}();
							return A4(_user$project$Record$InsertAtPos, headOfPossibilities, n, _p21, _p22);
						} else {
							return A4(_user$project$Record$InsertAtPos, lastIndex.value + 1, n, _p21, _p22);
						}
					} else {
						var _p20 = _p14._0._1;
						var _p19 = lastIndexSet(_p20);
						return A3(
							_user$project$Record$ReplaceAtPos,
							_p20,
							_p21,
							{ctor: '_Tuple2', _0: _p14._0._0, _1: _p22});
					}
				},
				bvIndexed));
	});
var _user$project$Record$getPatternMatch = F4(
	function (keyPat, keyRecord, patElems, recordElems) {
		return _user$project$Utils$projJusts(
			A2(
				_elm_lang$core$List$map,
				function (mo) {
					var _p23 = mo;
					if (_p23.ctor === 'InsertAtPos') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Just(
							{ctor: '_Tuple2', _0: _p23._2._1, _1: _p23._2._0});
					}
				},
				A4(_user$project$Record$getMergeOperations, keyRecord, keyPat, recordElems, patElems)));
	});
var _user$project$Record$mergeLabelValues = F3(
	function (keyA, av, bv) {
		var mergingOperations = A4(_user$project$Record$getMergeOperations, keyA, keyA, av, bv);
		var newRecord = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (p, avNew) {
					var _p24 = p;
					if (_p24.ctor === 'ReplaceAtPos') {
						return A3(_user$project$Utils$updated, avNew, _p24._0, _p24._2._1);
					} else {
						if (_p24._0 === -1) {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								avNew,
								{
									ctor: '::',
									_0: _p24._3,
									_1: {ctor: '[]'}
								});
						} else {
							return A3(_user$project$Utils$inserted, avNew, _p24._0, _p24._3);
						}
					}
				}),
			av,
			mergingOperations);
		return newRecord;
	});
var _user$project$Record$InsertToRight = function (a) {
	return {ctor: 'InsertToRight', _0: a};
};
var _user$project$Record$InsertToLeft = function (a) {
	return {ctor: 'InsertToLeft', _0: a};
};
var _user$project$Record$getMergeMapping = F4(
	function (keyA, av, bv, out) {
		var mergingOperations = A4(_user$project$Record$getMergeOperations, keyA, keyA, av, bv);
		var avIndices = A2(
			_elm_lang$core$List$range,
			0,
			_elm_lang$core$List$length(av) - 1);
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (p, avNew) {
					var _p25 = p;
					if (_p25.ctor === 'ReplaceAtPos') {
						return A3(
							_user$project$Utils$updated,
							avNew,
							_p25._0,
							_user$project$Record$InsertToRight(_p25._1));
					} else {
						if (_p25._0 === -1) {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								avNew,
								{
									ctor: '::',
									_0: _user$project$Record$InsertToRight(_p25._2),
									_1: {ctor: '[]'}
								});
						} else {
							return A3(
								_user$project$Utils$inserted,
								avNew,
								_p25._0,
								_user$project$Record$InsertToRight(_p25._2));
						}
					}
				}),
			A2(_elm_lang$core$List$map, _user$project$Record$InsertToLeft, avIndices),
			mergingOperations);
	});

var _user$project$ValUnparser$strLoc = function (_p0) {
	var _p1 = _p0;
	var _p2 = _p1._2;
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'k',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$Basics$toString(_p1._0),
			A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$Native_Utils.eq(_p2, '') ? '' : A2(_elm_lang$core$Basics_ops['++'], '_', _p2),
				_p1._1)));
};
var _user$project$ValUnparser$strOp = function (op) {
	var _p3 = op;
	switch (_p3.ctor) {
		case 'Plus':
			return '+';
		case 'Minus':
			return '-';
		case 'Mult':
			return '*';
		case 'Div':
			return '/';
		case 'Lt':
			return '<';
		case 'Eq':
			return '=';
		case 'Pow':
			return '^';
		case 'Pi':
			return 'pi';
		case 'Cos':
			return 'cos';
		case 'Sin':
			return 'sin';
		case 'ArcCos':
			return 'arccos';
		case 'ArcSin':
			return 'arcsin';
		case 'ArcTan2':
			return 'arctan2';
		case 'Floor':
			return 'floor';
		case 'Ceil':
			return 'ceiling';
		case 'Round':
			return 'round';
		case 'ToStr':
			return 'toString';
		case 'Explode':
			return 'explode';
		case 'Sqrt':
			return 'sqrt';
		case 'Mod':
			return 'mod';
		case 'DictEmpty':
			return '__DictEmpty__';
		case 'DictFromList':
			return '__DictFromList__';
		case 'DictInsert':
			return '__DictInsert__';
		case 'DictGet':
			return '__DictGet__';
		case 'DictRemove':
			return '__DictRemove__';
		case 'DebugLog':
			return 'debug';
		case 'NoWidgets':
			return 'noWidgets';
		case 'ToStrExceptStr':
			return 'ToStrExceptStr';
		case 'RegexExtractFirstIn':
			return 'extractFirstIn';
		case 'CurrentEnv':
			return '__CurrentEnv__';
		default:
			return '__strLength__';
	}
};
var _user$project$ValUnparser$strTrace = function (tr) {
	var _p4 = tr;
	if (_p4.ctor === 'TrLoc') {
		return _user$project$ValUnparser$strLoc(_p4._0);
	} else {
		return _user$project$Utils$parens(
			_elm_lang$core$String$concat(
				{
					ctor: '::',
					_0: _user$project$ValUnparser$strOp(_p4._0),
					_1: {
						ctor: '::',
						_0: ' ',
						_1: {
							ctor: '::',
							_0: A2(
								_elm_lang$core$String$join,
								' ',
								A2(_elm_lang$core$List$map, _user$project$ValUnparser$strTrace, _p4._1)),
							_1: {ctor: '[]'}
						}
					}
				}));
	}
};
var _user$project$ValUnparser$strNum = _elm_lang$core$Basics$toString;
var _user$project$ValUnparser$strNumTrunc = function (k) {
	return function (_p5) {
		return function (s) {
			return (_elm_lang$core$Native_Utils.cmp(
				_elm_lang$core$String$length(s),
				k) > 0) ? A2(
				_elm_lang$core$Basics_ops['++'],
				A2(_elm_lang$core$String$left, k, s),
				'..') : s;
		}(
			_user$project$ValUnparser$strNum(_p5));
	};
};
var _user$project$ValUnparser$strBaseVal = function (v) {
	var _p6 = v;
	switch (_p6.ctor) {
		case 'VBool':
			if (_p6._0 === true) {
				return 'true';
			} else {
				return 'false';
			}
		case 'VString':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'\'',
				A2(_elm_lang$core$Basics_ops['++'], _p6._0, '\''));
		default:
			return 'null';
	}
};
var _user$project$ValUnparser$strVal_ = F2(
	function (showTraces, v) {
		var recurse = _user$project$ValUnparser$strVal_(showTraces);
		var _p7 = v.v_;
		switch (_p7.ctor) {
			case 'VConst':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$ValUnparser$strNum(_p7._1._0),
					showTraces ? A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Utils$angleBracks(
							_elm_lang$core$Basics$toString(_p7._0)),
						_user$project$Utils$braces(
							_user$project$ValUnparser$strTrace(_p7._1._1))) : '');
			case 'VBase':
				return _user$project$ValUnparser$strBaseVal(_p7._0);
			case 'VClosure':
				return '<fun>';
			case 'VList':
				return _user$project$Utils$bracks(
					A2(
						_elm_lang$core$String$join,
						' ',
						A2(_elm_lang$core$List$map, recurse, _p7._0)));
			case 'VDict':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'<dict ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$String$join,
							' ',
							A2(
								_elm_lang$core$List$map,
								function (_p8) {
									var _p9 = _p8;
									return A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(_p9._0),
										A2(
											_elm_lang$core$Basics_ops['++'],
											':',
											recurse(_p9._1)));
								},
								_elm_lang$core$Dict$toList(_p7._0))),
						'>'));
			case 'VRecord':
				var _p11 = _p7._0;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'<record ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$String$join,
							' ',
							A2(
								_elm_lang$core$List$map,
								function (k) {
									var _p10 = A2(_elm_lang$core$Dict$get, k, _p11);
									if (_p10.ctor === 'Nothing') {
										return '';
									} else {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											k,
											A2(
												_elm_lang$core$Basics_ops['++'],
												':',
												recurse(_p10._0)));
									}
								},
								_elm_lang$core$Dict$keys(_p11))),
						'>'));
			default:
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'<fun name=',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p7._0,
						A2(
							_elm_lang$core$Basics_ops['++'],
							' arity=',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(_p7._1),
								A2(
									_elm_lang$core$Basics_ops['++'],
									function () {
										var _p12 = _p7._3;
										if (_p12.ctor === 'Just') {
											return ' reversible';
										} else {
											return '';
										}
									}(),
									'>')))));
		}
	});
var _user$project$ValUnparser$strVal = _user$project$ValUnparser$strVal_(false);
var _user$project$ValUnparser$strValLocs = _user$project$ValUnparser$strVal_(true);

var _user$project$LangParserUtils$implodeStyleValue = function (content) {
	return A2(
		_elm_lang$core$String$join,
		';',
		A2(
			_elm_lang$core$List$map,
			function (_p0) {
				var _p1 = _p0;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p1._0,
					A2(_elm_lang$core$Basics_ops['++'], ':', _p1._1));
			},
			content));
};
var _user$project$LangParserUtils$styleSplitRegex = _elm_lang$core$Regex$regex('(?=;\\s*\\S)');
var _user$project$LangParserUtils$explodeStyleValue = function (content) {
	return A2(
		_elm_lang$core$List$filterMap,
		function (s) {
			var _p2 = A3(
				_elm_lang$core$Regex$find,
				_elm_lang$core$Regex$AtMost(1),
				_elm_lang$core$Regex$regex('^(;?)([\\s\\S]*)(:)([\\s\\S]*?)(;?\\s*)$'),
				s);
			if ((_p2.ctor === '::') && (_p2._1.ctor === '[]')) {
				var _p3 = _p2._0.submatches;
				if (((((((((((_p3.ctor === '::') && (_p3._0.ctor === 'Just')) && (_p3._1.ctor === '::')) && (_p3._1._0.ctor === 'Just')) && (_p3._1._1.ctor === '::')) && (_p3._1._1._0.ctor === 'Just')) && (_p3._1._1._1.ctor === '::')) && (_p3._1._1._1._0.ctor === 'Just')) && (_p3._1._1._1._1.ctor === '::')) && (_p3._1._1._1._1._0.ctor === 'Just')) && (_p3._1._1._1._1._1.ctor === '[]')) {
					return _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple5', _0: _p3._0._0, _1: _p3._1._0._0, _2: _p3._1._1._0._0, _3: _p3._1._1._1._0._0, _4: _p3._1._1._1._1._0._0});
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$LangParserUtils$styleSplitRegex, content));
};
var _user$project$LangParserUtils$mapWSInfo = function (_p4) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfoWS(_p4));
}(_elm_lang$core$Basics$identity);
var _user$project$LangParserUtils$mapWSExp_ = function (_p5) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfoWS(_p5));
}(_user$project$Lang$exp_);
var _user$project$LangParserUtils$mapExp_ = function (_p6) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfo(_p6));
}(_user$project$Lang$exp_);
var _user$project$LangParserUtils$mapWSType_ = function (_p7) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfoWS(_p7));
}(_user$project$Lang$type_);
var _user$project$LangParserUtils$mapType_ = function (_p8) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfo(_p8));
}(_user$project$Lang$type_);
var _user$project$LangParserUtils$mapWSPat_ = function (_p9) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfoWS(_p9));
}(_user$project$Lang$pat_);
var _user$project$LangParserUtils$mapPat_ = function (_p10) {
	return _MikaelMayer$parser$Parser$map(
		_user$project$Info$mapInfo(_p10));
}(_user$project$Lang$pat_);
var _user$project$LangParserUtils$unwrapInfo = _MikaelMayer$parser$Parser$map(
	F2(
		function (_p11, a) {
			var _p12 = _p11;
			return A3(
				_user$project$Info$withInfo,
				_p12.val(a),
				_p12.start,
				_p12.end);
		}));
var _user$project$LangParserUtils$transferInfo = F2(
	function (combiner, p) {
		return A2(
			_MikaelMayer$parser$Parser$map,
			function (x) {
				return A3(
					_user$project$Info$withInfo,
					combiner(x.val),
					x.start,
					x.end);
			},
			p);
	});
var _user$project$LangParserUtils$paddedBefore = F3(
	function (combiner, sp, p) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (wsBefore, x) {
					return A3(
						_user$project$Info$withInfo,
						A2(combiner, wsBefore, x.val),
						x.start,
						x.end);
				}),
			sp,
			p);
	});
var _user$project$LangParserUtils$spaceSaverKeyword = F3(
	function (sp, kword, combiner) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (ws, _p13) {
					return A3(
						_user$project$Info$withInfo,
						combiner(ws),
						ws.start,
						ws.end);
				}),
			sp,
			_MikaelMayer$parser$Parser$keyword(kword));
	});
var _user$project$LangParserUtils$isRestChar = function ($char) {
	return _elm_lang$core$Char$isLower($char) || (_elm_lang$core$Char$isUpper($char) || (_elm_lang$core$Char$isDigit($char) || (_elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('_')) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('$')))));
};
var _user$project$LangParserUtils$guardSpace = _user$project$ParserUtils$trackInfo(
	A2(
		_MikaelMayer$parser$Parser$andThen,
		function (_p14) {
			var _p15 = _p14;
			var _p17 = _p15._0;
			return A2(
				_user$project$ParserUtils$guard,
				'expecting space or an opening parenthese',
				A2(
					_elm_lang$core$String$all,
					function (_p16) {
						return !_user$project$LangParserUtils$isRestChar(_p16);
					},
					A3(_elm_lang$core$String$slice, _p17, _p17 + 1, _p15._1)));
		},
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})),
				_MikaelMayer$parser$Parser_LowLevel$getOffset),
			_MikaelMayer$parser$Parser_LowLevel$getSource)));
var _user$project$LangParserUtils$keywordWithSpace = function (kword) {
	return _user$project$ParserUtils$trackInfo(
		A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				_MikaelMayer$parser$Parser$succeed(
					{ctor: '_Tuple0'}),
				_MikaelMayer$parser$Parser$keyword(kword)),
			_user$project$LangParserUtils$guardSpace));
};
var _user$project$LangParserUtils$isFirstChar = function ($char) {
	return _elm_lang$core$Char$isLower($char) || (_elm_lang$core$Char$isUpper($char) || (_elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('_')) || _elm_lang$core$Native_Utils.eq(
		$char,
		_elm_lang$core$Native_Utils.chr('$'))));
};
var _user$project$LangParserUtils$nospace = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$succeed(''));
var _user$project$LangParserUtils$oldLineComment = A2(
	_MikaelMayer$parser$Parser_ops['|.'],
	A2(
		_MikaelMayer$parser$Parser_ops['|.'],
		_MikaelMayer$parser$Parser$symbol(';'),
		A2(
			_MikaelMayer$parser$Parser$ignore,
			_MikaelMayer$parser$Parser$zeroOrMore,
			function (c) {
				return !_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('\n'));
			})),
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$symbol('\n'),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$end,
				_1: {ctor: '[]'}
			}
		}));
var _user$project$LangParserUtils$nestableIgnore = F2(
	function (ignoreParser, keepParser) {
		return A3(
			_MikaelMayer$parser$Parser$map2,
			F2(
				function (a, b) {
					return b;
				}),
			ignoreParser,
			keepParser);
	});
var _user$project$LangParserUtils$nestableCommentHelp = F4(
	function (isNotRelevant, start, end, nestLevel) {
		return _MikaelMayer$parser$Parser$lazy(
			function (_p18) {
				return A2(
					_user$project$LangParserUtils$nestableIgnore,
					A2(_MikaelMayer$parser$Parser$ignore, _MikaelMayer$parser$Parser$zeroOrMore, isNotRelevant),
					_MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: A2(
								_user$project$LangParserUtils$nestableIgnore,
								_MikaelMayer$parser$Parser$symbol(end),
								_elm_lang$core$Native_Utils.eq(nestLevel, 1) ? _MikaelMayer$parser$Parser$succeed(
									{ctor: '_Tuple0'}) : A4(_user$project$LangParserUtils$nestableCommentHelp, isNotRelevant, start, end, nestLevel - 1)),
							_1: {
								ctor: '::',
								_0: A2(
									_user$project$LangParserUtils$nestableIgnore,
									_MikaelMayer$parser$Parser$symbol(start),
									A4(_user$project$LangParserUtils$nestableCommentHelp, isNotRelevant, start, end, nestLevel + 1)),
								_1: {
									ctor: '::',
									_0: A2(
										_user$project$LangParserUtils$nestableIgnore,
										A2(
											_MikaelMayer$parser$Parser$ignore,
											_MikaelMayer$parser$Parser$Exactly(1),
											function (_p19) {
												return true;
											}),
										A4(_user$project$LangParserUtils$nestableCommentHelp, isNotRelevant, start, end, nestLevel)),
									_1: {ctor: '[]'}
								}
							}
						}));
			});
	});
var _user$project$LangParserUtils$nestableComment = F2(
	function (start, end) {
		var _p20 = {
			ctor: '_Tuple2',
			_0: _elm_lang$core$String$uncons(start),
			_1: _elm_lang$core$String$uncons(end)
		};
		if (_p20._0.ctor === 'Nothing') {
			return _MikaelMayer$parser$Parser$fail('Trying to parse a multi-line comment, but the start token cannot be the empty string!');
		} else {
			if (_p20._1.ctor === 'Nothing') {
				return _MikaelMayer$parser$Parser$fail('Trying to parse a multi-line comment, but the end token cannot be the empty string!');
			} else {
				var isNotRelevant = function ($char) {
					return (!_elm_lang$core$Native_Utils.eq($char, _p20._0._0._0)) && (!_elm_lang$core$Native_Utils.eq($char, _p20._1._0._0));
				};
				return _MikaelMayer$parser$Parser$source(
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$symbol(start),
						A4(_user$project$LangParserUtils$nestableCommentHelp, isNotRelevant, start, end, 1)));
			}
		}
	});
var _user$project$LangParserUtils$lineComment = A2(
	_MikaelMayer$parser$Parser_ops['|.'],
	A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F2(
					function (x, y) {
						return A2(_elm_lang$core$Basics_ops['++'], x, y);
					})),
			_MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('--'))),
		A2(
			_MikaelMayer$parser$Parser$keep,
			_MikaelMayer$parser$Parser$zeroOrMore,
			function (c) {
				return (!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('\n'))) && (!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('\r')));
			})),
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$symbol('\r\n'),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$symbol('\n'),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$end,
					_1: {ctor: '[]'}
				}
			}
		}));
var _user$project$LangParserUtils$isSpace = function (c) {
	return _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr(' ')) || (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('\n')) || (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('\t')) || (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('\r')) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('Â ')))));
};
var _user$project$LangParserUtils$isOnlySpaces = _elm_lang$core$String$all(_user$project$LangParserUtils$isSpace);
var _user$project$LangParserUtils$space = _user$project$ParserUtils$trackInfo(
	A2(
		_MikaelMayer$parser$Parser$keep,
		_MikaelMayer$parser$Parser$Exactly(1),
		_user$project$LangParserUtils$isSpace));
var _user$project$LangParserUtils$oldSpacesRaw = A2(
	_MikaelMayer$parser$Parser$andThen,
	function (_p21) {
		return _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser$andThen,
					function (_p22) {
						return _user$project$LangParserUtils$oldSpacesRaw;
					},
					_user$project$LangParserUtils$oldLineComment),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$succeed(
						{ctor: '_Tuple0'}),
					_1: {ctor: '[]'}
				}
			});
	},
	A2(_MikaelMayer$parser$Parser$ignore, _MikaelMayer$parser$Parser$zeroOrMore, _user$project$LangParserUtils$isSpace));
var _user$project$LangParserUtils$oldSpaces = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$source(_user$project$LangParserUtils$oldSpacesRaw));
var _user$project$LangParserUtils$SpaceCheck = F2(
	function (a, b) {
		return {spaceCheck: a, msgBuilder: b};
	});
var _user$project$LangParserUtils$minIndentation = F2(
	function (forwhat, i) {
		return A2(
			_user$project$LangParserUtils$SpaceCheck,
			F2(
				function (start, end) {
					return _elm_lang$core$Native_Utils.cmp(end.col - 1, i) > -1;
				}),
			function (_p23) {
				var _p24 = _p23;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'I need an indentation of at least ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(i),
						A2(_elm_lang$core$Basics_ops['++'], ' spaces ', forwhat)));
			});
	});
var _user$project$LangParserUtils$maxIndentation = F2(
	function (forwhat, i) {
		return A2(
			_user$project$LangParserUtils$SpaceCheck,
			F2(
				function (start, end) {
					return _elm_lang$core$Native_Utils.cmp(end.col - 1, i) < 1;
				}),
			function (_p25) {
				var _p26 = _p25;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'I need an indentation of at most ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(i),
						A2(_elm_lang$core$Basics_ops['++'], ' spaces ', forwhat)));
			});
	});
var _user$project$LangParserUtils$differentIndentation = F2(
	function (forwhat, i) {
		return A2(
			_user$project$LangParserUtils$SpaceCheck,
			F2(
				function (start, end) {
					return !_elm_lang$core$Native_Utils.eq(end.col - 1, i);
				}),
			function (_p27) {
				var _p28 = _p27;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'I need an indentation of not ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(i),
						A2(_elm_lang$core$Basics_ops['++'], ' spaces ', forwhat)));
			});
	});
var _user$project$LangParserUtils$withoutNewline = function (forwhat) {
	return A2(
		_user$project$LangParserUtils$SpaceCheck,
		F2(
			function (start, end) {
				return _elm_lang$core$Native_Utils.eq(start.line, end.line);
			}),
		function (_p29) {
			var _p30 = _p29;
			return A2(_elm_lang$core$Basics_ops['++'], 'I need a space not containing a newline for ', forwhat);
		});
};
var _user$project$LangParserUtils$maxOneLine = function (forwhat) {
	return A2(
		_user$project$LangParserUtils$SpaceCheck,
		F2(
			function (start, end) {
				return _elm_lang$core$Native_Utils.cmp(start.line + 1, end.line) > -1;
			}),
		function (_p31) {
			var _p32 = _p31;
			return A2(_elm_lang$core$Basics_ops['++'], 'Cannot have more than one newline for ', forwhat);
		});
};
var _user$project$LangParserUtils$SpacePolicy = F2(
	function (a, b) {
		return {first: a, apparg: b};
	});
var _user$project$LangParserUtils$LineComment = function (a) {
	return {ctor: 'LineComment', _0: a};
};
var _user$project$LangParserUtils$MultilineComment = function (a) {
	return {ctor: 'MultilineComment', _0: a};
};
var _user$project$LangParserUtils$White = function (a) {
	return {ctor: 'White', _0: a};
};
var _user$project$LangParserUtils$parseWhitespace = function (lReverse) {
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		function (firstSpaces) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser$andThen,
						function (comment) {
							return _user$project$LangParserUtils$parseWhitespace(
								{
									ctor: '::',
									_0: _user$project$LangParserUtils$LineComment(comment),
									_1: {
										ctor: '::',
										_0: _user$project$LangParserUtils$White(firstSpaces),
										_1: lReverse
									}
								});
						},
						_user$project$LangParserUtils$lineComment),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser$andThen,
							function (comment) {
								return _user$project$LangParserUtils$parseWhitespace(
									{
										ctor: '::',
										_0: _user$project$LangParserUtils$MultilineComment(comment),
										_1: {
											ctor: '::',
											_0: _user$project$LangParserUtils$White(firstSpaces),
											_1: lReverse
										}
									});
							},
							A2(_user$project$LangParserUtils$nestableComment, '{-', '-}')),
						_1: {
							ctor: '::',
							_0: _MikaelMayer$parser$Parser$succeed(
								_elm_lang$core$List$reverse(
									{
										ctor: '::',
										_0: _user$project$LangParserUtils$White(firstSpaces),
										_1: lReverse
									})),
							_1: {ctor: '[]'}
						}
					}
				});
		},
		A2(_MikaelMayer$parser$Parser$keep, _MikaelMayer$parser$Parser$zeroOrMore, _user$project$LangParserUtils$isSpace));
};
var _user$project$LangParserUtils$spacesRaw = A2(
	_MikaelMayer$parser$Parser$map,
	function (_p33) {
		return {ctor: '_Tuple0'};
	},
	_user$project$LangParserUtils$parseWhitespace(
		{ctor: '[]'}));
var _user$project$LangParserUtils$spaces = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$source(_user$project$LangParserUtils$spacesRaw));
var _user$project$LangParserUtils$spacesCustom = function (_p34) {
	var _p35 = _p34;
	return A2(
		_MikaelMayer$parser$Parser$andThen,
		_elm_lang$core$Basics$identity,
		A2(
			_MikaelMayer$parser$Parser$map,
			function (ws) {
				return A2(_p35.spaceCheck, ws.start, ws.end) ? _MikaelMayer$parser$Parser$succeed(ws) : _MikaelMayer$parser$Parser$fail(
					_p35.msgBuilder(
						{ctor: '_Tuple0'}));
			},
			_user$project$LangParserUtils$spaces));
};
var _user$project$LangParserUtils$spaceSameLineOrNextAfterOrTwoLines = function (minStartCol) {
	return _user$project$LangParserUtils$spacesCustom(
		A2(
			_user$project$LangParserUtils$SpaceCheck,
			F2(
				function (start, end) {
					return (_elm_lang$core$Native_Utils.cmp(start.line + 1, end.line) < 0) || ((_elm_lang$core$Native_Utils.cmp(end.line, start.line + 1) < 1) && (_elm_lang$core$Native_Utils.eq(start.line + 1, end.line) ? (_elm_lang$core$Native_Utils.cmp(minStartCol, end.col) < 1) : true));
				}),
			function (_p36) {
				var _p37 = _p36;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a min indentation of ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(minStartCol),
						' if on the next line'));
			}));
};
var _user$project$LangParserUtils$spacesWithoutIndentation = _user$project$LangParserUtils$spacesCustom(
	A2(_user$project$LangParserUtils$maxIndentation, 'at this place', 0));
var _user$project$LangParserUtils$spacesNotBetweenDefs = _user$project$LangParserUtils$spacesCustom(
	A2(_user$project$LangParserUtils$minIndentation, 'at this place', 1));
var _user$project$LangParserUtils$spacesWithoutNewline = _user$project$LangParserUtils$spacesCustom(
	_user$project$LangParserUtils$withoutNewline('at this place'));
var _user$project$LangParserUtils$removeComments = function (whitespace) {
	var _p38 = A2(
		_MikaelMayer$parser$Parser$run,
		_user$project$LangParserUtils$parseWhitespace(
			{ctor: '[]'}),
		whitespace);
	if (_p38.ctor === 'Err') {
		return '';
	} else {
		return A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex('multilinecomment'),
			function (_p39) {
				return '';
			},
			A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$All,
				_elm_lang$core$Regex$regex(' *linecomment'),
				function (_p40) {
					return '';
				},
				A2(
					_elm_lang$core$String$join,
					'',
					A2(
						_elm_lang$core$List$map,
						function (t) {
							var _p41 = t;
							switch (_p41.ctor) {
								case 'White':
									return _p41._0;
								case 'LineComment':
									return 'linecomment';
								default:
									return 'multilinecomment';
							}
						},
						_p38._0))));
	}
};
var _user$project$LangParserUtils$putbackComments = F2(
	function (newWhitespace, oldWhitespace) {
		var _p42 = A2(
			_MikaelMayer$parser$Parser$run,
			_user$project$LangParserUtils$parseWhitespace(
				{ctor: '[]'}),
			oldWhitespace);
		if (_p42.ctor === 'Err') {
			return newWhitespace;
		} else {
			var indentation = A2(
				_elm_lang$core$Maybe$withDefault,
				'',
				A2(_user$project$Lang$minIndentation, _elm_lang$core$Maybe$Nothing, newWhitespace));
			var allComments = A2(
				_elm_lang$core$String$join,
				'\n',
				A2(
					_elm_lang$core$List$concatMap,
					function (t) {
						var _p43 = t;
						switch (_p43.ctor) {
							case 'White':
								return {ctor: '[]'};
							case 'LineComment':
								return {
									ctor: '::',
									_0: A2(_elm_lang$core$Basics_ops['++'], indentation, _p43._0),
									_1: {ctor: '[]'}
								};
							default:
								return {
									ctor: '::',
									_0: A2(_elm_lang$core$Basics_ops['++'], indentation, _p43._0),
									_1: {ctor: '[]'}
								};
						}
					},
					_p42._0));
			return (!_elm_lang$core$Native_Utils.eq(allComments, '')) ? (A2(
				_elm_lang$core$Regex$contains,
				_elm_lang$core$Regex$regex('\n'),
				newWhitespace) ? _elm_lang$core$String$reverse(
				A4(
					_elm_lang$core$Regex$replace,
					_elm_lang$core$Regex$AtMost(1),
					_elm_lang$core$Regex$regex('\n'),
					function (_p44) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							_elm_lang$core$String$reverse(allComments));
					},
					_elm_lang$core$String$reverse(newWhitespace))) : A2(
				_elm_lang$core$Basics_ops['++'],
				indentation,
				A2(
					_elm_lang$core$Basics_ops['++'],
					allComments,
					A2(_elm_lang$core$Basics_ops['++'], '\n', newWhitespace)))) : newWhitespace;
		}
	});
var _user$project$LangParserUtils$MinIndentSpace = {ctor: 'MinIndentSpace'};
var _user$project$LangParserUtils$NoSpace = {ctor: 'NoSpace'};
var _user$project$LangParserUtils$spaceSameLineOrNextAfter = F2(
	function (minStartCol, spConstraint) {
		return _elm_lang$core$Native_Utils.eq(spConstraint, _user$project$LangParserUtils$NoSpace) ? _user$project$LangParserUtils$nospace : _user$project$LangParserUtils$spacesCustom(
			A2(
				_user$project$LangParserUtils$SpaceCheck,
				F2(
					function (start, end) {
						return (_elm_lang$core$Native_Utils.cmp(end.line, start.line + 1) < 1) && (_elm_lang$core$Native_Utils.eq(end.line, start.line + 1) ? (_elm_lang$core$Native_Utils.cmp(minStartCol, end.col) < 1) : true);
					}),
				function (_p45) {
					var _p46 = _p45;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected a min indentation of ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(minStartCol),
							' if on the next line'));
				}));
	});

var _user$project$LeoLang$isInfixOperator = function (op) {
	var _p0 = op.val;
	switch (_p0.ctor) {
		case 'Pi':
			return false;
		case 'DictEmpty':
			return false;
		case 'CurrentEnv':
			return false;
		case 'DictFromList':
			return false;
		case 'Cos':
			return false;
		case 'Sin':
			return false;
		case 'ArcCos':
			return false;
		case 'ArcSin':
			return false;
		case 'Floor':
			return false;
		case 'Ceil':
			return false;
		case 'Round':
			return false;
		case 'ToStr':
			return false;
		case 'StrLength':
			return false;
		case 'Sqrt':
			return false;
		case 'Explode':
			return false;
		case 'Plus':
			return true;
		case 'Minus':
			return true;
		case 'Mult':
			return true;
		case 'Div':
			return true;
		case 'Lt':
			return true;
		case 'Eq':
			return true;
		case 'Mod':
			return false;
		case 'Pow':
			return true;
		case 'ArcTan2':
			return false;
		case 'DictInsert':
			return false;
		case 'DictGet':
			return false;
		case 'DictRemove':
			return false;
		case 'DebugLog':
			return false;
		case 'NoWidgets':
			return false;
		case 'ToStrExceptStr':
			return false;
		default:
			return false;
	}
};
var _user$project$LeoLang$arity = function (op) {
	return _user$project$Lang$opArity(op);
};
var _user$project$LeoLang$symbols = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: _elm_lang$core$Native_Utils.chr('+'),
		_1: {
			ctor: '::',
			_0: _elm_lang$core$Native_Utils.chr('-'),
			_1: {
				ctor: '::',
				_0: _elm_lang$core$Native_Utils.chr('/'),
				_1: {
					ctor: '::',
					_0: _elm_lang$core$Native_Utils.chr('*'),
					_1: {
						ctor: '::',
						_0: _elm_lang$core$Native_Utils.chr('='),
						_1: {
							ctor: '::',
							_0: _elm_lang$core$Native_Utils.chr('<'),
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Native_Utils.chr('>'),
								_1: {
									ctor: '::',
									_0: _elm_lang$core$Native_Utils.chr('&'),
									_1: {
										ctor: '::',
										_0: _elm_lang$core$Native_Utils.chr('|'),
										_1: {
											ctor: '::',
											_0: _elm_lang$core$Native_Utils.chr('^'),
											_1: {
												ctor: '::',
												_0: _elm_lang$core$Native_Utils.chr('?'),
												_1: {
													ctor: '::',
													_0: _elm_lang$core$Native_Utils.chr('%'),
													_1: {
														ctor: '::',
														_0: _elm_lang$core$Native_Utils.chr('#'),
														_1: {
															ctor: '::',
															_0: _elm_lang$core$Native_Utils.chr('~'),
															_1: {
																ctor: '::',
																_0: _elm_lang$core$Native_Utils.chr('!'),
																_1: {ctor: '[]'}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$LeoLang$isSymbol = function ($char) {
	return A2(_elm_lang$core$Set$member, $char, _user$project$LeoLang$symbols);
};

var _user$project$PreludeGenerated$preludeLeo = '\n-- This standard prelude library is accessible by every program.\n--------------------------------------------------------------------------------\n-- Debug --\n\nDebug = {\n  log msg value =\n    -- Call Debug.log \"msg\" value\n    let _ = debug (msg + \": \" + toString value) in\n    value\n  start msg value =\n    -- Call Debug.start \"msg\" <| \\_ -> (remaining)\n    let _ = debug msg in\n    value []\n  crash msg = error msg\n  time msg callback =\n    let start = getCurrentTime () in\n    let res = callback () in\n    let end = getCurrentTime () in\n    let _ = debug (msg + \" took \" + toString (end - start) + \"ms\") in\n    res\n}\n\n -- Much simpler version, does not handle @ symbols wells.\nhtmlViaEval string =\n  case __evaluate__ [(\"append\", append)] <| Update.freezeExcept (always \"Cannot modify raw template\") string <| \\string -> \"\"\"<raw>@string</raw>\"\"\" of\n    Ok [_, _, children] -> children\n    Err msg -> error msg\n    _ -> error \"Parsing HTML failed:\"\n\n-- building block for updating\nfreeze x = x\nexpressionFreeze x = Debug.log \"expressionFreeze is deprecated. Please use Update.freezeExcept instead\" x\n-----------------------------------------\n-- Building blocks functions\n\n-- The following functions should be removed if they are not used (they are redundant)\n\n--; The identity function - given a value, returns exactly that value\n-- id: (forall a (-> a a))\nid x = x\n--; Composes two functions together\n--compose: (forall (a b c) (-> (-> b c) (-> a b) (-> a c)))\ncompose f g = \\x -> f (g x)\n--fst: (forall (a b) (-> [a b] a))\n--snd: (forall (a b) (-> [a b] b))\nfst [a, _] = a\nsnd [_, b] = b\n--or:  (-> Bool Bool Bool)\n--and: (-> Bool Bool Bool)\nor p q = if p then True else q\nand p q = if p then q else False\n--lt: (-> Num Num Bool)\n--eq: (-> Num Num Bool)\n--le: (-> Num Num Bool)\n--gt: (-> Num Num Bool)\n--ge: (-> Num Num Bool)\nlt x y = x < y\neq x y = x == y\nle x y = or (lt x y) (eq x y)\ngt x y = x > y\nge x y = or (gt x y) (eq x y)\nnil = []\ncons x xs = x :: xs\n\n-- The following functions could be kept but could migrate (e.g. len to List.length)\n\n--; Given two bools, returns a bool regarding if the first argument is true, then the second argument is as well\n--implies: (-> Bool Bool Bool)\nimplies p q = if p then q else True\n\n--; Returns the length of a given list\n--len: (forall a (-> (List a) Num))\nlen xs = case xs of [] -> 0; (_ :: xs1) -> 1 + len xs1\n\nzip xs ys =\n  case (xs, ys) of\n    (x::xsRest, y::ysRest) -> (x, y) :: zip xsRest ysRest\n    _                      -> []\n\nzipOld xs ys =\n  case (xs, ys) of\n    (x::xsRest, y::ysRest) -> [x, y] :: zipOld xsRest ysRest\n    _                      -> []\n\nrange i j =\n  if i < j + 1\n    then cons i (range (i + 1) j)\n    else nil\n\n-----------------------------------------\n--Basics = {\n-- TODO: Once we have types, wrap these basics into a module.\n\n--(==) is an Op\n--(/=) is in builtinEnv\n--(<) is an Op\n--(>) is in builtinEnv\n--(<=) is in builtinEnv\n--(>=) is in builtinEnv\n\n--max: (-> Num Num Num)\nmax i j = if i >= j then i else j\n\n--min: (-> Num Num Num)\nmin i j = if i < j then i else j\n\ntype Order = LT | EQ | GT\n\ncompare a b = if a < b then LT else if a == b then EQ else GT\n\n--- Booleans\n\n--; Given a bool, returns the opposite boolean value\n--not: (-> Bool Bool)\nnot b =  {\n    apply b = if b then False else True\n    unapply b = Just (if b then False else True)\n  }.apply b\n\n--(&&) is built-in\n--(||) is built-in\n\nxor a b = if a then not b else b\n\n-- Mathematics\n\n-- (+) is an Op\n-- (-) is an Op\n-- (*) is an Op\n-- (/) is an Op\n-- (^) is an Op\n-- TODO: (//)\n-- TODO: rem\n\nnegate x = 0 - x\n\n--; Absolute value\n--abs: (-> Num Num)\nabs x = if x < 0 then neg x else x\n\n-- sqrt is an Op\n\n--; Given an upper bound, lower bound, and a number, restricts that number between those bounds (inclusive)\n--; Ex. clamp 1 5 4 = 4\n--; Ex. clamp 1 5 6 = 5\n--clamp: (-> Num Num Num Num)\nclamp i j n = if n < i then i else if j < n then j else n\n\n-- TODO: logBase base num\n\ne = 2.718281828459045\n\n-- pi is an Op\n\ntau = 2 * pi\n\n-- cos is an op\n-- sin is an op\n\ntan x = cos x / sin x\n\nacos = arccos\n\nasin = arcsin\n\n-- TODO: atan\n\natan2 = arctan2\n\n-- round is an op\n-- floor is an op\n-- ceiling is an op\ntruncate x = if x > 0 then floor x else ceiling x\n\ntoFloat x = x\n\n-- Convert radians to degrees\n-- radToDeg: (-> Num Num)\nradToDeg rad = rad / tau * 360!\n\n-- Convert degrees to radians\n-- degToRad: (-> Num Num)\ndegToRad deg = deg / 360! * tau\n\ndegrees = degToRad\n\nradians x = x\n\nturns x = x * tau\n\n-- Polar coordinates\n\ntoPolar (x, y) = (sqrt (x * x + y * y), atan2 y x)\nfromPolar (r, t) = (r * cos t, r * sin t)\n\n-- Floating point check\n\n-- TODO: isNaN\n-- TODO: isInfinite\n\n-- Strings and lists\n\n-- toString is an op\n-- (++) is interpreted as append\n\n-- Higher-order helpers\n\nidentity x = x\n  --; A function that always returns the same value a, regardless of b\n  -- always: (forall (a b) (-> a b a))\nalways x _ = x\n\n-- <| is defined as a left application\n-- |> is defined as a right application\n-- (<<) is defined in builtinEnv\n-- (>>) is defined in builtinEnv\n\n--flip: (forall (a b c) (-> (-> a b c) (-> b a c)))\nflip f = \\x y -> f y x\n\nflips = {\n  moveArg n m f =\n    if n == 1 && m == 1 then f\n    else if n > 1 && m > 1 then\n       \\x -> moveArg (n-1) (m-1) (f x)\n    else if n == 1 then   -- Here m > 1\n      moveArg 2 m (\\x y -> f y x)\n    else -- m == 1 && n > 1\n      \\x y -> (moveArg n 2 f) y x\n\n  ab_ba = moveArg 1 2 -- same as flip\n  abc_bca = moveArg 1 3\n  abcd_bcda = moveArg 1 4\n}\n\ncurry f a b = f (a,b)\nuncurry f (a,b) = f a b\n\n-- type Never\n\nnever x = Debug.crash \"Never can never be called\"\n\n--------------------------------------------------------------------------------\n-- LensLess modules (List, Results, String) for definitions without lenses\n\nLensLess =\n  let reverse l =\n    let r acc l = case l of [] -> acc; head::tail -> r (head::acc) tail in\n    r [] l\n  in\n  let map f l =\n     case l of\n       []    -> []\n       x::xs -> f x :: map f xs\n  in\n  let append xs ys =\n     case xs of\n       [] -> ys\n       x::xs1 -> x :: append xs1 ys\n  in\n  let split n l =\n    let aux acc n l =\n      if n == 0 then (reverse acc, l) else\n      case l of\n        [] -> (reverse acc, l)\n        head::tail -> aux (head::acc) (n - 1) tail\n    in aux [] n l in\n  let take =\n    let aux n l = if n == 0 then [] else\n      case l of\n        [] -> []\n        head::tail -> head :: (aux (n - 1) tail)\n    in aux in\n  let drop =\n    let aux n l = if n == 0 then l else\n      case l of\n        [] -> []\n        head::tail -> aux (n - 1) tail\n    in aux in\n  let reverse_move n stack from = if n <= 0 then (stack, from) else case from of\n    [] -> (stack, from)\n    head::tail -> reverse_move (n - 1) (head::stack) tail\n  in\n  let filterMap f l = case l of\n    [] -> []\n    (head :: tail) -> case f head of\n      Nothing -> filterMap f tail\n      Just newHead -> newHead :: filterMap f tail\n  in\n  let concatMap f l = case l of\n    [] -> []\n    head :: tail -> f head ++ concatMap f tail\n  in\n  let last l = case l of\n    [head] -> Just head\n    _ :: tail -> last tail\n    _ -> Nothing\n  in\n  let map2 f xs ys =\n    case [xs, ys] of\n      [x::xs1, y::ys1] -> f x y :: map2 f xs1 ys1\n      _                -> []\n  in\n  let zip = map2 (,) in\n  { appendStrDef = \"\"\"let append a b = case a of [] -> b; (h::t) -> h :: append t b in \"\"\"\n    Maybe = {\n      map f a = case a of\n        Nothing -> Nothing\n        Just x -> Just (f x)\n    }\n    List = {\n      append = append\n      split = split\n      take = take\n      drop = drop\n      reverse = reverse\n      reverse_move = reverse_move\n      filterMap = filterMap\n      map = map\n      last = last\n      map2 = map2\n      concatMap = concatMap\n      zip = zip\n    },\n    Result =\n      let map f res = case res of\n        Err msg -> res\n        Ok x -> Ok (f x)\n      in\n      let andThen f res = case res of\n        Err msg -> res\n        Ok x -> f x\n      in\n      {\n        map = map\n        andThen = andThen\n    },\n    Results =\n      let keepOks l =\n        case l of\n          [] -> []\n          (Err _) ::tail -> keepOks tail\n          (Ok ll) :: tail -> ll ++ keepOks tail\n      in\n      let projOks l =\n        case l of\n          [] -> Ok []\n          (Ok []) :: tail -> projOks tail\n          (Ok (vhead :: vtail)) ::tail -> Ok (vhead::(vtail ++ keepOks tail))\n          (Err msg) :: tail ->\n            case projOks tail of\n              Err msgTail -> Err msg\n              Ok []-> Err msg\n              result -> result\n      in\n      let andThen callback results =\n        --andThen : (a -> Results x b) -> Results x a -> Results x b\n        case results of\n          Ok ll -> ll |> map callback |> projOks\n          Err msg -> results\n      in\n      let resultMap callback results =\n        case results of\n          Ok ll -> Ok (ll |> map callback)\n          Err msg -> results\n      in\n      let andAlso otherResults results =\n        case (results, otherResults) of\n          (Ok ll, Ok otherLl) -> Ok (ll ++ otherLl)\n          (Err msg, Err msg2) -> Err (msg + \"\\n\" + msg2)\n          (Err msg, _) -> Err msg\n          (_, Err msg2) -> Err msg2\n      in\n      {\n        keepOks = keepOks\n        projOks = projOks\n        andThen = andThen\n        andAlso = andAlso\n        map = resultMap\n      }\n    String = {\n      toInt =\n        let d = __DictFromList__ [(\"0\", 0), (\"1\", 1), (\"2\", 2), (\"3\", 3), (\"4\", 4), (\"5\", 5), (\"6\", 6), (\"7\", 7), (\"8\", 8), (\"9\", 9)] in\n        let aux x =\n          case extractFirstIn \"^([0-9]*)([0-9])$\" x of\n            Just [init, last] -> (aux init)*10 + case __DictGet__ last d of\n              Just x -> x\n              Nothing -> 0\n            Nothing -> 0\n        in\n        \\x ->\n          case extractFirstIn \"^-(.*)$\" x of\n            Just part -> 0 - aux part\n            Nothing -> aux x\n\n      join delimiter list =\n        let aux acc list = case list of\n          [] -> acc\n          [head] -> acc + head\n          (head::tail) -> aux (acc + head + freeze delimiter) tail\n        in aux \"\" list\n\n      substring start end x =\n        case extractFirstIn (\"^[\\\\s\\\\S]{0,\" + toString start + \"}([\\\\s\\\\S]{0,\" + toString (end - start) + \"})\") x of\n          Just [substr] -> substr\n          Nothing -> Debug.crash <| \"bad arguments to String.substring \" + toString start + \" \" + toString end + \" \" + toString x\n\n      take length x =\n          case extractFirstIn (\"^([\\\\s\\\\S]{0,\" + toString length + \"})\") x of\n            Just [substr] -> substr\n            Nothing -> Debug.crash <| \"bad arguments to String.take \" + toString length + \" \" + toString x\n\n      drop length x =\n        if length <= 0 then x else\n        case extractFirstIn (\"^[\\\\s\\\\S]{0,\" + toString length + \"}([\\\\s\\\\S]*)\") x of\n                Just [substr] -> substr\n                Nothing -> Debug.crash <| \"bad arguments to String.drop \" + toString length + \" \" + toString x\n\n      dropLeft = drop\n      dropRight length x =\n        if length <= 0 then x else\n        case extractFirstIn \"\"\"^([\\s\\S]*?)[\\s\\S]{0,@length}$\"\"\" x of\n              Just [substr] -> substr\n              Nothing -> Debug.crash <| \"bad arguments to String.drop \" + toString length + \" \" + toString x\n\n      length x = __strLength__ x\n\n      slice = substring\n\n      toFloat s =\n        case extractFirstIn \"\"\"((-?)\\d+)\\.(\\d+)\"\"\" s of\n           Just [intPart, negative, floatPart] ->\n             let combine y = if negative == \"-\" then 0 - y else y in\n             toInt intPart + (combine <| toInt floatPart / (10 ^ length floatPart))\n           Nothing ->\n        case extractFirstIn \"\"\"((-?)\\d)(?:\\.(\\d*))?(?:e|E)\\+?(-?\\d+)\"\"\" s of -- Scientific notation\n           Just [beforeComma, negative, afterComma, exponent] ->\n             toInt beforeComma + (combine <| toInt afterComma  / (10 ^ length afterComma)) * 10 ^ (toInt exponent)\n           Nothing ->\n             toInt s\n\n      sprintf str inline = case inline of\n          a::tail -> sprintf (replaceFirstIn \"%s\" a str) tail\n          [] -> str\n          a -> replaceFirstIn \"%s\" a str\n    }\n  }\n\nResult = {\n  type Result err ok = Err err | Ok ok\n\n  map: (a -> b) -> Result err a -> Result err b\n  map f res = case res of\n    Err msg -> res\n    Ok x -> Ok (f x)\n\n  mapError err err2: (err -> err2) -> forall a. Result err a -> Result err2 a\n  mapError f res = case res of\n    Err msg -> res\n    Ok x -> Ok (f x)\n\n  andThen: (a -> Result err b) -> Result err a -> Result err b\n  andThen f res = case res of\n    Err msg -> res\n    Ok x -> f x\n\n  toMaybe: Result err ok -> Maybe ok\n  toMaybe res = case res of\n    Err msg -> Nothing\n    Ok x -> Just x\n\n  fromMaybe: err -> Maybe ok -> Result err ok\n  fromMaybe err res = case res of\n    Nothing -> Err err\n    Just x -> Ok x\n\n  fromMaybeLazy: (() -> err) -> Maybe ok -> Result err ok\n  fromMaybeLazy msgBuilder = case of\n    Just x -> Ok x\n    Nothing -> Err (msgBuilder ())\n\n  withDefault: ok -> Result err ok -> ok\n  withDefault defaultValue res = case res of\n    Err x -> defaultValue\n    Ok x -> x\n\n  (errn) n msg = if n == 1 then Err msg else \\_ -> errn (n - 1) msg\n\n  --Variable arity function. mapn 1 == map, mapn 2 == map2, etc.\n  --Dependently typed.\n  mapn n = if n == 1 then map else\n    \\f res -> case res of\n      Err msg -> errn n msg\n      Ok r -> mapn (n - 1) (f r)\n\n  map2 = mapn 2\n  map3 = mapn 3\n  map4 = mapn 4\n\n  andThenn n = if n == 1 then andThen else\n    \\f res -> case res of\n      Err msg -> errn n msg\n      Ok r -> andThenn (n - 1) (f r)\n\n  andThen2 = andThenn 2\n  andThen3 = andThenn 3\n  andThen4 = andThenn 4\n\n  withDefaultMapError: (b -> a) -> Result a b -> a\n  withDefaultMapError f = case of\n    Ok x -> x\n    Err msg -> f msg\n\n  fold : (err -> a) -> (x -> a) -> Result err x -> a\n  fold onErr onOk content =\n    case content of\n      Err msg -> onErr msg\n      Ok c -> onOk c\n}\n\n--------------------------------------------------------------------------------\n-- Update --\n\n--type ListElemDiff a = ListElemUpdate a | ListElemInsert Int | ListElemDelete Int\n--type VDictElemDiff = VDictElemDelete | VDictElemInsert | VDictElemUpdate VDiffs\n--type alias EnvDiffs = TupleDiffs VDiffs\n-- The environment of a closure if it was modified, the modifications of an environment else.\n--type VDiffs = VClosureDiffs EnvDiffs (Maybe EDiffs)\n--            | VListDiffs (ListDiffs VDiffs)\n--            | VDictDiffs (Dict (String, String) VDictElemDiff)\n--            | VRecordDiffs (Dict String VDiffs)\n--            | VConstDiffs\n\n--type EDiffs = EConstDiffs EWhitespaceDiffs\n--            | EListDiffs (ListDiffs EDiffs)\n--            | EChildDiffs (TupleDiffs EDiffs) -- Also for records\n\n--type EWhitespaceDiffs = EOnlyWhitespaceDiffs | EAnyDiffs\n  \n-- The diff primitive is:\n--\n--   type alias DiffOp : Value -> Value -> Result String (Maybe VDiffs)\n--   diff : DiffOp\n--   diff ~= SnS.Update.defaultVDiffs\n--\n\nUpdate =\n  let {String, List} = LensLess in\n  let {reverse} = List in\n  let freeze x =\n    x\n  in\n  let applyLens lens x =\n    lens.apply x\n  in\n  let softFreeze x =\n    -- Update.freeze x prevents changes to x (resulting in failure),\n    -- Update.softFreeze x ignores changes to x\n    let constantInputLens =\n      { apply x = x, update {input} = Ok (Inputs [input]) }\n    in\n    applyLens constantInputLens x\n  in\n  -- TODO: Replace this by enabling the return of Result String (Values [values...] | ValuesDiffs [(values, diffs)])\n  let valuesWithDiffs valuesDiffs = Ok (InputsWithDiffs valuesDiffs) in\n  let resultValuesWithDiffs valuesDiffs = case valuesDiffs of\n     [] -> Ok (InputsWithDiffs [])\n     (Ok vd)::tail -> case resultValuesWithDiffs tail of\n       Err msg -> Ok (InputsWithDiffs [vd])\n       Ok (InputsWithDiffs vds) -> Ok (InputsWithDiffs (vd :: vds))\n     (Err msg)::tail -> if tail == [] then Err msg else\n       case resultValuesWithDiffs tail of\n       Err error-> Err (msg + \"\\n\" + error)\n       x -> x\n  in\n  let addDiff f mbDiff (d, changed) =\n        case mbDiff of\n          Nothing -> (d, changed)\n          Just x -> (f d x, True)\n  in\n  let pairDiff2 mbDiff1 mbDiff2 =\n        ({}, False)\n        |> addDiff (\\d x -> {d | _1 = x}) mbDiff1\n        |> addDiff (\\d x -> {d | _2 = x}) mbDiff2\n        |> (\\(d, changed) -> if changed then Just (VRecordDiffs d) else Nothing)\n  in\n  let pairDiff3 mbDiff1 mbDiff2 mbDiff3 =\n        ({}, False)\n        |> addDiff (\\d x -> {d | _1 = x}) mbDiff1\n        |> addDiff (\\d x -> {d | _2 = x}) mbDiff2\n        |> addDiff (\\d x -> {d | _3 = x}) mbDiff3\n        |> (\\(d, changed) -> if changed then Just (VRecordDiffs d) else Nothing)\n  in\n  let pairDiff4 mbDiff1 mbDiff2 mbDiff3 mbDiff4 =\n        ({}, False)\n        |> addDiff (\\d x -> {d | _1 = x}) mbDiff1\n        |> addDiff (\\d x -> {d | _2 = x}) mbDiff2\n        |> addDiff (\\d x -> {d | _3 = x}) mbDiff3\n        |> addDiff (\\d x -> {d | _4 = x}) mbDiff4\n        |> (\\(d, changed) -> if changed then Just (VRecordDiffs d) else Nothing)\n  in\n  let\n    type SimpleListDiffOp = KeepValue | DeleteValue | InsertValue Value | UpdateValue Value\n  in\n  let listDiffOp diffOp oldValues newValues =\n   -- listDiffOp : DiffOp -> List Value -> List Value -> List SimpleListDiffOp\n\n    -- let {Keep, Delete, Insert, Update} = SimpleListDiffOp in\n     let {append} = List in\n     case diffOp oldValues newValues of\n        Ok (Just (VListDiffs listDiffs)) ->\n          let aux i revAcc oldValues newValues listDiffs =\n            case listDiffs of\n              [] ->\n                reverse (map1 (\\_ -> KeepValue) oldValues ++ revAcc)\n              (j, listDiff)::diffTail ->\n                if j > i then\n                  case [oldValues, newValues] of\n                    [_::oldTail, _::newTail] ->\n                      aux (i + 1) (KeepValue::revAcc) oldTail newTail listDiffs\n                    _ -> Debug.crash <| \"[Internal error] Expected two non-empty tails, got  \" + toString [oldValues, newValues]\n                else if j == i then\n                  case listDiff of\n                    ListElemUpdate _ ->\n                      case [oldValues, newValues] of\n                        [oldHead::oldTail, newHead::newTail] ->\n                          aux (i + 1) (UpdateValue newHead :: revAcc) oldTail newTail diffTail\n                        _ -> Debug.crash <| \"[Internal error] update but missing element\"\n                    ListElemInsert count ->\n                      case newValues of\n                        newHead::newTail ->\n                          aux i (InsertValue newHead::revAcc) oldValues newTail (if count == 1 then diffTail else (i, ListElemInsert (count - 1))::diffTail)\n                        _ -> Debug.crash <| \"[Internal error] insert but missing element\"\n                    ListElemDelete count ->\n                      case oldValues of\n                        oldHead::oldTail ->\n                          aux (i + 1) (DeleteValue::revAcc) oldTail newValues (if count == 1 then diffTail else (i + 1, ListElemDelete (count - 1))::diffTail)\n                        _ -> Debug.crash <| \"[Internal error] insert but missing element\"\n                else Debug.crash <| \"[Internal error] Differences not in order, got index \" + toString j + \" but already at index \" + toString i\n          in aux 0 [] oldValues newValues listDiffs\n\n        result -> Debug.crash (\"Expected Ok (Just (VListDiffs listDiffs)), got \" + toString result)\n  in\n  let\n    type StringDiffs = StringUpdate Int Int Int\n    type ConcStringDiffs = ConcStringUpdate Int Int String\n  in\n  -- Converts a VStringDiffs -> List ConcStringDiffs\n  let strDiffToConcreteDiff newString diffs =\n    case diffs of\n      VStringDiffs d ->\n        let aux offset d revAcc = case d of\n          [] -> List.reverse revAcc\n          ((StringUpdate start end replaced) :: tail) ->\n             ConcStringUpdate start end (String.slice (start + offset) (start + replaced + offset) newString) :: revAcc |>\n             aux (offset + replaced - (end - start)) tail\n        in aux 0 d []\n  in\n  let affinity a b = if a == \"\" || b == \"\" then 10 else\n     case extractFirstIn \"\\\\d$\" a of\n       Just _ -> case extractFirstIn \"^\\\\d\" b of\n         Just _ -> 8\n         _ -> 5\n       _ -> 5\n  in\n  let preferStringInsertionToLeft s1 inserted s2 = affinity s1 inserted > affinity inserted s2 in\n  let offsetStr n list = case list of\n      (StringUpdate start end replaced) :: tail -> StringUpdate (start + n) (end + n) replaced :: offsetStr n tail\n      [] -> []\n  in\n  let mbConsStringUpdate start end replaced tail =\n    if start == end && replaced == 0 then tail else (StringUpdate start end replaced) :: tail\n  in\n  let\n    -- Returns all the possible ways of splitting the string differences at a particular index,\n    -- at which the oldString used to be concatenated.\n    -- Returns the new strings for left and for right.\n    -- The old strings would simply be computed by (String.take n oldString) (String.drop n oldString)\n    splitStringDiffsAt n offset oldString newString stringDiffs = case stringDiffs of\n      [] -> [(String.take (n + offset) newString, [],\n             String.drop (n + offset) newString, [])]\n      ((StringUpdate start end replaced) as head) :: tail ->\n        if end < n then\n          splitStringDiffsAt n (offset + replaced - (end - start)) oldString newString tail\n          |> List.map (\\(left, leftDiffs, right, rightDiffs) -> (left, head::leftDiffs, right, rightDiffs))\n        else if n < start then\n          [(String.take (n + offset) newString, [],\n            String.drop (n + offset) newString, offsetStr (0 - n - offset) stringDiffs)]\n        else if replaced == 0 then\n          [(String.take (start + offset) newString, mbConsStringUpdate start n 0 [],\n            String.drop (start + offset) newString, offsetStr (0 - n) <| mbConsStringUpdate n end 0 tail)]\n        else\n          let insertionToLeft =\n           (String.take (start + offset + replaced) newString, mbConsStringUpdate start n replaced [],\n            String.drop (start + offset + replaced) newString, offsetStr (0 - n) <| mbConsStringUpdate n end 0 tail)\n          in\n          let insertionToRight =\n           (String.take (start + offset) newString, mbConsStringUpdate start n 0 [],\n             String.drop (start + offset) newString, offsetStr (0 - n) <| mbConsStringUpdate n end replaced tail)\n          in\n          if preferStringInsertionToLeft\n            (String.substring 0 start oldString)\n            (String.substring (start + offset)\n              (start + offset + replaced) newString)\n            (String.drop end oldString)\n          then [insertionToLeft, insertionToRight]\n          else [insertionToRight, insertionToLeft]\n  in\n  let\n    offsetList n list = case list of\n      (i, d)::tail -> (i + n, d)::offsetList n tail\n      [] -> []\n  in\n  -- Given a split index n (offset is zero at the beginning), split the newList that is being\n  -- pushed back at the index n (n should be the original length of the left list being concatenated)\n  -- Returns the new list to the left and its differences, and the new list on the right and its differences.\n  let\n    splitListDiffsAt n offset newList listDiffs = case listDiffs of\n      [] ->\n        let (left, right) = List.split (n + offset) newList in\n        [(left, [], right, [])]\n      (i, d) :: tail ->\n        let newOffset = case d of\n          ListElemInsert count -> offset + count\n          ListElemDelete count -> offset - count\n          ListElemUpdate _ -> offset\n        in\n        if i < n then\n          if i + (offset - newOffset) > n then -- a deletion spanning until after the split point\n            let (left, right) = List.split (n + offset) newList in\n            [(left, (i, ListElemDelete (n - i))::[],\n              right, offsetList (0 - n) <| (n, ListElemDelete (i + (offset - newOffset) - n))::tail)]\n          else\n          splitListDiffsAt n newOffset newList tail\n          |> List.map (\\(left, leftDiffs, right, rightDiffs) ->\n            (left, (i, d)::leftDiffs, right, rightDiffs))\n        else if i > n || i == n && (case d of ListElemInsert _ -> False; _ -> True) then\n          let (left, right) = List.split (n + offset) newList in\n          [(left, [], right, offsetList (0 - n) listDiffs)]\n        else -- i == n now, everything happens at the intersection.\n          let insertionToLeft =\n            let (left, right) = List.split (i + newOffset) newList in\n            (left, (i, d)::[],\n             right, tail)\n          in\n          let insertionToRight =\n            let (left, right) = List.split (i + offset) newList in\n            (left, [],\n             right, offsetList (0 - i) <| (i, d)::tail)\n          in\n          [insertionToLeft, insertionToRight]\n  in\n  let --------------------------------------------------------------------------------\n      -- Update.foldDiff\n\n      -- type Results err ok = Result err (List ok)\n\n      -- every onFunction should either return a Ok (List a) or an Err msg\n      -- start    : a\n      -- onUpdate : a -> {oldOutput: b, newOutput: b, index: Int, diffs: VDiffs} -> Results String a\n      -- onInsert : a -> {newOutput: b, index: Int, diffs: VDiffs}  -> Results String a\n      -- onRemove : a -> {oldOutput: b, index: Int, diffs! VDoffs}  -> Results String a\n      -- onSkip   : a -> {count: Int, index: Int, oldOutputs: List b, newOutputs: List b}  -> Results String a\n      -- onFinish : a -> Results String c\n      -- onGather : c -> (InputWithDiff (d, Maybe VDiffs) | Input d)\n      -- oldOutput: List b\n      -- newOutput: List b\n      -- diffs    : ListDiffs\n      -- Returns  : Err String | Ok (Inputs (List d} | InputsWithDiffs (List (d, Maybe VDiffs)))\n      foldDiff =\n        let {List, Results} = LensLess in\n        let {append, split, reverse} = List in\n        \\{start, onSkip, onUpdate, onRemove, onInsert, onFinish, onGather} oldOutput newOutput diffs ->\n        let listDiffs = case diffs of\n          VListDiffs l -> l\n          _ -> Debug.crash <| \"Expected VListDiffs, got \" + toString diffs\n        in\n        -- Returns either Err msg or Ok (list of values)\n        --     fold: Int -> List b -> List b -> List (Int, ListElemDiff) -> a -> Results String c\n        let fold  j      oldOutput  newOutput  listDiffs                    acc =\n            let next i      oldOutput_ newOutput_ d newAcc =\n              newAcc |> Results.andThen (\\accCase ->\n                fold i oldOutput_ newOutput_ d accCase\n              )\n            in\n            case listDiffs of\n            [] ->\n              let count = len newOutput in\n              if count == 0 then\n                onFinish acc\n              else\n               onSkip acc {count = count, index = j, oldOutputs = oldOutput, newOutputs = newOutput}\n               |> next (j + count) [] [] listDiffs\n\n            (i, diff)::dtail  ->\n              if i > j then\n                let count = i - j in\n                let (previous, remainingOld) = split count oldOutput in\n                let (current,  remainingNew) = split count newOutput in\n                onSkip acc {count = count, index = j, oldOutputs = previous, newOutputs = current}\n                |> next i remainingOld remainingNew listDiffs\n              else case diff of\n                ListElemUpdate d->\n                  let previous::remainingOld = oldOutput in\n                  let current::remainingNew = newOutput in\n                  onUpdate acc {oldOutput = previous, index = i, output = current, newOutput = current, diffs = d}\n                  |> next (i + 1) remainingOld remainingNew dtail\n                ListElemInsert count ->\n                  if count >= 1 then\n                    let current::remainingNew = newOutput in\n                    onInsert acc {newOutput = current, index = i}\n                    |> next i oldOutput remainingNew (if count == 1 then dtail else (i, ListElemInsert (count - 1))::dtail)\n                  else Debug.crash <| \"insertion count should be >= 1, got \" + toString count\n                ListElemDelete count ->\n                  if count >= 1 then\n                    let dropped::remainingOld = oldOutput in\n                    onRemove acc {oldOutput =dropped, index = i} |>\n                    next (i + count) remainingOld newOutput (if count == 1 then dtail else (i + 1, ListElemDelete (count - 1))::dtail)\n                  else Debug.crash <| \"deletion count should be >= 1, got \" ++ toString count\n            _ -> Debug.crash <| \"Expected a list of diffs, got \" + toString diffs\n        in\n        case fold 0 oldOutput newOutput listDiffs start of\n          Err msg -> Err msg\n          Ok values -> -- values might be a pair of value and diffs. We use onGather to do the split.\n            let aux revAccValues revAccDiffs values = case values of\n              [] -> case revAccDiffs of\n                Nothing -> Ok (Inputs (reverse revAccValues))\n                Just revDiffs -> Ok (InputsWithDiffs (LensLess.List.zip (reverse revAccValues) (reverse revDiffs)))\n              head::tail -> case onGather head of\n                Ok (InputWithDiff (value, diff)) -> case revAccDiffs of\n                  Nothing -> if len revAccValues > 0 then Err (\"Diffs not specified for all values, e.g.\" + toString value) else\n                    aux [value] (Just [diff]) tail\n                  Just revDiffs ->\n                    aux (value :: revAccValues) (Just (diff::revDiffs)) tail\n                Ok (Input value) -> case revAccDiffs of\n                  Nothing -> aux (value :: revAccValues) revAccDiffs tail\n                  Just revDiffs -> Err (\"Diffs not specified until \" + toString value)\n            in aux [] Nothing values\n  in\n  let sizeFreeze l = {\n         apply l = l\n         update {outputNew=newL, diffs=d} =\n           let lengthNotModified = case d of\n             VListDiffs ds -> let aux ds = case ds of\n               (_, ListElemDelete _)::tail -> False\n               (_, ListElemInsert _)::tail -> False\n               _::tail -> aux tail\n               [] -> True\n              in aux ds\n             _ -> False\n           in\n           if lengthNotModified then Ok (InputsWithDiffs [(newL, Just d)]) else Ok (InputsWithDiffs [])\n       }.apply l\n  in\n  let mbPairDiffs mbDiffsPair = case mbDiffsPair of\n        (Nothing, Nothing) -> Nothing\n        (Just d, Nothing) -> Just (VRecordDiffs {_1=d})\n        (Just d, Just d2) -> Just (VRecordDiffs {_1=d, _2=d2})\n        (Nothing, Just d2) -> Just (VRecordDiffs {_2=d2})\n  in\n  let bijection forward backward elem =\n    {apply elem = forward elem\n     update {outputNew} = Ok (Inputs [backward outputNew])\n    }.apply elem\n  in\n  -- exports from Update module\n  { freeze x = x\n    expressionFreeze x = Debug.log \"Update.expressionFreeze is deprecated. Please use Update.freezeExcept instead\" x\n    sizeFreeze = sizeFreeze\n    conditionalFreeze cond = if cond then (\\x -> freeze x) else identity\n\n    freezeWhen: Bool -> ((new_a, Diffs) -> String) -> a -> a\n    freezeWhen notPermission lazyMessage x = {\n      apply x = x\n      update {outputNew, diffs} =\n        if notPermission then\n          Err (lazyMessage (outputNew, diffs))\n        else\n          Ok (InputsWithDiffs [(outputNew, Just diffs)])\n    }.apply x\n\n    -- Alternative to expressionFreeze. Provides a cleaner error message and enables to specify which variables to freeze on\n    -- expressionFreeze F[x] <=> freezeExcept (always \"impossible\") x <| \\x -> F[x]\n    freezeExcept: (Diffs -> String) -> a -> (a -> b) -> b\n    freezeExcept lazyMessage arg fun = freezeWhenExcept True lazyMessage arg fun\n\n    -- More precise version of freezeExcept that accepts a condition operator\n    freezeWhenExcept: Bool -> (Diffs -> String) -> a -> (a -> b) -> b\n    freezeWhenExcept notPermission lazyMessage arg fun = (freezeWhen notPermission (\\(newA, newDiffs) -> lazyMessage newDiffs) fun) arg\n\n    foldDiff = foldDiff\n    applyLens = applyLens\n    lens l x = l.apply x\n    lens1 = lens\n    lens2 l x y = l.apply (x, y)\n    lens3 l x y z = l.apply (x, y, z)\n    lens4 l x y z w = l.apply (x, y, z, w)\n    bijection = bijection\n    vTupleDiffs_1 d = VRecordDiffs {_1=d}\n    vTupleDiffs_2 d = VRecordDiffs {_2=d}\n    vTupleDiffs_3 d = VRecordDiffs {_3=d}\n    vTupleDiffs_4 d = VRecordDiffs {_4=d}\n    vTupleDiffs_1_2 d1 d2 = VRecordDiffs {_1=d1, _2=d2}\n    default apply uInput =\n        __updateApp__ {uInput | fun = apply }\n    -- Instead of returning a result of a lens, just returns the list or empty if there is an error.\n    defaultAsListWithDiffs apply uInput =\n      case default apply uInput of\n        Err msg -> []\n        Ok (InputsWithDiffs l) -> l\n      -- \"f.apply x\" is a syntactic form for U-Lens, but eta-expanded anyway\n\n    softFreeze = softFreeze\n    splitStringDiffsAt = splitStringDiffsAt\n    listDiffOp = listDiffOp\n    updateApp  = __updateApp__\n    diff: a -> b -> Result (Maybe VDiffs)\n    diff = __diff__\n    -- Instead of returning Ok (Maybe VDiffs) or error, raises the error if there is one or returns the Maybe VDiffs\n    diffs: a -> b -> Maybe VDiffs\n    diffs a b = case __diff__ a b of\n        Err msg -> error msg\n        Ok d -> d\n    merge = __merge__\n    listDiff = listDiffOp __diff__\n    strDiffToConcreteDiff = strDiffToConcreteDiff\n    splitListDiffsAt = splitListDiffsAt\n    valuesWithDiffs = valuesWithDiffs\n    resultValuesWithDiffs = resultValuesWithDiffs\n    pairDiff2 = pairDiff2\n    pairDiff3 = pairDiff3\n    pairDiff4 = pairDiff4\n    mbPairDiffs = mbPairDiffs\n    Regex = {\n        -- Performs replacements on a string with differences but also return those differences along with the old ones.\n        replace: String -> (Match -> String) -> String -> Diffs -> (String, Diffs)\n        replace regex replacement string diffs = updateReplace regex replacement string diffs\n      }\n    mapInserted fun modifiedStr diffs =\n       let aux offset d strAcc = case d of\n       [] -> strAcc\n       ((ConcStringUpdate start end inserted) :: dtail) ->\n         let left = String.take (start + offset) strAcc in\n         let right =  String.dropLeft (start + offset + String.length inserted) strAcc in\n         let newInserted = fun inserted in\n         (if newInserted /= inserted then left + newInserted + right else strAcc) |>\n         aux (offset + String.length newInserted - (end - start)) dtail\n       in\n       aux 0 (strDiffToConcreteDiff modifiedStr diffs) modifiedStr\n\n    onUpdate callback = lens {\n        apply = identity\n        update {outputNew} = Ok (Inputs [callback outputNew])\n    }\n\n    debug msg x =\n         { apply x = x, update { input, newOutput, oldOutput, diffs} =\n           let _ = Debug.log (\"\"\"@msg:\noldOutput:@oldOutput\nnewOutput:@newOutput\ndiffs:@(if typeof oldOutput == \"string\" then strDiffToConcreteDiff newOutput diffs else diffs)\"\"\") \"end\" in\n           Ok (InputsWithDiffs [(newOutput, Just diffs)])\n         }.apply x\n    debugstr msg x = Debug.log \"Update.debugstr is deprecated. Use Update.debug instead\" <| debug msg x\n\n    debugFold msg callback value =\n      callback (debug msg value)\n\n    replaceInstead y x = {\n       apply y = x\n       update {outputNew,diffs} =\n         Ok (InputsWithDiffs [(outputNew, Just diffs)])\n     }.apply y\n  }\n\nevaluate program =\n  case __evaluate__ [] program of\n    Ok x -> x\n    Err msg -> Debug.crash msg\n\n--------------------------------------------------------------------------------\n-- ListLenses --\n\n-- append is defined here because it is used when we want x ++ y to be reversible.\n-- Note that because this is not syntactically a lambda, the function is not recursive.\nappend =\n  let {append,split} = LensLess.List in\n  \\aas bs -> {\n    apply [aas, bs] = append aas bs\n    update {input = [aas, bs], outputNew, outputOld, diffs} =\n      let asLength = len aas in\n      Update.foldDiff {\n        start = [[], [], [], [], len aas, len bs]\n        onSkip [nas, nbs, diffas, diffbs, numA, numB] {count = n, newOutputs = outs} =\n          if n <= numA then\n            Ok [[nas ++ outs, nbs, diffas, diffbs, numA - n, numB]]\n          else\n            let (forA, forB) = split numA outs in\n            Ok [[nas ++ forA, nbs ++ forB, diffas, diffbs, 0, numB - (n - numA)]]\n        onUpdate [nas, nbs, diffas, diffbs, numA, numB] {newOutput = out, diffs, index} =\n          Ok [if numA >= 1\n           then [nas ++ [out],                                      nbs,\n                 diffas ++ [(index, ListElemUpdate diffs)], diffbs,\n                 numA - 1,                                          numB]\n           else [nas,    nbs ++ [out],\n                 diffas, diffbs ++ [(index - asLength, ListElemUpdate diffs)],\n                 0,      numB - 1]]\n        onRemove  [nas, nbs, diffas, diffbs, numA, numB] {oldOutput, index} =\n          if 1 <= numA then\n            Ok [[nas, nbs, diffas ++ [(index, ListElemDelete 1)], diffbs, numA - 1, numB]]\n          else\n            Ok [[nas, nbs, diffas, diffbs ++ [(index - asLength, ListElemDelete 1)], numA, numB - 1]]\n        onInsert [nas, nbs, diffas, diffbs, numA, numB] {newOutput, index} =\n          Ok (\n            (if numA > 0 || len nbs == 0 then\n              [[nas ++ [newOutput], nbs,\n                diffas ++ [(index, ListElemInsert 1)], diffbs,\n                numA, numB]]\n            else []) ++\n              (if len nbs > 0 || numA == 0 then\n                [[nas,    nbs ++ [newOutput],\n                  diffas, diffbs ++ [(index - asLength, ListElemInsert 1)],\n                  numA, numB]]\n              else [])\n            )\n\n        onFinish [nas, nbs, diffas, diffbs, _, _] = Ok [[[nas, nbs], (if len diffas == 0 then [] else\n             [(0, ListElemUpdate (VListDiffs diffas))]) ++\n                   (if len diffbs == 0 then [] else\n             [(1, ListElemUpdate (VListDiffs diffbs))])]]\n        onGather [[nas, nbs], diffs] = Ok (InputWithDiff ([nas, nbs],\n          if len diffs == 0 then Nothing else Just (VListDiffs diffs)))\n      } outputOld outputNew diffs\n    }.apply [aas, bs]\n\n--; Maps a function, f, over a list of values and returns the resulting list\n\n--; Maps a function, f, over a list of values and returns the resulting list\n--map a b: (a -> b) -> List a -> List b\nmap f l = {\n  apply [f, l] = LensLess.List.map f l\n  update {input=[f, l], oldOutput, outputNew, diffs} =\n    Update.foldDiff {\n      start =\n        --Start: the collected functions and diffs,\n        -- the collected inputs,\n        -- The collected input diffs,\n        -- the inputs yet to process.\n        [[], [], [], l]\n\n\n      onSkip [fs, insA, diffInsA, insB] {count} =\n        --\'outs\' was the same in oldOutput and outputNew\n        let (skipped, remaining) = LensLess.List.split count insB in\n        Ok [[fs, insA ++ skipped, diffInsA, remaining]]\n\n      onUpdate [fs, insA, diffInsA, insB] {oldOutput, newOutput, diffs, index} =\n        let input::remaining = insB in\n        case Update.updateApp {fun (f,x) = f x, input = (f, input), output = newOutput, oldOutput = oldOutput, diffs = diffs} of\n          Err msg -> Err msg\n          Ok (InputsWithDiffs vsds) -> Ok (\n              LensLess.List.map (\\((newF, newA), d) ->\n                let newFs = case d of\n                  Just (VRecordDiffs {_1 = d}) -> (newF, Just d)::fs\n                  _ -> fs\n                in\n                let newDiffsInsA = case d of\n                  Just (VRecordDiffs {_2 = d}) -> diffInsA ++ [(index, ListElemUpdate d)]\n                  _ -> diffInsA\n                in\n                [newFs, insA ++ [newA], newDiffsInsA, remaining]) vsds)\n\n      onRemove [fs, insA, diffInsA, insB] {oldOutput, index} =\n        let _::remaining = insB in\n        Ok [[fs, insA, diffInsA ++ [(index, ListElemDelete 1)], remaining]]\n\n      onInsert [fs, insA, diffInsA, insB] {newOutput, index} =\n        let input =\n          case insB of h::_ -> h; _ ->\n          case LensLess.List.last insA of Just h -> h; Nothing -> Debug.crash \"Empty list for map, cannot insert\" in\n        case Update.updateApp {fun (f,x) = f x, input = (f, input), output = newOutput} of\n          Err msg -> Err msg\n          Ok (InputsWithDiffs vsds) -> Ok (\n              -- We disable the modification of f itself in the insertion (to prevent programmatic styling to change unexpectedly) newF::\n              let aprioriResult = LensLess.List.concatMap (\\((newF, newA), diff) ->\n                case diff of\n                  Just (VRecordDiffs {_1}) -> []\n                  _ -> [[fs, insA++[newA], diffInsA ++ [(index, ListElemInsert 1)], insB]]) <| vsds\n              in -- If one of the result does not change f, that\'s good. Else, we take all the results.\n              if aprioriResult == [] then -- Here we return all possibilities, ignoring changes to the function\n                LensLess.List.concatMap (\\((newF, newA), _) ->\n                   [[fs, insA++[newA], diffInsA ++ [(index, ListElemInsert 1)], insB]]) vsds\n              else\n                aprioriResult)\n\n      onFinish [newFs, newIns, diffInsA, _] =\n       --after we finish, we need to return the new function\n       --as a merge of original functions with all other modifications\n       -- and the collected new inputs\n       Ok [[Update.merge f newFs, newIns, diffInsA]]\n\n      onGather [(newF, fdiff), newIns, diffInsA] =\n        let fdiffPart = case fdiff of\n          Nothing -> []\n          Just d -> [(0, ListElemUpdate d)]\n        in\n        let inPart = case diffInsA of\n          [] -> []\n          d -> [(1, ListElemUpdate (VListDiffs d))]\n        in\n        let finalDiff = case fdiffPart ++ inPart of\n          [] -> Nothing\n          d -> Just (VListDiffs d)\n        in\n        Ok (InputWithDiff ([newF, newIns], finalDiff))\n    } oldOutput outputNew diffs\n  }.apply [f, l]\n\nmapWithDefault default f l = {\n  apply [f, l] = LensLess.List.map f l\n  update {input=[f, l], oldOutput, outputNew, diffs} =\n    Update.foldDiff {\n      start =\n        --Start: the collected functions and diffs,\n        -- the collected inputs,\n        -- The collected input diffs,\n        -- the inputs yet to process.\n        [[], [], [], l]\n\n\n      onSkip [fs, insA, diffInsA, insB] {count} =\n        --\'outs\' was the same in oldOutput and outputNew\n        let (skipped, remaining) = LensLess.List.split count insB in\n        Ok [[fs, insA ++ skipped, diffInsA, remaining]]\n\n      onUpdate [fs, insA, diffInsA, insB] {oldOutput, newOutput, diffs, index} =\n        let input::remaining = insB in\n        case Update.updateApp {fun (f,x) = f x, input = (f, input), output = newOutput, oldOutput = oldOutput, diffs = diffs} of\n          Err msg -> Err msg\n          Ok (InputsWithDiffs vsds) -> Ok (\n              LensLess.List.map (\\((newF, newA), d) ->\n                let newFs = case d of\n                  Just (VRecordDiffs {_1 = d}) -> (newF, Just d)::fs\n                  _ -> fs\n                in\n                let newDiffsInsA = case d of\n                  Just (VRecordDiffs {_2 = d}) -> diffInsA ++ [(index, ListElemUpdate d)]\n                  _ -> diffInsA\n                in\n                [newFs, insA ++ [newA], newDiffsInsA, remaining]) vsds)\n\n      onRemove [fs, insA, diffInsA, insB] {oldOutput, index} =\n        let _::remaining = insB in\n        Ok [[fs, insA, diffInsA ++ [(index, ListElemDelete 1)], remaining]]\n\n      onInsert [fs, insA, diffInsA, insB] {newOutput, index} =\n        let input = default in\n        case Update.updateApp {fun (f,x) = f x, input = (f, input), output = newOutput} of\n          Err msg -> Err msg\n          Ok (InputsWithDiffs vsds) -> Ok (\n              -- We disable the modification of f itself in the insertion (to prevent programmatic styling to change unexpectedly) newF::\n              let aprioriResult = LensLess.List.concatMap (\\((newF, newA), diff) ->\n                case diff of\n                  Just (VRecordDiffs {_1}) -> []\n                  _ -> [[fs, insA++[newA], diffInsA ++ [(index, ListElemInsert 1)], insB]]) <| vsds\n              in -- If one of the result does not change f, that\'s good. Else, we take all the results.\n              if aprioriResult == [] then -- Here we return all possibilities, ignoring changes to the function\n                LensLess.List.concatMap (\\((newF, newA), _) ->\n                   [[fs, insA++[newA], diffInsA ++ [(index, ListElemInsert 1)], insB]]) vsds\n              else\n                aprioriResult)\n\n      onFinish [newFs, newIns, diffInsA, _] =\n       --after we finish, we need to return the new function\n       --as a merge of original functions with all other modifications\n       -- and the collected new inputs\n       Ok [[Update.merge f newFs, newIns, diffInsA]]\n\n      onGather [(newF, fdiff), newIns, diffInsA] =\n        let fdiffPart = case fdiff of\n          Nothing -> []\n          Just d -> [(0, ListElemUpdate d)]\n        in\n        let inPart = case diffInsA of\n          [] -> []\n          d -> [(1, ListElemUpdate (VListDiffs d))]\n        in\n        let finalDiff = case fdiffPart ++ inPart of\n          [] -> Nothing\n          d -> Just (VListDiffs d)\n        in\n        Ok (InputWithDiff ([newF, newIns], finalDiff))\n    } oldOutput outputNew diffs\n  }.apply [f, l]\n\nmapWithReverse reverse f l = {\n  apply [f, l] = LensLess.List.map f l\n  update {input=[f, l], oldOutput, outputNew, diffs} =\n    Update.foldDiff {\n      start =\n        --Start: the collected functions and diffs,\n        -- the collected inputs,\n        -- The collected input diffs,\n        -- the inputs yet to process.\n        [[], [], [], l]\n\n\n      onSkip [fs, insA, diffInsA, insB] {count} =\n        --\'outs\' was the same in oldOutput and outputNew\n        let (skipped, remaining) = LensLess.List.split count insB in\n        Ok [[fs, insA ++ skipped, diffInsA, remaining]]\n\n      onUpdate [fs, insA, diffInsA, insB] {oldOutput, newOutput, diffs, index} =\n        let input::remaining = insB in\n        case Update.updateApp {fun (f,x) = f x, input = (f, input), output = newOutput, oldOutput = oldOutput, diffs = diffs} of\n          Err msg -> Err msg\n          Ok (InputsWithDiffs vsds) -> Ok (\n              LensLess.List.map (\\((newF, newA), d) ->\n                let newFs = case d of\n                  Just (VRecordDiffs {_1 = d}) -> (newF, Just d)::fs\n                  _ -> fs\n                in\n                let newDiffsInsA = case d of\n                  Just (VRecordDiffs {_2 = d}) -> diffInsA ++ [(index, ListElemUpdate d)]\n                  _ -> diffInsA\n                in\n                [newFs, insA ++ [newA], newDiffsInsA, remaining]) vsds)\n\n      onRemove [fs, insA, diffInsA, insB] {oldOutput, index} =\n        let _::remaining = insB in\n        Ok [[fs, insA, diffInsA ++ [(index, ListElemDelete 1)], remaining]]\n\n      onInsert [fs, insA, diffInsA, insB] {newOutput, index} =\n        let newA  = reverse newOutput in\n        Ok [[fs, insA ++ [newA], diffInsA ++ [(index, ListElemInsert 1)], insB]]\n\n      onFinish [newFs, newIns, diffInsA, _] =\n       --after we finish, we need to return the new function\n       --as a merge of original functions with all other modifications\n       -- and the collected new inputs\n       Ok [[Update.merge f newFs, newIns, diffInsA]]\n\n      onGather [(newF, fdiff), newIns, diffInsA] =\n        let fdiffPart = case fdiff of\n          Nothing -> []\n          Just d -> [(0, ListElemUpdate d)]\n        in\n        let inPart = case diffInsA of\n          [] -> []\n          d -> [(1, ListElemUpdate (VListDiffs d))]\n        in\n        let finalDiff = case fdiffPart ++ inPart of\n          [] -> Nothing\n          d -> Just (VListDiffs d)\n        in\n        Ok (InputWithDiff ([newF, newIns], finalDiff))\n    } oldOutput outputNew diffs\n  }.apply [f, l]\n\nzipWithIndex xs =\n  { apply x = zip (range 0 (len xs - 1)) xs\n    update {output} = Ok (Inputs [map (\\(i, x) -> x) output])}.apply xs\n\nindexedMap f l =\n  map (\\(i, x) -> f i x) (zipWithIndex l)\n\n-- TODO: Remove list lenses (lenses should be part of List)\nListLenses =\n  { map = map\n    append = append\n    zipWithIndex = zipWithIndex\n    indexedMap = indexedMap\n  }\n\n--------------------------------------------------------------------------------\n-- TODO (re-)organize this section into modules\n-- HEREHEREHERE\n\n--; Combines two lists with a given function, extra elements are dropped\n--map2: (forall (a b c) (-> (-> a b c) (List a) (List b) (List c)))\nmap2 f xs ys =\n  case [xs, ys] of\n    [x::xs1, y::ys1] -> f x y :: map2 f xs1 ys1\n    _                -> []\n\n--; Combines three lists with a given function, extra elements are dropped\n--map3: (forall (a b c d) (-> (-> a b c d) (List a) (List b) (List c) (List d)))\nmap3 f xs ys zs =\n  case [xs, ys, zs] of\n    [x::xs1, y::ys1, z::zs1] -> f x y z :: map3 f xs1 ys1 zs1\n    _                        -> []\n\n--; Combines four lists with a given function, extra elements are dropped\n--map4: (forall (a b c d e) (-> (-> a b c d e) (List a) (List b) (List c) (List d) (List e)))\nmap4 f ws xs ys zs =\n  case [ws, xs, ys, zs]of\n    [w::ws1, x::xs1, y::ys1, z::zs1] -> f w x y z :: map4 f ws1 xs1 ys1 zs1\n    _                                -> []\n\n--; Takes a function, an accumulator, and a list as input and reduces using the function from the left\n--foldl: (forall (a b) (-> (-> a b b) b (List a) b))\nfoldl f acc xs =\n  case xs of [] -> acc; x::xs1 -> foldl f (f x acc) xs1\n\n--; Takes a function, an accumulator, and a list as input and reduces using the function from the right\n--foldr: (forall (a b) (-> (-> a b b) b (List a) b))\nfoldr f acc xs =\n  case xs of []-> acc; x::xs1 -> f x (foldr f acc xs1)\n\n--; Given two lists, append the second list to the end of the first\n--append: (forall a (-> (List a) (List a) (List a)))\n-- append xs ys =\n--   case xs of [] -> ys; x::xs1 -> x :: append xs1 ys\n\n--; concatenate a list of lists into a single list\n--concat: (forall a (-> (List (List a)) (List a)))\nconcat xss = foldr append [] xss\n-- TODO eta-reduced version:\n-- (def concat (foldr append []))\n\n--; Map a given function over a list and concatenate the resulting list of lists\n--concatMap: (forall (a b) (-> (-> a (List b)) (List a) (List b)))\nconcatMap f xs = concat (map f xs)\n\n--; Takes two lists and returns a list that is their cartesian product\n--cartProd: (forall (a b) (-> (List a) (List b) (List [a b])))\ncartProd xs ys =\n  concatMap (\\x -> map (\\y -> [x, y]) ys) xs\n\n--; Takes elements at the same position from two input lists and returns a list of pairs of these elements\n--zip: (forall (a b) (-> (List a) (List b) (List [a b])))\n-- zip xs ys = map2 (\\x y -> [x, y]) xs ys\n-- TODO eta-reduced version:\n-- (def zip (map2 (\\(x y) [x y])))\n\n--; The empty list\n--; (typ nil (forall a (List a)))\n--nil: []\n-- nil = []\n\n--; attaches an element to the front of a list\n--cons: (forall a (-> a (List a) (List a)))\n-- cons x xs = x :: xs\n\n--; attaches an element to the end of a list\n--snoc: (forall a (-> a (List a) (List a)))\nsnoc x ys = append ys [x]\n\n--; Returns the first element of a given list\n--hd: (forall a (-> (List a) a))\n--tl: (forall a (-> (List a) (List a)))\nhd (x::xs) = x\ntl (x::xs) = xs\n\n--; Returns the last element of a given list\n--last: (forall a (-> (List a) a))\nlast xs =\n  case xs of\n    [x]   -> x\n    _::xs -> last xs\n\n--; Given a list, reverse its order\n--reverse: (forall a (-> (List a) (List a)))\nreverse xs = foldl cons nil xs\n-- TODO eta-reduced version:\n-- (def reverse (foldl cons nil))\n\nadjacentPairs xs = zipOld xs (tl xs)\n\n--; Given two numbers, creates the list between them (inclusive)\n--range: (-> Num Num (List Num))\n-- range i j =\n--   if i < j + 1\n--     then cons i (range (i + 1) j)\n--     else nil\n\n--; Given a number, create the list of 0 to that number inclusive (number must be > 0)\n--list0N: (-> Num (List Num))\nlist0N n = range 0 n\n\n--; Given a number, create the list of 1 to that number inclusive\n--list1N: (-> Num (List Num))\nlist1N n = range 1 n\n\n--zeroTo: (-> Num (List Num))\nzeroTo n = range 0 (n - 1)\n\n--; Given a number n and some value x, return a list with x repeated n times\n--repeat: (forall a (-> Num a (List a)))\nrepeat n x = map (always x) (range 1 n)\n\n--; Given two lists, return a single list that alternates between their values (first element is from first list)\n--intermingle: (forall a (-> (List a) (List a) (List a)))\nintermingle xs ys =\n  case [xs, ys] of\n    [x::xs1, y::ys1] -> cons x (cons y (intermingle xs1 ys1))\n    [[], []]         -> nil\n    _                -> append xs ys\n\nintersperse sep xs =\n  case xs of\n    []    -> xs\n    x::xs -> reverse (foldl (\\y acc -> y :: sep :: acc) [x] xs)\n\n--mapi: (forall (a b) (-> (-> [Num a] b) (List a) (List b)))\nmapi f xs = map f (zipWithIndex xs)\n\n--nth: (forall a (-> (List a) Num (union Null a)))\nnth xs n =\n  if n < 0 then error \"index out of range. Use List.nthMaybe instead of nth to avoid this\"\n  else\n    case [n, xs] of\n      [_, []]     -> error \"index out of range. Use List.nthMaybe instead of nth to avoid this\"\n      [0, x::xs1] -> x\n      [_, x::xs1] -> nth xs1 (n - 1)\n\n-- (defrec nth (\\(xs n)\n--   (if (< n 0)   \"ERROR: nth\"\n--     (case xs\n--       ([]       \"ERROR: nth\")\n--       ([x|xs1]  (if (= n 0) x (nth xs1 (- n 1))))))))\n\n-- TODO change typ/def\n-- (typ take (forall a (-> (List a) Num (union Null (List a)))))\n--take: (forall a (-> (List a) Num (List (union Null a))))\ntake xs n =\n  if n == 0 then []\n  else\n    case xs of\n      []     -> [null]\n      x::xs1 -> x :: take xs1 (n - 1)\n\n-- (def take\n--   (let take_ (\\(n xs)\n--     (case [n xs]\n--       ([0 _]       [])\n--       ([_ []]      [])\n--       ([_ [x|xs1]] [x | (take_ (- n 1) xs1)])))\n--   (compose take_ (max 0))))\n--drop: (forall a (-> (List a) Num (union Null (List a))))\ndrop xs n =\n  if le n 0 then xs\n  else\n    case xs of\n      []     -> null\n      x::xs1 -> drop xs1 (n - 1)\n\n--; Drop n elements from the end of a list\n-- dropEnd: (forall a (-> (List a) Num (union Null (List a))))\n-- dropEnd xs n =\n--   let tryDrop = drop (reverse xs) n in\n--     Err \"typecase not yet implemented for Elm syntax\"\n\n--elem: (forall a (-> a (List a) Bool))\nelem x ys =\n  case ys of\n    []     -> False\n    y::ys1 -> or (x == y) (elem x ys1)\n\nsortBy f xs =\n  let ins x ys =   -- insert is a keyword...\n    case ys of\n      []    -> [x]\n      y::ys -> if f x y then x :: y :: ys else y :: ins x ys\n  in\n  foldl ins [] xs\n\nsortAscending = sortBy lt\nsortDescending = sortBy gt\n\n\n--; multiply two numbers and return the result\n--mult: (-> Num Num Num)\nmult m n =\n  if m < 1 then 0 else n + mult (m + -1) n\n\n--; Given two numbers, subtract the second from the first\n--minus: (-> Num Num Num)\nminus x y = x + mult y -1\n\n--; Given two numbers, divide the first by the second\n--div: (-> Num Num Num)\ndiv m n =\n  if m < n then 0 else\n  if n < 2 then m else 1 + div (minus m n) n\n\n--; Given a number, returns the negative of that number\n--neg: (-> Num Num)\nneg x = 0 - x\n\n--; Sign function; -1, 0, or 1 based on sign of given number\n--sgn: (-> Num Num)\nsgn x = if 0 == x then 0 else x / abs x\n\n--some: (forall a (-> (-> a Bool) (List a) Bool))\nsome p xs =\n  case xs of\n    []     -> False\n    x::xs1 -> or (p x) (some p xs1)\n\n--all: (forall a (-> (-> a Bool) (List a) Bool))\nall p xs =\n  case xs of\n    []     -> True\n    x::xs1 -> and (p x) (all p xs1)\n\n--between: (-> Num Num Num Bool)\nbetween i j n = n == clamp i j n\n\n--plus: (-> Num Num Num)\nplus x y = x + y\n\n--minimum: (-> (List Num) Num)\nminimum (hd::tl) = foldl min hd tl\n\n--maximum: (-> (List Num) Num)\nmaximum (hd::tl) = foldl max hd tl\n\n--average: (-> (List Num) Num)\naverage nums =\n  let sum = foldl plus 0 nums in\n  let n = len nums in sum / n\n\n--; Combine a list of strings with a given separator\n--; Ex. joinStrings \", \" [\"hello\" \"world\"] = \"hello, world\"\n--joinStrings: (-> String (List String) String)\njoinStrings sep ss =\n  foldr (\\str acc -> if acc == \"\" then str else str + sep + acc) \"\" ss\n\n--; Concatenate a list of strings and return the resulting string\n--concatStrings: (-> (List String) String)\nconcatStrings = joinStrings \"\"\n\n--; Concatenates a list of strings, interspersing a single space in between each string\n--spaces: (-> (List String) String)\nspaces = joinStrings \" \"\n\n--; First two arguments are appended at the front and then end of the third argument correspondingly\n--; Ex. delimit \"+\" \"+\" \"plus\" = \"+plus+\"\n--delimit: (-> String String String String)\ndelimit a b s = concatStrings [a, s, b]\n\n--; delimit a string with parentheses\n--parens: (-> String String)\nparens = delimit \"(\" \")\"\n\n--;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n-- (def columnsToRows (\\columns\n--   (let numColumns (len columns)\n--   (let numRows ; maxColumnSize\n--     (if (= numColumns 0) 0 (maximum (map len columns)))\n--   (foldr\n--     (\\(col rows)\n--       (let paddedCol (append col (repeat (- numRows (len col)) \".\"))\n--       (map\n--         (\\[datum row] [ datum | row ])\n--         (zipOld paddedCol rows))))\n--     (repeat numRows [])\n--     columns)\n-- ))))\n--\n-- (def addColToRows (\\(col rows)\n--   (let width (maximum (map len rows))\n--   (let foo (\\(col rows)\n--     (case [col rows]\n--       ([ []     []     ] [                                          ])\n--       ([ [x|xs] [r|rs] ] [ (snoc x r)                 | (foo xs rs) ])\n--       ([ []     [r|rs] ] [ (snoc \"\" r)                | (foo [] rs) ])\n--       ([ [x|xs] []     ] [ (snoc x (repeat width \"\")) | (foo xs []) ])\n--     ))\n--   (foo col rows)))))\n\n-- (def border [\"border\" \"1px solid black\"])\n-- (def padding [\"padding\" \"5px\"])\n-- (def center [\"align\" \"center\"])\n-- (def style (\\list [\"style\" list]))\n-- (def onlyStyle (\\list [(style list)]))\n--\n-- (def td (\\text\n--   [\"td\" (onlyStyle [border padding])\n--         [[\"TEXT\" text]]]))\n--\n-- (def th (\\text\n--   [\"th\" (onlyStyle [border padding center])\n--         [[\"TEXT\" text]]]))\n--\n-- (def tr (\\children\n--   [\"tr\" (onlyStyle [border])\n--         children]))\n--\n-- ; TODO div name is already taken...\n--\n-- (def div_ (\\children [\"div\" [] children]))\n-- (def h1 (\\text [\"h1\" [] [[\"TEXT\" text]]]))\n-- (def h2 (\\text [\"h2\" [] [[\"TEXT\" text]]]))\n-- (def h3 (\\text [\"h3\" [] [[\"TEXT\" text]]]))\n--\n-- (def table (\\children\n--   [\"table\" (onlyStyle [border padding]) children]))\n\n-- (def table (\\children\n--   (let [x y] [100 100]\n--   [\"table\" (onlyStyle [border padding\n--                       [\"position\" \"relative\"]\n--                       [\"left\" (toString x)]\n--                       [\"top\" (toString y)]]) children])))\n\n-- (def tableOfData (\\data\n--   (let letters (explode \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n--   (let data (mapi (\\[i row] [(+ i 1) | row]) data)\n--   (let tableWidth (maximum (map len data))\n--   (let headers\n--     (tr (map (\\letter (th letter)) (take letters tableWidth)))\n--   (let rows\n--     (map (\\row (tr (map (\\col (td (toString col))) row))) data)\n--   (table\n--     [ headers | rows ]\n-- ))))))))\n\n\n\n-- absolutePositionStyles x y = let _ = [x, y] : Point in\n--   [ [\"position\", \"absolute\"]\n--   , [\"left\", toString x + \"px\"]\n--   , [\"top\", toString y + \"px\"]\n--   ]\n\n--------------------------------------------------------------------------------\n-- Regex --\n\nRegex =\n  let split regex = Update.lens {\n    apply s =\n      case extractFirstIn (\"^([\\\\s\\\\S]*?)(\" + regex + \")([\\\\s\\\\S]*)$\") s of\n        Just [before, removed, after] ->\n          if before == \"\" && removed == \"\" then\n            case extractFirstIn \"^([\\\\s\\\\S])([\\\\s\\\\S]*)$\" after of\n              Nothing -> [after]\n              Just [x, remaining] ->\n                let head::tail = split regex remaining in\n                (x + head) :: tail\n\n          else before :: split regex after\n        _ -> [s]\n    update {input=s, outputNew} =\n      case extractFirstIn (\"^([\\\\s\\\\S]*?)(\" + regex + \")([\\\\s\\\\S]*)$\") s of\n        Just [before, removed, after] ->\n          Ok (Inputs [outputNew |> LensLess.String.join removed])\n        _ -> case outputNew of\n          [x] -> Ok (Inputs [x])\n          _ -> Err \"Regex.split resulted in 1 element or less, cannot update with more elements. Use Regex.splitReverse if you know the join string\"\n    }\n  in\n  let splitReverse joinStr regex = Update.lens {\n    apply s = split regex s\n    update {input=s, outputNew} =\n      Ok (Inputs [outputNew |> LensLess.String.join joinStr])\n    }\n  in\n  let find regex s =\n    case extractFirstIn (\"(\" + regex + \")([\\\\s\\\\S]*)\") s of\n      Nothing -> []\n      Just matchremaining ->\n        case LensLess.List.split (len matchremaining - 1) matchremaining of\n          (init, [last]) ->\n            init::find regex last\n  in\n  {\n  replace regex replacement string = replaceAllIn regex replacement string\n  replaceFirst regex replacement string = replaceFirstIn regex replacement string\n  extract regex string = extractFirstIn regex string\n  matchIn r x = case extractFirstIn r x of\n    Nothing -> False\n    _ -> True\n  split = split\n  splitReverse = splitReverse\n  find = find\n  escape = replace \"\"\"\\||\\\\|\\{|\\}|\\[|\\]|\\$|\\.|\\?|\\+|\\(|\\)\"\"\" (\\m -> \"\\\\\" + m.match)\n}\n\n--------------------------------------------------------------------------------\n-- Dict --\n\n-- Interface\ndictLike = {\n  apply this d x = case this.get x d of\n    Just x -> x\n    _ -> Debug.crash (\"Expected element \" + toString x + \" in dict, got nothing\")\n  member this key list = this.get key list /= Nothing\n  contains this = this.member\n  delete this = this.remove\n  update this k f d = case f <| this.get k d of\n    Nothing -> this.delete k d\n    Just v -> this.insert k v d\n}\n\n-- Dictionary implementation\nDict = { dictLike |\n  empty = __DictEmpty__\n  fromList l = __DictFromList__ l\n  get x d = __DictGet__ x d\n  remove x d = __DictRemove__ x d\n  insert k v d = __DictInsert__ k v d\n}\n\n-- List of pairs implementation\nlistDict = { dictLike |\n  empty = []\n  fromList = identity\n  get key = Update.lens {\n    apply list = case list of\n      [] -> Nothing\n      (k, v) :: tail -> if k == key then Just v else get key tail\n    update = case of\n      {input, outputOld = Nothing, outputNew = Just v} ->\n        Ok (Inputs [insert key v input])\n      {input, outputOld = Just _, outputNew = Nothing} ->\n        Ok (Inputs [remove key input])\n      uInput -> Update.default apply uInput\n    }\n  remove key list = case list of\n    [] -> []\n    ((k, v) as head) :: tail -> if k == key then tail else head :: remove key tail\n  insert key value list = case list of\n    [] -> [(key, value)]\n    ((k, v) as head) :: tail -> if k == key then (k, value)::tail else head :: insert key value tail\n\n  -- Enables the deletion of the key-value in reverse\n  insert2 ([(key, value)] as keyValue) list = case list of\n    [] -> keyValue\n    _ ->\n      let (([(k, v)] as head), tail)  = List.split 1 list in\n      if k == key then keyValue ++ tail else head ++ insert2 keyValue tail\n}\n\n\n-- List of 2-element list implementation\nattrDict = { dictLike |\n  empty = []\n  fromList = identity\n  get key = Update.lens {\n    apply list = case list of\n      [] -> Nothing\n      [k, v] :: tail -> if k == key then Just v else get key tail\n    update = case of\n      {input, outputOld = Nothing, outputNew = Just v} ->\n        Ok (Inputs [insert key v input])\n      {input, outputOld = Just _, outputNew = Nothing} ->\n        Ok (Inputs [remove key input])\n      uInput -> Update.default apply uInput\n    }\n  remove key list = case list of\n    [] -> []\n    ([k, v] as head) :: tail -> if k == key then tail else head :: remove key tail\n  insert key value list = case list of\n    [] -> [[key, value]]\n    ([k, v] as head) :: tail -> if k == key then [k, value]::tail else head :: insert key value tail\n}\n\nSet = {\n  empty = __DictEmpty__\n  fromList l = __DictFromList__ (zip l l)\n  insert k d = __DictInsert__ k k d\n  remove x d = __Dict.remove__ x d\n  member x d = case __DictGet__ x d of\n      Just _ -> True\n      _ -> False\n}\n\n\n--------------------------------------------------------------------------------\n-- List (all operations should be lenses) --\n\nList = {\n  reverse =\n    let r = LensLess.List.reverse in\n    -- TODO: reverse the differences as well !\n    \\l -> { apply l = r l, update {output}= Ok (Inputs [r output])}.apply l\n\n  simpleMap = LensLess.List.map\n\n  {-\n  filterMap f l = case l of\n    [] -> []\n    _ ->\n      let ([head] as headList, tail) = split 1 l in\n      case f head of\n        Nothing -> filterMap f tail\n        Just newHead -> -- TODO: Correct for deletion, but not insertions!\n          (List.map (always newHead) headList) ++ filterMap f tail\n  -}\n  filterMap f l = map f l |> filter (\\x -> x /= Nothing) |> map (\\(Just x) -> x)\n\n  length x = len x\n\n  nth = nth\n  nthMaybe n list = case list of\n    head :: tail -> if n == 0 then Just head else nthMaybe (n - 1) tail\n    [] -> Nothing\n\n  (mapi) f xs = map f (zipWithIndex xs)\n  (mapiWithDefault) default f xs = mapWithDefault (0, default) f (zipWithIndex xs)\n  (mapiWithReverse) reverse f xs = mapWithReverse (\\x -> (0, reverse x)) f (zipWithIndex xs)\n\n  indexedMap f xs =\n    mapi (\\(i,x) -> f i x) xs\n\n  indexedMapWithDefault default f xs =\n    mapiWithDefault default (\\(i,x) -> f i x) xs\n\n  indexedMapWithReverse reverse f xs =\n    mapiWithReverse reverse (\\(i, x) -> f i x) xs\n\n  concatMap f l = case l of\n    [] -> []\n    head :: tail -> f head ++ concatMap f tail\n\n  indexedConcatMap f l =\n    let aux i l = case l of\n      [] -> []\n      head :: tail -> f i head ++ aux (i + 1) tail\n    in aux 0 l\n\n  cartesianProductWith f xs ys =\n    concatMap (\\x -> map (\\y -> f x y) ys) xs\n\n  unzip xys =\n    case xys of\n      []          -> ([], [])\n      (x,y)::rest -> let (xs,ys) = unzip rest in\n                     (x::xs, y::ys)\n\n  split n l = Update.lens {\n      apply l = LensLess.List.split n l\n      update {output = (l1, l2), diffs} =\n        let finalDiffs = case diffs of\n          VRecordDiffs {_1 = VListDiffs l1, _2 = VListDiffs l2} ->\n            Just (VListDiffs (l1 ++ simpleMap (\\(i, d) -> (i + n, d)) l2))\n          VRecordDiffs {_1 = VListDiffs l1} ->  Just (VListDiffs l1)\n          VRecordDiffs {_2 = VListDiffs l2} -> Just (VListDiffs (simpleMap (\\(i, d) -> (i + n, d)) l2))\n          _ -> Nothing\n        in\n        Ok (InputsWithDiffs [(l1 ++ l2, finalDiffs)])\n    } l\n\n  -- This filter lens supports insertions and deletions in output\n  filter f l =\n        case l of\n          [] -> l\n          _ ->\n             let ([head] as head1, tail) = split 1 l in\n             let cond = f head in\n             if cond then head1 ++ filter f tail\n             else filter f tail\n\n  -- In this version of foldl, the function f accepts a 1-element list instead of just the element.\n  -- This enable programmers to insert or delete values from the accumulator.\n  foldl2 f b l =\n    let aux b l = case l of\n      [] -> b\n      _ ->\n        let (h1, t1) = split 1 l in\n        aux (f h1 b) t1\n    in aux b l\n\n  -- Pushes the elements to the head of the reverse accumulator revAcc in O(elements) time\n  reverseInsert elements revAcc =\n    case elements of\n      [] -> revAcc\n      head::tail -> reverseInsert tail (head::revAcc)\n\n  sum l = foldl (\\x y -> x + y) 0 l\n  product l = foldl (\\x y -> x * y) 1 l\n\n  maximum l = case l of\n    [] -> Nothing\n    h :: t -> Just (foldl (\\x y -> if x > y then x else y) h t)\n\n  minimum l = case l of\n    [] -> Nothing\n    h :: t -> Just (foldl (\\x y -> if x < y then x else y) h t)\n\n  range min max = if min > max then [] else min :: range (min + 1) max\n\n  mapFirstSuccess f l = case l of\n    [] -> Nothing\n    head :: tail -> case f head of\n      Nothing -> mapFirstSuccess f tail\n      x -> x\n\n  contains n =\n    let aux l = case l of\n      [] -> False\n      head::tail -> if head == n then True else aux tail\n    in aux\n\n  -- Contrary to concatMap, concatMap_ supports insertion and deletions of elements.\n  -- It requires a function to indicate what to do when inserting in empty lists.\n  -- f takes a 1-element list but can push back many elements or remove them\n  concatMap_ insert_in_empty f l =\n        case l of -- Insertion to an emptylist.\n          [] -> { apply l = []\n                  update {input=l, outputNew=lp} = Ok (Inputs [insert_in_empty lp])\n                }.apply l\n          _ -> Update.applyLens { -- Back-propagating a ghost boolean indicating if the next element in the computation had its first element deleted.\n          apply (x, y) = x\n          update {output, diffs} = Ok (InputsWithDiffs [\n            ((output, True),\n             Just (VRecordDiffs { _1 = diffs, _2 = VConstDiffs}))])\n        } <| foldl2 (\\headList (oldAcc, dummyBool) ->\n          let lengthAcc = length oldAcc in\n          {apply (f, oldAcc, headList, dummyBool) = (oldAcc ++ f headList, dummyBool)\n           update {input=(f, oldAcc, headList, _) as input, outputNew=(newAccFHeadList, prevDeletedOrLast), diffs=ds} =\n             let handleDiffs = case ds of\n                VRecordDiffs {_1=VListDiffs diffs} -> \\continuation -> continuation diffs\n                _ -> \\continuation -> Ok (InputsWithDiffs [(input, Nothing)])\n             in handleDiffs <| \\diffs ->\n             Update.splitListDiffsAt lengthAcc 0 newAccFHeadList diffs\n             |> concatMap (\\(newAcc, newAccDiffs, newFHeadList, newFHeadListDiffs) ->\n               let finalAccDiffs = if newAccDiffs == [] then Nothing else Just (VListDiffs newAccDiffs) in\n               let finalAccDeletedRight =\n                 let aux diffs = case diffs of\n                   [] -> False\n                   (i, d)::tail -> case d of\n                     ListElemDelete count -> if count + i == lengthAcc then True else\n                       aux tail\n                     _ -> aux tail\n                 in aux newAccDiffs\n               in\n               let firstElementDeleted = case newFHeadListDiffs of\n                 (0, ListElemDelete x) :: tail -> True\n                 _ -> False\n               in\n               let deleteBoolUpdate = if firstElementDeleted then Just VConstDiffs else Nothing in\n               let surroundingElementsDeleted = finalAccDeletedRight && prevDeletedOrLast in\n               let headListDeletable = newFHeadList == []  && (firstElementDeleted || surroundingElementsDeleted) in\n               let atLeastOneSurroundingElementDeleted = finalAccDeletedRight || prevDeletedOrLast in\n               (if atLeastOneSurroundingElementDeleted && headListDeletable then [] else\n               case newFHeadListDiffs of\n                 [] -> [Ok ((f, newAcc, headList, firstElementDeleted),\n                            Update.pairDiff4 Nothing finalAccDiffs Nothing deleteBoolUpdate)]\n                 _ ->\n               case Update.updateApp{fun (f, x) = f x, input=(f, headList), output=newFHeadList, diffs=VListDiffs newFHeadListDiffs} of\n                 Ok (InputsWithDiffs fAndNewHeadListsWithDiffs) ->\n                    LensLess.List.map (\\((newF, newHeadList), diff) ->\n                      case diff of\n                        Nothing ->  Ok ((f, newAcc, headList, firstElementDeleted),\n                          Update.pairDiff4 Nothing finalAccDiffs Nothing deleteBoolUpdate)\n                        Just (VRecordDiffs d) ->\n                          let newFDiff = case d of {_1} -> Just _1; _ -> Nothing in\n                          let newHeadListDiffs = case d of {_2} -> Just _2; _ -> Nothing in\n                          Ok ((newF, newAcc, newHeadList, firstElementDeleted), Update.pairDiff4 newFDiff finalAccDiffs newHeadListDiffs deleteBoolUpdate)\n                    ) fAndNewHeadListsWithDiffs\n                 Err msg -> [Err msg]\n               ) ++ (\n                 if headListDeletable then\n                   [Ok ((f, newAcc, [], True),\n                        Update.pairDiff4 Nothing finalAccDiffs (Just (VListDiffs [(0, ListElemDelete 1)])) (Just VConstDiffs))]\n                 else\n                   [])\n              ) |> Update.resultValuesWithDiffs\n          }.apply (f, oldAcc, headList, dummyBool)) (Update.freeze [], Update.softFreeze False) l\n\n  indices l = range 0 (length l - 1)\n  isEmpty l = l == []\n  head = Update.lens {\n    apply l = case l of\n      h :: l -> Just h\n      _ -> Nothing\n    update {input, outputNew, diffs} = case (input, outputNew, diffs) of\n      (h :: tail, Nothing, _) ->\n        Ok (InputsWithDiffs [(tail, Just (VListDiffs [(0, ListElemDelete 1)]))])\n      (h :: tail, Just newH, VRecordDiffs {args= VRecordDiffs {_1=d}}) ->\n        Ok (InputsWithDiffs [(newH :: tail, Just (VListDiffs [(0, ListElemUpdate d)]))])\n      ([], Nothing, _) -> Ok (Inputs [input])\n      ([], Just newH, _) ->\n        Ok (InputsWithDiffs [([newH], Just (VListDiffs [(0, ListElemInsert 1)]))])\n      (_, _, _) -> Err (\"Inconsistent diffs in List.head\" ++ toString diffs)\n    }\n\n  tail =  Update.lens {\n    apply l = case l of\n      h :: l -> Just l\n      _ -> Nothing\n    update {input, outputNew, diffs} = case (input, outputNew, diffs) of\n      (h :: tail, Nothing, _) ->\n        Ok (InputsWithDiffs [([], Just (VListDiffs [(0, ListElemDelete (List.length input))]))])\n      (h :: tail, Just newTail, VRecordDiffs {args= VRecordDiffs {_1=VListDiffs tailDiffs}}) ->\n        Ok (InputsWithDiffs [(h :: newTail, Just (VListDiffs (List.map (\\(i, d) -> (i+1, d)) tailDiffs)))])\n      ([], Nothing, _) -> Ok (Inputs [input])\n      ([], Just newTail, _) ->\n        Err \"I don\'t know how to insert a new tail where there was none originally.\"\n      (_, _, _) -> Err (\"Inconsistent diffs in List.head\" ++ toString diffs)\n    }\n\n  take n l =\n    let (taken, remaining) = split n l in\n    taken\n\n  drop n l =\n    let (taken, remaining) = split n l in\n    remaining\n\n  singleton elem = [elem]\n\n  repeat n a =\n    {apply (n, a) =\n      let aux i = if i == 0 then [] else a :: aux (i - 1)\n      in aux n\n     update {input, outputNew, diffs = VListDiffs ds} =\n       let nNew = length outputNew in\n       let nNewDiffs = if nNew == n then Nothing else Just (VConstDiffs) in\n       let mergeEnabled =\n         let aux i diffs outputNew = case diffs of\n           [] -> []\n           (j, diff)::tailDiffs ->\n             if i == j then\n               case diff of\n                 ListElemUpdate d ->\n                   case outputNew of\n                     o :: t -> (o, Just d) :: aux (i + 1) tailDiffs t\n                 ListElemInsert count ->\n                   let (inserted, remOutputNew) = split count outputNew in\n                   concatMap (\\newA ->\n                     case __diff__ a newA of\n                       Err msg -> []\n                       Ok mbDiff -> [(newA, mbDiff)]) inserted ++ aux i tailDiffs remOutputNew\n                 ListElemDelete count ->\n                   aux (i + count) tailDiffs outputNew\n             else\n               let (_, remOutputNew) = split (j - i) outputNew in\n               aux j diffs remOutputNew\n           k::tailDiffs -> aux i tailDiffs outputNew\n         in aux 0 ds outputNew\n       in\n       let (nA, nDiffsA) = __merge__ a mergeEnabled in\n       Ok (InputsWithDiffs [((nNew, nA), Update.mbPairDiffs (nNewDiffs, nDiffsA))])\n    }.apply (n, a)\n\n  insertAt index newElem elements =\n    let (before, after) = split index elements in\n    before ++ [newElem] ++ after\n\n  removeAt index elements =\n    let (before, after) = split index elements in\n    case after of\n      [] -> Nothing\n      elem::afterTail ->\n        Just (elem, before ++ afterTail)\n\n  -- Given two converters cA and cB, a list and a target, finds an element\n  -- of the list that, converted using cA, equals target. Returns cB of this element.\n  -- In the reverse direction, it finds the cB of the new output and returns the cA.\n  findByAReturnB: (a -> b) -> (a -> c) -> b -> List a -> Maybe c\n  findByAReturnB =\n        Update.lens4 {\n          apply (cA, cB, target, l) =\n            let aux l = case l of\n              [] -> Nothing\n              h :: t -> if cA h == target then Just (cB h) else aux t\n            in aux l\n          update {input=(converterA, converterB, target, list) as input, outputNew} as uInput =\n            case outputNew of\n              Nothing -> Ok (InputsWithDiffs [(input, Nothing)])\n              Just outputNewTarget ->\n            case apply (converterB, converterA, outputNewTarget, list) of\n              Just x -> -- No rename here.\n                Ok (InputsWithDiffs [\n                  ((converterA, converterB, x, list),\n                    Update.diffs target x |> LensLess.Maybe.map Update.vTupleDiffs_3)])\n              Nothing ->\n                Update.default apply uInput\n            -- To ways to update: Either find the new B in the list and return A\n            -- Or just regular update (to change the name)\n        }\n\n  find pred list = case list of\n    [] -> Nothing\n    head :: tail -> if pred head then Just head else find pred tail\n\n  indexWhere pred list =\n    let aux n list = case list of\n      head :: tail -> if pred head then n else aux (n + 1) tail\n      _ -> -1\n    in\n    aux 0 list\n\n  indexOf value list = Update.lens {\n    apply value =  indexWhere ((==) value) list\n    update {input=value, outputNew=newIndex} as uInput =\n      case nthMaybe newIndex list of\n        Just newValue -> Ok (Inputs [newValue])\n        Nothing -> Err <| \"\"\"Index @newIndex not found in @list\"\"\"\n  } value\n\n  -- TODO: Continue to insert List functions from Elm (http://package.elm-lang.org/packages/elm-lang/core/latest/List#range)\n  map = map\n\n  append = append\n\n  concat = concatMap identity\n\n  intersperse elem list = drop 1 (concatMap_ identity (\\headAsList -> elem :: headAsList)) list\n\n  partition pred list = case list of\n    [] -> (list, list)\n    _ ->\n     let ([head] as headList, tail) = split 1 list in\n     let (ok, notok) = partition pred tail in\n     if pred head then\n       (headList ++ ok, notok)\n     else\n       (ok, headList ++ notok)\n\n  mapWithDefault = mapWithDefault\n  mapWithReverse = mapWithReverse\n  map2 = map2 -- TOOD: Make it a lens that supports insertion?\n  nil = nil\n  cons = cons\n  foldl = foldl\n  foldr = foldr\n\n  scanl : (a -> b -> b) -> b -> List a -> List b\n  scanl f acc list = case list of\n    [] -> [acc]\n    head :: tail -> acc :: scanl f (f head acc) tail\n\n  scanr : (a -> b -> b) -> b -> List a -> List b\n  scanr f acc list = case list of\n    [] -> [acc]\n    head :: tail ->\n      let headAcc::tailAcc = scanr f acc tail in\n      f head headAcc :: headAcc :: tailAcc\n\n  sort : List comparable -> List comparable\n  sort = sortBy identity\n\n  sortBy : (a -> comparable) -> List a -> List a\n  sortBy f xs =\n    let ins x ys =\n      case ys of\n        []    -> [x]\n        y::ys -> if f x < f y then x :: y :: ys else y :: ins x ys\n    in\n    foldl ins [] xs\n\n  sortWith : (a -> a -> Order) -> List a -> List a\n  sortWith f xs =\n    let ins x ys =\n      case ys of\n        []    -> [x]\n        y::ys -> if f x y == LT then x :: y :: ys else y :: ins x ys\n    in\n    foldl ins [] xs\n\n  zipWithIndex = zipWithIndex\n  member = contains\n  last = LensLess.List.last\n\n  all pred list = case list of\n    [] -> True\n    hd :: tl -> if pred hd then all pred tl else False\n\n  any pred list = case list of\n    [] -> False\n    hd :: tl -> if pred hd then True else any pred tl\n\n  projOks list = case list of\n    [] -> Ok []\n    head :: tail ->\n      Result.andThen2 (\\x y -> Ok (x :: y)) head (projOks tail)\n}\n\n\n--------------------------------------------------------------------------------\n-- String --\nString = {\n  ({toInt=strToInt, toFloat=strToFloat, join=join__}) = LensLess.String\n  (length) = LensLess.String.length -- We redefine length as a lens later in this module\n\n  (join_) x =\n    -- An example of using reversible foldl to join strings without separators\n    -- Here no insertion of element is possible, but we can remove elements.\n    -- We use a trick to propagate a value that is never computed, in order to know if, during update,\n    -- the last string had its first char deleted\n    case x of\n        [] -> {apply x = \"\", update {outputNew} = Ok (Inputs [[outputNew]])}.apply x\n        _ -> Update.applyLens {\n        apply (x, y) = x\n        update {output, diffs} = Ok (InputsWithDiffs\n          [((output, True), Just (VRecordDiffs { _1 = diffs, _2 = VConstDiffs}))])\n        } <| List.foldl2 (\\oldHeadList (oldAcc, dummyBool) ->\n      { apply (oldAcc, [head], dummyBool) = (oldAcc + head, dummyBool)\n        update {input=(oldAcc, [head], _) as input,outputNew=(newAcc, prevDeletedOrLast),diffs=ds} =\n          let handleDiffs = case ds of\n            VRecordDiffs {_1=VStringDiffs diffs} -> \\continuation -> continuation diffs\n            _ -> \\continuation -> Ok (InputsWithDiffs [(input, Nothing)])\n          in handleDiffs <| \\diffs ->\n          Update.splitStringDiffsAt (length oldAcc) 0 (oldAcc + head) newAcc diffs\n          |> List.concatMap (\\(leftValue, leftDiffs, rightValue, rightDiffs) ->\n            let lastCharLeftDeleted =\n              let aux leftDiffs = case leftDiffs of\n                [StringUpdate _ end 0] -> end == length oldAcc\n                head::tail -> aux tail\n                _ -> leftValue == \"\"\n              in aux leftDiffs\n            in\n            let firstCharDeleted = case rightDiffs of (StringUpdate 0 i 0) :: tail -> i > 0; _ -> False in\n            let surroundingElementsDeleted = lastCharLeftDeleted && prevDeletedOrLast in\n            let atLeastOneSurroundingElementDeleted = lastCharLeftDeleted || prevDeletedOrLast in\n            let elemDeleted = rightValue == \"\" && (firstCharDeleted || surroundingElementsDeleted) in\n            (if atLeastOneSurroundingElementDeleted && elemDeleted then [] else\n              [((leftValue, [rightValue], firstCharDeleted),\n                Update.pairDiff3\n                  (if leftDiffs == [] then Nothing else Just (VStringDiffs leftDiffs))\n                  (if rightDiffs == [] then Nothing else\n                   Just (VListDiffs [(0, ListElemUpdate (VStringDiffs rightDiffs))]))\n                  (if firstCharDeleted then Just VConstDiffs else Nothing)\n              )]) ++\n            (if elemDeleted then -- The string was deleted, one solution is to remove it.\n              [((leftValue, [], True),\n                Update.pairDiff3\n                  (if leftDiffs == [] then Nothing else Just (VStringDiffs leftDiffs))\n                  (Just (VListDiffs [(0, ListElemDelete 1)]))\n                  (Just VConstDiffs)\n                  )]\n            else [])\n          ) |> Update.valuesWithDiffs\n      }.apply (oldAcc, oldHeadList, dummyBool)\n      ) (freeze \"\", Update.softFreeze False) x\n\n  {substring,\n   take,\n   drop,\n   dropLeft,\n   dropRight,\n   sprintf} = LensLess.String\n\n  -- Repeats or shrinks s until it makes the given target length\n  (makeSize) s targetLength =\n    let n = length s in\n    if n < targetLength then makeSize (s + s) targetLength\n    else if n == targetLength then s\n    else take targetLength s\n\n  repeat n s = if n <= 0 then \"\" else if n == 1 then s else s + repeat (n - 1) s\n  slice = substring\n  left = take\n  right n x = dropLeft (max 0 ((length x) - n)) x\n\n  uncons s = case extractFirstIn \"^([\\\\s\\\\S])([\\\\s\\\\S]*)$\" s of\n    Just [x, y] -> Just (x, y)\n    Nothing -> Nothing\n\n  padLeft n c = Update.lens {\n    apply s = (List.range 1 (n - length s) |> List.map (always c) |> join \"\") + s\n    update {outputNew} =\n       case extractFirstIn (\"^(\" + c + \")*([\\\\s\\\\S]*)$\") outputNew of\n         Just [padding, str] -> Ok (Inputs [str])\n         Nothing -> Err \"String.pad could not complete\"\n  }\n\n  toInt = Update.lens\n    { apply x = strToInt x\n      unapply output = Just (toString output) }\n\n  toFloat = Update.lens\n      { apply x = strToFloat x -- TODO: Recognize strange floats (e.g. NaN, infinity)\n        unapply output = Just (toString output) }\n\n  join delimiter x =\n    if delimiter == \"\" then join_ x\n    else join__ delimiter x\n\n  -- In the forward direction, it joins the string.\n  -- In the backwards direction, if the delimiter is not empty, it splits the output string with it.\n  joinAndSplitBack regexSplit delimiter x = if delimiter == \"\" then join_ x else {\n        apply x = join__ delimiter x\n        update {output, oldOutput, diffs} =\n          Ok (Inputs [Regex.split regexSplit output])\n      }.apply x\n\n  length = Update.lens {\n    apply = length\n    update {input, oldOutput, newOutput} =\n      if newOutput < oldOutput then\n        Ok (InputsWithDiffs [(take newOutput input, Just (VStringDiffs [StringUpdate newOutput oldOutput 0]))])\n      else if newOutput == oldOutput then\n        Ok (InputsWithDiffs [(input, Nothing)])\n      else\n        let increment = newOutput - oldOutput in\n        let addition = makeSize (if input == \"\" then \"#\" else input) increment in\n        Ok (InputsWithDiffs [(input + addition, Just (VStringDiffs [StringUpdate oldOutput oldOutput increment]))])\n    }\n\n  trim s =\n    case extractFirstIn \"^\\\\s*([\\\\s\\\\S]*?)\\\\s*$\" s of\n      Just [trimmed] -> trimmed\n      _ -> s\n\n  update = {\n      freezeRight = Update.lens {\n        apply x = x\n        update {input, outputNew} =\n          if take (length input) outputNew == input then\n            Err <| \"Cannot add anything to the right of \'\" + input + \"\'\"\n          else\n            Ok <| Inputs [outputNew]\n      }\n\n      freezeLeft = Update.lens {\n        apply x = x\n        update {input, outputNew} =\n          if drop (length outputNew - length input) outputNew == input then\n            Err <| \"Cannot add anything to the left of \'\" + input + \"\'\"\n          else\n            Ok <| Inputs [outputNew]\n      }\n\n      debug tag text = onDeleteInsertLeftRight (\\l d i r ->\n        Debug.log (tag + \" deleted: \" + toString d + \", left: \" + toString (drop (max 0 (length l - 100)) l) + \", right: \" + toString (take 100 r) + \", inserted:\") i) text\n\n      onInsert callbackOnInserted string =\n        onDeleteInsertLeftRight (\\left deleted inserted right -> callbackOnInserted inserted) string\n\n      -- Enables to change the inserted text during back-propagation.\n      onDeleteInsertLeftRight callbackOnLeftDeletedInsertedRight string = Update.lens {\n        apply string = string\n        update {outputOld, outputNew, diffs=(VStringDiffs sDiffs)} =\n          let aux offset outputNewUpdated revDiffsUpdated oldDiffs = case oldDiffs of\n            [] -> Ok (InputsWithDiffs [\n              (outputNewUpdated, Just (VStringDiffs (List.reverse revDiffsUpdated)))])\n            ((StringUpdate start end replaced) as headDiff) :: tailOldDiffs ->\n              let inserted = substring (start + offset) (start + offset + replaced) outputNewUpdated in\n              let left = take (start+offset) outputNewUpdated in\n              let right = drop (start+offset+replaced) outputNewUpdated in\n              let deleted = substring start end outputOld in\n              let newInserted = callbackOnLeftDeletedInsertedRight left deleted inserted right in\n              let lengthNewInserted = length newInserted in\n              let newOffset = offset + lengthNewInserted - (end - start) in\n              let (newOutputNewUpdated, newDiff) = if inserted /= newInserted then\n                 ( take (start + offset) outputNewUpdated +\n                   newInserted + drop (start + offset + replaced) outputNewUpdated\n                 , StringUpdate start end lengthNewInserted)\n                 else (outputNewUpdated, headDiff)\n              in\n              aux newOffset newOutputNewUpdated (newDiff::revDiffsUpdated) tailOldDiffs\n           in aux 0 outputNew [] sDiffs\n       } string\n\n\n      -- Same version but also enables to change some state as well.\n      onDeleteInsertLeftRightState callbackOnLeftDeletedInsertedRightState state string = Update.lens {\n          apply (string, state) = string\n          update {input=(string, originalState), outputOld, outputNew, diffs=(VStringDiffs sDiffs)} =\n            let aux offset outputNewUpdated revDiffsUpdated oldDiffs state = case oldDiffs of\n              [] -> Ok (InputsWithDiffs [\n                ( (outputNewUpdated, state)\n                , Update.mbPairDiffs (\n                    Just <| VStringDiffs <| List.reverse revDiffsUpdated,\n                    Update.diffs originalState state\n                  )\n                )])\n              ((StringUpdate start end replaced) as headDiff) :: tailOldDiffs ->\n                let inserted = substring (start + offset) (start + offset + replaced) outputNewUpdated in\n                let left = take (start+offset) outputNewUpdated in\n                let right = drop (start+offset+replaced) outputNewUpdated in\n                let deleted = substring start end outputOld in\n                let (newInserted, state) = callbackOnLeftDeletedInsertedRightState left deleted inserted right state in\n                let lengthNewInserted = length newInserted in\n                let newOffset = offset + lengthNewInserted - (end - start) in\n                let (newOutputNewUpdated, newDiff) = if inserted /= newInserted then\n                   ( take (start + offset) outputNewUpdated +\n                     newInserted + drop (start + offset + replaced) outputNewUpdated\n                   , StringUpdate start end lengthNewInserted)\n                   else (outputNewUpdated, headDiff)\n                in\n                aux newOffset newOutputNewUpdated (newDiff::revDiffsUpdated) tailOldDiffs state\n             in aux 0 outputNew [] sDiffs originalState\n         } (string, state)\n\n      fixTagUpdates string = Update.lens {\n         apply string = string\n         update {outputOld, outputNew, diffs=(VStringDiffs sDiffs)} =\n           let aux offset revDiffsUpdated oldDiffs = case oldDiffs of\n             [] -> Ok (InputsWithDiffs [\n               (outputNew, Just (VStringDiffs (List.reverse revDiffsUpdated)))])\n             ((StringUpdate start end replaced) as headDiff) :: tailOldDiffs ->\n               let continueWith callback = case tailOldDiffs of\n                 StringUpdate start2 end2 replaced2 :: tailTailOldDiffs->\n                   if start2 <= end + 2 && start2 /= end then -- Second condition necessary to not merge immediate deletion/insertions\n                     if not <| Regex.matchIn \"[<>]\" (substring end start2 outputOld) then\n                       aux offset revDiffsUpdated (StringUpdate start end2 (replaced + replaced2 + start2 - end) :: tailTailOldDiffs)\n                     else\n                       callback ()\n                   else\n                     callback ()\n                 _ ->\n                 callback ()\n               in\n               continueWith <| \\_ ->\n               let inserted = substring (start + offset) (start + offset + replaced) outputNew in\n               let deleted = substring start end outputOld in\n               let right = drop (start + offset + replaced) outputNew in\n               let rightOld = drop end outputOld in\n               let left = take (start + offset) outputNew in\n               let newOffset = offset + replaced - (end - start) in\n               if Regex.matchIn \"\"\"^<[\\s\\S]*>$\"\"\" inserted && Regex.matchIn \"\"\"^<[\\s\\S]*>$\"\"\" deleted then\n                 -- <img> --> <br> It should be a true replacement instead, else we\'ll back-propagate the transformation inside the <>\n                 aux offset revDiffsUpdated (StringUpdate start end 0 :: StringUpdate end end replaced :: tailOldDiffs)\n               else\n               let newDiff =\n                    if Regex.matchIn \"^><\" inserted  && Regex.matchIn \"^>\" right then\n                      StringUpdate (start + 1) (end + 1) replaced\n                    else if Regex.matchIn \"<$\" left && Regex.matchIn \"><$\" inserted then\n                      StringUpdate (start - 1) (end - 1) replaced\n                    else if Regex.matchIn \"</$\" left && Regex.matchIn \"></$\" inserted then\n                      StringUpdate (start - 2) (end - 2) replaced\n                    else if Regex.matchIn \"<$\" left && Regex.matchIn \"<$\" deleted then\n                      StringUpdate (start - 1) (end - 1) replaced\n                    else if Regex.matchIn \"^>\" deleted && Regex.matchIn \"^>\" right then\n                      StringUpdate (start + 1) (end + 1) replaced\n                    else if Regex.matchIn \"<$\" left && Regex.matchIn \"^>\" right && Regex.matchIn \"^>\" rightOld then -- We expand the replacement\n                      StringUpdate (start - 1) (end + 1) (replaced + 2)\n                    else\n                      headDiff\n               in\n               aux newOffset (newDiff::revDiffsUpdated) tailOldDiffs\n            in aux 0 [] sDiffs\n        } string\n  }\n\n  newlines = {\n    isCRLF = Regex.matchIn \"\\r\\n\"\n    toUnix string =\n      if isCRLF string then\n        Regex.split \"\\r\\n\" string\n        |> joinAndSplitBack \"\\n\" \"\\n\"\n      else\n        string\n  }\n\n  toLowerCase string =\n    Regex.replace \"[A-Z]\" (\\m ->\n      Update.replaceInstead m.match <|\n      case m.match of\n        \"A\" -> \"a\"; \"B\" -> \"b\"; \"C\" -> \"c\"; \"D\" -> \"d\"; \"E\" -> \"e\"; \"F\" -> \"f\"; \"G\" -> \"g\"; \"H\" -> \"h\"; \"I\" -> \"i\";\n        \"J\" -> \"j\"; \"K\" -> \"k\"; \"L\" -> \"l\"; \"M\" -> \"m\"; \"N\" -> \"n\"; \"O\" -> \"o\"; \"P\" -> \"p\"; \"Q\" -> \"q\"; \"R\" -> \"r\";\n        \"S\" -> \"s\"; \"T\" -> \"t\"; \"U\" -> \"u\"; \"V\" -> \"v\"; \"W\" -> \"w\"; \"X\" -> \"x\"; \"Y\" -> \"y\"; \"Z\" -> \"z\"; _ -> m.match\n      ) string\n\n  toUpperCase string =\n    Regex.replace \"[a-z]\" (\\m ->\n      Update.replaceInstead m.match <|\n      case m.match of\n        \"a\" -> \"A\"; \"b\" -> \"B\"; \"c\" -> \"C\"; \"d\" -> \"D\"; \"e\" -> \"E\"; \"f\" -> \"F\"; \"g\" -> \"G\"; \"h\" -> \"H\"; \"i\" -> \"I\";\n        \"j\" -> \"J\"; \"k\" -> \"K\"; \"l\" -> \"L\"; \"m\" -> \"M\"; \"n\" -> \"N\"; \"o\" -> \"O\"; \"p\" -> \"P\"; \"q\" -> \"Q\"; \"r\" -> \"R\";\n        \"s\" -> \"S\"; \"t\" -> \"T\"; \"u\" -> \"U\"; \"v\" -> \"V\"; \"w\" -> \"W\"; \"x\" -> \"X\"; \"y\" -> \"Y\"; \"z\" -> \"Z\"; _ -> m.match\n      ) string\n\n  markdown text =\n    let escapeHtml = Regex.replace \"[<>&]\" (case of\n          {match = \"<\"} -> freeze \"&lt;\"\n          {match = \">\"} -> freeze \"&gt;\"\n          {match = \"&\"} -> freeze \"&amp;\")\n        escapeAttribute = Regex.replace \"\\r?\\n|\\\"\" (case of\n          \"\\\"\" -> \"\\\\\\\"\"\n          _ -> \"\")\n        notincode = \"\"\"(?!(?:(?!<code>)[\\s\\S])*</code>)\"\"\"\n        notinulol = \"\"\"(?!(?:(?!<[uo]l>)[\\s\\S])*</[uo]l>)\"\"\"\n        notinattr = \"\"\"(?!(?:(?!<)[\\s\\S])*>)\"\"\"\n        regexFootnotes = \"\"\"\\r?\\n\\[\\^@notincode([^\\]]+)\\]:\\s*@notincode((?:(?!\\r?\\n\\r?\\n)[\\s\\S])+)@notincode\"\"\"\n        regexReferences = \"\"\"\\r?\\n\\[(?!\\^)([^\\]\\\\]+)\\]:\\s*@notincode(\\S+)@notincode\"\"\"\n        footnotes = Regex.find regexFootnotes text\n                     |> List.map (\\m -> (nth m 1, nth m 2))\n                     |> List.indexedMap (\\i (name, value) -> (name, (i + 1, value)))\n        references = Regex.find regexReferences text\n                     |> List.map (\\m -> (nth m 1, nth m 2))\n        r  = Regex.replace\n        lregex = \"\"\"(?:\\r?\\n|^)((?:(?![\\r\\n])\\s)*)(\\*|-|\\d+\\.)(\\s+)((?:@notincode.*)(?:\\r?\\n\\1  ?\\3(?:@notincode.*))*(?:\\r?\\n\\1(?:\\*|-|\\d+\\.)\\3(?:@notincode.*)(?:\\r?\\n\\1 \\3(?:@notincode.*))*)*)@notincode\"\"\"\n        handleLists text  =\n          flip (r lregex) text <|\n            \\m -> let indent = nth m.group 1\n                      afterindent = nth m.group 3\n                      symbol = nth m.group 2\n                      ul_ol = Update.bijection\n                               (case of \"*\" -> \"ul\"; \"-\" -> \"ul\"; _ -> \"ol\")\n                               (case of\n                                 \"ul\" -> if symbol == \"*\" || symbol == \"-\" then symbol else \"*\"\n                                 \"ol\" -> if symbol == \"*\" || symbol == \"-\" then \"1.\" else symbol\n                                 x -> error \"\"\"tag name \'@x\' not compatible with ul or ol\"\"\")\n                               symbol\n                      elements =\n                        Regex.split \"\"\"\\r?\\n@indent(?:\\*|-|\\d+\\.)@afterindent\"\"\" (nth m.group 4)\n                      insertionPoint callback = Update.lens {\n                        apply elements = \"\"\n                        update {input=elements, output} =\n                          case Regex.extract \"\"\"^<li>([\\s\\S]*)</li>$\"\"\" output of\n                            Just [content] ->\n                              Ok (Inputs [callback elements (Regex.split \"\"\"</li><li>\"\"\" content)]) -- TODO: Precompute diffs (insertions)\n                            _->\n                              Err (\"Can only insert <li> elements to lists, got \" + output)\n                      } elements\n                      insertAfter = insertionPoint (append)\n                      insertBefore = insertionPoint (flip append)\n                  in\n                  Update.freezeExcept (\\_ ->  \"ul template\")  [ul_ol, insertBefore, handleLists, elements, notinulol, insertAfter] <|\n                                                             \\[ul_ol, insertBefore, handleLists, elements, notinulol, insertAfter] ->\n                  \"\"\"<@ul_ol>@insertBefore<li>@(\n                    List.map handleLists elements\n                    |> joinAndSplitBack \"\"\"</li><li>@notinulol\"\"\" \"</li><li>\")</li>@insertAfter</@ul_ol>\"\"\"\n\n        handleblockquotes text =\n          Regex.replace \"\"\"(?:(?:\\r?\\n|^)>(?!.*</.*).*)+@notincode\"\"\" (\\m ->\n           Regex.extract \"\"\"(\\r?\\n|^)>([\\s\\S]*)\"\"\" m.match\n           |> Maybe.map (\\[newline, content] ->\n             let quoteContent =\n                  Regex.replace \"\"\"(\\r?\\n)> *\"\"\" (\\m -> nth m.group 1) content\n             in\n             let recursivecontent = quoteContent |> handleblockquotes in\n             Update.freezeExcept (\\_ -> \"blockquote template\") [newline, recursivecontent] <|\n                                                              \\[newline, recursivecontent] ->\n             \"\"\"@newline<blockquote>@recursivecontent</blockquote>\"\"\"\n           ) |> Maybe.withDefault m.match\n          ) text\n    in let\n    text =\n      r \"\"\"(```)([\\s\\S]*?)\\1(?!`)|(\\r?\\n *|^ *)((?:\\r?\\n    .*)+)\"\"\" (\\m ->\n      if nth m.group 1 == \"\" then\n        nth m.group 4 |>\n        Regex.extract \"\"\"^\\r?\\n    ([\\s\\S]*)$\"\"\" |>\n        Maybe.map (\\[code] ->\n                nth m.group 3 + \"\"\"<pre><code>@(Regex.split \"\"\"\\r?\\n    \"\"\" code |> join \"\\n\" |> trim |> escapeHtml)</code></pre>\"\"\")\n        |> Maybe.withDefault m.match\n      else\n      \"\"\"<pre><code>@(nth m.group 2 |> trim |> escapeHtml)</code></pre>\"\"\") text\n    text =  handleblockquotes text\n    text =  r \"\"\"(`)(?=[^\\s`])(@notincode.*?)\\1@notincode\"\"\" (\\m -> \"\"\"<code>@(nth m.group 2 |> escapeHtml)</code>\"\"\") text\n    text =  r \"\"\"(?:@regexReferences|@regexFootnotes)@notincode\"\"\" (\\m -> \"\") text\n    text = -- Expand footnotes\n      if List.length footnotes == 0 then text\n      else text + \"\"\"\n  <div class=\"footnotes\"><hr><ol>@(footnotes |>\n              List.map (\\(name, (n, value)) ->\n                \"\"\"<li id=\"fn@n\"><p>@value<a href=\"#fnref@n\">â†©</a></p></li>\"\"\"\n              ) |> join \"\")</ol></div>\"\"\"\n    text = r \"\"\"(^|\\r?\\n)(#+)\\s*(@notincode[^\\r\\n]*)@notincode\"\"\" (\\m ->\n      let hlevel = \"\"\"h@(length (nth m.group 2))\"\"\" in\n      Update.freezeExcept (always \"h-template\") [m, hlevel] <| \\[m, hlevel] -> \"\"\"@(nth m.group 1)<@hlevel>@(nth m.group 3)</@hlevel>\"\"\") text\n    text = handleLists text\n    text = r \"\"\"(?:(\\r?\\n *\\r?\\n)(?:\\\\noindent\\r?\\n)?|^)((?=\\s*\\w|\\S)@notincode[\\s\\S]*?)(?=(\\r?\\n *\\r?\\n|\\r?\\n$|$))@notincode\"\"\" (\n      \\m ->\n        if nth m.group 1 == \"\" && nth m.group 3 == \"\" -- titles and images should not be paragraphs.\n         || Regex.matchIn \"\"\"</?(?:h\\d|ul|ol|p|pre|center)>\"\"\" (nth m.group 2) then m.match else Update.freezeExcept (always \"p template\") m <| \\m -> \"\"\"@(nth m.group 1)<p>@(nth m.group 2)</p>\"\"\") text\n    text = r \"\"\"(!?)\\[([^\\]\\[\\\\]+)\\](\\^?)(\\(|\\[)([^\\[\\)\\]\\s]+)\\s?\"?([^\\)\\]\"]+)?\"?(?:\\)|\\])|(?:http|ftp|https):\\/\\/(?:[\\w_-]+(?:(?:\\.[\\w_-]+)+))(?:[\\w.,@@?^=%&:/~+#-]*[\\w@@?^=%&/~+#-])?@notincode@notinattr\"\"\" (\n      \\{group=[match, picPrefix, text, targetblank, parensStyle, url, title]} ->  -- Direct and indirect References + syntax ^ to open in external page.\n      let a = if picPrefix == \"!\" then \"img\" else \"a\"\n          aclose = if picPrefix == \"!\" then \"\" else text + \"</a>\"\n          href = if picPrefix == \"!\" then \"src\" else \"href\"\n          t = if title == \"\" then \"\" else \" title=\'\" + title + \"\'\"\n          targetblank = if targetblank == \"^\" then \"\"\" target=\'_blank\'\"\"\" else \"\"\n          alt = if picPrefix == \"!\" then \"\"\" alt=\'@text\'\"\"\" else \"\"\n      in\n      case parensStyle of\n        \"(\" -> (Update.freezeWhen True toString (\\a t href url targetblank alt aclose -> \"\"\"<@a @t @href=\"@url\"@targetblank@alt>@aclose\"\"\"))\n                  a t href url targetblank alt aclose\n        \"[\" -> listDict.get url references |> case of\n              Just link ->\n                Update.freezeExcept (always \"a or img relative template\")\n                  [a, t, href, link, targetblank, alt, aclose] <|\n                 \\[a, t, href, link, targetblank, alt, aclose] ->\n               \"\"\"<@a @t @href=\"@link\"@targetblank@alt>@aclose\"\"\"\n              Nothing -> match\n        _ -> Update.freezeExcept (always \"full URL template\") match <| \\match -> \"\"\"<a href=\"@match\">@(escapeHtml match)</a>\"\"\"\n        ) text\n    text = r \"\"\"\\[\\^(@notincode[^\\]]+)\\]@notincode\"\"\" (\\m ->  -- Footnotes\n      listDict.get (nth m.group 1) footnotes |> case of\n        Just (n, key) ->\n          Update.freezeExcept (always \"footnote template\") [n, key] <| \\[n, key] ->\n          \"\"\"<a href=\"#fn@n\" title=\"@(escapeAttribute key)\" class=\"footnoteRef\" id=\"fnref@n\"><sup>@n</sup></a>\"\"\"\n        Nothing -> m.match) text\n    text = r \"\"\"(\\*{1,3}|_{1,3})(?=[^\\s\\*_])(@notincode(?:(?!\\\\\\*|\\_).)*?)(\\1)@notincode@notinattr\"\"\" (\\m ->\n      let content = nth m.group 2 in\n      let n = nth m.group 1 |> length in\n      let m = nth m.group 3 |> length in\n      let (start, end)= Update.lens2 {\n        apply (n, m) = case n of\n          1 -> (\"<em>\", \"</em>\")\n          2 -> (\"<strong>\", \"</strong>\")\n          3 -> (\"<em><strong>\", \"</strong></em>\")\n        update {outputNew=(start,end)} = case (start, end) of\n          (\"\", \"\") -> Ok (Inputs [(0, 0)])\n          (\"<span>\", \"</span>\") -> Ok (Inputs [(0, 0)])\n          (\"<em>\", \"</em>\") -> Ok (Inputs [(1, 1)])\n          (\"<strong>\", \"</strong>\") -> Ok (Inputs [(2, 2)])\n          _ -> Err \"Cannot touch em and strong tags directly. For now, just delete and replace the text without italics/bold\"\n      } n m\n      in start + content + end) text\n    text = r \"\"\"(&mdash;|\\\\\\*|\\\\_|\\\\\\[|\\\\\\]|  \\r?\\n)@notincode\"\"\" (\\m -> case m.match of\n      \"&mdash;\" -> \"â€”\"\n      \"\\\\*\" -> drop 1 m.match\n      \"\\\\_\" -> drop 1 m.match\n      \"\\\\[\" -> drop 1 m.match\n      \"\\\\]\" -> drop 1 m.match\n      \"  \\r\\n\" -> \"<br>\"\n      \"  \\n\" -> \"<br>\"\n      ) text\n    text = update.onDeleteInsertLeftRight (\\left deleted inserted right ->\n      let\n        inserted =\n          Regex.replace \"\"\"<(b|i|em|strong)>(?=\\S)((?:(?!</\\1\\s*>).)*\\S)</\\1\\s*>\"\"\" (\\m ->\n            let tag = nth m.group 1\n                content = nth m.group 2\n            in if tag == \"b\" || tag == \"strong\" then\n              \"**\" + content + \"**\"\n            else\n              \"*\" + content + \"*\"\n          ) inserted\n        inserted =\n          Regex.replace \"\"\"\\s*<(h([1-6]))>((?:(?!</\\1\\s*>).)*)</\\1\\s*>\\s*\"\"\" (\\m ->\n              let n = String.toInt <| nth m.group 2\n                  hash = String.repeat n \"#\"\n              in \"\\n\\n\" + hash + \" \" + String.trim (nth m.group 3) + \"\\n\\n\"\n            ) inserted\n        inserted = case Regex.extract \"\"\"^([\\s\\S]*)</p>\\s*<p>([\\s\\S]*)$\"\"\" inserted of\n          Just [before, after] -> before + \"\\n\\n\" + after\n          _ -> inserted\n        inserted = case Regex.extract \"\"\"^([\\s\\S]*)<div>([\\s\\S]*)</div>([\\s\\S]*)$\"\"\" inserted of\n          Just [before, paragraph, after] ->\n             before + \"\\n\\n\" + paragraph + after\n          _ -> inserted\n        inserted = case Regex.extract \"\"\"^([\\s\\S]*)<(/?)(b|i|strong|em)\\s*>([\\s\\S]*)$\"\"\" inserted of\n          Just [before, mbSlash, bi, after] ->\n            let mdtag = if bi == \"b\" || bi == \"strong\" then \"**\" else \"*\" in\n            let mdtagregex = if bi == \"b\" then \"\\\\*\\\\*\" else \"\\\\*\" in\n            if mbSlash == \"\" && Regex.matchIn \"\"\"^\\S(?:(?!</@bi\\s*>).)*?\\S</@bi\\s*>\"\"\" (after + right) then\n              before + mdtag + after\n            else if mbSlash == \"/\" && Regex.matchIn \"\"\"@mdtagregex\\S(?:(?!@mdtagregex).)*?$\"\"\" (left + before) then\n              before + mdtag + after\n            else inserted\n          _ -> inserted\n        inserted = Regex.replace \"\"\"<a href=\"((?:(?!</a>).)*)\">((?:(?!</a>).)*)</a>\"\"\" (\\{submatches=[url, text]} ->\n             \"[\" + text + \"](\"+ url +\")\"\n          ) inserted\n        inserted = Regex.replace \"\"\"<img[^>]+\\bsrc=[^>]+>\"\"\" (\\match ->\n           case htmlViaEval match.match of\n              [[\"img\", attrs, _]] ->\n                let title = attrDict.get \"title\" attrs |> Maybe.map (\\x -> \" \\\"\" + x + \"\\\"\") |> Maybe.withDefault \"\"\n                    alt = attrDict.get \"alt\" attrs |> Maybe.map (\\x -> if x == \"\" then \"Image\" else x) |> Maybe.withDefault \"Image\"\n                    url = attrDict.get \"src\" attrs |> Maybe.withDefault \"url\"\n                in\n                \"![\" + alt + \"](\"+ url + title + \")\"\n              _ -> match.match) inserted\n      in inserted\n      ) text\n    text = update.fixTagUpdates text\n    in text\n\n  q3 = \"\\\"\\\"\\\"\" -- To interpolate triple quotes into strings\n}\n\n\n--------------------------------------------------------------------------------\n-- Maybe --\n\nMaybe =\n  { type Maybe a = Nothing | Just a\n\n    -- Returns the first argument if the second is Nothing. If the second is Just x returns x\n    withDefault d mb =\n      case mb of\n        Nothing -> d\n        Just j -> j\n\n    -- Like withDefault, but if the default was used and we push a new value,\n    -- it will push it back as a \"Just\" before trying the usual behavior. Ideal for displaying placeholders.\n    withDefaultReplace = Update.lens2 {\n      apply (d, mb) = case mb of\n        Nothing -> d\n        Just j -> j\n      update {input=(d,mb) as input,outputNew} as uInput =\n        Ok (InputsWithDiffs ([((d, Just outputNew),\n              Update.diffs mb (Just outputNew) |> LensLess.Maybe.map Update.vTupleDiffs_2)] ++ (\n              if mb /= Nothing then [] else Update.defaultAsListWithDiffs apply uInput)))\n    }\n\n    -- Like withDefault, but the default value is a callback that is called if mb is empty.\n    withDefaultLazy df mb =\n      case mb of\n        Nothing -> df ()\n        Just j -> j\n\n    -- Like withDefault, but if the default was used and we push a new value,\n    -- it will push it back as a \"Just\" before trying the usual behavior. Ideal for displaying placeholders.\n    withDefaultReplaceLazy = Update.lens2 {\n      apply (df, mb) = case mb of\n        Nothing -> df ()\n        Just j -> j\n      update {input=(df,mb) as input,outputNew} as uInput =\n        Ok (InputsWithDiffs ([((df, Just outputNew),\n              Update.diffs mb (Just outputNew) |> LensLess.Maybe.map Update.vTupleDiffs_2)] ++ (\n              if mb /= Nothing then [] else Update.defaultAsListWithDiffs apply uInput)))\n    }\n\n    map = Update.lens2 {\n      apply (f, a) = case a of\n        Nothing -> Nothing\n        Just x -> Just (f x)\n      update = case of\n        {outputOld=Just x, outputNew=Nothing} ->\n          Ok (InputsWithDiffs [((f, Nothing), Update.mbPairDiffs (Nothing, Just VConstDiffs))])\n        uInput -> Update.default apply uInput\n    }\n\n    -- Like map, but does not fail if the input was NOthing and the new output is Just, because it knows a default element.\n    mapWithDefault = Update.lens2 {\n      apply (default, f, a) = case a of\n        Nothing -> Nothing\n        Just x -> Just (f x)\n      update = case of\n        {outputOld=Just x, outputNew=Nothing} ->\n           Ok (InputsWithDiffs [((f, Nothing), Update.mbPairDiffs (Nothing, Just VConstDiffs))])\n        {outputOld=Nothing, outputNew=Just x} ->\n           case Update.updateApp {fun (_, f, x) = f x, input = (default, f, default), outputNew = x} of\n             Err msg -> Err msg\n             Ok (InputsWithDiffs inputsWithDiffs) ->\n               Ok (InputsWithDiffs (inputsWithDiffs |> List.map (\\((default, f, newX), newDiff) ->\n                 ((default, f, Just newX), case newDiff of\n                   Just _ -> Just (VRecordDiffs { _3=VConstDiffs})\n                   Nothing -> Nothing)\n               )))\n        uInput -> Update.default apply uInput\n    }\n\n    andThen f a = case a of\n      Nothing -> Nothing\n      Just x -> f x\n\n    orElse mb2 mb1 = case mb1 of\n      Just _ -> mb1\n      Nothing -> mb2\n\n    -- like orElse, but in the reverse direction, will try to push Nothing to mb1\n    orElseReplace = Update.lens2 {\n      apply (mb2, mb1) = case mb1 of\n        Nothing -> mb2\n        Just x -> mb1\n      update {input=(mb2, mb1), outputOld, outputNew} =\n        case outputNew of\n          Just _ -> case mb1 of\n            Nothing -> Ok (Inputs [(mb2, outputNew), (outputNew, mb1)])\n            Just _ -> Ok (Inputs [(mb2, outputNew)])\n          Nothing -> Ok (Inputs [(mb2, Nothing)])\n    }\n\n    -- Given emptyCondition and Just x, returns x.\n    -- On the reverse direction, if the new x passes the emptyCondition, propagates back Nothing\n    getUnless emptyCondition = Update.lens {\n      apply (Just x) = x\n      update {outputNew} as uInput =\n        if emptyCondition outputNew then\n          Ok (Inputs [Nothing])\n        else\n          Update.default apply uInput\n    }\n\n    fold : a -> (x -> a) -> Maybe x -> a\n    fold onNothing onJust content =\n      case content of\n        Nothing -> onNothing\n        Just c -> onJust c\n\n    foldLazy : (() -> a) -> (x -> a) -> Maybe x -> a\n    foldLazy onNothing onJust content =\n      case content of\n        Nothing -> onNothing ()\n        Just c -> onJust c\n  }\n\n-- if we decide to allow types to be defined within (and exported from) modules\n--\n-- {Nothing, Just} = Maybe\n--\n-- might look something more like\n--\n-- {Maybe(Nothing,Just)} = Maybe\n-- {Maybe(..)} = Maybe\n--\n-- -- Sample deconstructors once generalized pattern matching works.\n-- Nothing$ = {\n--   unapplySeq exp = case exp of\n--     {$d_ctor=\"Nothing\", args=[]} -> Just []\n--     _ -> Nothing\n-- }\n-- Just$ = {\n--   unapplySeq exp = case exp of\n--     {$d_ctor=\"Just\", args=[x]} -> Just [x]\n--     _ -> Nothing\n-- }\n\n--------------------------------------------------------------------------------\n-- Tuple --\n\nTuple =\n  { mapFirst f (x, y) = (f x, y)\n    mapSecond f (x, y) = (x, f y)\n    first (x, y) = x\n    second (x, y) = y\n  }\n\n--------------------------------------------------------------------------------\n-- Editor --\n\nEditor = {}\n\n-- TODO remove this; add as imports as needed in examples\n{freeze, applyLens} = Update\n\n-- Custom Update: List Map, List Append, ...\n\n-- TODO\n\n-- HTML\n\n--------------------------------------------------------------------------------\n-- Html.html\n\n--type HTMLAttributeValue = HTMLAttributeUnquoted WS WS String | HTMLAttributeString WS WS String {-Delimiter char-}  String | HTMLAttributeNoValue\n--type HTMLAttribute = HTMLAttribute WS String HTMLAttributeValue\n--type HTMLCommentStyle = Less_Greater String {- The string should start with a ? -}\n--                      | LessSlash_Greater {- The string should start with a space -} String\n--                      | LessBang_Greater String\n--                      | LessBangDashDash_DashDashGreater String\n\n--type HTMLClosingStyle = RegularClosing WS | VoidClosing | AutoClosing | ForgotClosing\n--type HTMLEndOpeningStyle = RegularEndOpening {- usually > -} | SlashEndOpening {- add a slash before the \'>\' of the opening, does not mark the element as ended in non-void HTML elements -}\n-- HTMLInner may have unmatched closing tags inside it. You have to remove them to create a real innerHTML\n-- HTMLInner may have unescaped chars (e.g. <, >, & etc.)\n--type HTMLNode = HTMLInner String\n--              | HTMLElement String (List HTMLAttribute) WS HTMLEndOpeningStyle (List HTMLNode) HTMLClosingStyle\n--              | HTMLComment HTMLCommentStyle\n\nupdateOutputToResults c = case c of\n  Ok (Inputs i) -> Ok i\n  Ok (InputsWithDiffs id) -> Ok (List.unzip id |> Tuple.first)\n  Err msg -> Err msg\n\n-- Returns a list of HTML nodes parsed from a string. It uses the API for loosely parsing HTML\n-- Example: html \"Hello<b>world</b>\" returns [[\"TEXT\",\"Hello\"],[\"b\",[], [[\"TEXT\", \"world\"]]]]\nhtml string = {\n  apply trees =\n    let unwrapcontent elems = List.map (case of\n      HTMLAttributeStringRaw raw -> raw\n      HTMLAttributeEntity rendered _ -> rendered) elems |> String.join \"\" in\n    let domap tree = case tree of\n      HTMLInner v -> [\"TEXT\",\n        replaceAllIn \"</[^>]*>\" (\\{match} -> \"\") v]\n      HTMLEntity entityRendered entity -> [\"TEXT\", entityRendered]\n      HTMLElement tagName attrs ws1 endOp children closing ->\n        [ tagName\n        , map (case of\n          HTMLAttribute ws0 name value ->\n            let (name, content) = case value of\n              HTMLAttributeUnquoted _ _ content -> (name, unwrapcontent content)\n              HTMLAttributeString _ _ _ content -> (name, unwrapcontent content)\n              HTMLAttributeNoValue -> (name, \"\")\n            in\n            if name == \"style\" then\n              let styleContent = Regex.split \"(?=;\\\\s*\\\\S)\" content |> LensLess.List.filterMap (\n                  Regex.extract \"^;?([\\\\s\\\\S]*):([\\\\s\\\\S]*);?\\\\s*$\"\n                )\n              in\n              [name, styleContent]\n            else [name, content]\n            ) attrs\n        , map domap children]\n      HTMLComment {args = {_1=content}} -> [\"comment\", [[\"display\", \"none\"]], [[\"TEXT\", content]]]\n    in map domap trees\n\n  update {input, oldOutput, newOutput, diffs} =\n    let toHTMLAttribute [name, mbStyleValue] =\n      let value =\n        if name == \"style\" then\n          LensLess.String.join \"; \" (LensLess.List.map (\\[styleName, styleValue] ->\n            styleName + \":\" + styleValue\n          ) mbStyleValue)\n        else mbStyleValue\n      in\n      HTMLAttribute \" \" name (HTMLAttributeString \"\" \"\" \"\\\"\" value) in\n    let toHTMLInner text = HTMLInner (replaceAllIn \"<|>|&\" (\\{match} -> case match of \"&\" -> \"&amp;\"; \"<\" -> \"&lt;\"; \">\" -> \"&gt;\"; _ -> \"\") text) in\n    let toHTMLNode e = case e of\n      [\"TEXT\",v2] -> toHTMLInner v2\n      [tag, attrs, children] -> HTMLElement tag (map toHTMLAttribute attrs) \"\"\n           RegularEndOpening (map toHTMLNode children) (RegularClosing \"\")\n    in\n    let reconcile oldAttrElems newString = [HTMLAttributeStringRaw newString] in\n    let mergeAttrs input oldOutput newOutput diffs =\n      Update.foldDiff {\n        start =\n          -- Accumulator of HTMLAttributes, accumulator of differences, original list of HTMLAttributes\n          ([], [], input)\n        onSkip (revAcc, revDiffs, input) {count} =\n          --\'outs\' was the same in oldOutput and outputNew\n          let (newRevAcc, remainingInput) = LensLess.List.reverse_move count revAcc input in\n          Ok [(newRevAcc, revDiffs, remainingInput)]\n\n        onUpdate (revAcc, revDiffs, input) {oldOutput, newOutput, diffs, index} =\n          let inputElem::inputRemaining = input in\n          let newInputElem = case (inputElem, newOutput) of\n            (HTMLAttribute sp0 name value, [name2, value2 ]) ->\n             let realValue2 =\n               if name == \"style\" then -- value2\n                 String.join \"\" (List.map (\\[styleName, styleValue] ->\n                   styleName + \":\" + styleValue + \";\"\n                 ) value2)\n               else value2\n             in\n             case value of\n               HTMLAttributeUnquoted sp1 sp2 v ->\n                 case extractFirstIn \"\\\\s\" realValue2 of\n                   Nothing ->\n                     HTMLAttribute sp0 name2 (HTMLAttributeUnquoted sp1 sp2 (reconcile v realValue2))\n                   _ ->\n                     HTMLAttribute sp0 name2 (HTMLAttributeString sp1 sp2 \"\\\"\" (reconcile v realValue2))\n               HTMLAttributeString sp1 sp2 delim v ->\n                     HTMLAttribute sp0 name2 (HTMLAttributeString sp1 sp2 delim (reconcile v realValue2))\n               HTMLAttributeNoValue ->\n                  if value2 == \"\" then HTMLAttribute sp0 name2 (HTMLAttributeNoValue)\n                  else toHTMLAttribute [name2, value2]\n               _ -> Debug.crash <| \"expected HTMLAttributeUnquoted, HTMLAttributeString, HTMLAttributeNoValue, got \" ++ toString (inputElem, newOutput)\n            _ -> Debug.crash \"Expected HTMLAttribute, got \" ++ toString (inputElem, newOutput)\n          in\n          let newRevDiffs = case Update.diff inputElem newInputElem of\n            Ok (Just d) -> (index, ListElemUpdate d)::revDiffs\n            Ok (Nothing) ->  revDiffs\n            Err msg -> Debug.crash msg\n          in\n          Ok [(newInputElem::revAcc, newRevDiffs, inputRemaining)]\n\n        onRemove (revAcc, revDiffs, input) {oldOutput, index} =\n          let _::remainingInput = input in\n          Ok [(revAcc, (index, ListElemDelete 1)::revDiffs, remainingInput)]\n\n        onInsert (revAcc, revDiffs, input) {newOutput, index} =\n          Ok [(toHTMLAttribute newOutput :: revAcc, (index, ListElemInsert 1)::revDiffs, input)]\n\n        onFinish (revAcc, revDiffs, _) =\n          Ok [(reverse revAcc, reverse revDiffs)]\n\n        onGather (acc, diffs) =\n          Ok (InputWithDiff (acc,\n               (if len diffs == 0 then Nothing else Just (VListDiffs diffs))))\n      } oldOutput newOutput diffs\n    in\n    -- Returns Ok (List (List HTMLNode)., diffs = List (Maybe ListDiff)} or Err msg\n    let mergeNodes input oldOutput newOutput diffs =\n      Update.foldDiff {\n        start =\n          -- Accumulator of values, accumulator of differences, original input\n          ([], [], input)\n\n        onSkip (revAcc, revDiffs, input) {count} =\n          --\'outs\' was the same in oldOutput and outputNew\n          let (newRevAcc, remainingInput) = LensLess.List.reverse_move count revAcc input in\n          Ok [(newRevAcc, revDiffs, remainingInput)]\n\n        onUpdate (revAcc, revDiffs, input) {oldOutput, newOutput, diffs, index} =\n          let inputElem::inputRemaining = input in\n          --Debug.start (\"onUpdate\" + toString (oldOutput, newOutput, diffs, index)) <| \\_ ->\n          let newInputElems = case (inputElem, oldOutput, newOutput) of\n            ( HTMLInner v, _, [\"TEXT\",v2]) -> Ok [toHTMLInner v2]\n            ( HTMLEntity entityRendered entity, _, [\"TEXT\", v2]) -> Ok [HTMLEntity v2 v2]\n            ( HTMLElement tagName attrs ws1 endOp children closing,\n              [tag1, attrs1, children1], [tag2, attrs2, children2] ) ->\n               if tag2 == tagName || attrs1 == attrs2 || children2 == children1  then\n                 case diffs of\n                   VListDiffs listDiffs ->\n                     let (newAttrsMerged, otherDiffs) = case listDiffs of\n                       (1, ListElemUpdate diffAttrs)::tailDiff ->\n                         (mergeAttrs attrs attrs1 attrs2 diffAttrs, tailDiff)\n                       _ -> (Ok (Inputs [attrs]), listDiffs)\n                     in\n                     let newChildrenMerged = case otherDiffs of\n                       (2, ListElemUpdate diffNodes)::_ ->\n                         case mergeNodes children children1 children2 diffNodes of\n                           Ok (InputsWithDiffs vds) -> Ok (List.map Tuple.first vds)\n                           Err msg -> Err msg\n                       _ -> Ok [children]\n                     in\n                     newAttrsMerged |> updateOutputToResults |> LensLess.Results.andThen (\\newAttrs ->\n                       newChildrenMerged |>LensLess.Results.andThen (\\newChildren ->\n                         Ok [HTMLElement tag2 newAttrs ws1 endOp newChildren closing]\n                       )\n                     )\n               else Ok [toHTMLNode newOutput]\n            _ -> Ok [toHTMLNode newOutput]\n          in\n          newInputElems |>LensLess.Results.andThen (\\newInputElem ->\n            --Debug.start (\"newInputElem:\" + toString newInputElem) <| \\_ ->\n            case Update.diff inputElem newInputElem of\n              Err msg -> Err msg\n              Ok maybeDiff ->\n                let newRevDiffs = case maybeDiff of\n                  Nothing -> revDiffs\n                  Just v -> (index, ListElemUpdate v)::revDiffs in\n                Ok [ (newInputElem::revAcc, newRevDiffs, inputRemaining) ]\n          )\n\n        onRemove (revAcc, revDiffs, input) {oldOutput, index} =\n          let _::remainingInput = input in\n          Ok [(revAcc, (index, ListElemDelete 1)::revDiffs, remainingInput)]\n\n        onInsert (revAcc, revDiffs, input) {newOutput, index} =\n          Ok [(toHTMLNode newOutput :: revAcc, (index, ListElemInsert 1)::revDiffs, input)]\n\n        onFinish (revAcc, revDiffs, _) =\n          Ok [(reverse revAcc, reverse revDiffs)]\n\n        onGather (acc, diffs) =\n          Ok (InputWithDiff (acc, if len diffs == 0 then Nothing else Just (VListDiffs diffs)))\n      } oldOutput newOutput diffs\n    in mergeNodes input oldOutput newOutput diffs\n}.apply (parseHTML string)\n\n\n--------------------------------------------------------------------------------\n-- Html module\n\nHtml = {\n  -- Returns a list of one text element from a string, and updates by taking all the pasted text.\n  text = Update.lens {\n    apply s = [[\"TEXT\", s]]\n    update {output} =\n      let textOf = case of\n        [\"TEXT\", s]::tail -> s + textOf tail\n        [tag, attrs, children]::tail ->\n          textOf children + textOf tail\n        _ -> \"\"\n      in\n      Ok (Inputs [textOf output])\n  }\n\n  textNode text = [\"TEXT\", text]\n\n  (textElementHelper) tag styles attrs textContent =\n    [ tag,  [\"style\", styles] :: attrs , text textContent ]\n\n  p = textElementHelper \"p\"\n  th = textElementHelper \"th\"\n  td = textElementHelper \"td\"\n  h1 = textElementHelper \"h1\"\n  h2 = textElementHelper \"h2\"\n  h3 = textElementHelper \"h3\"\n  h4 = textElementHelper \"h4\"\n  h5 = textElementHelper \"h5\"\n  h6 = textElementHelper \"h6\"\n  pre = textElementHelper \"pre\"\n\n  (elementHelper) tag styles attrs children =\n    [ tag,  [\"style\", styles] :: attrs , children ]\n\n  div = elementHelper \"div\"\n  tr = elementHelper \"tr\"\n  table = elementHelper \"table\"\n  span = elementHelper \"span\"\n  b= elementHelper \"b\"\n  i= elementHelper \"i\"\n  li = elementHelper \"li\"\n  ul = elementHelper \"ul\"\n  br = [\"br\", [], []]\n\n  element = elementHelper\n\n  parse = html\n  parseViaEval = htmlViaEval\n\n  freshTag = Update.lens {\n    apply x = \"dummy\" + toString (getCurrentTime x)\n    update {input} = Ok (InputsWithDiffs [(input, Nothing)]) }\n\n  integerRefresh i node = [\"\"\"span@i\"\"\", [], [node]]\n\n  forceRefresh node = [freshTag True, [], [node]]\n\n  (option) value selected content =\n    <option v=value @(\n      Update.bijection\n        (\\selected -> if selected then [[\"selected\",\"selected\"]] else [])\n        ((==) []) selected\n    )>@content</option>\n\n  select attributes strArray index =\n    let options = List.indexedMap (\\i opt ->\n        option (toString i) (i == index) [[\"TEXT\", opt]]\n      ) strArray\n    in\n    <select selected-index=(toString index)\n      onchange=\"this.setAttribute(\'selected-index\', this.selectedIndex)\" @attributes>@options</select>\n\n  checkbox text title isChecked =\n      let id = \"checkbox-\"+Regex.replace \"[^\\\\w]\" \"\" text in\n      [\"span\", [], [\n        [\"label\", [[\"class\",\"switch\"],[\"title\", title]], [\n          [\"input\", [\"type\",\"checkbox\"] :: [\"id\", id] :: [\"onclick\",\"if(this.checked) { this.setAttribute(\'checked\', \'\'); } else { this.removeAttribute(\'checked\') }\"]::\n            { apply checked =\n                if checked then [[\"checked\", \"\"]] else []\n              update {newOutput} = case newOutput of\n                [] -> Ok (Inputs [ False ])\n                _ ->  Ok (Inputs [ True ])\n            }.apply isChecked,\n            [[\"span\", [[\"class\", \"slider round\"]], []]]\n          ]\n        ]],\n        [\"label\", [[\"for\",id], [\"title\", title]], [[\"TEXT\", text]]]\n      ]]\n\n  -- Do not use if the view DOM is not totally re-rendered.\n  onChangeAttribute model controller =\n    Update.lens {\n      apply model = \"\"\n      update {input, outputNew} = Ok (Inputs [controller input outputNew])\n    } model\n\n  onClickCallback model controller =  Update.lens {\n    apply model = \"\"\"/*@getCurrentTime*/this.setAttribute(\'onclick\', \" \" + this.getAttribute(\'onclick\'))\"\"\"\n    update {input, outputNew} =\n      if String.take 1 outputNew == \" \" then\n      Ok (Inputs [controller model])\n      else\n      Ok (InputsWithDiffs [(input, Nothing)])\n    } model\n  \n  do = onClickCallback\n\n  button name title model controller =\n    <button title=title onclick=(onClickCallback model controller)>@name</button>\n\n  input tpe value =\n    <input type=tpe value=value v=value onchange=\"this.setAttribute(\'v\', this.value)\">\n\n  observeCopyValueToAttribute query attribute =\n    <script>\n      function handleMutation(mutations) {\n        mutations.forEach(function(mutation) {\n          mutation.target.value = mutation.target.getAttribute(\"@attribute\");\n        }) }\n      var textAreasObserver = new MutationObserver(handleMutation);\n      var textAreas = document.querySelectorAll(@query);\n      for (i = 0; i &lt; textAreas.length; i++)\n        textAreasObserver.observe(textAreas[i], {attributes: true});\n    </script>\n\n  -- Takes a 1-element node list, and whatever this element is replaced by.\n  -- In the reverse direction, modifies the element but also propagates its deletion to the list\n  -- or insertions of new elements.\n  mergeMatch: String -> Diffs -> Match -> String\n  (mergeMatch) originalMatch mDiffs m =\n     case mDiffs of\n       VRecordDiffs dDiffs ->\n         let matchLength = String.length originalMatch in\n         let gatherDiffs groups starts groupDiffs =\n           let combineDiffs i groupDiffs accDiffs =\n             case groupDiffs of\n               [] -> accDiffs\n               (j, d)::tdgd ->\n                 if i < j then combineDiffs (i + 1) groupDiffs accDiffs\n                 else case d of\n                     ListElemUpdate ud ->\n                       let startInMatch = nth starts i - m.index in\n                       case ud of\n                         VStringDiffs sds ->\n                           let (_, concreteUpdates) =  List.foldl (\\(StringUpdate start end replacement) (offset, accDiffs) ->\n                               (offset + replacement - (end - start),\n                                accDiffs ++ [ConcreteUpdate\n                                               (start + startInMatch)\n                                               (end + startInMatch)\n                                               (String.substring (start + offset) (start + replacement + offset) (nth groups i))\n                                            ])\n                             ) (0, []) sds\n                           in combineDiffs (i + 1) tdgd (accDiffs ++ concreteUpdates)\n                         _ -> error (\"Expected string diffs, got \" + toString ud)\n                     ListElemInsert _ -> error \"Not possible ot insert match groups\"\n                     ListElemDelete _ -> error \"Not possible to delete match groups\"\n           in\n           combineDiffs 0 groupDiffs []\n         in\n         let totalUpdates = (case dDiffs of\n           { group = VListDiffs groupDiffs} ->\n             gatherDiffs m.group m.start groupDiffs\n           _ -> []) ++ (case dDiffs of\n           { submatches = VListDiffs groupDiffs} ->\n             gatherDiffs m.submatches (List.drop 1 m.start) groupDiffs\n           _ -> []) ++ (case dDiffs of\n           {match = matchDiffs} ->\n             gatherDiffs [m.match] [m.index] [(0, ListElemUpdate matchDiffs)]\n           _ -> [])\n         in\n         let concreteUpdates = totalUpdates |>\n              sortBy (\\(ConcreteUpdate s1 _ _) (ConcreteUpdate s2 _ _) -> s1 <= s2) |>\n              List.foldl (\\((ConcreteUpdate start end replacement) as a) (accConcreteUpdates, minStartIndex) ->\n                if start >= minStartIndex && end <= matchLength then\n                  (a::accConcreteUpdates, end)\n                else\n                  (accConcreteUpdates, minStartIndex)\n                ) ([], 0) |>\n              Tuple.first\n         in\n         List.foldl (\\(ConcreteUpdate start end replacement) match ->\n           String.take start match + replacement + String.drop end match)\n             originalMatch concreteUpdates\n\n  -- Split the text into Text [[\"TEXT\", unchanged text]] and Match (match)\n  -- On the other direction, recombines the nodes of Text and Match\n  -- Allows to back-propagate insertions and deletions of nodes\n  findAugmentedInterleavings number regex ([[\"TEXT\", text]] as tNodes) =\n    let interleavings = findInterleavings number regex text in\n    let rev = List.foldl (\\elem acc -> case elem of\n        Left text -> Text [[\"TEXT\", text]] :: acc\n        Right match -> Match match :: acc\n      ) [] interleavings\n    in\n    let augmentedInterleavings = List.reverse rev in\n    let allMatches: List (Int, Match)\n        allMatches = List.concatMap (case of Match match -> [(match.number, match)]; _ -> []) augmentedInterleavings in\n    Update.lens {\n      apply tNodes = augmentedInterleavings\n      update ({outputNew, diffs} as uInput) = -- We should extract all the new matches\n        case diffs of\n          VListDiffs ds ->\n            let rebuild i outputNew ds newInput =\n               case ds of\n                 [] ->\n                   case outputNew of\n                     [] ->\n                       Ok (Inputs [__mergeHtmlText__ newInput])\n                     Text nodes :: outputNewTail ->\n                       newInput ++ nodes |>\n                       rebuild (i + 1) outputNewTail ds\n                     Match m :: outputNewTail ->\n                       newInput ++ [[\"TEXT\", m.match]] |>\n                       rebuild (i + 1) outputNewTail ds\n                 (j, ld)::tds ->\n                   if i < j then\n                     case outputNew of\n                     Text nodes :: outputNewTail ->\n                       newInput ++ nodes |>\n                       rebuild (i + 1) outputNewTail ds\n                     Match m :: outputNewTail ->\n                       newInput ++ [[\"TEXT\", m.match]] |>\n                       rebuild (i + 1) outputNewTail ds\n                     [] ->\n                       Err (\"Unexpected end of findAugmentedInterleavings.outputNew\" + toString uInput)\n                   else case ld of\n                     ListElemUpdate u  ->\n                       case outputNew of\n                         Text nodes :: outputNewTail ->\n                           newInput ++ nodes |>\n                           rebuild (i + 1) outputNewTail tds\n                         Match m :: outputNewTail ->\n                           case u of\n                             VRecordDiffs {args = VRecordDiffs { _1 = mDiffs } } ->\n                               let originalMatch = (listDict.get m.number allMatches |> Maybe.withDefault m).match in\n                               newInput ++ [[\"TEXT\", mergeMatch originalMatch mDiffs m]] |>\n                               rebuild (i + 1) outputNewTail tds\n                             _ -> Err (\"Unexpected findAugmentedInterleavings diffs: \" + toString u)\n                         [] ->\n                           Err (\"Unexpected end of findAugmentedInterleavings.outputNew\" + toString uInput)\n\n                     ListElemInsert n  ->\n                       let tailDiffs = if n == 1 then tds else (j, ListElemInsert (n - 1)) :: tds in\n                       case outputNew of\n                         [] ->\n                           Err (\"Expected inserted elements, got nothing\")\n                         Text nodes :: outputNewTail ->\n                           newInput ++ nodes |>\n                           rebuild i outputNewTail tailDiffs\n                         Match m :: outputNewTail ->\n                           newInput ++ [[\"TEXT\", m.match]] |>\n                           rebuild i outputNewTail tailDiffs\n\n                     ListElemDelete n  ->\n                       rebuild (i + n) outputNew tds newInput\n            in\n              rebuild 0 outputNew ds []\n          _ -> Err (\"Expected VListDiffs, got \" + toString diffs)\n    } tNodes\n\n  -- given a 1-element list and an element, returns the element wrapped\n  -- On the way back, back-propagates insertions and deletions to the list after applying the inverse\n  -- convertInserted,\n  -- and changes to element itself on the other side\n  insertionDeletionUpdatesTo: (b -> a) -> (List a, b) -> List b\n  insertionDeletionUpdatesTo convertInserted = Update.lens2 {\n      apply (node1List, node1) = [node1]\n      update {input=(node1List, node1), outputNew=newNodes, diffs} =\n        case diffs of\n          VListDiffs listDiffs ->\n            let aux i newNodes listDiffs newNode1List newNode1ListDiffs newNode1 mbNode1Diffs =\n              case listDiffs of\n                [] ->\n                  Ok (InputsWithDiffs [(\n                    (newNode1List, newNode1),\n                    Update.pairDiff2\n                      (if newNode1ListDiffs == [] then\n                        Nothing\n                       else Just (VListDiffs newNode1ListDiffs))\n                      mbNode1Diffs\n                  )])\n                (j, d)::diffTail ->\n                  if i < j then -- i == 0 and j == 1\n                    let (skipped, remainingNodes) = List.split 1 newNodes in\n                    aux j remainingNodes listDiffs (newNode1List ++ skipped) newNode1ListDiffs newNode1 mbNode1Diffs\n                  else\n                    case d of\n                      ListElemInsert x ->\n                        let (inserted, remainingNodes) = List.split x newNodes in\n                        let insertionDiffs = newNode1ListDiffs ++ [(j, ListElemInsert x)] in\n                        aux j remainingNodes diffTail\n                          (newNode1List ++ convertInserted inserted) insertionDiffs newNode1 mbNode1Diffs\n\n                      ListElemUpdate x ->\n                        let newNode1_ :: remainingNodes = newNodes in\n                        aux (j + 1) remainingNodes diffTail\n                          (newNode1List ++ node1List) newNode1ListDiffs newNode1_ (Just x)\n\n                      ListElemDelete 1 -> -- Only the element can be deleted.\n                        let deletionDiffs = newNode1ListDiffs ++ [(0, ListElemDelete 1)] in\n                        aux (j + 1) newNodes diffTail\n                          newNode1List deletionDiffs node1 Nothing\n\n                      _ -> Err <| \"Unexpected diff for insertionDeletionUpdatesTo:\" ++ toString d\n            in aux 0 newNodes listDiffs [] [] node1 Nothing\n          _ -> Err <| \"Expected VListDiffs for insertionDeletionUpdatesTo, got \" ++ toString diffs\n      }\n\n  -- Takes a list of nodes, returns a list of nodes.\n  replaceNodesIf nodePred regex replacement nodes =\n      List.concatMap_ identity (\\[node] as node1List ->\n        if not (nodePred node) then node1List else\n        case node of\n          [\"TEXT\", text] ->\n            findAugmentedInterleavings 0 regex node1List\n              |> List.concatMap_ identity (\\[head] as headList ->\n              case head of\n                Text nodes -> nodes\n                Match match -> replacement match\n            ) |> __mergeHtmlText__ |> List.filter (/= [\"TEXT\", \"\"])\n          [tag, attrs, children] ->\n            insertionDeletionUpdatesTo identity node1List <|\n              [tag, attrs, replaceNodesIf nodePred regex replacement children]\n      ) nodes\n\n  -- Takes a list of nodes, returns a list of nodes.\n  replaceNodes = replaceNodesIf (\\_ -> True)\n\n  {- Given\n     * a regex\n     * a replacement function that takes a string match and returns a list of Html nodes\n     * a node\n     This functions returns a node, (excepted if the top-level node is a [\"TEXT\", _] and is splitted.\n  -}\n  replaceIf nodePred regex replacement node = case replaceNodesIf nodePred regex replacement [node] of\n       [x] -> x\n       y -> y\n\n  replace  = replaceIf (\\_ -> True)\n\n  replaceNodesAsTextIf nodePred regex replacement nodes =\n       if nodes == [] then nodes else\n       let nodesAsText = nodes |> List.indexedMapWithReverse identity (\\i n -> case n of\n         [\"TEXT\", t] -> n\n         [tag, _, _] -> [\"TEXT\", \"\"\"<|#@i#@tag#|>\"\"\"]) |> __mergeHtmlText__\n       in\n       -- Takes a list of nodes, and replaces each <|(number)|> by the matching node in the top-level text nodes.\n       -- Calls replaceNodesAsTextIf on the result.\n       let reinsertNodes insideNodes = replaceNodesIf (\\_ -> True) \"\"\"<\\|#(\\d+)#\\w+#\\|>\"\"\" (\\m ->\n          Update.sizeFreeze [nth nodes (String.toInt (nth m.group 1))]) insideNodes in\n       let reinsertNodesInText text = reinsertNodes [[\"TEXT\", text]] in\n       -- Takes a string and replaces  each <|(number)|> by the matching node in the top-level text nodes.\n       let reinsertNodesInText text = reinsertNodes [[\"TEXT\", text]] in\n       -- Takes a string and replace each <|(number)|> by the node in raw format (i.e. printed as HTML)\n       let reinsertNodesRaw insideNodes = replaceNodesIf (\\_ -> True) \"\"\"<\\|#(\\d+)#\\w+#\\|>\"\"\" (\\m ->\n         let oldNode = nth nodes (String.toInt (nth m.group 1)) in\n         [[\"TEXT\", valToHTMLSource oldNode]]\n       ) insideNodes in\n       let reinsertNodesRawInText text = reinsertNodesRaw [[\"TEXT\", text]] in\n       nodesAsText |>\n       findAugmentedInterleavings 0 regex |>\n       List.concatMap (\\head ->\n         case head of\n           Text nodes -> reinsertNodes nodes\n           Match m ->  reinsertNodes (replacement { m | reinsertNodesRawInText = reinsertNodesRawInText})\n       ) |> __mergeHtmlText__ |>\n       List.filter (\\a -> a /= [\"TEXT\", \"\"]) |>\n       List.mapWithReverse identity (\\node -> case node of\n         [\"TEXT\", _] -> node\n         [tag, attrs, children] ->\n           if nodePred node then [tag, attrs,\n             replaceNodesAsTextIf nodePred regex replacement children] else node)\n\n  replaceNodesAsText regex replacement nodes = replaceNodesAsTextIf (\\_ -> True) regex replacement nodes\n\n  replaceAsTextIf nodePred regex replacement node = case replaceNodesAsTextIf nodePred regex replacement [node] of\n        [x] -> x\n        y -> y\n\n  replaceAsText = replaceAsTextIf (\\_ -> True)\n\n  find regex node =\n    let aux node = case node of\n       [\"TEXT\", text] ->\n         findInterleavings 0 regex text\n         |> List.concatMap (case of\n            Left _ -> []\n            Right match -> [match]\n          )\n       [tag, attrs, children] ->\n         List.concatMap aux children\n    in aux node\n\n  -- Takes a regex, a function that accepts a match and an accumulator and returns a list of nodes and the new accumulator\'s value.\n  -- a starting accumulator and a starting node. Returns the final accumulator and the final node.\n  foldAndReplace regex matchAccToNewNodesNewAcc startAcc node =\n          let aux acc node = case node of\n             [\"TEXT\", text] ->\n               findInterleavings 0 regex text\n               |> List.foldl (\\interleaving (nodes, acc) ->\n                 case interleaving of\n                  Left str -> (nodes ++ [[\"TEXT\", str]], acc)\n                  Right match -> let (newNodes, newAcc) = matchAccToNewNodesNewAcc match acc in\n                    (nodes ++ newNodes, newAcc)\n                ) ([], acc) |> Tuple.mapFirst (__mergeHtmlText__ >> List.filter (/= [\"TEXT\", \"\"]))\n             [tag, attrs, children] ->\n               let (newChildren, newAcc) =\n                 List.foldl (\\child (buildingChildren, acc) ->\n                   let (nChildren, nAcc) = aux acc child in\n                   (buildingChildren ++ nChildren, nAcc)\n                 ) ([], acc) children in\n               ([[tag, attrs, newChildren]], newAcc)\n          in case aux startAcc node of\n            ([node], acc)-> (node, acc)\n            r -> r\n\n  isEmptyText = case of\n        [\"TEXT\", x] -> Regex.matchIn \"^\\\\s*$\" x\n        _ -> False\n\n  filter pred elemList =\n        List.concatMap (case of\n          [tagName, attrs, children] as elem ->\n            if pred elem then [[tagName, attrs, filter pred children]]\n            else []\n          elem -> if pred elem then [elem] else []) elemList\n\n  translate =\n    let freshVarName name i dictionary =\n      if name == \"\" then freshVarName \"translation\" i dictionary else\n      let suffix = if i == 0 then \"\" else toString i in\n      let potentialName = name + suffix in\n      if Dict.member potentialName dictionary then freshVarName name (i + 1) dictionary else potentialName\n    in\n    \\translations indexLangue node ->\n    let currentTranslation = nth translations indexLangue |> Tuple.second |> Dict.fromList in\n    replace \"\"\"\\$(\\w+|\\$)\"\"\" (\\m ->\n      if m.match == \"$\" then [[\"TEXT\", m.match]] else\n        let key = nth m.group 1 in\n        case Dict.get key currentTranslation of\n          Nothing -> [[\"TEXT\", m.match]]\n          Just definition -> [[\"TEXT\", definition]]\n      ) node |>\n    \\htmlNode ->\n      Update.lens2 {\n        apply (htmlNode, _) = htmlNode\n        update {input = (_, translations), outputNew=newHtmlNode} =\n          find \"\"\"\\{:([^\\}]*(?!\\})\\S[^\\}]*):\\}\"\"\" newHtmlNode\n          |> List.foldl (\\matchToTranslate (updatedHtmlNode, currentTranslation, translations) ->\n              let definition = nth matchToTranslate.group 1\n                  name = freshVarName (Regex.replace \"[^a-zA-Z]\" \"\" definition |> String.take 16) 0 currentTranslation\n                  textToFind = \"\"\"\\{:@(Regex.escape definition):\\}\"\"\"\n              in\n              (replace textToFind (\\_ -> [[\"TEXT\", \"$\" + name]]) updatedHtmlNode,\n               Dict.insert name definition currentTranslation,\n               List.map (\\(lang, d) -> (lang, d ++ [(name, definition)])) translations)\n            ) (newHtmlNode, currentTranslation, translations)\n          |> \\(finalHtmlNode, _, newTranslations) ->\n            Ok (Inputs [(finalHtmlNode, newTranslations)])\n      } htmlNode translations\n\n  markdown node =\n      let\n          regexFootnotes = \"\"\"\\r?\\n\\[\\^([^\\]]+)\\]:\\s*((?:(?!\\r?\\n\\r?\\n)[\\s\\S])+)\"\"\"\n          regexReferences = \"\"\"\\r?\\n\\[(?!\\^)([^\\]\\\\]+)\\]:\\s*(\\S+)\"\"\"\n          footnotes = find regexFootnotes node\n                       |> List.map (\\m -> (nth m.group 1, nth m.group 2))\n                       |> List.indexedMap (\\i (name, value) -> (name, (i + 1, value)))\n          references = find regexReferences node\n                       |> List.map (\\m -> (nth m.group 1, nth m.group 2))\n          notCode = case of [\"code\", _, _] -> False; _ -> True\n          notTitle = case of [tag, _, _] -> not (Regex.matchIn \"\"\"h\\d\"\"\" tag); _ -> True\n          notList = case of [tag, _, _] -> tag /= \"ul\" && tag /= \"ol\"; _ -> True\n          notPara = case of [\"p\", _, _] -> False; _ -> True\n          notA = case of [\"a\", _, _] -> False; _ -> True\n          r: String -> (Match -> List HtmlNode) -> HtmlNode -> HtmlNode\n          r  = replaceAsTextIf notCode\n          r2 = replaceAsTextIf (\\x -> notCode x && notTitle x && notList x && notPara x)\n          ra = replaceAsTextIf (\\x -> notCode x && notA x)\n          lregex = \"\"\"(?:\\r?\\n|^)((?:(?![\\r\\n])\\s)*)(\\*|-|\\d+\\.)(\\s+)((?:.*)(?:\\r?\\n\\1  ?\\3(?:.*))*(?:\\r?\\n\\1(?:\\*|-|\\d+\\.)\\3(?:.*)(?:\\r?\\n\\1 \\3(?:.*))*)*)\"\"\"\n          handleLists node  =\n            r lregex (\n              \\m -> let indent = nth m.group 1\n                        afterindent = nth m.group 3\n                        ul_ol = case nth m.group 2 of \"*\" -> \"ul\"; \"-\" -> \"ul\"; _ -> \"ol\"\n                        elements =\n                          Regex.split \"\"\"\\r?\\n@indent(?:\\*|-|\\d+\\.)@afterindent\"\"\" (nth m.group 4)\n                    in\n                    [<@ul_ol>@(List.map (\\elem -> <li>@elem</li>) elements)</@>]) node\n      in (\n      node\n      |> r \"\"\"@regexReferences|@regexFootnotes\"\"\" (\\m -> [])\n      |> (\\result -> -- Expand footnotes\n        if List.length footnotes == 0 then result\n        else case result of\n          [tag, attrs, children] ->\n            [tag, attrs, children ++ Update.sizeFreeze [\n              <div class=\"footnotes\"><hr><ol>@(footnotes |>\n                List.map (\\(name, (n, value)) ->\n                  <li id=\"\"\"fn@n\"\"\"><p>@value<a href=\"\"\"#fnref@n\"\"\">â†©</a></p></li>\n                ))</ol></div>]\n            ])\n      |> r \"\"\"(```)([\\s\\S]*?)\\1(?!`)|((?:\\r?\\n    .*)+)\"\"\" (\\m ->\n        if nth m.group 1 == \"\" then\n          nth m.group 3 |>\n          Regex.extract \"\"\"\\r?\\n    ([\\s\\S]*)\"\"\" |>\n          Maybe.map (\\[code] ->\n                  [<pre><code>@(Regex.split \"\"\"\\r?\\n    \"\"\" code |> String.join \"\\n\" |> String.trim |> m.reinsertNodesRawInText)</code></pre>])\n          |> Maybe.withDefault [[\"TEXT\", m.match]]\n        else [\n        <pre><code>@(nth m.group 2 |> String.trim |> m.reinsertNodesRawInText)</code></pre>])\n      |> r \"\"\"(^|\\r?\\n)(#+)\\s*([^\\r\\n]*)\"\"\" (\\m -> [[\"TEXT\", nth m.group 1], <@(\"\"\"h@(String.length (nth m.group 2))\"\"\")>@(nth m.group 3)</@>])\n      |> handleLists --|> (\\x -> let _ = Debug.log (\"Paragraph phase\") () in x)\n      |> r2 \"\"\"(\\r?\\n *\\r?\\n(?:\\\\noindent\\r?\\n)?|^)((?=\\s*\\w|\\S)[\\s\\S]*?)(?=(\\r?\\n *\\r?\\n|\\r?\\n$|$))\"\"\" (\n        \\m ->\n          --let _ = Debug.log m.match () in\n          if nth m.group 1 == \"\" && nth m.group 3 == \"\" -- titles and images should not be paragraphs.\n           || Regex.matchIn \"\"\"^\\s*<\\|#\\d+#(?:h\\d|ul|ol|p|pre|center)#\\|>\\s*$\"\"\" (nth m.group 2) then [[\"TEXT\", m.match]] else  [<p>@(nth m.group 2)</p>]) --|> (\\x -> let _ = Debug.log (\"End of paragraph phase:\" + valToHTMLSource x) () in x)\n      |> ra \"\"\"\\[([^\\]\\\\]+)\\](\\^?)(\\(|\\[)([^\\)\\]]+)(\\)|\\])|(?:http|ftp|https)://(?:[\\w_-]+(?:(?:\\.[\\w_-]+)+))(?:[\\w.,@@?^=%&:/~+#-]*[\\w@@?^=%&/~+#-])?\"\"\" (\\m -> [ -- Direct and indirect References + syntax ^ to open in external page.\n        case nth m.group 3 of\n          \"(\" -> <a href=(nth m.group 4) @(if nth m.group 2 == \"^\" then [[\"target\", \"_blank\"]] else [])>@(nth m.group 1)</a>\n          \"[\" -> listDict.get (nth m.group 4) references |> case of\n                Just link -> <a href=link>@(nth m.group 1)</a>\n                Nothing -> [\"TEXT\", m.match]\n          _ -> <a href=m.match>@(m.match)</a>\n          ])\n      |> r \"\"\"\\[\\^([^\\]]+)\\]\"\"\" (\\m ->  -- Footnotes\n        listDict.get (nth m.group 1) footnotes |> case of\n          Just (n, key) -> [ <a href=\"\"\"#fn@n\"\"\" class=\"footnoteRef\" id=\"\"\"fnref@n\"\"\"><sup>@n</sup></a>]\n          Nothing -> [[\"TEXT\", m.match]])\n      |> r \"(`)(?=[^\\\\s`])(.*?)\\\\1\" (\\m -> [<code>@(nth m.group 2 |> m.reinsertNodesRawInText)</code>])\n      |> r \"\"\"(\\*{1,3}|_{1,3})(?=[^\\s\\*_])((?:(?!\\\\\\*|\\_).)*?)\\1\"\"\" (\\m -> [\n        case nth m.group 1 |> String.length of\n          1 -> <em>@(nth m.group 2)</em>\n          2 -> <strong>@(nth m.group 2)</strong>\n          _ -> <em><strong>@(nth m.group 2)</strong></em>])\n      |> r \"\"\"&mdash;|\\\\\\*|\\\\_|\\\\\\[|\\\\\\]\"\"\" (\\m -> [[\"TEXT\", case m.match of\n        \"&mdash;\" -> \"â€”\"\n        \"\\\\*\" -> String.drop 1 m.match\n        \"\\\\_\" -> String.drop 1 m.match\n        \"\\\\[\" -> String.drop 1 m.match\n        \"\\\\]\" -> String.drop 1 m.match\n        ]])\n      )\n\n  scriptFindEnclosing tagName varnameWhatToDo = \"\"\"\n      var elem = this\n      while(elem != null && elem.tagName.toLowerCase() != \"@tagName\")\n        elem = elem.parentElement;\n      if(elem == null) {\n        console.log(\'Error: duplicate button could not find enclosing target @tagName\');\n      } else {\n        @(varnameWhatToDo \"elem\")\n      }\"\"\"\n\n  buttonToDuplicateEnclosing tagNameToDuplicate attrs children =\n      <button onclick=(scriptFindEnclosing(tagNameToDuplicate)(\\v ->\n          \"\"\"@(v).parentElement.insertBefore(@(v).cloneNode(true), @(v))\"\"\"))\n      @attrs>@children</button>\n\n  buttonToDeleteEnclosing tagNameToDelete attrs children=\n      <button onclick=(scriptFindEnclosing(tagNameToDelete)(\\v ->\n          \"\"\"@(v).remove()\"\"\"))\n      @attrs>@children</button>\n\n  addClass name [t, attrs, c] =\n    [ t\n    , attrDict.update \"class\" (case of\n        Just classes -> if Regex.matchIn (\"\\\\b\" + name + \"\\\\b\") classes then Just classes else Just (classes + \" \" + name)\n        Nothing -> Just name) attrs\n    , c]\n}\n\n--------------------------------------------------------------------------------\n-- Javascript\n\njsCode = {\n  -- Create a tuple of a list of strings. Uses v as intermediate variable.\n  -- calling __jsEval__ (\"var a = 1\\n\" ++ tupleOf \"x\" [\"a\", \"2\", \"a\"]) == (1, 2, 1)\n  tupleOf: String -> List String -> String\n  tupleOf v list =\n    \"\"\"(function() { var @v = {@(List.indexedMap (\\i x -> \"\"\"_@(i+1): @x\"\"\") list |> String.join \",\")}; @v[\'$t_ctor\']=\'Tuple@(List.length list)\'; return @v})()\"\"\"\n\n  -- Creates a datatype of a list of strings. Uses v as intermediate variable.\n  datatypeOf: String -> String -> List String -> String\n  datatypeOf v kind args =\n    \"\"\"(function() { var @v = {args: {@(List.indexedMap (\\i x -> \"\"\"_@(i+1): @x\"\"\") args |> String.join \",\")}}; @v[\'$d_ctor\']=\'@kind\'; return @v})()\"\"\"\n\n  -- JS representation of a given string\n  stringOf: String -> String\n  stringOf content =\n    \"\\\"\" + Regex.replace \"\\\\\\\\|\\\"|\\r|\\n|\\t\" (\\m -> case m.match of\n      \"\\r\" -> \"\\\\r\"\n      \"\\n\" -> \"\\\\n\"\n      \"\\t\" -> \"\\\\t\"\n      x -> \"\\\\\" + x) content + \"\\\"\"\n}\n\n\nnodejs = {\n  (nothingJs) = jsCode.datatypeOf \"x\" \"Nothing\" []\n  (justJs) arg = jsCode.datatypeOf \"x\" \"Just\" [arg]\n  (fsjs) defaultValue prog = __jsEval__ \"\"\"\n    (function() {\n      if(!require) return @defaultValue;\n      const fs = require(\"fs\");\n      if(!fs) return @defaultValue;\n      @prog\n    })()\"\"\"\n\n  type alias BasicFileSystemUtils = {\n    read: String -> Maybe String,\n    listdir: String -> List String,\n    isdir: String -> Bool,\n    isfile: String -> Bool\n  }\n  -- Reads the file system directly without instrumentation.\n  nodeFS: BasicFileSystemUtils\n  nodeFS = {\n    read  name = fsjs nothingJs \"\"\"\n      const name = @(jsCode.stringOf name);\n      if(!fs) return @nothingJs;\n      if(fs.existsSync(name)) { // TODO: Atomic read\n        if(fs.lstatSync(name).isDirectory()) {\n          return @nothingJs;\n        } else {\n          return @(justJs \"fs.readFileSync(name, \'utf-8\')\");\n        }\n      } else return @nothingJs;\"\"\"\n    listdir foldername = fsjs \"[]\" \"\"\"\n      var name = @(jsCode.stringOf foldername);\n      if(name == \"\") name = \".\";\n      if(fs.existsSync(name) && fs.lstatSync(name).isDirectory()) {\n        var filesfolders =\n          fs.readdirSync(name);\n        return filesfolders;\n      } else {\n        return []\n      }\"\"\"\n    isdir name =\n      fsjs \"false\" \"\"\"\n       const name = @(jsCode.stringOf name);\n       return name == \"\" || fs.existsSync(name) && fs.lstatSync(@(jsCode.stringOf name)).isDirectory();\"\"\"\n    isfile name =\n      fsjs \"false\" \"\"\"\n       return fs.existsSync(@(jsCode.stringOf name)) && fs.lstatSync(@(jsCode.stringOf name)).isFile();\"\"\"\n  }\n\n\n  type FileOperation = Write {-old-} String {-new-} String Diffs |\n                       Rename {-newName-} String |\n                       Create {-content-} String |\n                       Delete {-old-} String |\n                       CreateFolder (List String {- file names in this folder -})\n  type alias ListFileOperations = List ({-filename-}String, FileOperation)\n\n  -- Consumes all update values by writing to the file system. Use this only if you don\'t need to display ambiguity.\n  nodeFSWrite: ListFileOperations\n  nodeFSWrite = Update.lens {\n    apply = identity\n    update {outputNew} =\n     List.foldl (\\(name, action) b ->\n      let write name contentOld content =\n        let mbCreateDir = case contentOld of\n             Nothing -> fsjs \"0\" \"\"\"\n               var pathToFile = @(jsCode.stringOf name);\n               var filePathSplit = pathToFile.split(\'/\');\n               var dirName = \"\";\n               for (var index = 0; index < filePathSplit.length - 1; index++) {\n                  dirName += filePathSplit[index]+\'/\';\n                  if (!fs.existsSync(dirName))\n                      fs.mkdirSync(dirName);\n               }\n               return 1;\"\"\" -- Create the file\'s directory structure.\n             Just oldContent -> \"\"\n            written = fsjs \"0\" \"\"\"\n              fs.writeFileSync(@(jsCode.stringOf name), @(jsCode.stringOf content), \"utf-8\");\n              return 1;\"\"\"\n        in ()\n      in\n      let _ = case action of\n        Write oldContent newContent diffs -> write name (Just oldcontent) newContent\n        Create content -> write name Nothing content\n        Delete oldContent -> fsjs \"0\" \"\"\"\n            fs.unlinkSync(@(jsCode.stringOf name));\n            return 1;\"\"\"\n        Rename newName -> fsjs \"0\" \"\"\"\n            fs.renameSync(@(jsCode.stringOf name), @(jsCode.stringOf newName));\n            return 1;\"\"\"\n      in b) (Ok <| InputsWithDiffs [([], Nothing)]) outputNew\n  } []\n\n  type alias InlineFS = List ({-path-}String, File content | Folder (List String)) -> BasicFileSystemUtils\n\n  inlineFS: InlineFS -> BasicFileSystemUtils\n  inlineFS content = {\n    read name = case listDict.get name content of\n       Just (File content) -> Just content\n       _ -> Nothing\n    listdir foldername = case listDict.get foldername content of\n       Just (Folder files) -> files\n       _ -> Nothing\n    isdir name = case listDict.get name content of\n      Just (Folder _) -> True\n      _ -> False\n    isfile name = case listDict.get name content of\n      Just (File _) -> True\n      _ -> False\n  }\n\n  inlineFSWrite: InlineFS -> ListFileOperations\n  inlineFSWrite = Update.lens {\n    apply inlineFS = []\n    update {input=inlineFS, outputNew} =\n      List.foldl (\\(name, action) resInlineFS ->\n        resInlineFS\n        |> Result.andThen (\\inlineFS ->\n          let prev = listDict.get name inlineFS in\n          case (prev, action) of\n             (Just (Folder _), Write oldContent newContent diffs) -> Err <| \"Can\'t write a folder as if it was a file\"\n             (_,               Write oldContent newContent diffs) -> Ok <| listDict.insert name (File newContent) inlineFS\n             (Nothing, Delete _) -> Err <| \"Can\'t delete \" + name + \" from file system because it did not exist\"\n             (_, Delete _) -> listDict.delete name inlineFS |>\n                List.map (\\(oname, ocontent) ->\n                  case ocontent of\n                  Folder subfiles ->\n                      (oname, Folder (List.filter (\\subfile -> oname + \"/\" + subfile /= name) subfiles))\n                  _ -> (oname, ocontent)\n                  ) |> Ok\n             (Just x, Create content) ->  Err <| \"Can\'t create \" + name + \" in file system because it did exist\"\n             (_, Create newContent) ->  listDict.insert name (File newContent) inlineFS |>\n               List.map (\\(oname, ocontent) ->\n                  case ocontent of\n                  Folder subfiles ->\n                      if String.left (String.length oname) name == oname then -- Starts with the folder\'s name\n                        let remaining = String.drop (String.length oname) name in\n                        if not (Regex.matchIn \"./\" remaining) && String.take 1 remaining == \"/\"  then\n                          (oname, Folder (subfiles ++ [String.drop 1 remaining]))\n                        else\n                          (oname, Folder subfiles)\n                      else\n                        (oname, Folder subfiles)\n                  _ -> (oname, ocontent)\n                  ) |> Ok\n             (Just x, Rename newName) -> case listDict.get newName inlineFS of\n               Just _ -> Err <| \"Can\'t rename \" + name + \" to \" + newName + \" because it already exists\"\n               _ -> inlineFS |> listDict.remove name |> listDict.insert newName x |>\n                    List.map (\\(oname, ocontent) ->\n                      case ocontent of\n                      Folder subfiles ->\n                          (oname, Folder (List.map (\\subfile -> if oname + \"/\" + subfile == name then\n                            String.drop (String.length (oname + \"/\")) newName else subfile)\n                          subfiles))\n                      _ -> (oname, ocontent)\n                      ) |> Ok\n             (_, Rename _) -> Err <| \"Can\'t rename \" + name + \" because it did not exist\"))  (Ok inlineFS) outputNew\n      |> Result.map (\\x -> Inputs [x])\n  }\n\n  type alias FileSystemUtils =  {\n    read: String -> Maybe String,\n    listdir: String -> List String,\n    listdircontentfilter: String -> (String -> Boolean)  -> List (String, String),\n    listdircontent: String -> List (String, String),\n    isdir: String -> Bool,\n    isfile: String -> Bool\n  }\n\n  {- nodejs.delayedFS basicFS fileOperations   provides a file system utility that, on update,\n     does not change the files on disk, but fills an array of fileOperations (create, write, delete, rename)\n\n     basicFS:         To read files from disk using node.js, use `nodejs.nodeFS`\n                      To simply read an inline content, which is a\n                        list of (path, File content | Folder (list of filenames)),\n                        use `(nodjs.inlineFS content)`\n     fileOperations:  Pass `[]` to recover file operations on update.\n                        If not empty, its operations will overwrite the content of basicFS.\n                      Pass `nodejs.nodeFSWrite` if writes do not have ambiguity\n                        and should be performed immediately on disk\n                      Pass `nodejs.inlineFSWrite content` if the first argument is `nodejs.inlineFS content` and\n                        you want the content to be immediately overriden.\n\n     -- Sample call (put fileOperations: [] in the environment)\n     fs = nodejs.delayedFS nodejs.nodeFS fileOperations\n\n     -- Sample mock call (to locally test a file system\n     fsContent = [(\"test/a.txt\", File \"Hello\"), (\"test/b.txt\", File \"World\"), (\"test\", Folder [\"a.txt\", \"b.txt\"])]\n     fs = nodejs.delayedFS (nodejs.inlineFS fsContent) (nodejs.inlineFSWrite fsContent)\n     fs.read \"test/a.txt\"\n     ...\n     -}\n  delayedFS: BasicFileSystemUtils -> ListFileOperations -> FileSystemUtils\n  delayedFS  basicFS                 fileOperations = {\n    (fileOperationsRaw) = Update.lens {\n      apply = identity\n      (remove) name = List.filter (\\(otherName, _) -> otherName /= name)\n      update {input=fileOperations, outputNew} =\n        let process outputNew revAcc = case outputNew of\n          [] -> Ok <| Inputs [List.reverse revAcc]\n          (name, action) :: tail ->\n            case action of\n              Delete _ -> process (remove name tail) ((name, action) :: remove name revAcc)\n              Create content -> process (remove name tail) ((name, action) :: remove name revAcc)\n              Write oldContent newContent diffs ->\n                let (sameName, otherNames) = List.partition (\\(otherName, _) -> name == otherName) tail in\n                let extractedWrites = List.concatMap (\\(_, action) -> case action of\n                     Write oldContent newContent diffs -> [(newContent, Just diffs)]\n                     _ -> []) sameName in\n                let (finalContent, mbFinalDiffs) =\n                      Update.merge oldContent ((newContent, Just diffs) :: extractedWrites)\n                in\n                let finalNameAction =\n                  case listDict.get name fileOperations of\n                    Just (Create content) -> [(name, Create finalContent)]\n                    _ ->\n                      case mbFinalDiffs of\n                        Just finalDiffs -> [(name, Write oldContent finalContent finalDiffs)]\n                        _ -> []\n                in\n                process otherNames (finalNameAction ++ revAcc)\n              Rename newName ->\n                if List.all (\\(_, action) -> case action of Rename _ -> True) tail then\n                  process tail ((name, action)::revAcc)\n                else\n                  process (tail ++ [(name, action)]) revAcc\n              CreateFolder content ->\n                process tail ((name, action)::revAcc)\n        in process outputNew []\n    } fileOperations\n\n    read: String -> Maybe String\n    read filename = Update.lens {\n      apply fileOperations =\n        case listDict.get filename fileOperations of\n          Just (Write oldContent newContent diffs) -> Just newContent\n          Just (Create content) -> Just content\n          Just (Delete _) -> Nothing\n          Just (Rename _) -> Nothing\n          Just (CreateFolder _) -> Nothing\n          _ -> basicFS.read filename\n      update  = case of\n        {input=fileOperations, outputOld = Just x , outputNew = Nothing} ->\n          Ok <| InputsWithDiffs [((filename, Delete x) :: fileOperations, Just <| VListDiffs [(0, ListElemInsert 1)])]\n        {input=fileOperations, outputOld = Just oldContent, outputNew = Just newContent, diffs} ->\n          let contentDiffs = case diffs of\n            VRecordDiffs { args = VRecordDiffs { _1 = d } } -> d\n            _ -> VStringDiffs []\n          in\n           Ok <| InputsWithDiffs [((filename, Write oldContent newContent contentDiffs) :: fileOperations, Just <| VListDiffs [(0, ListElemInsert 1)])]\n        {input=fileOperations, outputOld = Nothing, outputNew = Just newContent} ->\n           Ok <| InputsWithDiffs [((filename, Create newContent) :: fileOperations, Just <| VListDiffs [(0, ListElemInsert 1)])]\n        {input=fileOperations} ->\n          Ok (InputsWithDiffs [(fileOperations, Nothing)])\n      } fileOperationsRaw\n\n    listdir: String -> List String\n    listdir foldername = Update.lens {\n      apply fileOperations = case listDict.get foldername fileOperations of\n        Just (CreateFolder content) -> content -- We can mock the file system by creating a folder in initial fileOperations\n        _ -> basicFS.listdir foldername |>\n          (if fileOperations == [] then identity else\n          List.filterMap (\\name -> case listDict.get (foldername + \"/\" + name) fileOperations of\n            Just (Delete _) -> Nothing\n            Just (Rename newName) ->\n              let fn = foldername + \"/\" in\n              let fnLenth = String.length fn in\n              let possibleFolder = String.take fnLenth newName in\n              let possibleName = String.drop fnLenth newName in\n              if possibleFolder == fn then\n                if Regex.matchIn \"/\" possibleName then Nothing\n                else if possibleName == \"\" then Nothing\n                else Just possibleName\n              else Nothing\n            _ -> Just name\n          ))\n      update {outputOld, outputNew, diffs} =\n        let aux i outputOld outputNew diffs fo = case diffs of\n          [] -> Ok (Inputs [fo])\n          (j, d)::diffTail ->\n            if i < j then\n              aux j (List.drop (j - i) outputOld) (List.drop (j - i) outputNew) diffs fo\n            else case d of\n              ListElemInsert count -> Err <| \"fs.listdir cannot insert in reverse because it does not know if it should insert files or folders. Use fs.read instead\"\n\n              ListElemDelete count ->\n                let (deleted, remaining) = List.split count outputOld in\n                fo ++ (List.map (\\nameDeleted -> let fullName = foldername + \"/\" + nameDeleted in\n                  (fullName, Delete (basicFS.read fullName |> Maybe.withDefault \"\"))) deleted) |>\n                aux (i + count) remaining outputNew diffTail\n\n              ListElemUpdate nameChange ->\n                case (outputOld, outputNew) of\n                  (oldName :: outputOldTail, newName :: outputNewTail) ->\n                    fo ++ [(foldername + \"/\" + oldName, Rename (foldername + \"/\" + newName))] |>\n                    aux (i + 1) outputOldTail outputNewTail diffTail\n              _ -> Err <| \"\"\"Unknown diff for listdir @d\"\"\"\n        in case diffs of\n          VListDiffs diffs -> aux 0 outputOld outputNew diffs []\n          _ -> Err <| \"\"\"Don\'t know how to handle these list differences for listdircontent : @diffs\"\"\"\n    } fileOperations\n\n    listdircontentfilter: String -> (String -> Boolean) -> List (String, String)\n    listdircontentfilter foldername filter = Update.lens {\n      apply fileOperations = listdir foldername |>\n          List.filter (\\name -> isfile \"\"\"@foldername/@name\"\"\" && filter name) |>\n          List.map (\\name ->\n          let fullname = \"\"\"@foldername/@name\"\"\" in\n          (name, read fullname |> Maybe.withDefault (freeze \"\"\"Unknown file @fullname\"\"\")))\n      update {outputOld, outputNew, diffs} =\n        -- Insertions can be treated as Create, and deletions as Delete.\n        -- Changing the first component can be viewed as a Rename, whereas chaging the second component as a Write.\n        let aux i outputOld outputNew diffs fo = case diffs of\n          [] -> Ok (Inputs [fo])\n          (j, d)::diffTail ->\n            if i < j then\n              aux j (List.drop (j - i) outputOld) (List.drop (j - i) outputNew) diffs fo\n            else case d of\n              ListElemInsert count ->\n                let (inserted, remaining) = List.split count outputNew in\n                fo ++ (List.map (\\(nameInserted, contentInserted) -> (foldername + \"/\" + nameInserted, Create contentInserted)) inserted) |>\n                aux i outputOld remaining diffTail\n\n              ListElemDelete count ->\n                let (deleted, remaining) = List.split count outputOld in\n                fo ++ (List.map (\\(nameDeleted, contentDeleted) -> (foldername + \"/\" + nameDeleted, Delete contentDeleted)) deleted) |>\n                aux (i + count) remaining outputNew diffTail\n\n              ListElemUpdate (VRecordDiffs subd) ->\n                case (outputOld, outputNew) of\n                  ((oldName, oldContent) :: outputOldTail, (newName, newContent) :: outputNewTail) ->\n                    let\n                      fo = case subd of\n                        {_2=contentChange} -> fo ++ [(foldername + \"/\" + oldName, Write oldContent newContent contentChange)]\n                        _ -> fo\n                      fo = case subd of\n                        {_1=nameChange} -> fo ++ [(foldername + \"/\" + oldName, Rename (foldername + \"/\" + newName))]\n                        _ -> fo\n                    in\n                    aux (i + 1) outputOldTail outputNewTail diffTail fo\n              _ -> Err <| \"\"\"Unknown diff for listdircontent: @d\"\"\"\n        in case diffs of\n           VListDiffs diffs -> aux 0 outputOld outputNew diffs []\n           _ -> Err <| \"\"\"Don\'t know how to handle these list differences for listdircontent : @diffs\"\"\"\n    } fileOperations\n\n    listdircontent foldername = listdircontentfilter folderName (always True)\n\n    isdir: String -> Bool\n    isdir name =  case listDict.get name fileOperations of\n       Just (CreateFolder content) -> True\n       _ -> basicFS.isdir name\n    isfolder = isdir\n    isdirectory = isdir\n\n    isfile: String -> Bool\n    isfile name =\n        case listDict.get name fileOperations of\n          Just Create -> True\n          Just (Write _ _ _) -> True\n          Just (Delete _) -> True\n          _ -> basicFS.isfile name\n\n    isFile = isfile\n  }\n}\n\n-- Because we base decisions on random numbers,\n-- to update, it is essential that these random numbers are deterministically computed.\nrandom = {\n  -- Unsafe: it will not evaluate deterministically\n  jsNum = __jsEval__ \"\"\"Math.random()\"\"\"\n\n  type alias Seed = (Int, Int, Int, Int)\n  -- Builds a seed for a generator\n  seedOf: Int -> Seed\n  seedOf num = (num, num* -320161540, 320161540+num, 941627624 * num)\n\n  -- A random number generator that takes a seed and exposes a bunch of methods.\n  generator: Seed -> Generator\n  generator (a, b, c, d) = {\n    self () = generator (a, b, c, d)\n\n    -- Continuation version of randomFloat\n    randomFloat_: (Generator -> Float -> a) -> a\n    randomFloat_ withNewGeneratorResult =\n      let (newABCD, result) =\n        __jsEval__ \"\"\"\n        var a = @a, b = @b, c = @c, d = @d;\n        var t = b << 9, r = a * 5; r = (r << 7 | r >>> 25) * 9;\n        c ^= a; d ^= b;\n        b ^= c; a ^= d; c ^= t;\n        d = d << 11 | d >>> 21;\n        @(jsCode.tupleOf \"x\" [jsCode.tupleOf \"y\" [\"a\", \"b\", \"c\", \"d\"], \"(r >>> 0) / 4294967296\"]);\"\"\"\n      in\n      withNewGeneratorResult (generator newABCD) result\n\n    randomFloat: () -> (Generator, Float)\n    randomFloat () = randomFloat_ (,)\n\n    randomInt_: Int -> Int -> (Generator -> Int -> a) -> a\n    randomInt_ minInclusive maxExclusive withNewGeneratorInt =\n      randomFloat_ <| \\newGenerator float ->\n        withNewGeneratorInt newGenerator <|\n          floor (float * (maxExclusive - minInclusive)) + minInclusive\n\n    randomInt: Int -> Int -> (Generator, Int)\n    randomInt minInclusive maxExclusive = generateInt_ minInclusive maxExclusive (,)\n\n    -- Extract a random sublist of elements, but not in order\n    randomSublist_: Int -> List a -> (Generator -> List a -> b) -> b\n    randomSublist_ count list continuation =\n      if list == [] && count > 0 then continuation (self ()) list\n      else if count <= 0 then continuation (self ()) []\n      else randomInt_ 0 (List.length list) <| \\g n ->\n        case List.removeAt n list of\n          Nothing -> (g, []) -- Don\'t know why it would happen.\n          Just (head, remainingList) ->\n            g.randomSublist_ (count - 1) remainingList <| \\g2 tail ->\n            continuation g2 <| head::tail\n\n    randomSublist: Int -> List a -> (Generator, List a)\n    randomSublist count list = randomSublist_ count list (,)\n\n    shuffleList_: List a -> (Generator -> List a -> b) -> b\n    shuffleList_ list  continuation = randomSublist_ (List.length list) list continuation\n\n    shuffleList: List a -> (Generator, List a)\n    shuffleList list = shuffleList_ list (,)\n  }\n}\n\n-- TODO remove this; add as imports as needed in examples\n{textNode, p, th, td, h1, h2, h3, tr, table} = Html\ndiv_ = Html.div\n\n--------------------------------------------------------------------------------\n-- Lens: Table Library\n\n  -- Update.freeze and Update.softFreeze aren\'t needed below,\n  -- because library definitions are implicitly frozen.\n  -- But for performance it\'s better.\n\nTableWithButtons =\n  let wrapData rows =\n    let blankRow =\n       let numColumns =\n         case rows of\n            []     -> 0\n            row::_ -> List.length row\n       in\n       List.repeat numColumns \"?\"\n    in\n    Update.applyLens\n      { apply rows = List.map (\\row -> (False, row)) rows\n\n      , update {outputNew = flaggedRows} =\n          let processRow (flag, row) =\n            if flag == True\n              then [ row, blankRow ]\n              else [ row ]\n          in\n          Ok (Inputs [List.concatMap processRow flaggedRows])\n      }\n      rows\n  in\n  let mapData f flaggedRows =\n    List.map (Tuple.mapSecond f) flaggedRows\n  in\n  --\n  -- The globalBool flag is used to determine whether to insert \"\" or \" \"\n  -- before a couple attribute values. Toggling this choice in between\n  -- subsequent runs helps work around our issue forcing Elm to re-render.\n  --\n  let tr globalBool flag styles attrs children =\n    let (hasBeenClicked, nope, yep) =\n      (\"has-been-clicked\", Update.softFreeze \"gray\", Update.softFreeze \"coral\")\n    in\n    let dummyStrPrefix =\n      Update.softFreeze <| if globalBool then \"\" else \" \"\n    in\n    let onclick =\n      \"\"\"\n      var hasBeenClicked = document.createAttribute(\"@hasBeenClicked\");\n      var buttonStyle = document.createAttribute(\"style\");\n\n      if (this.parentNode.getAttribute(\"@hasBeenClicked\").endsWith(\"False\")) {\n        hasBeenClicked.value = \"@(dummyStrPrefix)True\";\n        buttonStyle.value = \"color: @yep;\";\n      } else {\n        hasBeenClicked.value = \"@(dummyStrPrefix)False\";\n        buttonStyle.value = \"color: @dummyStrPrefix@nope;\";\n      }\n\n      this.parentNode.setAttributeNode(hasBeenClicked);\n      this.setAttributeNode(buttonStyle);\n      \"\"\"\n    in\n    let button = -- text-button.enabled is an SnS class\n      [ \"span\"\n      , [ [\"class\", \"text-button.enabled\"]\n        , [\"onclick\", onclick]\n        , [\"style\", [[\"color\", dummyStrPrefix + nope]]]\n        ]\n      , [textNode \"+\"]\n      ]\n    in\n    Html.tr styles\n      ([hasBeenClicked, dummyStrPrefix + toString flag] :: attrs)\n      (snoc button children)\n  in\n  { wrapData = wrapData\n  , mapData = mapData\n  , tr = tr\n  }\n\nTableWithButtons =\n  -- Toggle the global boolean flag, to workaround the force re-render issue.\n  { new _ =\n      { TableWithButtons | tr = TableWithButtons.tr (toggleGlobalBool []) }\n  }\n\n\n-- Begin SVG Stuff -------------------------------------------------------------\n\n--\n-- SVG Manipulating Functions\n--\n\n-- === SVG Types ===\n\n-- type alias Point = [Num Num]\n-- type alias RGBA = [Num Num Num Num]\n-- type alias Color = (union String Num RGBA)\n-- type alias PathCmds = (List (union String Num))\n-- type alias Points = (List Point)\n-- type alias RotationCmd = [[String Num Num Num]]\n-- type alias AttrVal = (union String Num Bool Color PathCmds Points RotationCmd)\n-- type alias AttrName = String\n-- type alias AttrPair = [AttrName AttrVal]\n-- type alias Attrs = (List AttrPair)\n-- type alias NodeKind = String\n-- TODO add recursive types properly\n-- type alias SVG = [NodeKind Attrs (List SVG_or_Text)]\n-- type alias SVG_or_Text = (union SVG [String String])\n-- type alias Blob = (List SVG)\n\n-- === Attribute Lookup ===\n-- lookupWithDefault: (forall (k v) (-> v k (List [k v]) v))\nlookupWithDefault default k dict =\n  let foo = lookupWithDefault default k in\n  case dict of\n    [] -> default\n    [k1, v]::rest -> if k == k1 then v else foo rest\n\n--lookup: (forall (k v) (-> k (List [k v]) (union v Null)))\nlookup k dict =\n  let foo = lookup k in\n  case dict of\n    [] -> null\n    [k1, v]::rest -> if k == k1 then v else foo rest\n\n-- addExtras: (-> Num (List [String (List [Num AttrVal])]) SVG SVG)\naddExtras i extras shape =\n  case extras of\n    [] -> shape\n    [k, table]::rest ->\n      let v = lookup i table in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n-- lookupAttr: (-> SVG AttrName (union AttrVal Null))\nlookupAttr [_, attrs, _] k = lookup k attrs\n\n-- lookupAttrWithDefault: (-> AttrVal SVG AttrName AttrVal)\nlookupAttrWithDefault default [_, attrs, _] k =\n  lookupWithDefault default k attrs \n\n-- Pairs of Type-Specific Lookup Functions\n-- lookupNumAttr: (-> SVG AttrName (union Num Null))\nlookupNumAttr [_, attrs, _] k =\n  let val = lookup k attrs in\n  \"Error: typecase not yet implemented for Elm syntax\"\n  \n-- lookupNumAttrWithDefault: (-> Num SVG AttrName Num)\nlookupNumAttrWithDefault default shape k =\n  let val = lookupNumAttr shape k in\n  \"Error: typecase not yet implemented for Elm syntax\"\n\n-- lookupPointsAttr: (-> SVG AttrName (union Points Null))\nlookupPointsAttr [_, attrs, _] k =\n  let val = lookup k attrs in\n  \"Error: typecase not yet implemented for Elm syntax\"\n\n-- lookupPointsAttrWithDefault: (-> Points SVG AttrName Points)\nlookupPointsAttrWithDefault default shape k =\n  let val = lookupPointsAttr shape k in\n  \"Error: typecase not yet implemented for Elm syntax\"\n\n-- lookupStringAttr: (-> SVG AttrName (union String Null))\nlookupStringAttr [_, attrs, _] k =\n  let val = lookup k attrs in\n  \"Error: typecase not yet implemented for Elm syntax\"\n  \n-- lookupStringAttrWithDefault: (-> String SVG AttrName String)\nlookupStringAttrWithDefault default shape k =\n  let val = lookupStringAttr shape k in\n  \"Error: typecase not yet implemented for Elm syntax\"\n\n-- === Points ===\n\n-- type alias Vec2D = [Num Num]\n\n-- vec2DPlus: (-> Point Vec2D Point)\nvec2DPlus pt vec =\n  [ fst pt\n    + fst vec, snd pt\n    + snd vec\n  ]\n\n-- vec2DMinus: (-> Point Point Vec2D)\nvec2DMinus pt vec =\n  [ fst pt\n    - fst vec, snd pt\n    - snd vec\n  ]\n\n-- vec2DScalarMult: (-> Num Vec2D Point)\nvec2DScalarMult num vec =\n  [ fst vec\n    * num, snd vec\n    * num\n  ]\n\n-- vec2DScalarDiv: (-> Num Vec2D Point)\nvec2DScalarDiv num vec =\n  [ fst vec\n    / num, snd vec\n    / num\n  ]\n\n-- vec2DLength: (-> Point Point Num)\nvec2DLength [x1, y1] [x2, y2] =\n  let [dx, dy] = [ x2- x1, y2 - y1] in\n  sqrt (dx * dx + dy * dy) \n\n\n-- === Circles ===\n\ntype alias Circle = SVG\n\n--; argument order - color, x, y, radius\n--; creates a circle, center at (x,y) with given radius and color\n-- circle: (-> Color Num Num Num Circle)\ncircle fill cx cy r =\n  [\'circle\',\n     [[\'cx\', cx], [\'cy\', cy], [\'r\', r], [\'fill\', fill]],\n     []]\n\n-- circleCenter: (-> Ellipse Point)\ncircleCenter circle =\n  [\n    lookupNumAttrWithDefault 0 circle \'cx\',\n    lookupNumAttrWithDefault 0 circle \'cy\'\n  ]\n\n-- circleRadius: (-> Circle Num)\ncircleRadius circle =\n  lookupNumAttrWithDefault 0 circle \'r\'\n\n-- circleDiameter: (-> Circle Num)\ncircleDiameter circle = 2\n  * circleRadius circle\n\n-- circleNorth: (-> Circle Point)\ncircleNorth circle =\n  let [cx, cy] = circleCenter circle in\n    [cx, cy - circleRadius circle]\n\n-- circleEast: (-> Circle Point)\ncircleEast circle =\n  let [cx, cy] = circleCenter circle in\n    [ cx+ circleRadius circle, cy]\n\n-- circleSouth: (-> Circle Point)\ncircleSouth circle =\n  let [cx, cy] = circleCenter circle in\n    [cx, cy + circleRadius circle]\n\n-- circleWest: (-> Circle Point)\ncircleWest circle =\n  let [cx, cy] = circleCenter circle in\n    [ cx- circleRadius circle, cy] \n\n\n--; argument order - color, width, x, y, radius\n--; Just as circle, except new width parameter determines thickness of ring\n-- ring: (-> Color Num Num Num Num SVG)\nring c w x y r =\n  [\'circle\',\n     [ [\'cx\', x], [\'cy\', y], [\'r\', r], [\'fill\', \'none\'], [\'stroke\', c], [\'stroke-width\', w] ],\n     []] \n\n\n-- === Ellipses ===\n\ntype alias Ellipse = SVG\n\n--; argument order - color, x, y, x-radius, y-radius\n--; Just as circle, except radius is separated into x and y parameters\n-- ellipse: (-> Color Num Num Num Num Ellipse)\nellipse fill x y rx ry =\n  [\'ellipse\',\n     [ [\'cx\', x], [\'cy\', y], [\'rx\', rx], [\'ry\', ry], [\'fill\', fill] ],\n     []]\n\n-- ellipseCenter: (-> Ellipse Point)\nellipseCenter ellipse =\n  [\n    lookupNumAttrWithDefault 0 ellipse \'cx\',\n    lookupNumAttrWithDefault 0 ellipse \'cy\'\n  ]\n\n-- ellipseRadiusX: (-> Ellipse Num)\nellipseRadiusX ellipse =\n  lookupNumAttrWithDefault 0 ellipse \'rx\'\n\n-- ellipseRadiusY: (-> Ellipse Num)\nellipseRadiusY ellipse =\n  lookupNumAttrWithDefault 0 ellipse \'ry\'\n\n-- ellipseDiameterX: (-> Ellipse Num)\nellipseDiameterX ellipse = 2\n  * ellipseRadiusX ellipse\n\n-- ellipseDiameterY: (-> Ellipse Num)\nellipseDiameterY ellipse = 2\n  * ellipseRadiusY ellipse\n\n-- ellipseNorth: (-> Ellipse Point)\nellipseNorth ellipse =\n  let [cx, cy] = ellipseCenter ellipse in\n    [cx, cy - ellipseRadiusY ellipse]\n\n-- ellipseEast: (-> Ellipse Point)\nellipseEast ellipse =\n  let [cx, cy] = ellipseCenter ellipse in\n    [ cx+ ellipseRadiusX ellipse, cy]\n\n-- ellipseSouth: (-> Ellipse Point)\nellipseSouth ellipse =\n  let [cx, cy] = ellipseCenter ellipse in\n    [cx, cy + ellipseRadiusY ellipse]\n\n-- ellipseWest: (-> Ellipse Point)\nellipseWest ellipse =\n  let [cx, cy] = ellipseCenter ellipse in\n    [ cx- ellipseRadiusX ellipse, cy] \n\n\n-- === Bounds-based shapes (Oval and Box) ===\n\n-- type alias BoundedShape = SVG\n-- type alias Bounds = [Num Num Num Num]\n\n-- boundedShapeLeft: (-> BoundedShape Num)\nboundedShapeLeft shape =\n  lookupNumAttrWithDefault 0 shape \'LEFT\'\n\n-- boundedShapeTop: (-> BoundedShape Num)\nboundedShapeTop shape =\n  lookupNumAttrWithDefault 0 shape \'TOP\'\n\n-- boundedShapeRight: (-> BoundedShape Num)\nboundedShapeRight shape =\n  lookupNumAttrWithDefault 0 shape \'RIGHT\'\n\n-- boundedShapeBot: (-> BoundedShape Num)\nboundedShapeBot shape =\n  lookupNumAttrWithDefault 0 shape \'BOT\'\n\n-- boundedShapeWidth: (-> BoundedShape Num)\nboundedShapeWidth shape = boundedShapeRight shape\n  - boundedShapeLeft shape\n\n-- boundedShapeHeight: (-> BoundedShape Num)\nboundedShapeHeight shape = boundedShapeBot shape\n  - boundedShapeTop shape\n\n-- boundedShapeLeftTop: (-> BoundedShape Point)\nboundedShapeLeftTop shape =\n  [\n    boundedShapeLeft shape,\n    boundedShapeTop shape\n  ]\n\n-- boundedShapeCenterTop: (-> BoundedShape Point)\nboundedShapeCenterTop shape =\n  [ (boundedShapeLeft shape + boundedShapeRight shape)\n    / 2,\n    boundedShapeTop shape\n  ]\n\n-- boundedShapeRightTop: (-> BoundedShape Point)\nboundedShapeRightTop shape =\n  [\n    boundedShapeRight shape,\n    boundedShapeTop shape\n  ]\n\n-- boundedShapeRightCenter: (-> BoundedShape Point)\nboundedShapeRightCenter shape =\n  [\n    boundedShapeRight shape, (boundedShapeTop shape + boundedShapeBot shape)\n    / 2\n  ]\n\n-- boundedShapeRightBot: (-> BoundedShape Point)\nboundedShapeRightBot shape =\n  [\n    boundedShapeRight shape,\n    boundedShapeBot shape\n  ]\n\n-- boundedShapeCenterBot: (-> BoundedShape Point)\nboundedShapeCenterBot shape =\n  [ (boundedShapeLeft shape + boundedShapeRight shape)\n    / 2,\n    boundedShapeBot shape\n  ]\n\n-- boundedShapeLeftBot: (-> BoundedShape Point)\nboundedShapeLeftBot shape =\n  [\n    boundedShapeLeft shape,\n    boundedShapeBot shape\n  ]\n\n-- boundedShapeLeftCenter: (-> BoundedShape Point)\nboundedShapeLeftCenter shape =\n  [\n    boundedShapeLeft shape, (boundedShapeTop shape + boundedShapeBot shape)\n    / 2\n  ]\n\n-- boundedShapeCenter: (-> BoundedShape Point)\nboundedShapeCenter shape =\n  [ (boundedShapeLeft shape + boundedShapeRight shape)\n    / 2, (boundedShapeTop shape + boundedShapeBot shape)\n    / 2\n  ] \n\n\n-- === Rectangles ===\n\ntype alias Rect = SVG\n\n--; argument order - color, x, y, width, height\n--; creates a rectangle of given width and height with (x,y) as the top left corner coordinate\n-- rect: (-> Color Num Num Num Num Rect)\nrect fill x y w h =\n  [\'rect\',\n     [ [\'x\', x], [\'y\', y], [\'width\', w], [\'height\', h], [\'fill\', fill] ],\n     []]\n\n-- square: (-> Color Num Num Num Rect)\nsquare fill x y side = rect fill x y side side\n\n-- rectWidth: (-> Rect Num)\nrectWidth rect =\n  lookupNumAttrWithDefault 0 rect \'width\'\n\n-- rectHeight: (-> Rect Num)\nrectHeight rect =\n  lookupNumAttrWithDefault 0 rect \'height\'\n\n-- rectLeftTop: (-> Rect Point)\nrectLeftTop rect =\n  [\n    lookupNumAttrWithDefault 0 rect \'x\',\n    lookupNumAttrWithDefault 0 rect \'y\'\n  ]\n\n-- rectCenterTop: (-> Rect Point)\nrectCenterTop rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect / 2, 0 ]\n\n-- rectRightTop: (-> Rect Point)\nrectRightTop rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect, 0 ]\n\n-- rectRightCenter: (-> Rect Point)\nrectRightCenter rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect, rectHeight rect / 2 ]\n\n-- rectRightBot: (-> Rect Point)\nrectRightBot rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect, rectHeight rect ]\n\n-- rectCenterBot: (-> Rect Point)\nrectCenterBot rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect / 2, rectHeight rect ]\n\n-- rectLeftBot: (-> Rect Point)\nrectLeftBot rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [0, rectHeight rect ]\n\n-- rectLeftCenter: (-> Rect Point)\nrectLeftCenter rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [0, rectHeight rect / 2 ]\n\n-- rectCenter: (-> Rect Point)\nrectCenter rect =\n  vec2DPlus\n    (rectLeftTop rect)\n    [ rectWidth rect / 2, rectHeight rect / 2 ] \n\n\n-- === Lines ===\n\ntype alias Line = SVG\n\n--; argument order - color, width, x1, y1, x1, y2\n--; creates a line from (x1, y1) to (x2,y2) with given color and width\n-- line: (-> Color Num Num Num Num Num Line)\nline stroke w x1 y1 x2 y2 =\n  [\'line\',\n     [ [\'x1\', x1], [\'y1\', y1], [\'x2\', x2], [\'y2\', y2], [\'stroke\', stroke], [\'stroke-width\', w] ],\n     []]\n\n-- lineBetween: (-> Color Num Point Point Line)\nlineBetween stroke w [x1, y1] [x2, y2] =\n  line stroke w x1 y1 x2 y2\n\n-- lineStart: (-> Line Point)\nlineStart line =\n  [\n    lookupNumAttrWithDefault 0 line \'x1\',\n    lookupNumAttrWithDefault 0 line \'y1\'\n  ]\n\n-- lineEnd: (-> Line Point)\nlineEnd line =\n  [\n    lookupNumAttrWithDefault 0 line \'x2\',\n    lookupNumAttrWithDefault 0 line \'y2\'\n  ]\n\n-- lineMidPoint: (-> Line Point)\nlineMidPoint line =\n  halfwayBetween (lineStart line) (lineEnd line) \n\n\n--; argument order - fill, stroke, width, points\n--; creates a polygon following the list of points, with given fill color and a border with given width and stroke\n-- polygon: (-> Color Color Num Points SVG)\npolygon fill stroke w pts =\n  [\'polygon\',\n     [ [\'fill\', fill], [\'points\', pts], [\'stroke\', stroke], [\'stroke-width\', w] ],\n     []] \n\n--; argument order - fill, stroke, width, points\n--; See polygon\n-- polyline: (-> Color Color Num Points SVG)\npolyline fill stroke w pts =\n  [\'polyline\',\n     [ [\'fill\', fill], [\'points\', pts], [\'stroke\', stroke], [\'stroke-width\', w] ],\n     []] \n\n--; argument order - fill, stroke, width, d\n--; Given SVG path command d, create path with given fill color, stroke and width\n--; See https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths for path command info\n-- path: (-> Color Color Num PathCmds SVG)\npath fill stroke w d =\n  [\'path\',\n     [ [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', w], [\'d\', d] ],\n     []] \n\n--; argument order - x, y, string\n--; place a text string with top left corner at (x,y) - with default color & font\n-- text: (-> Num Num String SVG)\ntext x y s =\n   [\'text\', [[\'x\', x], [\'y\', y], [\'style\', \'fill:black\'],\n            [\'font-family\', \'Tahoma, sans-serif\']],\n           [[\'TEXT\', s]]] \n\n--; argument order - shape, new attribute\n--; Add a new attribute to a given Shape\n-- addAttr: (-> SVG AttrPair SVG)\naddAttr [shapeKind, oldAttrs, children] newAttr =\n  [shapeKind, snoc newAttr oldAttrs, children]\n\n-- consAttr: (-> SVG AttrPair SVG)\nconsAttr [shapeKind, oldAttrs, children] newAttr =\n  [shapeKind, cons newAttr oldAttrs, children] \n\n--; Given a list of shapes, compose into a single SVG\nsvg shapes = [\'svg\', [], shapes] \n\n--; argument order - x-maximum, y-maximum, shapes\n--; Given a list of shapes, compose into a single SVG within the x & y maxima\n-- svgViewBox: (-> Num Num (List SVG) SVG)\nsvgViewBox xMax yMax shapes =\n  let [sx, sy] = [toString xMax, toString yMax] in\n  [\'svg\',\n    [[\'x\', \'0\'], [\'y\', \'0\'], [\'viewBox\', joinStrings \' \' [\'0\', \'0\', sx, sy]]],\n    shapes] \n\n--; As rect, except x & y represent the center of the defined rectangle\n-- rectByCenter: (-> Color Num Num Num Num Rect)\nrectByCenter fill cx cy w h =\n  rect fill (cx - w / 2) (cy - h / 2) w h \n\n--; As square, except x & y represent the center of the defined rectangle\n-- squareByCenter: (-> Color Num Num Num Rect)\nsquareByCenter fill cx cy w = rectByCenter fill cx cy w w \n\n--; Some shapes with given default values for fill, stroke, and stroke width\n-- TODO remove these\ncircle_ =    circle \'red\' \nellipse_ =   ellipse \'orange\' \nrect_ =      rect \'#999999\' \nsquare_ =    square \'#999999\' \nline_ =      line \'blue\' 2 \npolygon_ =   polygon \'green\' \'purple\' 3 \npath_ =      path \'transparent\' \'goldenrod\' 5 \n\n--; updates an SVG by comparing differences with another SVG\n--; Note: accDiff pre-condition: indices in increasing order\n--; (so can\'t just use foldr instead of reverse . foldl)\n-- updateCanvas: (-> SVG SVG SVG)\nupdateCanvas [_, svgAttrs, oldShapes] diff =\n  let oldShapesI = zipOld (list1N (len oldShapes)) oldShapes in\n  let initAcc = [[], diff] in\n  let f [i, oldShape] [accShapes, accDiff] =\n    case accDiff of\n      []->\n        [cons oldShape accShapes, accDiff]\n      [j, newShape]::accDiffRest->\n        if i == j then\n          [cons newShape accShapes, accDiffRest]\n        else\n          [cons oldShape accShapes, accDiff] in\n  let newShapes = reverse (fst (foldl f initAcc oldShapesI)) in\n    [\'svg\', svgAttrs, newShapes] \n\naddBlob newShapes [\'svg\', svgAttrs, oldShapes] =\n  [\'svg\', svgAttrs, append oldShapes newShapes]\n\n--  groupMap: (forall (a b) (-> (List a) (-> a b) (List b)))\ngroupMap xs f = map f xs \n\nautoChose _ x _ = x \ninferred x _ _ = x \nflow _ x = x \n\ntwoPi = 2 * pi \nhalfPi = pi / 2 \n\n--; Helper function for nPointsOnCircle, calculates angle of points\n--; Note: angles are calculated clockwise from the traditional pi/2 mark\n-- nPointsOnUnitCircle: (-> Num Num (List Point))\nnPointsOnUnitCircle n rot =\n  let off = halfPi - rot in\n  let foo i =\n    let ang = off + i / n * twoPi in\n    [cos ang, neg (sin ang)] in\n  map foo (list0N (n - 1))\n\n-- nPointsOnCircle: (-> Num Num Num Num Num (List Point))\n--; argument order - Num of points, degree of rotation, x-center, y-center, radius\n--; Scales nPointsOnUnitCircle to the proper size and location with a given radius and center\nnPointsOnCircle n rot cx cy r =\n  let pts = nPointsOnUnitCircle n rot in\n  map \\[x, y] -> [ cx+ x * r, cy + y * r] pts\n\n-- nStar: (-> Color Color Num Num Num Num Num Num Num SVG)\n--; argument order -\n--; fill color - interior color of star\n--; stroke color - border color of star\n--; width - thickness of stroke\n--; points - number of star points\n--; len1 - length from center to one set of star points\n--; len2 - length from center to other set of star points (either inner or outer compared to len1)\n--; rot - degree of rotation\n--; cx - x-coordinate of center position\n--; cy - y-coordinate of center position\n--; Creates stars that can be modified on a number of parameters\nnStar fill stroke w n len1 len2 rot cx cy =\n  let pti [i, len] =\n    let anglei = i * pi / n - rot + halfPi in\n    let xi = cx + len * cos anglei in\n    let yi = cy + neg (len * sin anglei) in\n      [xi, yi] in\n  let lengths =\n    map (\\b -> if b then len1 else len2)\n        (concat (repeat n [True, False])) in\n  let indices = list0N (2! * n - 1!) in\n    polygon fill stroke w (map pti (zipOld indices lengths))\n\n-- setZones: (-> String SVG SVG)\nsetZones s shape = addAttr shape [\'ZONES\', s]\n\n-- zones: (-> String (List SVG) (List SVG))\nzones s shapes = map (setZones s) shapes \n-- TODO eta-reduced version:\n-- (def zones (\\s (map (setZones s))))\n\n--; Remove all zones from shapes except for the first in the list\n-- hideZonesTail: (-> (List SVG) (List SVG))\nhideZonesTail hd :: tl = hd :: zones \'none\' tl \n\n--; Turn all zones to basic for a given list of shapes except for the first shape\n-- basicZonesTail: (-> (List SVG) (List SVG))\nbasicZonesTail hd :: tl = hd :: zones \'basic\' tl\n\n-- ghost: (-> SVG SVG)\nghost =\n  -- consAttr (instead of addAttr) makes internal calls to\n  -- Utils.maybeRemoveFirst \'HIDDEN\' slightly faster\n  \\shape -> consAttr shape [\'HIDDEN\', \'\'] \n\nghosts = map ghost \n\n--; hSlider_ : Bool -> Bool -> Int -> Int -> Int -> Num -> Num -> Str -> Num\n--; -> [Num (List Svg)]\n--; argument order - dropBall roundInt xStart xEnd y minVal maxVal caption srcVal\n--; dropBall - Determines if the slider ball continues to appear past the edges of the slider\n--; roundInt - Determines whether to round to Ints or not\n--; xStart - left edge of slider\n--; xEnd - right edge of slider\n--; y - y positioning of entire slider bar\n--; minVal - minimum value of slider\n--; maxVal - maximum value of slider\n--; caption - text to display along with the slider\n--; srcVal - the current value given by the slider ball\nhSlider_ dropBall roundInt x0 x1 y minVal maxVal caption srcVal =\n  let preVal = clamp minVal maxVal srcVal in\n  let targetVal = if roundInt then round preVal else preVal in\n  let shapes =\n    let ball =\n      let [xDiff, valDiff] = [ x1- x0, maxVal - minVal] in\n      let xBall = x0 + xDiff * (srcVal - minVal) / valDiff in\n      if preVal == srcVal then circle \'black\' xBall y 10! else\n      if dropBall then          circle \'black\' 0! 0! 0! else\n                            circle \'red\' xBall y 10! in\n    [ line \'black\' 3! x0 y x1 y,\n      text (x1 + 10) (y + 5) (caption + toString targetVal),\n      circle \'black\' x0 y 4!, circle \'black\' x1 y 4!, ball ] in\n  [targetVal, ghosts shapes] \n-- TODO only draw zones for ball\n\nvSlider_ dropBall roundInt y0 y1 x minVal maxVal caption srcVal =\n  let preVal = clamp minVal maxVal srcVal in\n  let targetVal = if roundInt then round preVal else preVal in\n  let shapes =\n    let ball =\n      let [yDiff, valDiff] = [ y1- y0, maxVal - minVal] in\n      let yBall = y0 + yDiff * (srcVal - minVal) / valDiff in\n      if preVal == srcVal then circle \'black\' x yBall 10! else\n      if dropBall then          circle \'black\' 0! 0! 0! else\n                            circle \'red\' x yBall 10! in\n    [ line \'black\' 3! x y0 x y1,\n      -- (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))\n      circle \'black\' x y0 4!, circle \'black\' x y1 4!, ball ] in\n  [targetVal, ghosts shapes] \n-- TODO only draw zones for ball\n\nhSlider = hSlider_ False \nvSlider = vSlider_ False \n\n--; button_ : Bool -> Num -> Num -> String -> Num -> SVG\n--; Similar to sliders, but just has boolean values\nbutton_ dropBall xStart y caption xCur =\n  let [rPoint, wLine, rBall, wSlider] = [4!, 3!, 10!, 70!] in\n  let xEnd = xStart + wSlider in\n  let xBall = xStart + xCur * wSlider in\n  let xBall_ = clamp xStart xEnd xBall in\n  let val = xCur < 0.5 in\n  let shapes1 =\n    [ circle \'black\' xStart y rPoint,\n      circle \'black\' xEnd y rPoint,\n      line \'black\' wLine xStart y xEnd y,\n      text (xEnd + 10) (y + 5) (caption + toString val) ] in\n  let shapes2 =\n    [ if xBall_ == xBall then circle (if val then \'darkgreen\' else \'darkred\') xBall y rBall else\n      if dropBall then         circle \'black\' 0! 0! 0! else\n                           circle \'red\' xBall y rBall ] in\n  let shapes = append (zones \'none\' shapes1) (zones \'basic\' shapes2) in\n  [val, ghosts shapes] \n\nbutton = button_ False \n\nxySlider xStart xEnd yStart yEnd xMin xMax yMin yMax xCaption yCaption xCur yCur =\n    let [rCorner, wEdge, rBall] = [4!, 3!, 10!] in\n    let [xDiff, yDiff, xValDiff, yValDiff] = [ xEnd- xStart, yEnd - yStart, xMax - xMin, yMax - yMin] in\n    let xBall = xStart + xDiff * (xCur - xMin) / xValDiff in\n    let yBall = yStart + yDiff * (yCur - yMin) / yValDiff in\n    let cBall = if and (between xMin xMax xCur) (between yMin yMax yCur)then \'black\'else \'red\' in\n    let xVal = ceiling clamp xMin xMax xCur in\n    let yVal = ceiling clamp yMin yMax yCur in\n    let myLine x1 y1 x2 y2 = line \'black\' wEdge x1 y1 x2 y2 in\n    let myCirc x0 y0 = circle \'black\' x0 y0 rCorner in\n    let shapes =\n      [ myLine xStart yStart xEnd yStart,\n        myLine xStart yStart xStart yEnd,\n        myLine xStart yEnd xEnd yEnd,\n        myLine xEnd yStart xEnd yEnd,\n        myCirc xStart yStart,\n        myCirc xStart yEnd,\n        myCirc xEnd yStart,\n        myCirc xEnd yEnd,\n        circle cBall xBall yBall rBall,\n        text (xStart + xDiff / 2 - 40) (yEnd + 20) (xCaption + toString xVal),\n        text (xEnd + 10) (yStart + yDiff / 2) (yCaption + toString yVal) ] in\n    [ [ xVal, yVal ], ghosts shapes ]\n    \n-- enumSlider: (forall a (-> Num Num Num [a|(List a)] String Num [a (List SVG)]))\nenumSlider x0 x1 ((ya::_) as enum) caption srcVal =\n  let n = len enum in\n  let [minVal, maxVal] = [0!, n] in\n  let preVal = clamp minVal maxVal srcVal in\n  let i = floor preVal in\n  let item = -- using dummy first element for typechecking\n    let item_ = nth enum if i == n then n - 1 else i in\n    \"Error: typecase not yet implemented for Elm syntax\" in\n  let wrap circ = addAttr circ [\'SELECTED\', \'\'] in -- TODO\n  let shapes =\n    let rail = [ line \'black\' 3! x0 y x1 y ] in\n    let ball =\n      let [xDiff, valDiff] = [ x1- x0, maxVal - minVal] in\n      let xBall = x0 + xDiff * (srcVal - minVal) / valDiff in\n      let colorBall = if preVal == srcVal then \'black\' else \'red\' in\n        [ wrap (circle colorBall xBall y 10!) ] in\n    let endpoints =\n      [ wrap (circle \'black\' x0 y 4!), wrap (circle \'black\' x1 y 4!) ] in\n    let tickpoints =\n      let sep = (x1 - x0) / n in\n      map (\\j -> wrap (circle \'grey\' (x0 + mult j sep) y 4!))\n          (range 1! (n - 1!)) in\n    let label = [ text (x1 + 10!) (y + 5!) (caption + toString item) ] in\n    concat [ rail, endpoints, tickpoints, ball, label ] in\n  [item, ghosts shapes] \n\naddSelectionSliders y0 seeds shapesCaps =\n  let shapesCapsSeeds = zipOld shapesCaps (take seeds (len shapesCaps)) in\n  let foo [i, [[shape, cap], seed]] =\n    let [k, _, _] = shape in\n    let enum =\n      if k == \'circle\'then [\'\', \'cx\', \'cy\', \'r\']else\n      if k == \'line\'then   [\'\', \'x1\', \'y1\', \'x2\', \'y2\']else\n      if k == \'rect\'then   [\'\', \'x\', \'y\', \'width\', \'height\']else\n        [ \'NO SELECTION ENUM FOR KIND \'+ k] in\n    let [item, slider] = enumSlider 20! 170! (y0 + mult i 30!) enum cap seed in\n    let shape1 = addAttr shape [\'SELECTED\', item] in -- TODO overwrite existing\n    shape1::slider in\n  concat (mapi foo shapesCapsSeeds) \n\n-- Text Widgets\n\nsimpleText family color size x1 x2 y horizAlignSeed textVal =\n  let xMid = x1 + (x2 - x1) / 2! in\n  let [anchor, hAlignSlider] =\n    let dx = (x2 - x1) / 4! in\n    let yLine = 30! + y in\n    enumSlider (xMid - dx) (xMid + dx) yLine\n      [\'start\', \'middle\', \'end\'] \'\' horizAlignSeed in\n  let x =\n    if anchor == \'start\' then x1 else\n    if anchor == \'middle\' then xMid else\n    if anchor == \'end\' then x2 else\n      \'CRASH\' in\n  let theText =\n    [\'text\',\n      [[\'x\', x], [\'y\', y],\n       [\'style\', \'fill:\' + color],\n       [\'font-family\', family], [\'font-size\', size],\n       [\'text-anchor\', anchor]],\n      [[\'TEXT\', textVal]]] in\n  let rails =\n    let pad = 15! in\n    let yBaseLine = y + pad in\n    let xSideLine = x1 - pad in\n    let rail = line \'gray\' 3 in\n    let baseLine = rail xSideLine yBaseLine x2 yBaseLine in\n    let sideLine = rail xSideLine yBaseLine xSideLine (y - size) in\n    let dragBall = circle \'black\' x yBaseLine 8! in\n    ghosts [baseLine, sideLine, dragBall] in\n  concat [[theText], hAlignSlider, rails]\n\n-- rotate: (-> SVG Num Num Num SVG)\n--; argument order - shape, rot, x, y\n--; Takes a shape rotates it rot degrees around point (x,y)\nrotate shape n1 n2 n3 =\n  addAttr shape [\'transform\', [[\'rotate\', n1, n2, n3]]]\n\n-- rotateAround: (-> Num Num Num SVG SVG)\nrotateAround rot x y shape =\n  addAttr shape [\'transform\', [[\'rotate\', rot, x, y]]]\n\n-- Polygon and Path Helpers\n-- middleOfPoints: (-> (List Point) Point)\nmiddleOfPoints pts =\n  let [xs, ys] = [map fst pts, map snd pts] in\n  let [xMin, xMax] = [minimum xs, maximum xs] in\n  let [yMin, yMax] = [minimum ys, maximum ys] in\n  let xMiddle = noWidgets (xMin + 0.5 * (xMax - xMin)) in\n  let yMiddle = noWidgets (yMin + 0.5 * (yMax - yMin)) in\n    [xMiddle, yMiddle]\n\n-- polygonPoints: (-> SVG Points)\npolygonPoints [shapeKind, _, _]asshape =\n  case shapeKind of\n    \'polygon\'-> lookupPointsAttrWithDefault [] shape \'points\'\n    _->         []\n    \n-- allPointsOfPathCmds_: (-> PathCmds (List [(union Num String) (union Num String)]))\nallPointsOfPathCmds_ cmds = case cmds\nof\n  []->    []\n  [\'Z\']-> []\n\n  \'M\'::x::y::rest-> cons [x, y] (allPointsOfPathCmds_ rest)\n  \'L\'::x::y::rest-> cons [x, y] (allPointsOfPathCmds_ rest)\n\n  \'Q\'::x1::y1::x::y::rest->\n    append [[x1, y1], [x, y]] (allPointsOfPathCmds_ rest)\n\n  \'C\'::x1::y1::x2::y2::x::y::rest->\n    append [[x1, y1], [x2, y2], [x, y]] (allPointsOfPathCmds_ rest)\n\n  _-> [let _ = debug \"Prelude.allPointsOfPathCmds_: not Nums...\" in [-1, -1]] \n\n-- (typ allPointsOfPathCmds (-> PathCmds (List Point)))\n-- (def allPointsOfPathCmds (\\cmds\n--   (let toNum (\\numOrString\n--     (typecase numOrString (Num numOrString) (String -1)))\n--   (map (\\[x y] [(toNum x) (toNum y)]) (allPointsOfPathCmds_ cmds)))))\n\n-- TODO remove inner annotations and named lambda\n-- allPointsOfPathCmds: (-> PathCmds (List Point))\nallPointsOfPathCmds cmds =\n  -- toNum: (-> (union Num String) Num)\n  let toNum numOrString =\n  \"Error: typecase not yet implemented for Elm syntax\" in\n  -- foo: (-> [(union Num String) (union Num String)] Point)\n  let foo [x, y] = [toNum x, toNum y] in\n  map foo (allPointsOfPathCmds_ cmds) \n\n\n-- Raw Shapes\n\nrawShape kind attrs = [kind, attrs, []]\n\n-- rawRect: (-> Color Color Num Num Num Num Num Num Rect)\nrawRect fill stroke strokeWidth x y w h rot =\n  let [cx, cy] = [ x+ w / 2!, y + h / 2!] in\n  rotateAround rot cx cy\n    (rawShape \'rect\' [\n      [\'x\', x], [\'y\', y], [\'width\', w], [\'height\', h],\n      [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', strokeWidth] ])\n\n-- rawCircle: (-> Color Color Num Num Num Num Circle)\nrawCircle fill stroke strokeWidth cx cy r =\n  rawShape \'circle\' [\n    [\'cx\', cx], [\'cy\', cy], [\'r\', r],\n    [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', strokeWidth] ]\n\n-- rawEllipse: (-> Color Color Num Num Num Num Num Num Ellipse)\nrawEllipse fill stroke strokeWidth cx cy rx ry rot =\n  rotateAround rot cx cy\n    (rawShape \'ellipse\' [\n      [\'cx\', cx], [\'cy\', cy], [\'rx\', rx], [\'ry\', ry],\n      [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', strokeWidth] ])\n\n-- rawPolygon: (-> Color Color Num Points Num SVG)\nrawPolygon fill stroke w pts rot =\n  let [cx, cy] = middleOfPoints pts in\n  rotateAround rot cx cy\n    (rawShape \'polygon\'\n      [ [\'fill\', fill], [\'points\', pts], [\'stroke\', stroke], [\'stroke-width\', w] ])\n\n-- rawPath: (-> Color Color Num PathCmds Num SVG)\nrawPath fill stroke w d rot =\n  let [cx, cy] = middleOfPoints (allPointsOfPathCmds d) in\n  rotateAround rot cx cy\n    (rawShape \'path\'\n      [ [\'fill\', fill], [\'d\', d], [\'stroke\', stroke], [\'stroke-width\', w] ]) \n\n\n-- Shapes via Bounding Boxes\n-- box: (-> Bounds Color Color Num BoundedShape)\nbox bounds fill stroke strokeWidth =\n  let [x, y, xw, yh] = bounds in\n  [\'BOX\',\n    [ [\'LEFT\', x], [\'TOP\', y], [\'RIGHT\', xw], [\'BOT\', yh],\n      [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', strokeWidth]\n    ], []\n  ] \n\n-- string fill/stroke/stroke-width attributes to avoid sliders\n-- hiddenBoundingBox: (-> Bounds BoundedShape)\nhiddenBoundingBox bounds =\n  ghost (box bounds \'transparent\' \'transparent\' \'0\')\n\n-- simpleBoundingBox: (-> Bounds BoundedShape)\nsimpleBoundingBox bounds =\n  ghost (box bounds \'transparent\' \'darkblue\' 1)\n\n-- strList: (-> (List String) String)\nstrList =\n  let foo x acc = acc + if acc == \'\'then \'\'else \' \' + toString x in\n  foldl foo \'\'\n\n-- fancyBoundingBox: (-> Bounds (List SVG))\nfancyBoundingBox bounds =\n  let [left, top, right, bot] = bounds in\n  let [width, height] = [ right- left, bot - top] in\n  let [c1, c2, r] = [\'darkblue\', \'skyblue\', 6] in\n  [ ghost (box bounds \'transparent\' c1 1),\n    ghost (setZones \'none\' (circle c2 left top r)),\n    ghost (setZones \'none\' (circle c2 right top r)),\n    ghost (setZones \'none\' (circle c2 right bot r)),\n    ghost (setZones \'none\' (circle c2 left bot r)),\n    ghost (setZones \'none\' (circle c2 left (top + height / 2) r)),\n    ghost (setZones \'none\' (circle c2 right (top + height / 2) r)),\n    ghost (setZones \'none\' (circle c2 (left + width / 2) top r)),\n    ghost (setZones \'none\' (circle c2 (left + width / 2) bot r))\n  ]\n\n-- groupWithPad: (-> Num Bounds (List SVG) SVG)\ngroupWithPad pad bounds shapes =\n  let [left, top, right, bot] = bounds in\n  let paddedBounds = [ left- pad, top - pad, right + pad, bot + pad] in\n  [\'g\', [[\'BOUNDS\', bounds]],\n       cons (hiddenBoundingBox paddedBounds) shapes]\n\n-- group: (-> Bounds (List SVG) SVG)\ngroup = groupWithPad let nGroupPad = 20 in nGroupPad \n\n-- NOTE:\n--   keep the names nGroupPad and nPolyPathPad (and values)\n--   in sync with ExpressionBasedTransform.elm\n\n-- (def group (groupWithPad 15))\n\npolyPathGroup = groupWithPad let nPolyPathPad = 10 in nPolyPathPad \n\n-- TODO make one pass over pts\n-- boundsOfPoints: (-> (List Point) Bounds)\nboundsOfPoints pts =\n  let left =  minimum (map fst pts) in\n  let right = maximum (map fst pts) in\n  let top =   minimum (map snd pts) in\n  let bot =   maximum (map snd pts) in\n    [left, top, right, bot]\n    \n-- extremeShapePoints: (-> SVG Points)\nextremeShapePoints ([kind, _, _] as shape) =\n  case kind of\n    \'line\'->\n      let [x1, y1, x2, y2]as attrs = map (lookupAttr shape) [\"x1\", \"y1\", \"x2\", \"y2\"] in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n    \'rect\'->\n      let [x, y, w, h]as attrs = map (lookupAttr shape) [\"x\", \"y\", \"width\", \"height\"] in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n    \'circle\'->\n      let [cx, cy, r]as attrs = map (lookupAttr shape) [\"cx\", \"cy\", \"r\"] in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n    \'ellipse\'->\n      let [cx, cy, rx, ry]as attrs = map (lookupAttr shape) [\"cx\", \"cy\", \"rx\", \"ry\"] in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n    \'polygon\'-> polygonPoints shape\n\n    \'path\'->\n      let pathCmds = lookupAttr shape \"d\" in\n      \"Error: typecase not yet implemented for Elm syntax\"\n\n    _-> []\n\n-- anchoredGroup: (-> (List SVG) SVG)\nanchoredGroup shapes =\n  let bounds = boundsOfPoints (concat (map extremeShapePoints shapes)) in\n  group bounds shapes \n\n-- (def group (\\(bounds shapes)\n--   [\'g\' [[\'BOUNDS\' bounds]]\n--        (cons (hiddenBoundingBox bounds) shapes)]))\n\n       -- (concat [(fancyBoundingBox bounds) shapes])]))\n\n-- TODO no longer used...\n-- rotatedRect: (-> Color Num Num Num Num Num Rect)\nrotatedRect fill x y w h rot =\n  let [cx, cy] = [ x+ w / 2!, y + h / 2!] in\n  let bounds = [x, y, x + w, y + h] in\n  let shape = rotateAround rot cx cy (rect fill x y w h) in\n  group bounds [shape]\n\n-- rectangle: (-> Color Color Num Num Bounds Rect)\nrectangle fill stroke strokeWidth rot bounds =\n  let [left, top, right, bot] = bounds in\n  let [cx, cy] = [ left+ (right - left) / 2!, top + (bot - top) / 2!] in\n  let shape = rotateAround rot cx cy (box bounds fill stroke strokeWidth) in\n  shape \n-- (group bounds [shape])\n\n-- TODO no longer used...\n-- rotatedEllipse: (-> Color Num Num Num Num Num Ellipse)\nrotatedEllipse fill cx cy rx ry rot =\n  let bounds = [ cx- rx, cy - ry, cx + rx, cy + ry] in\n  let shape = rotateAround rot cx cy (ellipse fill cx cy rx ry) in\n  group bounds [shape] \n\n-- TODO take rot\n-- oval: (-> Color Color Num Bounds BoundedShape)\noval fill stroke strokeWidth bounds =\n  let [left, top, right, bot] = bounds in\n  let shape =\n    [\'OVAL\',\n       [ [\'LEFT\', left], [\'TOP\', top], [\'RIGHT\', right], [\'BOT\', bot],\n         [\'fill\', fill], [\'stroke\', stroke], [\'stroke-width\', strokeWidth] ],\n       []] in\n  shape \n\n-- ; TODO take rot\n-- (def oval (\\(fill stroke strokeWidth bounds)\n--   (let [left top right bot] bounds\n--   (let [rx ry] [(/ (- right left) 2!) (/ (- bot top) 2!)]\n--   (let [cx cy] [(+ left rx) (+ top ry)]\n--   (let shape ; TODO change def ellipse to take stroke/strokeWidth\n--     [\'ellipse\'\n--        [ [\'cx\' cx] [\'cy\' cy] [\'rx\' rx] [\'ry\' ry]\n--          [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]\n--        []]\n--   (group bounds [shape])\n-- ))))))\n\nscaleBetween a b pct =\n  case pct of\n    0-> a\n    1-> b\n    _-> a + pct * (b - a)\n\n-- stretchyPolygon: (-> Bounds Color Color Num (List Num) SVG)\nstretchyPolygon bounds fill stroke strokeWidth percentages =\n  let [left, top, right, bot] = bounds in\n  let [xScale, yScale] = [scaleBetween left right, scaleBetween top bot] in\n  let pts = map \\[xPct, yPct] -> [ xScale xPct, yScale yPct ] percentages in\n  -- (group bounds [(polygon fill stroke strokeWidth pts)])\n  polyPathGroup bounds [polygon fill stroke strokeWidth pts] \n\n-- TODO no longer used...\npointyPath fill stroke w d =\n  let dot x y = ghost (circle \'orange\' x y 5) in\n  let pointsOf cmds =\n    case cmds of\n      []->                     []\n      [\'Z\']->                  []\n      \'M\'::x::y::rest->       append [dot x y] (pointsOf rest)\n      \'L\'::x::y::rest->       append [dot x y] (pointsOf rest)\n      \'Q\'::x1::y1::x::y::rest-> append [dot x1 y1, dot x y] (pointsOf rest)\n      \'C\'::x1::y1::x2::y2::x::y::rest-> append [dot x1 y1, dot x2 y2, dot x y] (pointsOf rest)\n      _->                      \'ERROR\' in\n  [\'g\', [],\n    cons\n      (path fill stroke w d)\n      []] \n-- turning off points for now\n-- (pointsOf d)) ]\n\n-- can refactor to make one pass\n-- can also change representation/template code to pair points\nstretchyPath bounds fill stroke w d =\n  let [left, top, right, bot] = bounds in\n  let [xScale, yScale] = [scaleBetween left right, scaleBetween top bot] in\n  let dot x y = ghost (circle \'orange\' x y 5) in\n  let toPath cmds =\n    case cmds of\n      []->    []\n      [\'Z\']-> [\'Z\']\n      \'M\'::x::y::rest-> append [\'M\', xScale x, yScale y] (toPath rest)\n      \'L\'::x::y::rest-> append [\'L\', xScale x, yScale y] (toPath rest)\n      \'Q\'::x1::y1::x::y::rest->\n        append [\'Q\', xScale x1, yScale y1, xScale x, yScale y]\n                (toPath rest)\n      \'C\'::x1::y1::x2::y2::x::y::rest->\n        append [\'C\', xScale x1, yScale y1, xScale x2, yScale y2, xScale x, yScale y]\n                (toPath rest)\n      _-> \'ERROR\' in\n  let pointsOf cmds =\n    case cmds of\n      []->    []\n      [\'Z\']-> []\n      \'M\'::x::y::rest-> append [dot (xScale x) (yScale y)] (pointsOf rest)\n      \'L\'::x::y::rest-> append [dot (xScale x) (yScale y)] (pointsOf rest)\n      \'Q\'::x1::y1::x::y::rest->\n        append [dot (xScale x1) (yScale y1), dot (xScale x) (yScale y)]\n                (pointsOf rest)\n      \'C\'::x1::y1::x2::y2::x::y::rest->\n        append [dot (xScale x1) (yScale y1),\n                 dot (xScale x2) (yScale y2),\n                 dot (xScale x)  (yScale y)]\n                (pointsOf rest)\n      _-> \'ERROR\' in\n  -- (group bounds\n  polyPathGroup bounds\n    (cons\n      (path fill stroke w (toPath d))\n      []) \n-- turning off points for now\n-- (pointsOf d)))\n-- evalOffset: (-> [Num Num] Num)\nevalOffset [base, off] =\n  case off of\n    0-> base\n    _-> base + off \n\nstickyPolygon bounds fill stroke strokeWidth offsets =\n  let pts = map \\[xOff, yOff] -> [ evalOffset xOff, evalOffset yOff ] offsets in\n  group bounds [polygon fill stroke strokeWidth pts]\n\n-- withBounds: (-> Bounds (-> Bounds (List SVG)) (List SVG))\nwithBounds bounds f = f bounds\n\n-- withAnchor: (-> Point (-> Point (List SVG)) (List SVG))\nwithAnchor anchor f = f anchor\n\n-- star: (-> Bounds (List SVG))\nstar bounds =\n  let [left, top, right, bot] = bounds in\n  let [width, height] = [ right- left, bot - top] in\n  let [cx, cy] = [ left+ width / 2, top + height / 2] in\n  [nStar 0 \'black\' 0 6 (min (width / 2) (height / 2)) 10 0 cx cy]\n\n-- blobs: (-> (List Blob) SVG)\nblobs blobs =\n  let modifyBlob [i, blob] =\n    case blob of\n      [[\'g\', gAttrs, shape :: shapes]]->\n       [[\'g\', gAttrs, consAttr shape [\'BLOB\', toString (i + 1)] :: shapes]]\n      [shape]-> [consAttr shape [\'BLOB\', toString (i + 1)]]\n      _->       blob in\n  svg (concat (mapi modifyBlob blobs)) \n\n\n-- === Relations ===\n-- halfwayBetween: (-> Point Point Point)\nhalfwayBetween pt1 pt2 =\n  vec2DScalarMult 0.5 (vec2DPlus pt1 pt2)\n\n-- nextInLine: (-> Point Point Point)\nnextInLine pt1 pt2 =\n  vec2DPlus pt2 (vec2DMinus pt2 pt1) \n\n-- Point on line segment, at `ratio` location.\n-- onLine: (-> Point Point Num Point)\nonLine pt1 pt2 ratio =\n  let vec = vec2DMinus pt2 pt1 in\n  vec2DPlus pt1 (vec2DScalarMult ratio vec) \n\n-- === Basic Replicate ===\n\nhorizontalArray n sep func [x, y] =\n  let _ = -- draw point widget to control anchor\n    [x, y] : Point in\n  let draw_i i =\n    let xi = x + i * sep in\n    func [xi, y] in\n  concat (map draw_i (zeroTo n)) \n\nlinearArrayFromTo n func [xStart, yStart] [xEnd, yEnd] =\n  let xsep = (xEnd - xStart) / (n - 1) in\n  let ysep = (yEnd - yStart) / (n - 1) in\n  let draw_i i =\n    let xi = xStart + i * xsep in\n    let yi = yStart + i * ysep in\n    func [xi, yi] in\n  concat (map draw_i (zeroTo n)) \n\n-- To reduce size of resulting trace,\n-- could subtract up to M>1 at a time.\n--\nfloorAndLocalFreeze n =\n  if le n 1 then 0 else\n  --else\n  1    + floorAndLocalFreeze (n - 1) \n\n-- (let _ ; draw point widget to control anchor\n--   ([cx cy] : Point)\nradialArray n radius rot func [cx, cy] =\n  let center = -- draw ghost circle to control anchor\n              -- not using point widget, since it\'s not selectable\n    ghost (circle \'orange\' cx cy 20) in\n  let _ = -- draw point widget to control radius\n    let xWidget = floorAndLocalFreeze cx in\n    let yWidget = floorAndLocalFreeze cy - radius in\n      [xWidget, yWidget] : Point in\n  let endpoints = nPointsOnCircle n rot cx cy radius in\n  let bounds =\n    [ cx- radius, cy - radius, cx + radius, cy + radius] in\n  [group bounds (cons center (concat (map func endpoints)))] \n\noffsetAnchor dx dy f =\n  \\[x, y] -> f [ x+ dx, y + dy] \n\nhorizontalArrayByBounds n sep func [left_0, top, right_0, bot] =\n  let w_i = right_0     - left_0 in\n  let left_i i = left_0 + i * (w_i + sep) in\n  let right_i i = left_i i + w_i in\n  let draw_i i = func [left_i i, top, right_i i, bot] in\n  let bounds =  [left_0, top, right_i (n - 1), bot] in\n    [groupWithPad 30 bounds (concat (map draw_i (zeroTo n)))] \n\nrepeatInsideBounds n sep func[left, top, right, bot]as bounds =\n  let w_i = (right - left - sep * (n - 1)) / n in\n  let draw_i i =\n    let left_i = left + i * (w_i + sep) in\n    let right_i = left_i + w_i in\n    func [left_i, top, right_i, bot] in\n  [groupWithPad 30 bounds (concat (map draw_i (zeroTo n)))] \n\n\ndraw = svg \n\nshowOne x y val =\n   [\'text\', [[\'x\', x], [\'y\', y], [\'style\', \'fill:black\'],\n            [\'font-family\', \'monospace\'],\n            [\'font-size\', \'12pt\']],\n           [[\'TEXT\', toString val]]] \n\nshow = showOne 20 30 \n\nshowList vals =\n  [\'g\', [], mapi \\[i, val] -> showOne 20 ((i + 1) * 30) val vals] \n\nrectWithBorder stroke strokeWidth fill x y w h =\n  addAttr (addAttr\n    (rect fill x y w h)\n      [\"stroke\", stroke])\n      [\"stroke-width\", strokeWidth] \n\nsetStyles newStyles [kind, attrs, children] =\n  let attrs =\n    -- TODO\n    if styleAttr == null\n      then [\"style\", []] :: attrs\n      else attrs\n  in\n  let attrs =\n    map \\[key, val] ->\n      case key of\n        \"style\"->\n          let otherStyles =\n            concatMap \\[k, v] ->\n              case elem k (map fst newStyles) of\n                True  ->  []\n                False -> [[k, v]]\n              val in\n          [\"style\", append newStyles otherStyles]\n        _->\n          [key, val]\n      attrs\n  in\n  [kind, attrs, children]\n\nplaceAt [x, y] node =\n  let _ = [x, y] : Point in\n  -- TODO px suffix should be added in LangSvg/Html translation\n  setStyles\n    [ [\"position\", \"absolute\"],\n      [\"left\", toString x + \"px\"],\n      [\"top\", toString y + \"px\"]\n    ]\n    node\n\nplaceAtFixed [x, y] node =\n  let _ = [x, y] : Point in\n  setStyles\n    [[\"position\", \"fixed\"], [\"FIXED_LEFT\", x], [\"FIXED_TOP\", y]]\n    node\n\nplaceSvgAt [x, y] w h shapes =\n  placeAt [x, y]\n    [\"svg\", [[\"width\", w], [\"height\", h]], shapes]\n\nworkspace minSize children =\n  div_\n    (cons\n      (placeAt minSize (h3 \"</workspace>\"))\n      children)\n\n-- End SVG Stuff ---------------------------------------------------------------\n\n-- TODO: Refactor this in another module\n\ntutorialUtils = {\n  -- Perform basic markdown replacement (titles, newlines, italics)\n  -- Do this step BEFORE the htmlpass, so that the code is not parsed.\n  markdown =\n    Html.replace (\"(?:^|\\n)(#+)\\\\s(.+)\") (\\match ->\n      [<@(\"h\" + toString (String.length (nth match.group 1)))>@(nth match.group 2)</@>]\n    ) >>\n    Html.replace (\"_(?=\\\\S)(.*?)_\") (\\match ->\n      [<i>@(nth match.group 1)</i>]) >>\n    Html.replace \"(\\r?\\n|  )\\r?\\n\" (\\_ -> [<br>])\n\n  ------ Functions to call during the construction of the document. ------\n  ------ After the document is constructed, pass it to `htmlpass`   ------\n  ------ to compute the code snippets, the line numbers, etc.       ------\n  type alias Instruction = HtmlNode\n  type alias Options = {production: Bool}\n\n  -- Sets the current code to \'code\'. Not visible in the final document.\n  newcode: String -> Instruction\n  newcode code = <newcode code=code></newcode>\n\n  -- Replaces the \'placeHolder\' by \'code\' in the current code. In the final document,\n  -- In the final document, displays a message \"Replace [placeHolder] (line XXX) by \"\n  replace: String -> String -> Instruction\n  replace placeHolder code = <replace placeholder=placeHolder code=code class=\"snippet\"></replace>\n\n  -- Replaces the \'placeHolder\' by \'code\' in the current code. Not visible in the final document\n  -- Can be useful to replace the code if we gave instructions to replace it from the output.\n  hiddenreplace: String -> String -> Instruction\n  hiddenreplace placeHolder code = <hiddenreplace placeholder=placeHolder code=code></hiddenreplace>\n\n  -- Display the current code. You will use this perhaps only at the beginning and the end,\n  -- or for checkpoints.\n  displaycode: Instruction\n  displaycode = <displaycode class=\"snippet\"></displaycode>\n\n  -- Displays the given code snippet without touching the current code\n  displaylocalcode: String -> Instruction\n  displaylocalcode code = <displaylocalcode code=code class=\"snippet\"></displaylocalcode>\n\n  -- Evaluates the current code and display its result.\n  displayevalcode: String -> Instruction\n  displayevalcode = <displayevalcode></displayevalcode>\n\n  -- Performs a regex replacement on the current code and display its result,\n  -- but does not modify the current code.\n  displayevalcodeLocalReplace: String -> String -> Instruction\n  displayevalcodeLocalReplace regex replacement = <displayevalcode replace=regex by=replacement></displayevalcode>\n\n  -- Displays the line of the given snippet as it appears in the current code.\n  lineof: String -> Instruction\n  lineof snippet = <lineof snippet=snippet></lineof>\n\n  -- Future: Overridable items.\n  text_replace_the_code = \"Replace the code\"\n  text_with = \"with\"\n  text_line = \"line\"\n  text_position_unknown = \"position unknown\"\n\n  -- Interpret all \'newcode\', \'displaycode\', \'displaylocalcode\', \'displayevalcode\',\n  -- \'displayevalcodeLocalReplace\', \'lineof\' in the given Html node.\n  htmlpass: Options -> HtmlNode -> HtmlNode\n  htmlpass options =\n  let\n    displayintermediateresult display src =\n      if display then\n        case __evaluate__ (__CurrentEnv__) src of\n          Err msg -> <code class=\"error\">@msg</code>\n          Ok evalNode ->\n            <div class=\"outputwrapper\">@evalNode</div>\n      else\n        <div class=\"intermediateresult\">options.production is off. <button onclick=\"this.setAttribute(\'v\', \'True\')\" v=(toString options.production)>Turn it on</button> to display the intermediate result there.</div>\n\n    localReplace src attrs = case attrs of\n      [\"replace\", regex]::[\"by\", replacement]::attrs ->\n        localReplace (Regex.replace (escape regex) (\\_ -> replacement) src) attrs\n      attrs -> (src, attrs)\n  in \\htmlnode ->\n  let aux src htmlnode = case htmlnode of\n    [\"newcode\", [\"code\", code]::attrs, []] ->\n      (code, htmlnode)\n    [\"hiddenreplace\", [\"placeholder\", placeHolder]::[\"code\", code]::attrs, []] ->\n      let newSrc = Regex.replace (escape placeHolder) (\\_ -> code) src in\n      (newSrc, htmlnode)\n    [\"replace\", [\"placeholder\", placeHolder]::[\"code\", code]::attrs, []] ->\n      let newSrc = Regex.replace (escape placeHolder) (\\_ -> code) src in\n      (newSrc, <span>@text_replace_the_code <code>@placeHolder</code> (@(positionOf placeHolder src)) @text_with<code @attrs>@code</code></span>)\n    [\"lineof\", [\"snippet\", snippet]::attrs, []] ->\n      (src, <span>@(positionOf snippet src)</span>)\n    [\"displaylocalcode\", [\"code\", code]::attrs, []] ->\n      (src, [\"code\", attrs, [[\"TEXT\", code]]])\n    [\"displaycode\", attrs, []] ->\n      (src, [\"code\", attrs, [[\"TEXT\", src]]])\n    [\"displayevalcode\", attrs, []] ->\n      let (localSrc, localAttrs) = localReplace src attrs in\n      (src, displayintermediateresult options.production <| localSrc + \"\\n\\nmain\")\n    [tag, attrs, children] ->\n      let (newSrc, newRevChildren) =\n        List.foldl (\\child (tmpSrc, revChildren) ->\n          let (newTmpSrc, newChild) = aux tmpSrc child in\n          (newTmpSrc, newChild::revChildren)\n        ) (src, []) children\n      in\n      (newSrc, [tag, attrs, List.reverse newRevChildren])\n    _ -> (src, htmlnode)\n  in Tuple.second <| aux \"\" htmlnode\n\n  -- Escapes a string so that we can search it using regexes.\n  -- Replaces ... by a regexp that parses any sequence of chars, minimally.\n  escape = Regex.escape >> Regex.replace \"\"\"\\\\\\.\\\\\\.\\\\\\.\"\"\" (\\m -> \"\"\"[\\s\\S]+?\"\"\")\n\n  -- Computes the line position of a placeholder inside a string.\n  positionOf: String -> String -> String\n  positionOf placeHolder code =\n    case Regex.extract \"\"\"^([\\s\\S]*?)@(escape placeHolder)([\\s\\S]*)$\"\"\" code of\n      Just [before, after] ->\n        let line = Regex.split \"\\r?\\n\" before |> List.length |> toString in\n        \"\"\"@text_line @line\"\"\"\n      _ -> text_position_unknown\n}\n\n-- Utilities to invoke some of the usual browser commands\nbrowser = {\n  -- Refresh the output\n  refresh: String\n  refresh = \"\"\"document.querySelector(\".run\") ? document.querySelector(\".run\").click()\"\"\"\n\n  -- Returns the value of the global javascript variable or a placeholder else\n  localvar: String -> String -> String\n  localvar name initContent = \n    __jsEval__ \"\"\"typeof @name == \'undefined\' ? @initContent : @name\"\"\"\n    \n    \n}\n\nmedia = \"@media\" -- For compatibility with <style>\nkeyframes = \"@keyframes\"\nfont = \"@font\"\nimport = \"@import\"\ncharSet = \"@charSet\"\n\n-- The type checker relies on the name of this definition.\nlet dummyPreludeMain = [\"svg\", [], []] in dummyPreludeMain\n\n';
var _user$project$PreludeGenerated$prelude = '\n; prelude.little\n;\n; This little library is accessible by every program.\n; This is not an example that generates an SVG canvas,\n; but we include it here for reference.\n\n;; The identity function - given a value, returns exactly that value\n(typ id (forall a (-> a a)))\n(def id (\\x x))\n\n;; A function that always returns the same value a, regardless of b\n(typ always (forall (a b) (-> a b a)))\n(def always (\\(x _) x))\n\n;; Composes two functions together\n(typ compose (forall (a b c) (-> (-> b c) (-> a b) (-> a c))))\n(def compose (\\(f g) (\\x (f (g x)))))\n\n(typ flip (forall (a b c) (-> (-> a b c) (-> b a c))))\n(def flip (\\f (\\(x y) (f y x))))\n  ; TODO other version:\n  ; (def flip (\\(f x y) (f y x)))\n\n(typ fst (forall (a b) (-> [a b] a)))\n(typ snd (forall (a b) (-> [a b] b)))\n\n(def fst (\\[a _] a))\n(def snd (\\[_ b] b))\n\n;; Given a bool, returns the opposite boolean value\n(typ not (-> Bool Bool))\n(def not (\\b (if b false true)))\n\n;; Given two bools, returns a bool regarding if the first argument is true, then the second argument is as well\n(typ implies (-> Bool Bool Bool))\n(def implies (\\(p q) (if p q true)))\n\n(typ or  (-> Bool Bool Bool))\n(typ and (-> Bool Bool Bool))\n\n(def or  (\\(p q) (if p true q)))\n(def and (\\(p q) (if p q false)))\n\n(typ lt (-> Num Num Bool))\n(typ eq (-> Num Num Bool))\n(typ le (-> Num Num Bool))\n(typ gt (-> Num Num Bool))\n(typ ge (-> Num Num Bool))\n\n(def lt (\\(x y) (< x y)))\n(def eq (\\(x y) (= x y)))\n(def le (\\(x y) (or (lt x y) (eq x y))))\n(def gt (flip lt))\n(def ge (\\(x y) (or (gt x y) (eq x y))))\n\n;; Returns the length of a given list\n(typ len (forall a (-> (List a) Num)))\n(defrec len (\\xs (case xs ([] 0) ([_ | xs1] (+ 1 (len xs1))))))\n\n;; Maps a function, f, over a list of values and returns the resulting list\n(typ map (forall (a b) (-> (-> a b) (List a) (List b))))\n(defrec map (\\(f xs)\n  (case xs ([] []) ([hd|tl] [(f hd)|(map f tl)]))))\n\n;; Combines two lists with a given function, extra elements are dropped\n(typ map2 (forall (a b c) (-> (-> a b c) (List a) (List b) (List c))))\n(defrec map2 (\\(f xs ys)\n  (case [xs ys]\n    ([[x|xs1] [y|ys1]] [ (f x y) | (map2 f xs1 ys1) ])\n    (_                 []))))\n\n;; Combines three lists with a given function, extra elements are dropped\n(typ map3 (forall (a b c d) (-> (-> a b c d) (List a) (List b) (List c) (List d))))\n(defrec map3 (\\(f xs ys zs)\n  (case [xs ys zs]\n    ([[x|xs1] [y|ys1] [z|zs1]] [ (f x y z) | (map3 f xs1 ys1 zs1) ])\n    (_                         []))))\n\n;; Combines four lists with a given function, extra elements are dropped\n(typ map4 (forall (a b c d e) (-> (-> a b c d e) (List a) (List b) (List c) (List d) (List e))))\n(defrec map4 (\\(f ws xs ys zs)\n  (case [ws xs ys zs]\n    ([[w|ws1] [x|xs1] [y|ys1] [z|zs1]] [ (f w x y z) | (map4 f ws1 xs1 ys1 zs1) ])\n    (_                                 []))))\n\n;; Takes a function, an accumulator, and a list as input and reduces using the function from the left\n(typ foldl (forall (a b) (-> (-> a b b) b (List a) b)))\n(defrec foldl (\\(f acc xs)\n  (case xs ([] acc) ([x|xs1] (foldl f (f x acc) xs1)))))\n\n;; Takes a function, an accumulator, and a list as input and reduces using the function from the right\n(typ foldr (forall (a b) (-> (-> a b b) b (List a) b)))\n(defrec foldr (\\(f acc xs)\n  (case xs ([] acc) ([x|xs1] (f x (foldr f acc xs1))))))\n\n;; Given two lists, append the second list to the end of the first\n(typ append (forall a (-> (List a) (List a) (List a))))\n(defrec append (\\(xs ys)\n  (case xs ([] ys) ([x|xs1] [ x | (append xs1 ys)]))))\n\n;; concatenate a list of lists into a single list\n(typ concat (forall a (-> (List (List a)) (List a))))\n(def concat (\\xss (foldr append [] xss)))\n  ; TODO eta-reduced version:\n  ; (def concat (foldr append []))\n\n;; Map a given function over a list and concatenate the resulting list of lists\n(typ concatMap (forall (a b) (-> (-> a (List b)) (List a) (List b))))\n(def concatMap (\\(f xs) (concat (map f xs))))\n\n;; Takes two lists and returns a list that is their cartesian product\n(typ cartProd (forall (a b) (-> (List a) (List b) (List [a b]))))\n(def cartProd (\\(xs ys)\n  (concatMap (\\x (map (\\y [x y]) ys)) xs)))\n\n;; Takes elements at the same position from two input lists and returns a list of pairs of these elements\n(typ zip (forall (a b) (-> (List a) (List b) (List [a b]))))\n(def zip (\\(xs ys) (map2 (\\(x y) [x y]) xs ys)))\n  ; TODO eta-reduced version:\n  ; (def zip (map2 (\\(x y) [x y])))\n\n;; The empty list\n;; (typ nil (forall a (List a)))\n(typ nil [])\n(def nil [])\n\n;; attaches an element to the front of a list\n(typ cons (forall a (-> a (List a) (List a))))\n(def cons (\\(x xs) [x | xs]))\n\n;; attaches an element to the end of a list\n(typ snoc (forall a (-> a (List a) (List a))))\n(def snoc (\\(x ys) (append ys [x])))\n\n;; Returns the first element of a given list\n(typ hd (forall a (-> (List a) a)))\n(def hd (\\[x|xs] x))\n\n(typ tl (forall a (-> (List a) (List a))))\n(def tl (\\[x|xs] xs))\n\n;; Returns the last element of a given list\n(typ last (forall a (-> (List a) a)))\n(defrec last (\\xs\n  (case xs\n    ([x]    x)\n    ([_|xs] (last xs)))))\n\n;; Given a list, reverse its order\n(typ reverse (forall a (-> (List a) (List a))))\n(def reverse (\\xs (foldl cons nil xs)))\n  ; TODO eta-reduced version:\n  ; (def reverse (foldl cons nil))\n\n(def adjacentPairs (\\xs (zip xs (tl xs))))\n\n;; Given two numbers, creates the list between them (inclusive)\n(typ range (-> Num Num (List Num)))\n(defrec range (\\(i j)\n  (if (< i (+ j 1))\n      (cons i (range (+ i 1) j))\n      nil)))\n\n;; Given a number, create the list of 0 to that number inclusive (number must be > 0)\n(typ list0N (-> Num (List Num)))\n(def list0N (\\n (range 0 n)))\n\n;; Given a number, create the list of 1 to that number inclusive\n(typ list1N (-> Num (List Num)))\n(def list1N (\\n (range 1 n)))\n\n(typ zeroTo (-> Num (List Num)))\n(def zeroTo (\\n (range 0 (- n 1))))\n\n;; Given a number n and some value x, return a list with x repeated n times\n(typ repeat (forall a (-> Num a (List a))))\n(def repeat (\\(n x) (map (always x) (range 1 n))))\n\n;; Given two lists, return a single list that alternates between their values (first element is from first list)\n(typ intermingle (forall a (-> (List a) (List a) (List a))))\n(defrec intermingle (\\(xs ys)\n  (case [xs ys]\n    ([[x|xs1] [y|ys1]] (cons x (cons y (intermingle xs1 ys1))))\n    ([[]      []]      nil)\n    (_                 (append xs ys)))))\n\n(def intersperse (\\(sep xs)\n  (case xs\n    ([]     xs)\n    ([x|xs] (reverse (foldl (\\(y acc) [ y sep | acc ]) [x] xs))))))\n\n(typ mapi (forall (a b) (-> (-> [Num a] b) (List a) (List b))))\n(def mapi (\\(f xs) (map f (zip (range 0 (- (len xs) 1)) xs))))\n\n(def indexedMap (\\(f xs) (mapi (\\[i x] (f i x)) xs)))\n\n\n(typ nth (forall a (-> (List a) Num (union Null a))))\n(defrec nth (\\(xs n)\n  (if (< n 0)       null\n    (case [n xs]\n      ([_ []]       null)\n      ([0 [x|xs1]]  x)\n      ([_ [x|xs1]]  (nth xs1 (- n 1)))))))\n\n; (defrec nth (\\(xs n)\n;   (if (< n 0)   \'ERROR: nth\'\n;     (case xs\n;       ([]       \'ERROR: nth\')\n;       ([x|xs1]  (if (= n 0) x (nth xs1 (- n 1))))))))\n\n; TODO change typ/def\n; (typ take (forall a (-> (List a) Num (union Null (List a)))))\n\n(typ take (forall a (-> (List a) Num (List (union Null a)))))\n(defrec take (\\(xs n)\n  (if (= n 0) []\n    (case xs\n      ([]      [null])\n      ([x|xs1] [x | (take xs1 (- n 1))])))))\n\n; (def take\n;   (letrec take_ (\\(n xs)\n;     (case [n xs]\n;       ([0 _]       [])\n;       ([_ []]      [])\n;       ([_ [x|xs1]] [x | (take_ (- n 1) xs1)])))\n;   (compose take_ (max 0))))\n\n(typ drop (forall a (-> (List a) Num (union Null (List a)))))\n(defrec drop (\\(xs n)\n  (if (le n 0)\n    xs\n    (case xs\n      ([]      null)\n      ([x|xs1] (drop xs1 (- n 1)))))))\n\n;; Drop n elements from the end of a list\n(typ dropEnd (forall a (-> (List a) Num (union Null (List a)))))\n(def dropEnd (\\(xs n)\n  (let tryDrop (drop (reverse xs) n)\n  (typecase tryDrop\n    (Null null)\n    (_    (reverse tryDrop))))))\n\n(typ elem (forall a (-> a (List a) Bool)))\n(defrec elem (\\(x ys)\n  (case ys\n    ([]      false)\n    ([y|ys1] (or (= x y) (elem x ys1))))))\n\n(def sortBy (\\(f xs)\n  (letrec ins (\\(x ys)   ; insert is a keyword...\n    (case ys\n      ([]     [x])\n      ([y|ys] (if (f x y) [x y | ys] [y | (ins x ys)]))))\n  (foldl ins [] xs))))\n\n(def sortAscending (sortBy lt))\n(def sortDescending (sortBy gt))\n\n\n;; multiply two numbers and return the result\n(typ mult (-> Num Num Num))\n(defrec mult (\\(m n)\n  (if (< m 1) 0 (+ n (mult (+ m -1) n)))))\n\n;; Given two numbers, subtract the second from the first\n(typ minus (-> Num Num Num))\n(def minus (\\(x y) (+ x (mult y -1))))\n\n;; Given two numbers, divide the first by the second\n(typ div (-> Num Num Num))\n(defrec div (\\(m n)\n  (if (< m n) 0\n  (if (< n 2) m\n    (+ 1 (div (minus m n) n))))))\n\n;; Given a number, returns the negative of that number\n(typ neg (-> Num Num))\n(def neg (\\x (- 0 x)))\n\n;; Absolute value\n(typ abs (-> Num Num))\n(def abs (\\x (if (< x 0) (neg x) x)))\n\n;; Sign function; -1, 0, or 1 based on sign of given number\n(typ sgn (-> Num Num))\n(def sgn (\\x (if (= 0 x) 0 (/ x (abs x)))))\n\n(typ some (forall a (-> (-> a Bool) (List a) Bool)))\n(defrec some (\\(p xs)\n  (case xs\n    ([]      false)\n    ([x|xs1] (or (p x) (some p xs1))))))\n\n(typ all (forall a (-> (-> a Bool) (List a) Bool)))\n(defrec all (\\(p xs)\n  (case xs\n    ([]      true)\n    ([x|xs1] (and (p x) (all p xs1))))))\n\n;; Given an upper bound, lower bound, and a number, restricts that number between those bounds (inclusive)\n;; Ex. clamp 1 5 4 = 4\n;; Ex. clamp 1 5 6 = 5\n(typ clamp (-> Num Num Num Num))\n(def clamp (\\(i j n) (if (< n i) i (if (< j n) j n))))\n\n(typ between (-> Num Num Num Bool))\n(def between (\\(i j n) (= n (clamp i j n))))\n\n(typ plus (-> Num Num Num))\n(def plus (\\(x y) (+ x y)))\n\n(typ min (-> Num Num Num))\n(def min (\\(i j) (if (lt i j) i j)))\n\n(typ max (-> Num Num Num))\n(def max (\\(i j) (if (gt i j) i j)))\n\n(typ minimum (-> (List Num) Num))\n(def minimum (\\[hd|tl] (foldl min hd tl)))\n\n(typ maximum (-> (List Num) Num))\n(def maximum (\\[hd|tl] (foldl max hd tl)))\n\n(typ average (-> (List Num) Num))\n(def average (\\nums\n  (let sum (foldl plus 0 nums)\n  (let n   (len nums)\n    (/ sum n)))))\n\n;; Combine a list of strings with a given separator\n;; Ex. joinStrings \', \' [\'hello\' \'world\'] = \'hello, world\'\n(typ joinStrings (-> String (List String) String))\n(def joinStrings (\\(sep ss)\n  (foldr (\\(str acc) (if (= acc \'\') str (+ str (+ sep acc)))) \'\' ss)))\n\n;; Concatenate a list of strings and return the resulting string\n(typ concatStrings (-> (List String) String))\n(def concatStrings (joinStrings \'\'))\n\n;; Concatenates a list of strings, interspersing a single space in between each string\n(typ spaces (-> (List String) String))\n(def spaces (joinStrings \' \'))\n\n;; First two arguments are appended at the front and then end of the third argument correspondingly\n;; Ex. delimit \'+\' \'+\' \'plus\' = \'+plus+\'\n(typ delimit (-> String String String String))\n(def delimit (\\(a b s) (concatStrings [a s b])))\n\n;; delimit a string with parentheses\n(typ parens (-> String String))\n(def parens (delimit \'(\' \')\'))\n\n;\n; SVG Manipulating Functions\n;\n\n; === SVG Types ===\n\n(def Point [Num Num])\n(def RGBA [Num Num Num Num])\n(def Color (union String Num RGBA))\n(def PathCmds (List (union String Num)))\n(def Points (List Point))\n(def RotationCmd [[String Num Num Num]])\n(def AttrVal (union String Num Bool Color PathCmds Points RotationCmd))\n(def AttrName String)\n(def AttrPair [AttrName AttrVal])\n(def Attrs (List AttrPair))\n(def NodeKind String)\n; TODO add recursive types properly\n(def SVG [NodeKind Attrs (List SVG_or_Text)])\n(def SVG_or_Text (union SVG [String String]))\n(def Blob (List SVG))\n\n; === Attribute Lookup ===\n\n(typ lookupWithDefault (forall (k v) (-> v k (List [k v]) v)))\n(defrec lookupWithDefault (\\(default k dict)\n  (let foo (lookupWithDefault default k)\n  (case dict\n    ([]            default)\n    ([[k1 v]|rest] (if (= k k1) v (foo rest)))))))\n\n(typ lookup (forall (k v) (-> k (List [k v]) (union v Null))))\n(defrec lookup (\\(k dict)\n  (let foo (lookup k)\n  (case dict\n    ([]            null)\n    ([[k1 v]|rest] (if (= k k1) v (foo rest)))))))\n\n(typ addExtras (-> Num (List [String (List [Num AttrVal])]) SVG SVG))\n(defrec addExtras (\\(i extras shape)\n  (case extras\n    ([] shape)\n    ([[k table] | rest]\n      (let v (lookup i table)\n      (typecase v\n        (Null    (addExtras i rest shape))\n        (AttrVal (addExtras i rest (addAttr shape [k v])))))))))\n\n(typ lookupAttr (-> SVG AttrName (union AttrVal Null)))\n(def lookupAttr (\\([_ attrs _] k) (lookup k attrs)))\n\n(typ lookupAttrWithDefault (-> AttrVal SVG AttrName AttrVal))\n(def lookupAttrWithDefault (\\(default [_ attrs _] k) (lookupWithDefault default k attrs)))\n\n; Pairs of Type-Specific Lookup Functions\n\n(typ lookupNumAttr (-> SVG AttrName (union Num Null)))\n(def lookupNumAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val (Num val) (_ null)))))\n\n(typ lookupNumAttrWithDefault (-> Num SVG AttrName Num))\n(def lookupNumAttrWithDefault (\\(default shape k)\n  (let val (lookupNumAttr shape k)\n  (typecase val (Num val) (Null default)))))\n\n(typ lookupPointsAttr (-> SVG AttrName (union Points Null)))\n(def lookupPointsAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val ((List [Num Num]) val) (_ null)))))\n\n(typ lookupPointsAttrWithDefault (-> Points SVG AttrName Points))\n(def lookupPointsAttrWithDefault (\\(default shape k)\n  (let val (lookupPointsAttr shape k)\n  (typecase val ((List [Num Num]) val) (Null default)))))\n\n(typ lookupStringAttr (-> SVG AttrName (union String Null)))\n(def lookupStringAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val (String val) (_ null)))))\n\n(typ lookupStringAttrWithDefault (-> String SVG AttrName String))\n(def lookupStringAttrWithDefault (\\(default shape k)\n  (let val (lookupStringAttr shape k)\n  (typecase val (String val) (Null default)))))\n\n; === Points ===\n\n(def Vec2D [Num Num])\n\n(typ vec2DPlus (-> Point Vec2D Point))\n(def vec2DPlus (\\(pt vec)\n  [\n    (+ (fst pt) (fst vec))\n    (+ (snd pt) (snd vec))\n  ]\n))\n\n(typ vec2DMinus (-> Point Point Vec2D))\n(def vec2DMinus (\\(pt vec)\n  [\n    (- (fst pt) (fst vec))\n    (- (snd pt) (snd vec))\n  ]\n))\n\n(typ vec2DScalarMult (-> Num Vec2D Point))\n(def vec2DScalarMult (\\(num vec)\n  [\n    (* (fst vec) num)\n    (* (snd vec) num)\n  ]\n))\n\n(typ vec2DScalarDiv (-> Num Vec2D Point))\n(def vec2DScalarDiv (\\(num vec)\n  [\n    (/ (fst vec) num)\n    (/ (snd vec) num)\n  ]\n))\n\n(typ vec2DLength (-> Point Point Num))\n(def vec2DLength (\\([x1 y1] [x2 y2])\n  (let [dx dy] [(- x2 x1) (- y2 y1)]\n  (sqrt (+ (* dx dx) (* dy dy))))))\n\n\n; === Circles ===\n\n(def Circle SVG)\n\n;; argument order - color, x, y, radius\n;; creates a circle, center at (x,y) with given radius and color\n(typ circle (-> Color Num Num Num Circle))\n(def circle (\\(fill cx cy r)\n  [\'circle\'\n     [[\'cx\' cx] [\'cy\' cy] [\'r\' r] [\'fill\' fill]]\n     []]))\n\n(typ circleCenter (-> Ellipse Point))\n(def circleCenter (\\circle\n  [\n    (lookupNumAttrWithDefault 0 circle \'cx\')\n    (lookupNumAttrWithDefault 0 circle \'cy\')\n  ]\n))\n\n(typ circleRadius (-> Circle Num))\n(def circleRadius (\\circle\n  (lookupNumAttrWithDefault 0 circle \'r\')\n))\n\n(typ circleDiameter (-> Circle Num))\n(def circleDiameter (\\circle\n  (* 2 (circleRadius circle))\n))\n\n(typ circleNorth (-> Circle Point))\n(def circleNorth (\\circle\n  (let [cx cy] (circleCenter circle)\n    [cx (- cy (circleRadius circle))]\n  )\n))\n\n(typ circleEast (-> Circle Point))\n(def circleEast (\\circle\n  (let [cx cy] (circleCenter circle)\n    [(+ cx (circleRadius circle)) cy]\n  )\n))\n\n(typ circleSouth (-> Circle Point))\n(def circleSouth (\\circle\n  (let [cx cy] (circleCenter circle)\n    [cx (+ cy (circleRadius circle))]\n  )\n))\n\n(typ circleWest (-> Circle Point))\n(def circleWest (\\circle\n  (let [cx cy] (circleCenter circle)\n    [(- cx (circleRadius circle)) cy]\n  )\n))\n\n\n;; argument order - color, width, x, y, radius\n;; Just as circle, except new width parameter determines thickness of ring\n(typ ring (-> Color Num Num Num Num SVG))\n(def ring (\\(c w x y r)\n  [\'circle\'\n     [ [\'cx\' x] [\'cy\' y] [\'r\' r] [\'fill\' \'none\'] [\'stroke\' c] [\'stroke-width\' w] ]\n     []]))\n\n\n; === Ellipses ===\n\n(def Ellipse SVG)\n\n;; argument order - color, x, y, x-radius, y-radius\n;; Just as circle, except radius is separated into x and y parameters\n(typ ellipse (-> Color Num Num Num Num Ellipse))\n(def ellipse (\\(fill x y rx ry)\n  [\'ellipse\'\n     [ [\'cx\' x] [\'cy\' y] [\'rx\' rx] [\'ry\' ry] [\'fill\' fill] ]\n     []]))\n\n(typ ellipseCenter (-> Ellipse Point))\n(def ellipseCenter (\\ellipse\n  [\n    (lookupNumAttrWithDefault 0 ellipse \'cx\')\n    (lookupNumAttrWithDefault 0 ellipse \'cy\')\n  ]\n))\n\n(typ ellipseRadiusX (-> Ellipse Num))\n(def ellipseRadiusX (\\ellipse\n  (lookupNumAttrWithDefault 0 ellipse \'rx\')\n))\n\n(typ ellipseRadiusY (-> Ellipse Num))\n(def ellipseRadiusY (\\ellipse\n  (lookupNumAttrWithDefault 0 ellipse \'ry\')\n))\n\n(typ ellipseDiameterX (-> Ellipse Num))\n(def ellipseDiameterX (\\ellipse\n  (* 2 (ellipseRadiusX ellipse))\n))\n\n(typ ellipseDiameterY (-> Ellipse Num))\n(def ellipseDiameterY (\\ellipse\n  (* 2 (ellipseRadiusY ellipse))\n))\n\n(typ ellipseNorth (-> Ellipse Point))\n(def ellipseNorth (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [cx (- cy (ellipseRadiusY ellipse))]\n  )\n))\n\n(typ ellipseEast (-> Ellipse Point))\n(def ellipseEast (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [(+ cx (ellipseRadiusX ellipse)) cy]\n  )\n))\n\n(typ ellipseSouth (-> Ellipse Point))\n(def ellipseSouth (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [cx (+ cy (ellipseRadiusY ellipse))]\n  )\n))\n\n(typ ellipseWest (-> Ellipse Point))\n(def ellipseWest (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [(- cx (ellipseRadiusX ellipse)) cy]\n  )\n))\n\n\n; === Bounds-based shapes (Oval and Box) ===\n\n(def BoundedShape SVG)\n(def Bounds [Num Num Num Num])\n\n(typ boundedShapeLeft (-> BoundedShape Num))\n(def boundedShapeLeft (\\shape\n  (lookupNumAttrWithDefault 0 shape \'LEFT\')\n))\n\n(typ boundedShapeTop (-> BoundedShape Num))\n(def boundedShapeTop (\\shape\n  (lookupNumAttrWithDefault 0 shape \'TOP\')\n))\n\n(typ boundedShapeRight (-> BoundedShape Num))\n(def boundedShapeRight (\\shape\n  (lookupNumAttrWithDefault 0 shape \'RIGHT\')\n))\n\n(typ boundedShapeBot (-> BoundedShape Num))\n(def boundedShapeBot (\\shape\n  (lookupNumAttrWithDefault 0 shape \'BOT\')\n))\n\n(typ boundedShapeWidth (-> BoundedShape Num))\n(def boundedShapeWidth (\\shape\n  (- (boundedShapeRight shape) (boundedShapeLeft shape))\n))\n\n(typ boundedShapeHeight (-> BoundedShape Num))\n(def boundedShapeHeight (\\shape\n  (- (boundedShapeBot shape) (boundedShapeTop shape))\n))\n\n(typ boundedShapeLeftTop (-> BoundedShape Point))\n(def boundedShapeLeftTop (\\shape\n  [\n    (boundedShapeLeft shape)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeCenterTop (-> BoundedShape Point))\n(def boundedShapeCenterTop (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeRightTop (-> BoundedShape Point))\n(def boundedShapeRightTop (\\shape\n  [\n    (boundedShapeRight shape)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeRightCenter (-> BoundedShape Point))\n(def boundedShapeRightCenter (\\shape\n  [\n    (boundedShapeRight shape)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n(typ boundedShapeRightBot (-> BoundedShape Point))\n(def boundedShapeRightBot (\\shape\n  [\n    (boundedShapeRight shape)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeCenterBot (-> BoundedShape Point))\n(def boundedShapeCenterBot (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeLeftBot (-> BoundedShape Point))\n(def boundedShapeLeftBot (\\shape\n  [\n    (boundedShapeLeft shape)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeLeftCenter (-> BoundedShape Point))\n(def boundedShapeLeftCenter (\\shape\n  [\n    (boundedShapeLeft shape)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n(typ boundedShapeCenter (-> BoundedShape Point))\n(def boundedShapeCenter (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n\n; === Rectangles ===\n\n(def Rect SVG)\n\n;; argument order - color, x, y, width, height\n;; creates a rectangle of given width and height with (x,y) as the top left corner coordinate\n(typ rect (-> Color Num Num Num Num Rect))\n(def rect (\\(fill x y w h)\n  [\'rect\'\n     [ [\'x\' x] [\'y\' y] [\'width\' w] [\'height\' h] [\'fill\' fill] ]\n     []]))\n\n(typ square (-> Color Num Num Num Rect))\n(def square (\\(fill x y side) (rect fill x y side side)))\n\n(typ rectWidth (-> Rect Num))\n(def rectWidth (\\rect\n  (lookupNumAttrWithDefault 0 rect \'width\')\n))\n\n(typ rectHeight (-> Rect Num))\n(def rectHeight (\\rect\n  (lookupNumAttrWithDefault 0 rect \'height\')\n))\n\n(typ rectLeftTop (-> Rect Point))\n(def rectLeftTop (\\rect\n  [\n    (lookupNumAttrWithDefault 0 rect \'x\')\n    (lookupNumAttrWithDefault 0 rect \'y\')\n  ]\n))\n\n(typ rectCenterTop (-> Rect Point))\n(def rectCenterTop (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) 0 ]\n  )\n))\n\n(typ rectRightTop (-> Rect Point))\n(def rectRightTop (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) 0 ]\n  )\n))\n\n(typ rectRightCenter (-> Rect Point))\n(def rectRightCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) (/ (rectHeight rect) 2) ]\n  )\n))\n\n(typ rectRightBot (-> Rect Point))\n(def rectRightBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) (rectHeight rect) ]\n  )\n))\n\n(typ rectCenterBot (-> Rect Point))\n(def rectCenterBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) (rectHeight rect) ]\n  )\n))\n\n(typ rectLeftBot (-> Rect Point))\n(def rectLeftBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [0 (rectHeight rect) ]\n  )\n))\n\n(typ rectLeftCenter (-> Rect Point))\n(def rectLeftCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [0 (/ (rectHeight rect) 2) ]\n  )\n))\n\n(typ rectCenter (-> Rect Point))\n(def rectCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) (/ (rectHeight rect) 2) ]\n  )\n))\n\n\n; === Lines ===\n\n(def Line SVG)\n\n;; argument order - color, width, x1, y1, x1, y2\n;; creates a line from (x1, y1) to (x2,y2) with given color and width\n(typ line (-> Color Num Num Num Num Num Line))\n(def line (\\(stroke w x1 y1 x2 y2)\n  [\'line\'\n     [ [\'x1\' x1] [\'y1\' y1] [\'x2\' x2] [\'y2\' y2] [\'stroke\' stroke] [\'stroke-width\' w] ]\n     []]))\n\n(typ lineBetween (-> Color Num Point Point Line))\n(def lineBetween (\\(stroke w [x1 y1] [x2 y2])\n  (line stroke w x1 y1 x2 y2)))\n\n(typ lineStart (-> Line Point))\n(def lineStart (\\line\n  [\n    (lookupNumAttrWithDefault 0 line \'x1\')\n    (lookupNumAttrWithDefault 0 line \'y1\')\n  ]\n))\n\n(typ lineEnd (-> Line Point))\n(def lineEnd (\\line\n  [\n    (lookupNumAttrWithDefault 0 line \'x2\')\n    (lookupNumAttrWithDefault 0 line \'y2\')\n  ]\n))\n\n(typ lineMidPoint (-> Line Point))\n(def lineMidPoint (\\line\n  (halfwayBetween (lineStart line) (lineEnd line))\n))\n\n\n;; argument order - fill, stroke, width, points\n;; creates a polygon following the list of points, with given fill color and a border with given width and stroke\n(typ polygon (-> Color Color Num Points SVG))\n(def polygon (\\(fill stroke w pts)\n  [\'polygon\'\n     [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ]\n     []]))\n\n;; argument order - fill, stroke, width, points\n;; See polygon\n(typ polyline (-> Color Color Num Points SVG))\n(def polyline (\\(fill stroke w pts)\n  [\'polyline\'\n     [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ]\n     []]))\n\n;; argument order - fill, stroke, width, d\n;; Given SVG path command d, create path with given fill color, stroke and width\n;; See https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths for path command info\n(typ path (-> Color Color Num PathCmds SVG))\n(def path (\\(fill stroke w d)\n  [\'path\'\n     [ [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' w] [\'d\' d] ]\n     []]))\n\n;; argument order - x, y, string\n;; place a text string with top left corner at (x,y) - with default color & font\n(typ text (-> Num Num String SVG))\n(def text (\\(x y s)\n   [\'text\' [[\'x\' x] [\'y\' y] [\'style\' \'fill:black\']\n            [\'font-family\' \'Tahoma, sans-serif\']]\n           [[\'TEXT\' s]]]))\n\n;; argument order - shape, new attribute\n;; Add a new attribute to a given Shape\n(typ addAttr (-> SVG AttrPair SVG))\n(def addAttr (\\([shapeKind oldAttrs children] newAttr)\n  [shapeKind (snoc newAttr oldAttrs) children]))\n\n(typ consAttr (-> SVG AttrPair SVG))\n(def consAttr (\\([shapeKind oldAttrs children] newAttr)\n  [shapeKind (cons newAttr oldAttrs) children]))\n\n;; Given a list of shapes, compose into a single SVG\n(def svg (\\shapes [\'svg\' [] shapes]))\n\n;; argument order - x-maximum, y-maximum, shapes\n;; Given a list of shapes, compose into a single SVG within the x & y maxima\n(typ svgViewBox (-> Num Num (List SVG) SVG))\n(def svgViewBox (\\(xMax yMax shapes)\n  (let [sx sy] [(toString xMax) (toString yMax)]\n  [\'svg\'\n    [[\'x\' \'0\'] [\'y\' \'0\'] [\'viewBox\' (joinStrings \' \' [\'0\' \'0\' sx sy])]]\n    shapes])))\n\n;; As rect, except x & y represent the center of the defined rectangle\n(typ rectByCenter (-> Color Num Num Num Num Rect))\n(def rectByCenter (\\(fill cx cy w h)\n  (rect fill (- cx (/ w 2)) (- cy (/ h 2)) w h)))\n\n;; As square, except x & y represent the center of the defined rectangle\n(typ squareByCenter (-> Color Num Num Num Rect))\n(def squareByCenter (\\(fill cx cy w) (rectByCenter fill cx cy w w)))\n\n;; Some shapes with given default values for fill, stroke, and stroke width\n; TODO remove these\n(def circle_    (circle \'red\'))\n(def ellipse_   (ellipse \'orange\'))\n(def rect_      (rect \'#999999\'))\n(def square_    (square \'#999999\'))\n(def line_      (line \'blue\' 2))\n(def polygon_   (polygon \'green\' \'purple\' 3))\n(def path_      (path \'transparent\' \'goldenrod\' 5))\n\n;; updates an SVG by comparing differences with another SVG\n;; Note: accDiff pre-condition: indices in increasing order\n;; (so can\'t just use foldr instead of reverse . foldl)\n(typ updateCanvas (-> SVG SVG SVG))\n(def updateCanvas (\\([_ svgAttrs oldShapes] diff)\n  (let oldShapesI (zip (list1N (len oldShapes)) oldShapes)\n  (let initAcc [[] diff]\n  (let f (\\([i oldShape] [accShapes accDiff])\n    (case accDiff\n      ([]\n        [(cons oldShape accShapes) accDiff])\n      ([[j newShape] | accDiffRest]\n        (if (= i j)\n          [(cons newShape accShapes) accDiffRest]\n          [(cons oldShape accShapes) accDiff]))))\n  (let newShapes (reverse (fst (foldl f initAcc oldShapesI)))\n    [\'svg\' svgAttrs newShapes]))))))\n\n(def addBlob (\\(newShapes [\'svg\' svgAttrs oldShapes])\n  [\'svg\' svgAttrs (append oldShapes newShapes)]))\n\n(typ groupMap (forall (a b) (-> (List a) (-> a b) (List b))))\n(def groupMap (\\(xs f) (map f xs)))\n\n(def autoChose (\\(_ x _) x))\n(def inferred  (\\(x _ _) x))\n(def flow (\\(_ x) x))\n\n; \'constant folding\'\n(def twoPi (* 2 (pi)))\n(def halfPi (/ (pi) 2))\n\n;; Helper function for nPointsOnCircle, calculates angle of points\n;; Note: angles are calculated clockwise from the traditional pi/2 mark\n(typ nPointsOnUnitCircle (-> Num Num (List Point)))\n(def nPointsOnUnitCircle (\\(n rot)\n  (let off (- halfPi rot)\n  (let foo (\\i\n    (let ang (+ off (* (/ i n) twoPi))\n    [(cos ang) (neg (sin ang))]))\n  (map foo (list0N (- n 1)))))))\n\n(typ nPointsOnCircle (-> Num Num Num Num Num (List Point)))\n;; argument order - Num of points, degree of rotation, x-center, y-center, radius\n;; Scales nPointsOnUnitCircle to the proper size and location with a given radius and center\n(def nPointsOnCircle (\\(n rot cx cy r)\n  (let pts (nPointsOnUnitCircle n rot)\n  (map (\\[x y] [(+ cx (* x r)) (+ cy (* y r))]) pts))))\n\n(typ nStar (-> Color Color Num Num Num Num Num Num Num SVG))\n;; argument order -\n;; fill color - interior color of star\n;; stroke color - border color of star\n;; width - thickness of stroke\n;; points - number of star points\n;; len1 - length from center to one set of star points\n;; len2 - length from center to other set of star points (either inner or outer compared to len1)\n;; rot - degree of rotation\n;; cx - x-coordinate of center position\n;; cy - y-coordinate of center position\n;; Creates stars that can be modified on a number of parameters\n(def nStar (\\(fill stroke w n len1 len2 rot cx cy)\n  (let pti (\\[i len]\n    (let anglei (+ (- (/ (* i (pi)) n) rot) halfPi)\n    (let xi (+ cx (* len (cos anglei)))\n    (let yi (+ cy (neg (* len (sin anglei))))\n      [xi yi]))))\n  (let lengths\n    (map (\\b (if b len1 len2))\n         (concat (repeat n [true false])))\n  (let indices (list0N (- (* 2! n) 1!))\n    (polygon fill stroke w (map pti (zip indices lengths))))))))\n\n(typ setZones (-> String SVG SVG))\n(def setZones (\\(s shape) (addAttr shape [\'ZONES\' s])))\n\n(typ zones (-> String (List SVG) (List SVG)))\n(def zones (\\(s shapes) (map (setZones s) shapes)))\n  ; TODO eta-reduced version:\n  ; (def zones (\\s (map (setZones s))))\n\n;; Remove all zones from shapes except for the first in the list\n(typ hideZonesTail (-> (List SVG) (List SVG)))\n(def hideZonesTail  (\\[hd | tl] [hd | (zones \'none\' tl)]))\n\n;; Turn all zones to basic for a given list of shapes except for the first shape\n(typ basicZonesTail (-> (List SVG) (List SVG)))\n(def basicZonesTail (\\[hd | tl] [hd | (zones \'basic\' tl)]))\n\n(typ ghost (-> SVG SVG))\n(def ghost\n  ; consAttr (instead of addAttr) makes internal calls to\n  ; Utils.maybeRemoveFirst \'HIDDEN\' slightly faster\n  (\\shape (consAttr shape [\'HIDDEN\' \'\'])))\n\n(def ghosts (map ghost))\n\n;; hSlider_ : Bool -> Bool -> Int -> Int -> Int -> Num -> Num -> Str -> Num\n;; -> [Num (List Svg)]\n;; argument order - dropBall roundInt xStart xEnd y minVal maxVal caption srcVal\n;; dropBall - Determines if the slider ball continues to appear past the edges of the slider\n;; roundInt - Determines whether to round to Ints or not\n;; xStart - left edge of slider\n;; xEnd - right edge of slider\n;; y - y positioning of entire slider bar\n;; minVal - minimum value of slider\n;; maxVal - maximum value of slider\n;; caption - text to display along with the slider\n;; srcVal - the current value given by the slider ball\n(def hSlider_ (\\(dropBall roundInt x0 x1 y minVal maxVal caption srcVal)\n  (let preVal (clamp minVal maxVal srcVal)\n  (let targetVal (if roundInt (round preVal) preVal)\n  (let shapes\n    (let ball\n      (let [xDiff valDiff] [(- x1 x0) (- maxVal minVal)]\n      (let xBall (+ x0 (* xDiff (/ (- srcVal minVal) valDiff)))\n      (if (= preVal srcVal) (circle \'black\' xBall y 10!)\n      (if dropBall          (circle \'black\' 0! 0! 0!)\n                            (circle \'red\' xBall y 10!)))))\n    [ (line \'black\' 3! x0 y x1 y)\n      (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))\n      (circle \'black\' x0 y 4!) (circle \'black\' x1 y 4!) ball ])\n  [targetVal (ghosts shapes)])))))\n; TODO only draw zones for ball\n\n(def vSlider_ (\\(dropBall roundInt y0 y1 x minVal maxVal caption srcVal)\n  (let preVal (clamp minVal maxVal srcVal)\n  (let targetVal (if roundInt (round preVal) preVal)\n  (let shapes\n    (let ball\n      (let [yDiff valDiff] [(- y1 y0) (- maxVal minVal)]\n      (let yBall (+ y0 (* yDiff (/ (- srcVal minVal) valDiff)))\n      (if (= preVal srcVal) (circle \'black\' x yBall 10!)\n      (if dropBall          (circle \'black\' 0! 0! 0!)\n                            (circle \'red\' x yBall 10!)))))\n    [ (line \'black\' 3! x y0 x y1)\n      ; (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))\n      (circle \'black\' x y0 4!) (circle \'black\' x y1 4!) ball ])\n  [targetVal (ghosts shapes)])))))\n; TODO only draw zones for ball\n\n(def hSlider (hSlider_ false))\n(def vSlider (vSlider_ false))\n\n;; button_ : Bool -> Num -> Num -> String -> Num -> SVG\n;; Similar to sliders, but just has boolean values\n(def button_ (\\(dropBall xStart y caption xCur)\n  (let [rPoint wLine rBall wSlider] [4! 3! 10! 70!]\n  (let xEnd (+ xStart wSlider)\n  (let xBall (+ xStart (* xCur wSlider))\n  (let xBall_ (clamp xStart xEnd xBall)\n  (let val (< xCur 0.5)\n  (let shapes1\n    [ (circle \'black\' xStart y rPoint)\n      (circle \'black\' xEnd y rPoint)\n      (line \'black\' wLine xStart y xEnd y)\n      (text (+ xEnd 10) (+ y 5) (+ caption (toString val))) ]\n  (let shapes2\n    [ (if (= xBall_ xBall) (circle (if val \'darkgreen\' \'darkred\') xBall y rBall)\n      (if dropBall         (circle \'black\' 0! 0! 0!)\n                           (circle \'red\' xBall y rBall))) ]\n  (let shapes (append (zones \'none\' shapes1) (zones \'basic\' shapes2))\n  [val (ghosts shapes)]))))))))))\n\n(def button (button_ false))\n\n(def xySlider\n  (\\(xStart xEnd yStart yEnd xMin xMax yMin yMax xCaption yCaption xCur yCur)\n    (let [rCorner wEdge rBall] [4! 3! 10!]\n    (let [xDiff yDiff xValDiff yValDiff] [(- xEnd xStart) (- yEnd yStart) (- xMax xMin) (- yMax yMin)]\n    (let xBall (+ xStart (* xDiff (/ (- xCur xMin) xValDiff)))\n    (let yBall (+ yStart (* yDiff (/ (- yCur yMin) yValDiff)))\n    (let cBall (if (and (between xMin xMax xCur) (between yMin yMax yCur)) \'black\' \'red\')\n    (let xVal (ceiling (clamp xMin xMax xCur))\n    (let yVal (ceiling (clamp yMin yMax yCur))\n    (let myLine (\\(x1 y1 x2 y2) (line \'black\' wEdge x1 y1 x2 y2))\n    (let myCirc (\\(x0 y0) (circle \'black\' x0 y0 rCorner))\n    (let shapes\n      [ (myLine xStart yStart xEnd yStart)\n        (myLine xStart yStart xStart yEnd)\n        (myLine xStart yEnd xEnd yEnd)\n        (myLine xEnd yStart xEnd yEnd)\n        (myCirc xStart yStart)\n        (myCirc xStart yEnd)\n        (myCirc xEnd yStart)\n        (myCirc xEnd yEnd)\n        (circle cBall xBall yBall rBall)\n        (text (- (+ xStart (/ xDiff 2)) 40) (+ yEnd 20) (+ xCaption (toString xVal)))\n        (text (+ xEnd 10) (+ yStart (/ yDiff 2)) (+ yCaption (toString yVal))) ]\n    [ [ xVal yVal ] (ghosts shapes) ]\n))))))))))))\n\n(typ enumSlider (forall a (-> Num Num Num [a|(List a)] String Num [a (List SVG)])))\n(def enumSlider (\\(x0 x1 y enum@[a|_] caption srcVal)\n  (let n (len enum)\n  (let [minVal maxVal] [0! n]\n  (let preVal (clamp minVal maxVal srcVal)\n  (let i (floor preVal)\n  (let item ; using dummy first element for typechecking\n    (let item_ (nth enum (if (= i n) (- n 1) i))\n    (typecase item_\n      (Null a)\n      (_    item_)))\n  (let wrap (\\circ (addAttr circ [\'SELECTED\' \'\'])) ; TODO\n  (let shapes\n    (let rail [ (line \'black\' 3! x0 y x1 y) ]\n    (let ball\n      (let [xDiff valDiff] [(- x1 x0) (- maxVal minVal)]\n      (let xBall (+ x0 (* xDiff (/ (- srcVal minVal) valDiff)))\n      (let colorBall (if (= preVal srcVal) \'black\' \'red\')\n        [ (wrap (circle colorBall xBall y 10!)) ])))\n    (let endpoints\n      [ (wrap (circle \'black\' x0 y 4!)) (wrap (circle \'black\' x1 y 4!)) ]\n    (let tickpoints\n      (let sep (/ (- x1 x0) n)\n      (map (\\j (wrap (circle \'grey\' (+ x0 (mult j sep)) y 4!)))\n           (range 1! (- n 1!))))\n    (let label [ (text (+ x1 10!) (+ y 5!) (+ caption (toString item))) ]\n    (concat [ rail endpoints tickpoints ball label ]))))))\n  [item (ghosts shapes)])))))))))\n\n(def addSelectionSliders (\\(y0 seeds shapesCaps)\n  (let shapesCapsSeeds (zip shapesCaps (take seeds (len shapesCaps)))\n  (let foo (\\[i [[shape cap] seed]]\n    (let [k _ _] shape\n    (let enum\n      (if (= k \'circle\') [\'\' \'cx\' \'cy\' \'r\']\n      (if (= k \'line\')   [\'\' \'x1\' \'y1\' \'x2\' \'y2\']\n      (if (= k \'rect\')   [\'\' \'x\' \'y\' \'width\' \'height\']\n        [(+ \'NO SELECTION ENUM FOR KIND \' k)])))\n    (let [item slider] (enumSlider 20! 170! (+ y0 (mult i 30!)) enum cap seed)\n    (let shape1 (addAttr shape [\'SELECTED\' item]) ; TODO overwrite existing\n    [shape1|slider])))))\n  (concat (mapi foo shapesCapsSeeds))))))\n\n; Text Widgets\n\n(def simpleText (\\(family color size x1 x2 y horizAlignSeed textVal)\n  (let xMid (+ x1 (/ (- x2 x1) 2!))\n  (let [anchor hAlignSlider]\n    (let dx (/ (- x2 x1) 4!)\n    (let yLine (+ 30! y)\n    (enumSlider (- xMid dx) (+ xMid dx) yLine\n      [\'start\' \'middle\' \'end\'] \'\' horizAlignSeed)))\n  (let x\n    (if (= anchor \'start\') x1\n    (if (= anchor \'middle\') xMid\n    (if (= anchor \'end\') x2\n      \'CRASH\')))\n  (let theText\n    [\'text\'\n      [[\'x\' x] [\'y\' y]\n       [\'style\' (+ \'fill:\' color)]\n       [\'font-family\' family] [\'font-size\' size]\n       [\'text-anchor\' anchor]]\n      [[\'TEXT\' textVal]]]\n  (let rails\n    (let pad 15!\n    (let yBaseLine (+ y pad)\n    (let xSideLine (- x1 pad)\n    (let rail (line \'gray\' 3)\n    (let baseLine (rail xSideLine yBaseLine x2 yBaseLine)\n    (let sideLine (rail xSideLine yBaseLine xSideLine (- y size))\n    (let dragBall (circle \'black\' x yBaseLine 8!)\n    (ghosts [baseLine sideLine dragBall]))))))))\n  (concat [[theText] hAlignSlider rails])\n)))))))\n\n\n(typ rotate (-> SVG Num Num Num SVG))\n;; argument order - shape, rot, x, y\n;; Takes a shape rotates it rot degrees around point (x,y)\n(def rotate (\\(shape n1 n2 n3)\n  (addAttr shape [\'transform\' [[\'rotate\' n1 n2 n3]]])))\n\n(typ rotateAround (-> Num Num Num SVG SVG))\n(def rotateAround (\\(rot x y shape)\n  (addAttr shape [\'transform\' [[\'rotate\' rot x y]]])))\n\n; Convert radians to degrees\n(typ radToDeg (-> Num Num))\n(def radToDeg (\\rad (* (/ rad (pi)) 180!)))\n\n; Convert degrees to radians\n(typ degToRad (-> Num Num))\n(def degToRad (\\deg (* (/ deg 180!) (pi))))\n\n; Polygon and Path Helpers\n\n(typ middleOfPoints (-> (List Point) Point))\n(def middleOfPoints (\\pts\n  (let [xs ys] [(map fst pts) (map snd pts)]\n  (let [xMin xMax] [(minimum xs) (maximum xs)]\n  (let [yMin yMax] [(minimum ys) (maximum ys)]\n  (let xMiddle (noWidgets (+ xMin (* 0.5 (- xMax xMin))))\n  (let yMiddle (noWidgets (+ yMin (* 0.5 (- yMax yMin))))\n    [xMiddle yMiddle] )))))))\n\n(typ polygonPoints (-> SVG Points))\n(def polygonPoints (\\shape@[shapeKind _ _]\n  (case shapeKind\n    (\'polygon\' (lookupPointsAttrWithDefault [] shape \'points\'))\n    (_         []))))\n\n(typ allPointsOfPathCmds_ (-> PathCmds (List [(union Num String) (union Num String)])))\n(defrec allPointsOfPathCmds_ (\\cmds (case cmds\n  ([]    [])\n  ([\'Z\'] [])\n\n  ([\'M\' x y | rest] (cons [x y] (allPointsOfPathCmds_ rest)))\n  ([\'L\' x y | rest] (cons [x y] (allPointsOfPathCmds_ rest)))\n\n  ([\'Q\' x1 y1 x y | rest]\n    (append [[x1 y1] [x y]] (allPointsOfPathCmds_ rest)))\n\n  ([\'C\' x1 y1 x2 y2 x y | rest]\n    (append [[x1 y1] [x2 y2] [x y]] (allPointsOfPathCmds_ rest)))\n\n  (_ [(let _ (debug \"Prelude.allPointsOfPathCmds_: not Nums...\") [-1 -1])])\n)))\n\n; (typ allPointsOfPathCmds (-> PathCmds (List Point)))\n; (def allPointsOfPathCmds (\\cmds\n;   (let toNum (\\numOrString\n;     (typecase numOrString (Num numOrString) (String -1)))\n;   (map (\\[x y] [(toNum x) (toNum y)]) (allPointsOfPathCmds_ cmds)))))\n\n; TODO remove inner annotations and named lambda\n\n(typ allPointsOfPathCmds (-> PathCmds (List Point)))\n(def allPointsOfPathCmds (\\cmds\n  (typ toNum (-> (union Num String) Num))\n  (let toNum (\\numOrString\n    (typecase numOrString (Num numOrString) (String -1)))\n  (typ foo (-> [(union Num String) (union Num String)] Point))\n  (let foo (\\[x y] [(toNum x) (toNum y)])\n  (map foo (allPointsOfPathCmds_ cmds))))))\n\n\n; Raw Shapes\n\n(def rawShape (\\(kind attrs) [kind attrs []]))\n\n(typ rawRect (-> Color Color Num Num Num Num Num Num Rect))\n(def rawRect (\\(fill stroke strokeWidth x y w h rot)\n  (let [cx cy] [(+ x (/ w 2!)) (+ y (/ h 2!))]\n  (rotateAround rot cx cy\n    (rawShape \'rect\' [\n      [\'x\' x] [\'y\' y] [\'width\' w] [\'height\' h]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ])))))\n\n(typ rawCircle (-> Color Color Num Num Num Num Circle))\n(def rawCircle (\\(fill stroke strokeWidth cx cy r)\n  (rawShape \'circle\' [\n    [\'cx\' cx] [\'cy\' cy] [\'r\' r]\n    [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ])))\n\n(typ rawEllipse (-> Color Color Num Num Num Num Num Num Ellipse))\n(def rawEllipse (\\(fill stroke strokeWidth cx cy rx ry rot)\n  (rotateAround rot cx cy\n    (rawShape \'ellipse\' [\n      [\'cx\' cx] [\'cy\' cy] [\'rx\' rx] [\'ry\' ry]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]))))\n\n(typ rawPolygon (-> Color Color Num Points Num SVG))\n(def rawPolygon (\\(fill stroke w pts rot)\n  (let [cx cy] (middleOfPoints pts)\n  (rotateAround rot cx cy\n    (rawShape \'polygon\'\n      [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ])))))\n\n(typ rawPath (-> Color Color Num PathCmds Num SVG))\n(def rawPath (\\(fill stroke w d rot)\n  (let [cx cy] (middleOfPoints (allPointsOfPathCmds d))\n  (rotateAround rot cx cy\n    (rawShape \'path\'\n      [ [\'fill\' fill] [\'d\' d] [\'stroke\' stroke] [\'stroke-width\' w] ])))))\n\n\n; Shapes via Bounding Boxes\n\n(typ box (-> Bounds Color Color Num BoundedShape))\n(def box (\\(bounds fill stroke strokeWidth)\n  (let [x y xw yh] bounds\n  [\'BOX\'\n    [ [\'LEFT\' x] [\'TOP\' y] [\'RIGHT\' xw] [\'BOT\' yh]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth]\n    ] []\n  ])))\n\n; string fill/stroke/stroke-width attributes to avoid sliders\n(typ hiddenBoundingBox (-> Bounds BoundedShape))\n(def hiddenBoundingBox (\\bounds\n  (ghost (box bounds \'transparent\' \'transparent\' \'0\'))))\n\n(typ simpleBoundingBox (-> Bounds BoundedShape))\n(def simpleBoundingBox (\\bounds\n  (ghost (box bounds \'transparent\' \'darkblue\' 1))))\n\n(typ strList (-> (List String) String))\n(def strList\n  (let foo (\\(x acc) (+ (+ acc (if (= acc \'\') \'\' \' \')) (toString x)))\n  (foldl foo \'\')))\n\n(typ fancyBoundingBox (-> Bounds (List SVG)))\n(def fancyBoundingBox (\\bounds\n  (let [left top right bot] bounds\n  (let [width height] [(- right left) (- bot top)]\n  (let [c1 c2 r] [\'darkblue\' \'skyblue\' 6]\n  [ (ghost (box bounds \'transparent\' c1 1))\n    (ghost (setZones \'none\' (circle c2 left top r)))\n    (ghost (setZones \'none\' (circle c2 right top r)))\n    (ghost (setZones \'none\' (circle c2 right bot r)))\n    (ghost (setZones \'none\' (circle c2 left bot r)))\n    (ghost (setZones \'none\' (circle c2 left (+ top (/ height 2)) r)))\n    (ghost (setZones \'none\' (circle c2 right (+ top (/ height 2)) r)))\n    (ghost (setZones \'none\' (circle c2 (+ left (/ width 2)) top r)))\n    (ghost (setZones \'none\' (circle c2 (+ left (/ width 2)) bot r)))\n  ])))))\n\n(typ groupWithPad (-> Num Bounds (List SVG) SVG))\n(def groupWithPad (\\(pad bounds shapes)\n  (let [left top right bot] bounds\n  (let paddedBounds [(- left pad) (- top pad) (+ right pad) (+ bot pad)]\n  [\'g\' [[\'BOUNDS\' bounds]]\n       (cons (hiddenBoundingBox paddedBounds) shapes)]\n))))\n\n(typ group (-> Bounds (List SVG) SVG))\n(def group (groupWithPad (let nGroupPad 20 nGroupPad)))\n\n  ; NOTE:\n  ;   keep the names nGroupPad and nPolyPathPad (and values)\n  ;   in sync with ExpressionBasedTransform.elm\n\n  ; (def group (groupWithPad 15))\n\n(def polyPathGroup (groupWithPad (let nPolyPathPad 10 nPolyPathPad)))\n\n; TODO make one pass over pts\n(typ boundsOfPoints (-> (List Point) Bounds))\n(def boundsOfPoints (\\pts\n  (let left  (minimum (map fst pts))\n  (let right (maximum (map fst pts))\n  (let top   (minimum (map snd pts))\n  (let bot   (maximum (map snd pts))\n    [left top right bot]\n))))))\n\n(typ extremeShapePoints (-> SVG Points))\n(def extremeShapePoints (\\shape@[kind _ _]\n  (case kind\n\n    (\'line\'\n      (let attrs@[x1 y1 x2 y2] (map (lookupAttr shape) [\"x1\" \"y1\" \"x2\" \"y2\"])\n      (typecase attrs\n        ([Num Num Num Num] [[x1 y1] [x2 y2]])\n        (_ []))))\n\n    (\'rect\'\n      (let attrs@[x y w h] (map (lookupAttr shape) [\"x\" \"y\" \"width\" \"height\"])\n      (typecase attrs\n        ([Num Num Num Num] [[x y] [(+ x w) (+ y h)]])\n        (_ []))))\n\n    (\'circle\'\n      (let attrs@[cx cy r] (map (lookupAttr shape) [\"cx\" \"cy\" \"r\"])\n      (typecase attrs\n        ([Num Num Num] [[(- cx r) (- cy r)] [(+ cx r) (+ cy r)]])\n        (_ []))))\n\n    (\'ellipse\'\n      (let attrs@[cx cy rx ry] (map (lookupAttr shape) [\"cx\" \"cy\" \"rx\" \"ry\"])\n      (typecase attrs\n        ([Num Num Num Num] [[(- cx rx) (- cy ry)] [(+ cx rx) (+ cy ry)]])\n        (_ []))))\n\n    (\'polygon\' (polygonPoints shape))\n\n    (\'path\'\n      (let pathCmds (lookupAttr shape \"d\")\n      (typecase pathCmds\n        ((List (union String Num)) (allPointsOfPathCmds pathCmds))\n        (_ []))))\n\n    (_ [])\n)))\n\n(typ anchoredGroup (-> (List SVG) SVG))\n(def anchoredGroup (\\shapes\n  (let bounds (boundsOfPoints (concat (map extremeShapePoints shapes)))\n  (group bounds shapes)\n)))\n\n; (def group (\\(bounds shapes)\n;   [\'g\' [[\'BOUNDS\' bounds]]\n;        (cons (hiddenBoundingBox bounds) shapes)]))\n\n       ; (concat [(fancyBoundingBox bounds) shapes])]))\n\n; TODO no longer used...\n(typ rotatedRect (-> Color Num Num Num Num Num Rect))\n(def rotatedRect (\\(fill x y w h rot)\n  (let [cx cy] [(+ x (/ w 2!)) (+ y (/ h 2!))]\n  (let bounds [x y (+ x w) (+ y h)]\n  (let shape (rotateAround rot cx cy (rect fill x y w h))\n  (group bounds [shape])\n)))))\n\n(typ rectangle (-> Color Color Num Num Bounds Rect))\n(def rectangle (\\(fill stroke strokeWidth rot bounds)\n  (let [left top right bot] bounds\n  (let [cx cy] [(+ left (/ (- right left) 2!)) (+ top (/ (- bot top) 2!))]\n  (let shape (rotateAround rot cx cy (box bounds fill stroke strokeWidth))\n  shape\n)))))\n  ; (group bounds [shape])\n\n; TODO no longer used...\n(typ rotatedEllipse (-> Color Num Num Num Num Num Ellipse))\n(def rotatedEllipse (\\(fill cx cy rx ry rot)\n  (let bounds [(- cx rx) (- cy ry) (+ cx rx) (+ cy ry)]\n  (let shape (rotateAround rot cx cy (ellipse fill cx cy rx ry))\n  (group bounds [shape])\n))))\n\n; TODO take rot\n(typ oval (-> Color Color Num Bounds BoundedShape))\n(def oval (\\(fill stroke strokeWidth bounds)\n  (let [left top right bot] bounds\n  (let shape\n    [\'OVAL\'\n       [ [\'LEFT\' left] [\'TOP\' top] [\'RIGHT\' right] [\'BOT\' bot]\n         [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]\n       []]\n  shape\n))))\n\n; ; TODO take rot\n; (def oval (\\(fill stroke strokeWidth bounds)\n;   (let [left top right bot] bounds\n;   (let [rx ry] [(/ (- right left) 2!) (/ (- bot top) 2!)]\n;   (let [cx cy] [(+ left rx) (+ top ry)]\n;   (let shape ; TODO change def ellipse to take stroke/strokeWidth\n;     [\'ellipse\'\n;        [ [\'cx\' cx] [\'cy\' cy] [\'rx\' rx] [\'ry\' ry]\n;          [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]\n;        []]\n;   (group bounds [shape])\n; ))))))\n\n(def scaleBetween (\\(a b pct)\n  (case pct\n    (0 a)\n    (1 b)\n    (_ (+ a (* pct (- b a)))))))\n\n(typ stretchyPolygon (-> Bounds Color Color Num (List Num) SVG))\n(def stretchyPolygon (\\(bounds fill stroke strokeWidth percentages)\n  (let [left top right bot] bounds\n  (let [xScale yScale] [(scaleBetween left right) (scaleBetween top bot)]\n  (let pts (map (\\[xPct yPct] [ (xScale xPct) (yScale yPct) ]) percentages)\n  ; (group bounds [(polygon fill stroke strokeWidth pts)])\n  (polyPathGroup bounds [(polygon fill stroke strokeWidth pts)])\n)))))\n\n; TODO no longer used...\n(def pointyPath (\\(fill stroke w d)\n  (let dot (\\(x y) (ghost (circle \'orange\' x y 5)))\n  (letrec pointsOf (\\cmds\n    (case cmds\n      ([]                     [])\n      ([\'Z\']                  [])\n      ([\'M\' x y | rest]       (append [(dot x y)] (pointsOf rest)))\n      ([\'L\' x y | rest]       (append [(dot x y)] (pointsOf rest)))\n      ([\'Q\' x1 y1 x y | rest] (append [(dot x1 y1) (dot x y)] (pointsOf rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest] (append [(dot x1 y1) (dot x2 y2) (dot x y)] (pointsOf rest)))\n      (_                      \'ERROR\')))\n  [\'g\' []\n    (cons\n      (path fill stroke w d)\n      [])]\n))))\n      ; turning off points for now\n      ; (pointsOf d)) ]\n\n; can refactor to make one pass\n; can also change representation/template code to pair points\n(def stretchyPath (\\(bounds fill stroke w d)\n  (let [left top right bot] bounds\n  (let [xScale yScale] [(scaleBetween left right) (scaleBetween top bot)]\n  (let dot (\\(x y) (ghost (circle \'orange\' x y 5)))\n  (letrec toPath (\\cmds\n    (case cmds\n      ([]    [])\n      ([\'Z\'] [\'Z\'])\n      ([\'M\' x y | rest] (append [\'M\' (xScale x) (yScale y)] (toPath rest)))\n      ([\'L\' x y | rest] (append [\'L\' (xScale x) (yScale y)] (toPath rest)))\n      ([\'Q\' x1 y1 x y | rest]\n        (append [\'Q\' (xScale x1) (yScale y1) (xScale x) (yScale y)]\n                (toPath rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest]\n        (append [\'C\' (xScale x1) (yScale y1) (xScale x2) (yScale y2) (xScale x) (yScale y)]\n                (toPath rest)))\n      (_ \'ERROR\')))\n  (letrec pointsOf (\\cmds\n    (case cmds\n      ([]    [])\n      ([\'Z\'] [])\n      ([\'M\' x y | rest] (append [(dot (xScale x) (yScale y))] (pointsOf rest)))\n      ([\'L\' x y | rest] (append [(dot (xScale x) (yScale y))] (pointsOf rest)))\n      ([\'Q\' x1 y1 x y | rest]\n        (append [(dot (xScale x1) (yScale y1)) (dot (xScale x) (yScale y))]\n                (pointsOf rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest]\n        (append [(dot (xScale x1) (yScale y1))\n                 (dot (xScale x2) (yScale y2))\n                 (dot (xScale x)  (yScale y))]\n                (pointsOf rest)))\n      (_ \'ERROR\')))\n  ; (group bounds\n  (polyPathGroup bounds\n    (cons\n      (path fill stroke w (toPath d))\n      []))\n)))))))\n      ; turning off points for now\n      ; (pointsOf d)))\n\n(typ evalOffset (-> [Num Num] Num))\n(def evalOffset (\\[base off]\n  (case off\n    (0 base)\n    (_ (+ base off)))))\n\n(def stickyPolygon (\\(bounds fill stroke strokeWidth offsets)\n  (let pts (map (\\[xOff yOff] [ (evalOffset xOff) (evalOffset yOff) ]) offsets)\n  (group bounds [(polygon fill stroke strokeWidth pts)])\n)))\n\n(typ withBounds (-> Bounds (-> Bounds (List SVG)) (List SVG)))\n(def withBounds (\\(bounds f) (f bounds)))\n\n(typ withAnchor (-> Point (-> Point (List SVG)) (List SVG)))\n(def withAnchor (\\(anchor f) (f anchor)))\n\n(typ star (-> Bounds (List SVG)))\n(def star (\\bounds\n  (let [left top right bot] bounds\n  (let [width height] [(- right left) (- bot top)]\n  (let [cx cy] [(+ left (/ width 2)) (+ top (/ height 2))]\n  [(nStar 0 \'black\' 0 6 (min (/ width 2) (/ height 2)) 10 0 cx cy)]\n)))))\n\n(typ blobs (-> (List Blob) SVG))\n(def blobs (\\blobs\n  (let modifyBlob (\\[i blob]\n    (case blob\n      ([[\'g\' gAttrs [shape | shapes]]]\n       [[\'g\' gAttrs [(consAttr shape [\'BLOB\' (toString (+ i 1))]) | shapes]]])\n      ([shape] [(consAttr shape [\'BLOB\' (toString (+ i 1))])])\n      (_       blob)))\n  (svg (concat (mapi modifyBlob blobs)))\n)))\n\n\n; === Relations ===\n\n(typ halfwayBetween (-> Point Point Point))\n(def halfwayBetween (\\(pt1 pt2)\n  (vec2DScalarMult 0.5 (vec2DPlus pt1 pt2))\n))\n\n(typ nextInLine (-> Point Point Point))\n(def nextInLine (\\(pt1 pt2)\n  (vec2DPlus pt2 (vec2DMinus pt2 pt1))\n))\n\n; Point on line segment, at `ratio` location.\n(typ onLine (-> Point Point Num Point))\n(def onLine (\\(pt1 pt2 ratio)\n  (let vec (vec2DMinus pt2 pt1)\n  (vec2DPlus pt1 (vec2DScalarMult ratio vec)))))\n\n; === Basic Replicate ===\n\n(def horizontalArray (\\(n sep func [x y])\n  (let _ ; draw point widget to control anchor\n    ([x y] : Point)\n  (let draw_i (\\i\n    (let xi (+ x (* i sep))\n    (func [xi y])))\n  (concat (map draw_i (zeroTo n)))\n))))\n\n(def linearArrayFromTo (\\(n func [xStart yStart] [xEnd yEnd])\n  (let xsep (/ (- xEnd xStart) (- n 1))\n  (let ysep (/ (- yEnd yStart) (- n 1))\n  (let draw_i (\\i\n    (let xi (+ xStart (* i xsep))\n    (let yi (+ yStart (* i ysep))\n    (func [xi yi]))))\n  (concat (map draw_i (zeroTo n)))\n)))))\n\n; To reduce size of resulting trace,\n; could subtract up to M>1 at a time.\n;\n(defrec floorAndLocalFreeze (\\n\n  (if (le n 1) 0\n  ;else\n    (+ 1 (floorAndLocalFreeze (- n 1))))))\n\n  ; (let _ ; draw point widget to control anchor\n  ;   ([cx cy] : Point)\n(def radialArray (\\(n radius rot func [cx cy])\n  (let center ; draw ghost circle to control anchor\n              ; not using point widget, since it\'s not selectable\n    (ghost (circle \'orange\' cx cy 20))\n  (let _ ; draw point widget to control radius\n    (let xWidget (floorAndLocalFreeze cx)\n    (let yWidget (- (floorAndLocalFreeze cy) radius)\n      ([xWidget yWidget] : Point)))\n  (let endpoints (nPointsOnCircle n rot cx cy radius)\n  (let bounds\n    [(- cx radius) (- cy radius) (+ cx radius) (+ cy radius)]\n  [(group bounds (cons center (concat (map func endpoints))))]\n))))))\n\n(def offsetAnchor (\\(dx dy f)\n  (\\[x y] (f [(+ x dx) (+ y dy)]))\n))\n\n(def horizontalArrayByBounds (\\(n sep func [left_0 top right_0 bot])\n  (let w_i     (- right_0 left_0)\n  (let left_i  (\\i (+ left_0 (* i (+ w_i sep))))\n  (let right_i (\\i (+ (left_i i) w_i))\n  (let draw_i  (\\i (func [(left_i i) top (right_i i) bot]))\n  (let bounds  [left_0 top (right_i (- n 1)) bot]\n    [(groupWithPad 30 bounds (concat (map draw_i (zeroTo n))))]\n)))))))\n\n(def repeatInsideBounds (\\(n sep func bounds@[left top right bot])\n  (let w_i (/ (- (- right left) (* sep (- n 1))) n)\n  (let draw_i (\\i\n    (let left_i (+ left (* i (+ w_i sep)))\n    (let right_i (+ left_i w_i)\n    (func [left_i top right_i bot]))))\n  [(groupWithPad 30 bounds (concat (map draw_i (zeroTo n))))]\n))))\n\n\n(def draw svg)\n\n(def showOne (\\(x y val)\n   [\'text\' [[\'x\' x] [\'y\' y] [\'style\' \'fill:black\']\n            [\'font-family\' \'monospace\']\n            [\'font-size\' \'12pt\']]\n           [[\'TEXT\' (toString val)]]]))\n\n(def show (showOne 20 30))\n\n(def showList (\\vals\n  [\'g\' [] (mapi (\\[i val] (showOne 20 (* (+ i 1) 30) val)) vals)]))\n\n(def rectWithBorder (\\(stroke strokeWidth fill x y w h)\n  (addAttr (addAttr\n    (rect fill x y w h)\n      [\"stroke\" stroke])\n      [\"stroke-width\" strokeWidth])))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n; (def columnsToRows (\\columns\n;   (let numColumns (len columns)\n;   (let numRows ; maxColumnSize\n;     (if (= numColumns 0) 0 (maximum (map len columns)))\n;   (foldr\n;     (\\(col rows)\n;       (let paddedCol (append col (repeat (- numRows (len col)) \".\"))\n;       (map\n;         (\\[datum row] [ datum | row ])\n;         (zip paddedCol rows))))\n;     (repeat numRows [])\n;     columns)\n; ))))\n; \n; (def addColToRows (\\(col rows)\n;   (let width (maximum (map len rows))\n;   (letrec foo (\\(col rows)\n;     (case [col rows]\n;       ([ []     []     ] [                                          ])\n;       ([ [x|xs] [r|rs] ] [ (snoc x r)                 | (foo xs rs) ])\n;       ([ []     [r|rs] ] [ (snoc \'\' r)                | (foo [] rs) ])\n;       ([ [x|xs] []     ] [ (snoc x (repeat width \'\')) | (foo xs []) ])\n;     ))\n;   (foo col rows)))))\n\n; (def border [\'border\' \'1px solid black\'])\n; (def padding [\'padding\' \'5px\'])\n; (def center [\'align\' \'center\'])\n; (def style (\\list [\'style\' list]))\n; (def onlyStyle (\\list [(style list)]))\n; \n; (def td (\\text\n;   [\'td\' (onlyStyle [border padding])\n;         [[\'TEXT\' text]]]))\n; \n; (def th (\\text\n;   [\'th\' (onlyStyle [border padding center])\n;         [[\'TEXT\' text]]]))\n; \n; (def tr (\\children\n;   [\'tr\' (onlyStyle [border])\n;         children]))\n; \n; ; TODO div name is already taken...\n; \n; (def div_ (\\children [\'div\' [] children]))\n; (def h1 (\\text [\'h1\' [] [[\'TEXT\' text]]]))\n; (def h2 (\\text [\'h2\' [] [[\'TEXT\' text]]]))\n; (def h3 (\\text [\'h3\' [] [[\'TEXT\' text]]]))\n; \n; (def table (\\children\n;   [\'table\' (onlyStyle [border padding]) children]))\n\n; (def table (\\children\n;   (let [x y] [100 100]\n;   [\'table\' (onlyStyle [border padding\n;                       [\"position\" \"relative\"]\n;                       [\"left\" (toString x)]\n;                       [\"top\" (toString y)]]) children])))\n\n; (def tableOfData (\\data\n;   (let letters (explode \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n;   (let data (mapi (\\[i row] [(+ i 1) | row]) data)\n;   (let tableWidth (maximum (map len data))\n;   (let headers\n;     (tr (map (\\letter (th letter)) (take letters tableWidth)))\n;   (let rows\n;     (map (\\row (tr (map (\\col (td (toString col))) row))) data)\n;   (table\n;     [ headers | rows ]\n; ))))))))\n\n\n(def textNode (\\text\n  [\"TEXT\" text]))\n\n(def textElementHelper (\\(tag styles attrs text)\n  [ tag [ [\"style\" styles] | attrs ] [ (textNode text) ] ]))\n\n(def elementHelper (\\(tag styles attrs children)\n  [ tag [ [\"style\" styles] | attrs ] children ]))\n\n(def p (textElementHelper \"p\"))\n(def th (textElementHelper \"th\"))\n(def td (textElementHelper \"td\"))\n(def h1 (textElementHelper \"h1\"))\n(def h2 (textElementHelper \"h2\"))\n(def h3 (textElementHelper \"h3\"))\n\n(def div_ (elementHelper \"div\"))\n(def tr (elementHelper \"tr\"))\n(def table (elementHelper \"table\"))\n\n; absolutePositionStyles x y = let _ = [x, y] : Point in\n;   [ [\"position\", \"absolute\"]\n;   , [\"left\", toString x + \"px\"]\n;   , [\"top\", toString y + \"px\"]\n;   ] \n\n\n\n(def setStyles (\\(newStyles [kind attrs children])\n  (let attrs\n    (let styleAttr (lookup \'style\' attrs)\n    (typecase styleAttr\n      (Null [ [\'style\' []] | attrs ])\n      (_    attrs)))\n    ; (if (= styleAttr null)\n    ;   [ [\'style\' []] | attrs ]\n    ;   attrs)\n  (let attrs\n    (map (\\[key val]\n      (case key\n        (\'style\'\n          (let otherStyles\n            (concatMap (\\[k v]\n              (case (elem k (map fst newStyles))\n                (true  [])\n                (false [[k v]])))\n              val)\n          [\'style\' (append newStyles otherStyles)]))\n        (_\n          [key val])))\n      attrs)\n  [kind attrs children]\n))))\n\n(def placeAt (\\([x y] node)\n  (let _ ([x y] : Point)\n  ; TODO px suffix should be added in LangSvg/Html translation\n  (setStyles\n    [ [\'position\' \'absolute\']\n      [\'left\' (+ (toString x) \'px\')]\n      [\'top\' (+ (toString y) \'px\')]\n    ]\n    node))))\n\n(def placeAtFixed (\\([x y] node)\n  (let _ ([x y] : Point)\n  (setStyles\n    [[\'position\' \'fixed\'] [\'FIXED_LEFT\' x] [\'FIXED_TOP\' y]]\n    node))))\n\n(def placeSvgAt (\\([x y] w h shapes)\n  (placeAt [x y]\n    [\'svg\' [[\'width\' w] [\'height\' h]] shapes])))\n\n(def workspace (\\(minSize children)\n  (div_\n    (cons\n      (placeAt minSize (h3 \'</workspace>\'))\n      children))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def nothing [\"Nothing\"])\n(def just (\\x [\"Just\"  x]))\n\n(def mapFirst (\\(f [x y]) [(f x) y]))\n(def mapSecond (\\(f [x y]) [x (f y)]))\n\n(def freeze (\\x x))\n\n\n; The type checker relies on the name of this definition.\n(let dummyPreludeMain [\'svg\' [] []] dummyPreludeMain)\n\n';
var _user$project$PreludeGenerated$src = _user$project$PreludeGenerated$prelude;

var _user$project$HTMLParser$printAttrValueRaw = F2(
	function (prettyPrint, v) {
		return A3(
			_user$project$Utils$delimit,
			'\"',
			'\"',
			A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$All,
				_elm_lang$core$Regex$regex('\\\\|\"|\'|\n|\r|\t|&'),
				function (m) {
					var _p0 = m.match;
					switch (_p0) {
						case '\\':
							return prettyPrint ? '\\\\' : '\\';
						case '\'':
							return prettyPrint ? '\'' : '&#39;';
						case '\"':
							return prettyPrint ? '\\\"' : '&quot;';
						case '\n':
							return prettyPrint ? '\\n' : '&#10;';
						case '\r':
							return prettyPrint ? '\\r' : '&#13;';
						case '\t':
							return prettyPrint ? '\\t' : '\t';
						case '&':
							return prettyPrint ? '&' : '&amp;';
						default:
							return _p0;
					}
				},
				v));
	});
var _user$project$HTMLParser$unparseStrContent = F5(
	function (quoteChar, content1, content2, offset, mbvdiffs) {
		var unparsedContent1 = A2(_user$project$ParserUtils$unparseStringContent, quoteChar, content1);
		var unparsedContent2 = A2(_user$project$ParserUtils$unparseStringContent, quoteChar, content2);
		var _p1 = mbvdiffs;
		if (_p1.ctor === 'Nothing') {
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: unparsedContent2,
					_1: offset + _elm_lang$core$String$length(unparsedContent1),
					_2: {ctor: '[]'}
				});
		} else {
			if (_p1._0.ctor === 'VStringDiffs') {
				var find = A2(
					_elm_lang$core$Regex$find,
					_elm_lang$core$Regex$All,
					_elm_lang$core$Regex$regex(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'\\\\|',
							A2(_elm_lang$core$Basics_ops['++'], quoteChar, '|\r|\n|\t'))));
				var content1splitted = find(content1);
				var aux = F4(
					function (updateOffset, stringDiffs, matches2, revAcc) {
						aux:
						while (true) {
							var _p2 = stringDiffs;
							if (_p2.ctor === '[]') {
								return _elm_lang$core$Result$Ok(
									{
										ctor: '_Tuple3',
										_0: unparsedContent2,
										_1: offset + _elm_lang$core$String$length(unparsedContent1),
										_2: _elm_lang$core$List$reverse(revAcc)
									});
							} else {
								var _p9 = _p2._1;
								var _p8 = _p2._0._0;
								var _p7 = _p2._0._2;
								var _p6 = _p2._0._1;
								var newReplaced = function () {
									var newSubtr = A3(_elm_lang$core$String$slice, _p8 + updateOffset, (_p8 + _p7) + updateOffset, content2);
									var newSubstrUnparsed = A2(_user$project$ParserUtils$unparseStringContent, quoteChar, newSubtr);
									return _elm_lang$core$String$length(newSubstrUnparsed);
								}();
								var newUpdateOffset = (updateOffset + _p7) - (_p6 - _p8);
								var _p3 = matches2;
								if (_p3.ctor === '[]') {
									var _v4 = newUpdateOffset,
										_v5 = _p9,
										_v6 = {ctor: '[]'},
										_v7 = {
										ctor: '::',
										_0: A3(_user$project$Lang$StringUpdate, (offset + _p8) + updateOffset, (offset + _p6) + updateOffset, newReplaced),
										_1: revAcc
									};
									updateOffset = _v4;
									stringDiffs = _v5;
									matches2 = _v6;
									revAcc = _v7;
									continue aux;
								} else {
									var _p5 = _p3._1;
									var _p4 = _p3._0;
									if (_elm_lang$core$Native_Utils.cmp(_p4.index, _p6) > -1) {
										var _v8 = newUpdateOffset,
											_v9 = _p9,
											_v10 = matches2,
											_v11 = {
											ctor: '::',
											_0: A3(_user$project$Lang$StringUpdate, (offset + _p8) + updateOffset, (offset + _p6) + updateOffset, newReplaced),
											_1: revAcc
										};
										updateOffset = _v8;
										stringDiffs = _v9;
										matches2 = _v10;
										revAcc = _v11;
										continue aux;
									} else {
										if (_elm_lang$core$Native_Utils.cmp(_p4.index, _p8) < 0) {
											var _v12 = newUpdateOffset + 1,
												_v13 = stringDiffs,
												_v14 = _p5,
												_v15 = revAcc;
											updateOffset = _v12;
											stringDiffs = _v13;
											matches2 = _v14;
											revAcc = _v15;
											continue aux;
										} else {
											var _v16 = updateOffset + 1,
												_v17 = {
												ctor: '::',
												_0: A3(_user$project$Lang$StringUpdate, _p8, _p6 + 1, _p7),
												_1: _p9
											},
												_v18 = _p5,
												_v19 = revAcc;
											updateOffset = _v16;
											stringDiffs = _v17;
											matches2 = _v18;
											revAcc = _v19;
											continue aux;
										}
									}
								}
							}
						}
					});
				return A4(
					aux,
					0,
					_p1._0._0,
					content1splitted,
					{ctor: '[]'});
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected VStringDiffs for a string, got ',
						_elm_lang$core$Basics$toString(_p1._0)));
			}
		}
	});
var _user$project$HTMLParser$unparseStr = F4(
	function (oldStr, newStr, offset, diffs) {
		var _p10 = diffs;
		if (_p10.ctor === 'Nothing') {
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: newStr,
					_1: offset + _elm_lang$core$String$length(oldStr),
					_2: {ctor: '[]'}
				});
		} else {
			if (_p10._0.ctor === 'VStringDiffs') {
				return _elm_lang$core$Result$Ok(
					{
						ctor: '_Tuple3',
						_0: newStr,
						_1: offset + _elm_lang$core$String$length(oldStr),
						_2: A2(_user$project$Lang$offsetStr, offset, _p10._0._0)
					});
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected VStringDiffs for a string, got ',
						_elm_lang$core$Basics$toString(_p10._0)));
			}
		}
	});
var _user$project$HTMLParser$unparseTagNameDiff = F4(
	function (oldTag, newTag, offset, diffs) {
		var _p11 = {ctor: '_Tuple2', _0: oldTag, _1: newTag};
		if (((_p11.ctor === '_Tuple2') && (_p11._0.ctor === 'HTMLTagString')) && (_p11._1.ctor === 'HTMLTagString')) {
			return A4(_user$project$HTMLParser$unparseStr, _p11._0._0.val, _p11._1._0.val, offset, diffs);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Don\'t know how to unparse ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(newTag),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' from ',
							_elm_lang$core$Basics$toString(oldTag)))));
		}
	});
var _user$project$HTMLParser$unparseList = F6(
	function (subUnparserDiff, defaultUnparser, list1, list2, offset, mbdiffs) {
		var $default = F3(
			function (_p12, list1, list2) {
				var _p13 = _p12;
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (_p15, _p14) {
							var _p16 = _p15;
							var _p17 = _p14;
							var str2 = defaultUnparser(_p16._1);
							return {
								ctor: '_Tuple3',
								_0: A2(_elm_lang$core$Basics_ops['++'], _p17._0, str2),
								_1: _p17._1 + _elm_lang$core$String$length(str2),
								_2: _p17._2
							};
						}),
					{ctor: '_Tuple3', _0: _p13._0, _1: _p13._1, _2: _p13._2},
					A2(_user$project$Utils$zip, list1, list2));
			});
		var _p18 = mbdiffs;
		if (_p18.ctor === 'Nothing') {
			return _elm_lang$core$Result$Ok(
				A3(
					$default,
					{
						ctor: '_Tuple3',
						_0: '',
						_1: offset,
						_2: {ctor: '[]'}
					},
					list1,
					list2));
		} else {
			if (_p18._0.ctor === 'VListDiffs') {
				var aux = F5(
					function (i, ds, remaining1, remaining2, _p19) {
						aux:
						while (true) {
							var _p20 = _p19;
							var _p34 = _p20._0;
							var _p33 = _p20._1;
							var _p32 = _p20._2;
							var _p21 = ds;
							if (_p21.ctor === '[]') {
								return _elm_lang$core$Result$Ok(
									A3(
										$default,
										{ctor: '_Tuple3', _0: _p34, _1: _p33, _2: _p32},
										remaining1,
										remaining2));
							} else {
								var _p31 = _p21._0._0;
								var _p30 = _p21._1;
								if (_elm_lang$core$Native_Utils.cmp(i, _p31) < 0) {
									var count = _p31 - i;
									var _p22 = A2(_user$project$Utils$split, count, remaining1);
									var r1c = _p22._0;
									var r1t = _p22._1;
									var _p23 = A2(_user$project$Utils$split, count, remaining2);
									var r2c = _p23._0;
									var r2t = _p23._1;
									var _v28 = _p31,
										_v29 = ds,
										_v30 = r1t,
										_v31 = r2t,
										_v32 = A3(
										$default,
										{ctor: '_Tuple3', _0: _p34, _1: _p33, _2: _p32},
										r1c,
										r2c);
									i = _v28;
									ds = _v29;
									remaining1 = _v30;
									remaining2 = _v31;
									_p19 = _v32;
									continue aux;
								} else {
									if (_elm_lang$core$Native_Utils.cmp(i, _p31) > 0) {
										return _elm_lang$core$Result$Err('Unexpected mismatch in HTMLParser.unparseList');
									} else {
										var _p24 = _p21._0._1;
										switch (_p24.ctor) {
											case 'ListElemInsert':
												var _p25 = A2(_user$project$Utils$split, _p24._0, remaining2);
												var newElems = _p25._0;
												var remaining22 = _p25._1;
												var newStr = A2(
													_elm_lang$core$String$join,
													'',
													A2(_elm_lang$core$List$map, defaultUnparser, newElems));
												var _v34 = i,
													_v35 = _p30,
													_v36 = remaining1,
													_v37 = remaining22,
													_v38 = {
													ctor: '_Tuple3',
													_0: A2(_elm_lang$core$Basics_ops['++'], _p34, newStr),
													_1: _p33,
													_2: A2(
														_elm_lang$core$Basics_ops['++'],
														_p32,
														{
															ctor: '::',
															_0: A3(
																_user$project$Lang$StringUpdate,
																_p33,
																_p33,
																_elm_lang$core$String$length(newStr)),
															_1: {ctor: '[]'}
														})
												};
												i = _v34;
												ds = _v35;
												remaining1 = _v36;
												remaining2 = _v37;
												_p19 = _v38;
												continue aux;
											case 'ListElemDelete':
												var _p27 = _p24._0;
												var _p26 = A2(_user$project$Utils$split, _p27, remaining1);
												var oldElems = _p26._0;
												var remaining12 = _p26._1;
												var oldStr = A2(
													_elm_lang$core$String$join,
													'',
													A2(_elm_lang$core$List$map, defaultUnparser, oldElems));
												var lengthOldStr = _elm_lang$core$String$length(oldStr);
												var _v39 = i + _p27,
													_v40 = _p30,
													_v41 = remaining12,
													_v42 = remaining2,
													_v43 = {
													ctor: '_Tuple3',
													_0: _p34,
													_1: _p33 + lengthOldStr,
													_2: A2(
														_elm_lang$core$Basics_ops['++'],
														_p32,
														{
															ctor: '::',
															_0: A3(_user$project$Lang$StringUpdate, _p33, _p33 + lengthOldStr, 0),
															_1: {ctor: '[]'}
														})
												};
												i = _v39;
												ds = _v40;
												remaining1 = _v41;
												remaining2 = _v42;
												_p19 = _v43;
												continue aux;
											default:
												var _p28 = {ctor: '_Tuple2', _0: remaining1, _1: remaining2};
												if (((_p28.ctor === '_Tuple2') && (_p28._0.ctor === '::')) && (_p28._1.ctor === '::')) {
													var _p29 = A4(
														subUnparserDiff,
														_p28._0._0,
														_p28._1._0,
														_p33,
														_elm_lang$core$Maybe$Just(_p24._0));
													if (_p29.ctor === 'Err') {
														return _elm_lang$core$Result$Err(_p29._0);
													} else {
														var _v46 = i + 1,
															_v47 = _p30,
															_v48 = _p28._0._1,
															_v49 = _p28._1._1,
															_v50 = {
															ctor: '_Tuple3',
															_0: A2(_elm_lang$core$Basics_ops['++'], _p34, _p29._0._0),
															_1: _p29._0._1,
															_2: A2(_elm_lang$core$Basics_ops['++'], _p32, _p29._0._2)
														};
														i = _v46;
														ds = _v47;
														remaining1 = _v48;
														remaining2 = _v49;
														_p19 = _v50;
														continue aux;
													}
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'Expected non-empty lists, got ',
															_elm_lang$core$Basics$toString(
																{ctor: '_Tuple2', _0: remaining1, _1: remaining2})));
												}
										}
									}
								}
							}
						}
					});
				return A5(
					aux,
					0,
					_p18._0._0,
					list1,
					list2,
					{
						ctor: '_Tuple3',
						_0: '',
						_1: offset,
						_2: {ctor: '[]'}
					});
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected VListDiffs, got ',
						_elm_lang$core$Basics$toString(_p18._0)));
			}
		}
	});
var _user$project$HTMLParser$unparseConstructor = F4(
	function (tagName, offset, tDiffs, unparsers) {
		var aux = F4(
			function (i, tDiffs, unparsers, _p35) {
				aux:
				while (true) {
					var _p36 = _p35;
					var _p47 = _p36._0;
					var _p46 = _p36._1;
					var _p45 = _p36._2;
					var _p37 = tDiffs;
					if (_p37.ctor === '[]') {
						var _p38 = unparsers;
						if (_p38.ctor === '[]') {
							return _elm_lang$core$Result$Ok(
								{ctor: '_Tuple3', _0: _p47, _1: _p46, _2: _p45});
						} else {
							if (_p38._0.ctor === 'UnparseSymbol') {
								var _p39 = _p38._0._0;
								var _v54 = i,
									_v55 = tDiffs,
									_v56 = _p38._1,
									_v57 = {
									ctor: '_Tuple3',
									_0: A2(_elm_lang$core$Basics_ops['++'], _p47, _p39),
									_1: _p46 + _elm_lang$core$String$length(_p39),
									_2: _p45
								};
								i = _v54;
								tDiffs = _v55;
								unparsers = _v56;
								_p35 = _v57;
								continue aux;
							} else {
								var _p40 = A2(_p38._0._0, _p46, _elm_lang$core$Maybe$Nothing);
								if (_p40.ctor === 'Err') {
									return _elm_lang$core$Result$Err(_p40._0);
								} else {
									var _v59 = i + 1,
										_v60 = {ctor: '[]'},
										_v61 = _p38._1,
										_v62 = {
										ctor: '_Tuple3',
										_0: A2(_elm_lang$core$Basics_ops['++'], _p47, _p40._0._0),
										_1: _p40._0._1,
										_2: A2(_elm_lang$core$Basics_ops['++'], _p45, _p40._0._2)
									};
									i = _v59;
									tDiffs = _v60;
									unparsers = _v61;
									_p35 = _v62;
									continue aux;
								}
							}
						}
					} else {
						var _p44 = _p37._0._0;
						var _p41 = unparsers;
						if (_p41.ctor === '[]') {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Unexpected end in unparseConstructor ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(_p46),
										_elm_lang$core$Basics$toString(tDiffs))));
						} else {
							if (_p41._0.ctor === 'UnparseSymbol') {
								var _p42 = _p41._0._0;
								var _v64 = i,
									_v65 = tDiffs,
									_v66 = _p41._1,
									_v67 = {
									ctor: '_Tuple3',
									_0: A2(_elm_lang$core$Basics_ops['++'], _p47, _p42),
									_1: _p46 + _elm_lang$core$String$length(_p42),
									_2: _p45
								};
								i = _v64;
								tDiffs = _v65;
								unparsers = _v66;
								_p35 = _v67;
								continue aux;
							} else {
								if (_elm_lang$core$Native_Utils.cmp(_p44, i) > -1) {
									var _p43 = A2(
										_p41._0._0,
										_p46,
										_elm_lang$core$Native_Utils.eq(_p44, i) ? _elm_lang$core$Maybe$Just(_p37._0._1) : _elm_lang$core$Maybe$Nothing);
									if (_p43.ctor === 'Err') {
										return _elm_lang$core$Result$Err(_p43._0);
									} else {
										var _v69 = i + 1,
											_v70 = _elm_lang$core$Native_Utils.eq(_p44, i) ? _p37._1 : tDiffs,
											_v71 = _p41._1,
											_v72 = {
											ctor: '_Tuple3',
											_0: A2(_elm_lang$core$Basics_ops['++'], _p47, _p43._0._0),
											_1: _p43._0._1,
											_2: A2(_elm_lang$core$Basics_ops['++'], _p45, _p43._0._2)
										};
										i = _v69;
										tDiffs = _v70;
										unparsers = _v71;
										_p35 = _v72;
										continue aux;
									}
								} else {
									return _elm_lang$core$Result$Err('[internal error] HTMLParser j is < than i, we are missing something ');
								}
							}
						}
					}
				}
			});
		return A4(
			aux,
			0,
			tDiffs,
			unparsers,
			{
				ctor: '_Tuple3',
				_0: '',
				_1: offset,
				_2: {ctor: '[]'}
			});
	});
var _user$project$HTMLParser$contructorVDiffs = function (vdiffs) {
	var _p48 = vdiffs;
	switch (_p48.ctor) {
		case 'VConstDiffs':
			return _elm_lang$core$Result$Ok(
				{ctor: '[]'});
		case 'VRecordDiffs':
			var _p52 = _p48._0;
			var _p49 = A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorArgs, _p52);
			if (_p49.ctor === 'Nothing') {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$ctorArgs,
						A2(
							_elm_lang$core$Basics_ops['++'],
							' not found in ',
							_elm_lang$core$Basics$toString(_p52))));
			} else {
				if (_p49._0.ctor === 'VRecordDiffs') {
					return _user$project$Utils$projOk(
						A2(
							_elm_lang$core$List$map,
							function (_p50) {
								var _p51 = _p50;
								return A2(
									_elm_lang$core$Result$map,
									function (i) {
										return {ctor: '_Tuple2', _0: i - 1, _1: _p51._1};
									},
									_user$project$Lang$nameToArg(_p51._0));
							},
							_elm_lang$core$Dict$toList(_p49._0._0)));
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Expected a datatype constructor vdiffs (nested VRecordDiffs), got ',
							_elm_lang$core$Basics$toString(vdiffs)));
				}
			}
		default:
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a datatype constructor vdiffs (nested VRecordDiffs), got ',
					_elm_lang$core$Basics$toString(vdiffs)));
	}
};
var _user$project$HTMLParser$unparseTagName = function (tagName) {
	var _p53 = tagName;
	if (_p53.ctor === 'HTMLTagString') {
		return _p53._0.val;
	} else {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'[internal error] Don\'t know how to unparse ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$Basics$toString(tagName),
				' as a tagname'));
	}
};
var _user$project$HTMLParser$unparseCommentStyle = function (style) {
	var _p54 = style;
	switch (_p54.ctor) {
		case 'Less_Greater':
			var _p56 = _p54._0;
			return (A2(_elm_lang$core$String$startsWith, '?', _p56) && (!A2(_elm_lang$core$String$contains, '>', _p56))) ? A2(
				_elm_lang$core$Basics_ops['++'],
				'<',
				A2(_elm_lang$core$Basics_ops['++'], _p56, '>')) : A2(
				_elm_lang$core$Basics_ops['++'],
				'<!--',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A4(
						_elm_lang$core$Regex$replace,
						_elm_lang$core$Regex$All,
						_elm_lang$core$Regex$regex('-->'),
						function (_p55) {
							return '~~>';
						},
						_p56),
					'-->'));
		case 'LessSlash_Greater':
			var _p58 = _p54._0;
			return (A2(_elm_lang$core$String$startsWith, ' ', _p58) && (!A2(_elm_lang$core$String$contains, '>', _p58))) ? A2(
				_elm_lang$core$Basics_ops['++'],
				'</',
				A2(_elm_lang$core$Basics_ops['++'], _p58, '>')) : A2(
				_elm_lang$core$Basics_ops['++'],
				'<!--',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A4(
						_elm_lang$core$Regex$replace,
						_elm_lang$core$Regex$All,
						_elm_lang$core$Regex$regex('-->'),
						function (_p57) {
							return '~~>';
						},
						_p58),
					'-->'));
		case 'LessBang_Greater':
			var _p60 = _p54._0;
			return (A2(_elm_lang$core$String$startsWith, '--', _p60) && (!A2(_elm_lang$core$String$contains, '-->', _p60))) ? A2(
				_elm_lang$core$Basics_ops['++'],
				'<!',
				A2(_elm_lang$core$Basics_ops['++'], _p60, '>')) : A2(
				_elm_lang$core$Basics_ops['++'],
				'<!--',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A4(
						_elm_lang$core$Regex$replace,
						_elm_lang$core$Regex$All,
						_elm_lang$core$Regex$regex('-->'),
						function (_p59) {
							return '~~>';
						},
						_p60),
					'-->'));
		default:
			var _p62 = _p54._0;
			return (!A2(_elm_lang$core$String$contains, '-->', _p62)) ? A2(
				_elm_lang$core$Basics_ops['++'],
				'<!--',
				A2(_elm_lang$core$Basics_ops['++'], _p62, '-->')) : A2(
				_elm_lang$core$Basics_ops['++'],
				'<!--',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A4(
						_elm_lang$core$Regex$replace,
						_elm_lang$core$Regex$All,
						_elm_lang$core$Regex$regex('-->'),
						function (_p61) {
							return '~~>';
						},
						_p62),
					'-->'));
	}
};
var _user$project$HTMLParser$unparseEndOp = F2(
	function (endOp, closing) {
		var _p63 = endOp;
		if (_p63.ctor === 'RegularEndOpening') {
			var _p64 = closing;
			if (_p64.ctor === 'AutoClosing') {
				return '/';
			} else {
				return '';
			}
		} else {
			return '/';
		}
	});
var _user$project$HTMLParser$interpretAttrValueStringElem = function (elem) {
	var _p65 = elem.val;
	if (_p65.ctor === 'HTMLAttributeStringRaw') {
		return _p65._0;
	} else {
		return _p65._0;
	}
};
var _user$project$HTMLParser$interpretAttrValueContent = function (content) {
	return A2(
		_elm_lang$core$String$join,
		'',
		A2(_elm_lang$core$List$map, _user$project$HTMLParser$interpretAttrValueStringElem, content));
};
var _user$project$HTMLParser$unparseAttrValueStringElem = function (elem) {
	var _p66 = elem.val;
	if (_p66.ctor === 'HTMLAttributeStringRaw') {
		return _p66._0;
	} else {
		return _p66._1;
	}
};
var _user$project$HTMLParser$unparseAttrValueContent = function (content) {
	return A2(
		_elm_lang$core$String$join,
		'',
		A2(_elm_lang$core$List$map, _user$project$HTMLParser$unparseAttrValueStringElem, content));
};
var _user$project$HTMLParser$unparseAttrValue = function (value) {
	var _p67 = value.val;
	switch (_p67.ctor) {
		case 'HTMLAttributeUnquoted':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p67._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'=',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p67._1.val,
						_user$project$HTMLParser$unparseAttrValueContent(_p67._2))));
		case 'HTMLAttributeString':
			var _p68 = _p67._2;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p67._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'=',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p67._1.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p68,
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$HTMLParser$unparseAttrValueContent(_p67._3),
								_p68)))));
		case 'HTMLAttributeNoValue':
			return '';
		default:
			return '[Internal error] Don\'t know how to unparse an HTMLAttributeExp here';
	}
};
var _user$project$HTMLParser$unparseAttr = function (a) {
	var _p69 = a.val;
	if (_p69.ctor === 'HTMLAttribute') {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			_p69._0.val,
			A2(
				_elm_lang$core$Basics_ops['++'],
				_p69._1.val,
				_user$project$HTMLParser$unparseAttrValue(_p69._2)));
	} else {
		return '[Internal error] Don\'t know how to unparse an HTMLAttributeListExp here';
	}
};
var _user$project$HTMLParser$incompatible_p_children = _MikaelMayer$parser$Parser$oneOf(
	A2(
		_elm_lang$core$List$map,
		_MikaelMayer$parser$Parser$symbol,
		{
			ctor: '::',
			_0: 'address',
			_1: {
				ctor: '::',
				_0: 'article',
				_1: {
					ctor: '::',
					_0: 'aside',
					_1: {
						ctor: '::',
						_0: 'blockquote',
						_1: {
							ctor: '::',
							_0: 'details',
							_1: {
								ctor: '::',
								_0: 'div',
								_1: {
									ctor: '::',
									_0: 'dl',
									_1: {
										ctor: '::',
										_0: 'fieldset',
										_1: {
											ctor: '::',
											_0: 'figcaption',
											_1: {
												ctor: '::',
												_0: 'figure',
												_1: {
													ctor: '::',
													_0: 'footer',
													_1: {
														ctor: '::',
														_0: 'form',
														_1: {
															ctor: '::',
															_0: 'h1',
															_1: {
																ctor: '::',
																_0: 'h2',
																_1: {
																	ctor: '::',
																	_0: 'h3',
																	_1: {
																		ctor: '::',
																		_0: 'h4',
																		_1: {
																			ctor: '::',
																			_0: 'h5',
																			_1: {
																				ctor: '::',
																				_0: 'h6',
																				_1: {
																					ctor: '::',
																					_0: 'header',
																					_1: {
																						ctor: '::',
																						_0: 'hgroup',
																						_1: {
																							ctor: '::',
																							_0: 'hr',
																							_1: {
																								ctor: '::',
																								_0: 'main',
																								_1: {
																									ctor: '::',
																									_0: 'menu',
																									_1: {
																										ctor: '::',
																										_0: 'nav',
																										_1: {
																											ctor: '::',
																											_0: 'ol',
																											_1: {
																												ctor: '::',
																												_0: 'p',
																												_1: {
																													ctor: '::',
																													_0: 'pre',
																													_1: {
																														ctor: '::',
																														_0: 'section',
																														_1: {
																															ctor: '::',
																															_0: 'table',
																															_1: {
																																ctor: '::',
																																_0: 'ul',
																																_1: {ctor: '[]'}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}));
var _user$project$HTMLParser$childrenIncompatibleWith = function (tagName) {
	var _p70 = tagName;
	if (_p70 === 'p') {
		return A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$succeed(
						{ctor: '_Tuple0'}),
					_MikaelMayer$parser$Parser$symbol('<')),
				_user$project$HTMLParser$incompatible_p_children),
			_user$project$LangParserUtils$spaces);
	} else {
		return _MikaelMayer$parser$Parser$fail('No child incompatible with this');
	}
};
var _user$project$HTMLParser$nodeStart = A2(
	_MikaelMayer$parser$Parser$delayedCommit,
	_MikaelMayer$parser$Parser$symbol('<'),
	A2(
		_MikaelMayer$parser$Parser$keep,
		_MikaelMayer$parser$Parser$oneOrMore,
		function (c) {
			return (!_user$project$LangParserUtils$isSpace(c)) && ((!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('/'))) && ((!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('>'))) && ((!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('!'))) && (!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('?'))))));
		}));
var _user$project$HTMLParser$letterRegex = _elm_lang$core$Regex$regex('^[a-zA-Z]$');
var _user$project$HTMLParser$isLetter = function (c) {
	return A2(
		_elm_lang$core$Regex$contains,
		_user$project$HTMLParser$letterRegex,
		_elm_lang$core$String$fromChar(c));
};
var _user$project$HTMLParser$parseTagName = A2(
	_MikaelMayer$parser$Parser_ops['|='],
	A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(
			F2(
				function (a, b) {
					return A2(_elm_lang$core$Basics_ops['++'], a, b);
				})),
		A2(
			_MikaelMayer$parser$Parser$keep,
			_MikaelMayer$parser$Parser$Exactly(1),
			_user$project$HTMLParser$isLetter)),
	A2(
		_MikaelMayer$parser$Parser$keep,
		_MikaelMayer$parser$Parser$zeroOrMore,
		function (c) {
			return (!_user$project$LangParserUtils$isSpace(c)) && ((!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('/'))) && (!_elm_lang$core$Native_Utils.eq(
				c,
				_elm_lang$core$Native_Utils.chr('>'))));
		}));
var _user$project$HTMLParser$parseHtmlAttributeName = A2(
	_MikaelMayer$parser$Parser$inContext,
	'HTML attribute name',
	_user$project$ParserUtils$trackInfo(
		A3(
			_MikaelMayer$parser$Parser_LanguageKit$variable,
			function (c) {
				return (!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('>'))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('<'))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr(','))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('/'))) && (!_user$project$LangParserUtils$isSpace(c)))));
			},
			function (c) {
				return (!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('>'))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('<'))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr(','))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('/'))) && ((!_elm_lang$core$Native_Utils.eq(
					c,
					_elm_lang$core$Native_Utils.chr('='))) && (!_user$project$LangParserUtils$isSpace(c))))));
			},
			_elm_lang$core$Set$fromList(
				{ctor: '[]'}))));
var _user$project$HTMLParser$attributeSpaces = _user$project$ParserUtils$trackInfo(
	A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(
			function (chars) {
				return A2(_elm_lang$core$String$join, '', chars);
			}),
		A2(
			_MikaelMayer$parser$Parser$repeat,
			_MikaelMayer$parser$Parser$zeroOrMore,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser$keep,
						_MikaelMayer$parser$Parser$Exactly(1),
						_user$project$LangParserUtils$isSpace),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser$delayedCommit,
							_user$project$ParserUtils$negativeLookAhead(
								_MikaelMayer$parser$Parser$symbol('/>')),
							_MikaelMayer$parser$Parser$source(
								_MikaelMayer$parser$Parser$symbol('/'))),
						_1: {ctor: '[]'}
					}
				}))));
var _user$project$HTMLParser$svgTagNames = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'a',
		_1: {
			ctor: '::',
			_0: 'altGlyph',
			_1: {
				ctor: '::',
				_0: 'altGlyphDef',
				_1: {
					ctor: '::',
					_0: 'altGlyphItem',
					_1: {
						ctor: '::',
						_0: 'animate',
						_1: {
							ctor: '::',
							_0: 'animateColor',
							_1: {
								ctor: '::',
								_0: 'animateMotion',
								_1: {
									ctor: '::',
									_0: 'animateTransform',
									_1: {
										ctor: '::',
										_0: 'circle',
										_1: {
											ctor: '::',
											_0: 'clipPath',
											_1: {
												ctor: '::',
												_0: 'color-profile',
												_1: {
													ctor: '::',
													_0: 'cursor',
													_1: {
														ctor: '::',
														_0: 'defs',
														_1: {
															ctor: '::',
															_0: 'desc',
															_1: {
																ctor: '::',
																_0: 'discard',
																_1: {
																	ctor: '::',
																	_0: 'ellipse',
																	_1: {
																		ctor: '::',
																		_0: 'feBlend',
																		_1: {
																			ctor: '::',
																			_0: 'feColorMatrix',
																			_1: {
																				ctor: '::',
																				_0: 'feComponentTransfer',
																				_1: {
																					ctor: '::',
																					_0: 'feComposite',
																					_1: {
																						ctor: '::',
																						_0: 'feConvolveMatrix',
																						_1: {
																							ctor: '::',
																							_0: 'feDiffuseLighting',
																							_1: {
																								ctor: '::',
																								_0: 'feDisplacementMap',
																								_1: {
																									ctor: '::',
																									_0: 'feDistantLight',
																									_1: {
																										ctor: '::',
																										_0: 'feDropShadow',
																										_1: {
																											ctor: '::',
																											_0: 'feFlood',
																											_1: {
																												ctor: '::',
																												_0: 'feFuncA',
																												_1: {
																													ctor: '::',
																													_0: 'feFuncB',
																													_1: {
																														ctor: '::',
																														_0: 'feFuncG',
																														_1: {
																															ctor: '::',
																															_0: 'feFuncR',
																															_1: {
																																ctor: '::',
																																_0: 'feGaussianBlur',
																																_1: {
																																	ctor: '::',
																																	_0: 'feImage',
																																	_1: {
																																		ctor: '::',
																																		_0: 'feMerge',
																																		_1: {
																																			ctor: '::',
																																			_0: 'feMergeNode',
																																			_1: {
																																				ctor: '::',
																																				_0: 'feMorphology',
																																				_1: {
																																					ctor: '::',
																																					_0: 'feOffset',
																																					_1: {
																																						ctor: '::',
																																						_0: 'fePointLight',
																																						_1: {
																																							ctor: '::',
																																							_0: 'feSpecularLighting',
																																							_1: {
																																								ctor: '::',
																																								_0: 'feSpotLight',
																																								_1: {
																																									ctor: '::',
																																									_0: 'feTile',
																																									_1: {
																																										ctor: '::',
																																										_0: 'feTurbulence',
																																										_1: {
																																											ctor: '::',
																																											_0: 'filter',
																																											_1: {
																																												ctor: '::',
																																												_0: 'font',
																																												_1: {
																																													ctor: '::',
																																													_0: 'font-face',
																																													_1: {
																																														ctor: '::',
																																														_0: 'font-face-format',
																																														_1: {
																																															ctor: '::',
																																															_0: 'font-face-name',
																																															_1: {
																																																ctor: '::',
																																																_0: 'font-face-src',
																																																_1: {
																																																	ctor: '::',
																																																	_0: 'font-face-uri',
																																																	_1: {
																																																		ctor: '::',
																																																		_0: 'foreignObject',
																																																		_1: {
																																																			ctor: '::',
																																																			_0: 'g',
																																																			_1: {
																																																				ctor: '::',
																																																				_0: 'glyph',
																																																				_1: {
																																																					ctor: '::',
																																																					_0: 'glyphRef',
																																																					_1: {
																																																						ctor: '::',
																																																						_0: 'hatch',
																																																						_1: {
																																																							ctor: '::',
																																																							_0: 'hatchpath',
																																																							_1: {
																																																								ctor: '::',
																																																								_0: 'hkern',
																																																								_1: {
																																																									ctor: '::',
																																																									_0: 'image',
																																																									_1: {
																																																										ctor: '::',
																																																										_0: 'line',
																																																										_1: {
																																																											ctor: '::',
																																																											_0: 'linearGradient',
																																																											_1: {
																																																												ctor: '::',
																																																												_0: 'marker',
																																																												_1: {
																																																													ctor: '::',
																																																													_0: 'mask',
																																																													_1: {
																																																														ctor: '::',
																																																														_0: 'mesh',
																																																														_1: {
																																																															ctor: '::',
																																																															_0: 'meshgradient',
																																																															_1: {
																																																																ctor: '::',
																																																																_0: 'meshpatch',
																																																																_1: {
																																																																	ctor: '::',
																																																																	_0: 'meshrow',
																																																																	_1: {
																																																																		ctor: '::',
																																																																		_0: 'metadata',
																																																																		_1: {
																																																																			ctor: '::',
																																																																			_0: 'missing-glyph',
																																																																			_1: {
																																																																				ctor: '::',
																																																																				_0: 'mpath',
																																																																				_1: {
																																																																					ctor: '::',
																																																																					_0: 'path',
																																																																					_1: {
																																																																						ctor: '::',
																																																																						_0: 'pattern',
																																																																						_1: {
																																																																							ctor: '::',
																																																																							_0: 'polygon',
																																																																							_1: {
																																																																								ctor: '::',
																																																																								_0: 'polyline',
																																																																								_1: {
																																																																									ctor: '::',
																																																																									_0: 'radialGradient',
																																																																									_1: {
																																																																										ctor: '::',
																																																																										_0: 'rect',
																																																																										_1: {
																																																																											ctor: '::',
																																																																											_0: 'script',
																																																																											_1: {
																																																																												ctor: '::',
																																																																												_0: 'set',
																																																																												_1: {
																																																																													ctor: '::',
																																																																													_0: 'solidcolor',
																																																																													_1: {
																																																																														ctor: '::',
																																																																														_0: 'stop',
																																																																														_1: {
																																																																															ctor: '::',
																																																																															_0: 'style',
																																																																															_1: {
																																																																																ctor: '::',
																																																																																_0: 'svg',
																																																																																_1: {
																																																																																	ctor: '::',
																																																																																	_0: 'switch',
																																																																																	_1: {
																																																																																		ctor: '::',
																																																																																		_0: 'symbol',
																																																																																		_1: {
																																																																																			ctor: '::',
																																																																																			_0: 'text',
																																																																																			_1: {
																																																																																				ctor: '::',
																																																																																				_0: 'textPath',
																																																																																				_1: {
																																																																																					ctor: '::',
																																																																																					_0: 'title',
																																																																																					_1: {
																																																																																						ctor: '::',
																																																																																						_0: 'tref',
																																																																																						_1: {
																																																																																							ctor: '::',
																																																																																							_0: 'tspan',
																																																																																							_1: {
																																																																																								ctor: '::',
																																																																																								_0: 'unknown',
																																																																																								_1: {
																																																																																									ctor: '::',
																																																																																									_0: 'use',
																																																																																									_1: {
																																																																																										ctor: '::',
																																																																																										_0: 'view',
																																																																																										_1: {
																																																																																											ctor: '::',
																																																																																											_0: 'vkern',
																																																																																											_1: {ctor: '[]'}
																																																																																										}
																																																																																									}
																																																																																								}
																																																																																							}
																																																																																						}
																																																																																					}
																																																																																				}
																																																																																			}
																																																																																		}
																																																																																	}
																																																																																}
																																																																															}
																																																																														}
																																																																													}
																																																																												}
																																																																											}
																																																																										}
																																																																									}
																																																																								}
																																																																							}
																																																																						}
																																																																					}
																																																																				}
																																																																			}
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$HTMLParser$possiblyAutoClosingElements = _user$project$HTMLParser$svgTagNames;
var _user$project$HTMLParser$isPossiblyAutoClosing = function (s) {
	return A2(
		_elm_lang$core$Set$member,
		_elm_lang$core$String$toLower(s),
		_user$project$HTMLParser$svgTagNames);
};
var _user$project$HTMLParser$isForeignElement = function (s) {
	var s2 = _elm_lang$core$String$toLower(s);
	return _elm_lang$core$Native_Utils.eq(s, 'math') || _elm_lang$core$Native_Utils.eq(s, 'svg');
};
var _user$project$HTMLParser$voidElements = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'area',
		_1: {
			ctor: '::',
			_0: 'base',
			_1: {
				ctor: '::',
				_0: 'br',
				_1: {
					ctor: '::',
					_0: 'col',
					_1: {
						ctor: '::',
						_0: 'embed',
						_1: {
							ctor: '::',
							_0: 'hr',
							_1: {
								ctor: '::',
								_0: 'img',
								_1: {
									ctor: '::',
									_0: 'input',
									_1: {
										ctor: '::',
										_0: 'link',
										_1: {
											ctor: '::',
											_0: 'meta',
											_1: {
												ctor: '::',
												_0: 'param',
												_1: {
													ctor: '::',
													_0: 'source',
													_1: {
														ctor: '::',
														_0: 'track',
														_1: {
															ctor: '::',
															_0: 'wbr',
															_1: {ctor: '[]'}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$HTMLParser$isVoidElement = function (s) {
	return A2(
		_elm_lang$core$Set$member,
		_elm_lang$core$String$toLower(s),
		_user$project$HTMLParser$voidElements);
};
var _user$project$HTMLParser$unparseClosing = F2(
	function (htmlTag, closing) {
		var _p71 = htmlTag;
		if (_p71.ctor === 'HTMLTagString') {
			var _p73 = _p71._0;
			var _p72 = closing;
			switch (_p72.ctor) {
				case 'RegularClosing':
					return _user$project$HTMLParser$isVoidElement(_p73.val) ? '' : A2(
						_elm_lang$core$Basics_ops['++'],
						'</',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p73.val,
							A2(_elm_lang$core$Basics_ops['++'], _p72._0.val, '>')));
				case 'VoidClosing':
					return '';
				case 'AutoClosing':
					return '';
				case 'ForgotClosing':
					return '';
				default:
					return '';
			}
		} else {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'Don\'t know how to unparse tag ',
				_elm_lang$core$Basics$toString(htmlTag));
		}
	});
var _user$project$HTMLParser$unparseNode = function (node) {
	var _p74 = node.val;
	switch (_p74.ctor) {
		case 'HTMLInner':
			return _p74._0;
		case 'HTMLEntity':
			return _p74._1;
		case 'HTMLElement':
			var _p76 = _p74._0;
			var _p75 = _p74._5;
			var tagNameStr = _user$project$HTMLParser$unparseTagName(_p76);
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'<',
				A2(
					_elm_lang$core$Basics_ops['++'],
					tagNameStr,
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$String$join,
							'',
							A2(_elm_lang$core$List$map, _user$project$HTMLParser$unparseAttr, _p74._1)),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p74._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_user$project$HTMLParser$unparseEndOp, _p74._3, _p75),
								A2(
									_elm_lang$core$Basics_ops['++'],
									'>',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$String$join,
											'',
											A2(_elm_lang$core$List$map, _user$project$HTMLParser$unparseNode, _p74._4)),
										A2(_user$project$HTMLParser$unparseClosing, _p76, _p75))))))));
		case 'HTMLComment':
			return _user$project$HTMLParser$unparseCommentStyle(_p74._0);
		default:
			return '[Internal error] Don\'t know how to unparse an HTMLListNodeExp here';
	}
};
var _user$project$HTMLParser$unparseHtmlNodes = function (nodes) {
	return A2(
		_elm_lang$core$String$join,
		'',
		A2(_elm_lang$core$List$map, _user$project$HTMLParser$unparseNode, nodes));
};
var _user$project$HTMLParser$entityToString = function (entity) {
	var _p77 = A3(
		_elm_lang$core$Regex$find,
		_elm_lang$core$Regex$AtMost(1),
		_elm_lang$core$Regex$regex('^&#x0*([a-fA-F0-9]+);?$'),
		entity);
	if ((_p77.ctor === '::') && (_p77._1.ctor === '[]')) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			entity,
			A2(
				_elm_lang$core$Maybe$andThen,
				function (hex) {
					return _user$project$ImpureGoodies$fromHtmlEntity(
						A2(_elm_lang$core$Basics_ops['++'], 'x', hex));
				},
				A2(
					_elm_lang$core$Maybe$andThen,
					_elm_lang$core$Basics$identity,
					_elm_lang$core$List$head(_p77._0.submatches))));
	} else {
		var _p78 = A3(
			_elm_lang$core$Regex$find,
			_elm_lang$core$Regex$AtMost(1),
			_elm_lang$core$Regex$regex('^&#0*([0-9]+);?$'),
			entity);
		if ((_p78.ctor === '::') && (_p78._1.ctor === '[]')) {
			return A2(
				_elm_lang$core$Maybe$withDefault,
				entity,
				A2(
					_elm_lang$core$Maybe$andThen,
					function (dec) {
						return _user$project$ImpureGoodies$fromHtmlEntity(dec);
					},
					A2(
						_elm_lang$core$Maybe$andThen,
						_elm_lang$core$Basics$identity,
						_elm_lang$core$List$head(_p78._0.submatches))));
		} else {
			var _p79 = A3(
				_elm_lang$core$Regex$find,
				_elm_lang$core$Regex$AtMost(1),
				_elm_lang$core$Regex$regex('^(&\\w+;?)$'),
				entity);
			if ((_p79.ctor === '::') && (_p79._1.ctor === '[]')) {
				return A2(
					_elm_lang$core$Maybe$withDefault,
					entity,
					A2(
						_elm_lang$core$Maybe$andThen,
						function (name) {
							return _user$project$ImpureGoodies$fromHtmlEntity(name);
						},
						A2(
							_elm_lang$core$Maybe$andThen,
							_elm_lang$core$Basics$identity,
							_elm_lang$core$List$head(_p79._0.submatches))));
			} else {
				var _p80 = A3(
					_elm_lang$core$Regex$find,
					_elm_lang$core$Regex$AtMost(1),
					_elm_lang$core$Regex$regex('^</[\\s\\S]*>?$'),
					entity);
				if ((_p80.ctor === '::') && (_p80._1.ctor === '[]')) {
					return '';
				} else {
					return entity;
				}
			}
		}
	}
};
var _user$project$HTMLParser$parseHTMLEntity = F2(
	function (insideAttribute, untilEndTagNames) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'HTML entity',
			_user$project$ParserUtils$trackInfo(
				_MikaelMayer$parser$Parser$oneOf(
					A2(
						_elm_lang$core$Basics_ops['++'],
						(!insideAttribute) ? {
							ctor: '::',
							_0: A3(
								_MikaelMayer$parser$Parser$delayedCommitAndThen,
								F2(
									function (_p81, wrongClosingTag) {
										return _elm_lang$core$Result$Ok(
											{ctor: '_Tuple2', _0: '', _1: wrongClosingTag});
									}),
								_MikaelMayer$parser$Parser$source(
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$symbol('</'),
												_user$project$HTMLParser$parseTagName),
											A2(
												_MikaelMayer$parser$Parser$keep,
												_MikaelMayer$parser$Parser$zeroOrMore,
												function (c) {
													return !_elm_lang$core$Native_Utils.eq(
														c,
														_elm_lang$core$Native_Utils.chr('>'));
												})),
										_user$project$ParserUtils$optional(
											_MikaelMayer$parser$Parser$symbol('>')))),
								function (endTagName) {
									var tagNamesRegex = A2(
										_elm_lang$core$String$join,
										'|',
										A2(
											_elm_lang$core$List$map,
											function (et) {
												return A2(
													_elm_lang$core$Basics_ops['++'],
													'</',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Regex$escape(et),
														'\\s*>'));
											},
											untilEndTagNames));
									return A2(
										_elm_lang$core$Regex$contains,
										_elm_lang$core$Regex$regex(tagNamesRegex),
										endTagName) ? _MikaelMayer$parser$Parser$fail('it\'s a true closing tag') : _MikaelMayer$parser$Parser$succeed(endTagName);
								}),
							_1: {ctor: '[]'}
						} : {ctor: '[]'},
						{
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
									_MikaelMayer$parser$Parser$symbol('&')),
								A2(
									_MikaelMayer$parser$Parser$andThen,
									function (result) {
										var $default = function (matched) {
											return A2(
												_MikaelMayer$parser$Parser$map,
												function (x) {
													return _elm_lang$core$Result$Ok(
														{
															ctor: '_Tuple2',
															_0: _user$project$HTMLParser$entityToString(
																A2(_elm_lang$core$Basics_ops['++'], '&', x)),
															_1: A2(_elm_lang$core$Basics_ops['++'], '&', x)
														});
												},
												_MikaelMayer$parser$Parser$source(
													_MikaelMayer$parser$Parser$symbol(matched)));
										};
										if (A2(_elm_lang$core$String$startsWith, '#', result)) {
											return $default(result);
										} else {
											var aux = function (matched) {
												aux:
												while (true) {
													if (_elm_lang$core$Native_Utils.eq(matched, '')) {
														return _MikaelMayer$parser$Parser$succeed(
															_elm_lang$core$Result$Err('&'));
													} else {
														var _p82 = _user$project$ImpureGoodies$fromHtmlEntity(
															A2(_elm_lang$core$Basics_ops['++'], '&', matched));
														if (_p82.ctor === 'Nothing') {
															var _v93 = A2(
																_elm_lang$core$String$left,
																_elm_lang$core$String$length(matched) - 1,
																matched);
															matched = _v93;
															continue aux;
														} else {
															var lastChar = A2(_elm_lang$core$String$right, 1, matched);
															return (insideAttribute && (!_elm_lang$core$Native_Utils.eq(lastChar, ';'))) ? _MikaelMayer$parser$Parser$oneOf(
																{
																	ctor: '::',
																	_0: A2(
																		_MikaelMayer$parser$Parser_ops['|='],
																		A2(
																			_MikaelMayer$parser$Parser_ops['|.'],
																			_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
																			_user$project$ParserUtils$lookAhead(
																				A3(
																					_MikaelMayer$parser$Parser$delayedCommitMap,
																					F2(
																						function (a, b) {
																							return {ctor: '_Tuple0'};
																						}),
																					_MikaelMayer$parser$Parser$symbol(matched),
																					A2(
																						_MikaelMayer$parser$Parser$keep,
																						_MikaelMayer$parser$Parser$Exactly(1),
																						function (c) {
																							return _elm_lang$core$Char$isUpper(c) || (_elm_lang$core$Char$isLower(c) || (_elm_lang$core$Char$isDigit(c) || _elm_lang$core$Native_Utils.eq(
																								c,
																								_elm_lang$core$Native_Utils.chr('='))));
																						})))),
																		_MikaelMayer$parser$Parser$succeed(
																			_elm_lang$core$Result$Err('&'))),
																	_1: {
																		ctor: '::',
																		_0: $default(matched),
																		_1: {ctor: '[]'}
																	}
																}) : $default(matched);
														}
													}
												}
											};
											return aux(result);
										}
									},
									_user$project$ParserUtils$lookAhead(
										_MikaelMayer$parser$Parser$source(
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$oneOf(
													{
														ctor: '::',
														_0: A2(
															_MikaelMayer$parser$Parser_ops['|.'],
															_MikaelMayer$parser$Parser$symbol('#x'),
															A2(
																_MikaelMayer$parser$Parser$ignore,
																_MikaelMayer$parser$Parser$AtLeast(1),
																_elm_lang$core$Char$isHexDigit)),
														_1: {
															ctor: '::',
															_0: A2(
																_MikaelMayer$parser$Parser_ops['|.'],
																_MikaelMayer$parser$Parser$symbol('#'),
																A2(
																	_MikaelMayer$parser$Parser$ignore,
																	_MikaelMayer$parser$Parser$AtLeast(1),
																	_elm_lang$core$Char$isDigit)),
															_1: {
																ctor: '::',
																_0: A2(
																	_MikaelMayer$parser$Parser$ignore,
																	_MikaelMayer$parser$Parser$AtLeast(1),
																	function (x) {
																		return _elm_lang$core$Char$isLower(x) || (_elm_lang$core$Char$isUpper(x) || _elm_lang$core$Char$isDigit(x));
																	}),
																_1: {
																	ctor: '::',
																	_0: _MikaelMayer$parser$Parser$succeed(
																		{ctor: '_Tuple0'}),
																	_1: {ctor: '[]'}
																}
															}
														}
													}),
												_user$project$ParserUtils$optional(
													_MikaelMayer$parser$Parser$symbol(';'))))))),
							_1: {ctor: '[]'}
						}))));
	});
var _user$project$HTMLParser$Foreign = {ctor: 'Foreign'};
var _user$project$HTMLParser$HTML = {ctor: 'HTML'};
var _user$project$HTMLParser$HTMLAttributeEntity = F2(
	function (a, b) {
		return {ctor: 'HTMLAttributeEntity', _0: a, _1: b};
	});
var _user$project$HTMLParser$HTMLAttributeStringRaw = function (a) {
	return {ctor: 'HTMLAttributeStringRaw', _0: a};
};
var _user$project$HTMLParser$mergeHTMLAttributeStringRaw = function (children) {
	mergeHTMLAttributeStringRaw:
	while (true) {
		var _p83 = children;
		if ((_p83.ctor === '::') && (_p83._1.ctor === '::')) {
			var _p87 = _p83._1._1;
			var _p86 = _p83._1._0;
			var _p85 = _p83._0;
			var _p84 = {ctor: '_Tuple2', _0: _p85.val, _1: _p86.val};
			if ((_p84.ctor === '_Tuple2') && (_p84._1.ctor === 'HTMLAttributeStringRaw')) {
				if (_p84._0.ctor === 'HTMLAttributeStringRaw') {
					var _v96 = {
						ctor: '::',
						_0: A3(
							_user$project$Info$withInfo,
							_user$project$HTMLParser$HTMLAttributeStringRaw(
								A2(_elm_lang$core$Basics_ops['++'], _p84._0._0, _p84._1._0)),
							_p85.start,
							_p86.end),
						_1: _p87
					};
					children = _v96;
					continue mergeHTMLAttributeStringRaw;
				} else {
					return {
						ctor: '::',
						_0: _p85,
						_1: _user$project$HTMLParser$mergeHTMLAttributeStringRaw(
							{ctor: '::', _0: _p86, _1: _p87})
					};
				}
			} else {
				return {
					ctor: '::',
					_0: _p85,
					_1: {
						ctor: '::',
						_0: _p86,
						_1: _user$project$HTMLParser$mergeHTMLAttributeStringRaw(_p87)
					}
				};
			}
		} else {
			return children;
		}
	}
};
var _user$project$HTMLParser$parseHTMLAttributeStringContent = function (isEndChar) {
	var aux = function (revPreviousElems) {
		return _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A2(
					_MikaelMayer$parser$Parser$andThen,
					function (s) {
						return aux(
							{
								ctor: '::',
								_0: A2(
									_user$project$Info$replaceInfo,
									s,
									_user$project$HTMLParser$HTMLAttributeStringRaw(s.val)),
								_1: revPreviousElems
							});
					},
					_user$project$ParserUtils$trackInfo(
						A2(
							_MikaelMayer$parser$Parser$keep,
							_MikaelMayer$parser$Parser$AtLeast(1),
							function (c) {
								return (!isEndChar(c)) && (!_elm_lang$core$Native_Utils.eq(
									c,
									_elm_lang$core$Native_Utils.chr('&')));
							}))),
				_1: {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser$andThen,
						function (s) {
							var _p88 = s.val;
							if (_p88.ctor === 'Err') {
								return aux(
									{
										ctor: '::',
										_0: A2(
											_user$project$Info$replaceInfo,
											s,
											_user$project$HTMLParser$HTMLAttributeStringRaw(_p88._0)),
										_1: revPreviousElems
									});
							} else {
								return aux(
									{
										ctor: '::',
										_0: A2(
											_user$project$Info$replaceInfo,
											s,
											A2(_user$project$HTMLParser$HTMLAttributeEntity, _p88._0._0, _p88._0._1)),
										_1: revPreviousElems
									});
							}
						},
						A2(
							_user$project$HTMLParser$parseHTMLEntity,
							true,
							{ctor: '[]'})),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$succeed(
							_user$project$HTMLParser$mergeHTMLAttributeStringRaw(
								_elm_lang$core$List$reverse(revPreviousElems))),
						_1: {ctor: '[]'}
					}
				}
			});
	};
	return aux(
		{ctor: '[]'});
};
var _user$project$HTMLParser$parseHTMLAttributeString = A2(
	_MikaelMayer$parser$Parser$andThen,
	function (quoteCharStr) {
		var quoteChar = A2(
			_elm_lang$core$Maybe$withDefault,
			_elm_lang$core$Native_Utils.chr('\"'),
			A2(_user$project$ImpureGoodies$stringCharAt, 0, quoteCharStr));
		return A2(
			_MikaelMayer$parser$Parser$andThen,
			function (l) {
				return A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_MikaelMayer$parser$Parser$symbol(quoteCharStr)),
					_MikaelMayer$parser$Parser$succeed(
						{ctor: '_Tuple2', _0: quoteCharStr, _1: l}));
			},
			_user$project$HTMLParser$parseHTMLAttributeStringContent(
				function (c) {
					return _elm_lang$core$Native_Utils.eq(c, quoteChar);
				}));
	},
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('\"')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$symbol('\'')),
				_1: {ctor: '[]'}
			}
		}));
var _user$project$HTMLParser$HTMLAttributeExp = F4(
	function (a, b, c, d) {
		return {ctor: 'HTMLAttributeExp', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$HTMLParser$HTMLAttributeNoValue = {ctor: 'HTMLAttributeNoValue'};
var _user$project$HTMLParser$HTMLAttributeString = F4(
	function (a, b, c, d) {
		return {ctor: 'HTMLAttributeString', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$HTMLParser$HTMLAttributeUnquoted = F3(
	function (a, b, c) {
		return {ctor: 'HTMLAttributeUnquoted', _0: a, _1: b, _2: c};
	});
var _user$project$HTMLParser$AtAbsent = {ctor: 'AtAbsent'};
var _user$project$HTMLParser$AtPresent = {ctor: 'AtPresent'};
var _user$project$HTMLParser$parseHtmlAttributeValue = function (parsingMode) {
	var _p89 = parsingMode;
	if (_p89.ctor === 'Raw') {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'html raw attribute value',
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F2(
							function (sp1, _p90) {
								var _p91 = _p90;
								return A2(_p91._1, sp1, _p91._0);
							}),
						_user$project$LangParserUtils$spaces,
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (sp2, builder) {
												return {ctor: '_Tuple2', _0: sp2, _1: builder};
											})),
									_MikaelMayer$parser$Parser$symbol('=')),
								_user$project$LangParserUtils$spaces),
							_MikaelMayer$parser$Parser$oneOf(
								{
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser$map,
										F3(
											function (attrString, sp1, sp2) {
												var _p92 = attrString.val;
												var quoteChar = _p92._0;
												var content = _p92._1;
												return A2(
													_user$project$Info$replaceInfo,
													attrString,
													A4(_user$project$HTMLParser$HTMLAttributeString, sp1, sp2, quoteChar, content));
											}),
										_user$project$ParserUtils$trackInfo(_user$project$HTMLParser$parseHTMLAttributeString)),
									_1: {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser$map,
											F3(
												function (contentInfo, sp1, sp2) {
													return A2(
														_user$project$Info$replaceInfo,
														contentInfo,
														A3(_user$project$HTMLParser$HTMLAttributeUnquoted, sp1, sp2, contentInfo.val));
												}),
											_user$project$ParserUtils$trackInfo(
												_user$project$HTMLParser$parseHTMLAttributeStringContent(
													function (c) {
														return _user$project$LangParserUtils$isSpace(c) || _elm_lang$core$Native_Utils.eq(
															c,
															_elm_lang$core$Native_Utils.chr('>'));
													}))),
										_1: {ctor: '[]'}
									}
								}))),
					_1: {
						ctor: '::',
						_0: _user$project$ParserUtils$trackInfo(
							_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$HTMLAttributeNoValue)),
						_1: {ctor: '[]'}
					}
				}));
	} else {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'html interpolatable attribute value',
			_user$project$ParserUtils$trackInfo(
				_MikaelMayer$parser$Parser$oneOf(
					{
						ctor: '::',
						_0: A3(
							_MikaelMayer$parser$Parser$delayedCommitMap,
							F2(
								function (spBeforeEq, builder) {
									return builder(spBeforeEq);
								}),
							_user$project$LangParserUtils$spaces,
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F3(
												function (spAfterEq, _p93, spBeforeEq) {
													var _p94 = _p93;
													return A4(_user$project$HTMLParser$HTMLAttributeExp, spBeforeEq, spAfterEq, _p94._0, _p94._1);
												})),
										_MikaelMayer$parser$Parser$symbol('=')),
									_user$project$LangParserUtils$spaces),
								A2(
									_MikaelMayer$parser$Parser$andThen,
									function (maybeAt) {
										var atPresence = A2(
											_elm_lang$core$Maybe$withDefault,
											_user$project$HTMLParser$AtAbsent,
											A2(
												_elm_lang$core$Maybe$map,
												_elm_lang$core$Basics$always(_user$project$HTMLParser$AtPresent),
												maybeAt));
										return A2(
											_MikaelMayer$parser$Parser$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(atPresence),
											_MikaelMayer$parser$Parser$oneOf(
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Native_Utils.eq(atPresence, _user$project$HTMLParser$AtAbsent) ? {
														ctor: '::',
														_0: A3(
															_MikaelMayer$parser$Parser$delayedCommitMap,
															F2(
																function (x, y) {
																	return y;
																}),
															_user$project$ParserUtils$lookAhead(
																_MikaelMayer$parser$Parser$oneOf(
																	{
																		ctor: '::',
																		_0: _MikaelMayer$parser$Parser$symbol('\"'),
																		_1: {
																			ctor: '::',
																			_0: _MikaelMayer$parser$Parser$symbol('\''),
																			_1: {ctor: '[]'}
																		}
																	})),
															A2(
																_MikaelMayer$parser$Parser_ops['|='],
																A2(
																	_MikaelMayer$parser$Parser_ops['|.'],
																	_MikaelMayer$parser$Parser$succeed(
																		function (attrString) {
																			var _p95 = attrString.val;
																			var quoteChar = _p95._0;
																			var content = _p95._1;
																			var _p96 = A2(_p89._0.attributerawvalue, quoteChar, content);
																			var x = _p96._0;
																			return _elm_lang$core$Native_Utils.update(
																				x,
																				{start: attrString.start, end: attrString.end});
																		}),
																	_user$project$ParserUtils$negativeLookAhead(
																		_MikaelMayer$parser$Parser$symbol('\"\"\"'))),
																_user$project$ParserUtils$trackInfo(_user$project$HTMLParser$parseHTMLAttributeString))),
														_1: {ctor: '[]'}
													} : {ctor: '[]'},
													{
														ctor: '::',
														_0: _p89._0.attributevalue(_user$project$LangParserUtils$nospace),
														_1: {ctor: '[]'}
													})));
									},
									_user$project$ParserUtils$optional(
										_MikaelMayer$parser$Parser$symbol('@'))))),
						_1: {
							ctor: '::',
							_0: _MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$HTMLAttributeNoValue),
							_1: {ctor: '[]'}
						}
					})));
	}
};
var _user$project$HTMLParser$HTMLAttributeListExp = F2(
	function (a, b) {
		return {ctor: 'HTMLAttributeListExp', _0: a, _1: b};
	});
var _user$project$HTMLParser$HTMLAttribute = F3(
	function (a, b, c) {
		return {ctor: 'HTMLAttribute', _0: a, _1: b, _2: c};
	});
var _user$project$HTMLParser$parseHTMLAttribute = function (parsingMode) {
	return _user$project$ParserUtils$trackInfo(
		A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (sp, attrBuilder) {
					return attrBuilder(sp);
				}),
			_user$project$HTMLParser$attributeSpaces,
			function () {
				var defaultAttributeParser = A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (name, st, sp) {
									return A3(_user$project$HTMLParser$HTMLAttribute, sp, name, st);
								})),
						_user$project$HTMLParser$parseHtmlAttributeName),
					_user$project$HTMLParser$parseHtmlAttributeValue(parsingMode));
				var _p97 = parsingMode;
				if (_p97.ctor === 'Raw') {
					return defaultAttributeParser;
				} else {
					return _MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										_elm_lang$core$Basics$flip(_user$project$HTMLParser$HTMLAttributeListExp)),
									_MikaelMayer$parser$Parser$symbol('@')),
								_p97._0.attributelist),
							_1: {
								ctor: '::',
								_0: defaultAttributeParser,
								_1: {ctor: '[]'}
							}
						});
				}
			}()));
};
var _user$project$HTMLParser$LessBangDashDash_DashDashGreater = function (a) {
	return {ctor: 'LessBangDashDash_DashDashGreater', _0: a};
};
var _user$project$HTMLParser$LessBang_Greater = function (a) {
	return {ctor: 'LessBang_Greater', _0: a};
};
var _user$project$HTMLParser$LessSlash_Greater = function (a) {
	return {ctor: 'LessSlash_Greater', _0: a};
};
var _user$project$HTMLParser$Less_Greater = function (a) {
	return {ctor: 'Less_Greater', _0: a};
};
var _user$project$HTMLParser$ImplicitElem = {ctor: 'ImplicitElem'};
var _user$project$HTMLParser$ForgotClosing = {ctor: 'ForgotClosing'};
var _user$project$HTMLParser$AutoClosing = {ctor: 'AutoClosing'};
var _user$project$HTMLParser$VoidClosing = {ctor: 'VoidClosing'};
var _user$project$HTMLParser$RegularClosing = function (a) {
	return {ctor: 'RegularClosing', _0: a};
};
var _user$project$HTMLParser$SlashEndOpening = {ctor: 'SlashEndOpening'};
var _user$project$HTMLParser$RegularEndOpening = {ctor: 'RegularEndOpening'};
var _user$project$HTMLParser$HTMLListNodeExp = function (a) {
	return {ctor: 'HTMLListNodeExp', _0: a};
};
var _user$project$HTMLParser$HTMLComment = function (a) {
	return {ctor: 'HTMLComment', _0: a};
};
var _user$project$HTMLParser$parseHTMLComment = A2(
	_MikaelMayer$parser$Parser$inContext,
	'Parsing HTML comment',
	_user$project$ParserUtils$trackInfo(
		A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			function (_p98) {
				return _user$project$HTMLParser$HTMLComment;
			},
			_MikaelMayer$parser$Parser$symbol('<'),
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$Less_Greater),
								_user$project$ParserUtils$lookAhead(
									_MikaelMayer$parser$Parser$symbol('?'))),
							A2(
								_MikaelMayer$parser$Parser$keep,
								_MikaelMayer$parser$Parser$oneOrMore,
								function (c) {
									return !_elm_lang$core$Native_Utils.eq(
										c,
										_elm_lang$core$Native_Utils.chr('>'));
								})),
						_MikaelMayer$parser$Parser$symbol('>')),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
								_MikaelMayer$parser$Parser$symbol('!')),
							_MikaelMayer$parser$Parser$oneOf(
								{
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$LessBangDashDash_DashDashGreater),
												_MikaelMayer$parser$Parser$symbol('--')),
											_user$project$ParserUtils$keepUntilRegex(
												_elm_lang$core$Regex$regex('-->'))),
										_MikaelMayer$parser$Parser$symbol('-->')),
									_1: {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$LessBang_Greater),
												A2(
													_MikaelMayer$parser$Parser$keep,
													_MikaelMayer$parser$Parser$oneOrMore,
													function (c) {
														return !_elm_lang$core$Native_Utils.eq(
															c,
															_elm_lang$core$Native_Utils.chr('>'));
													})),
											_MikaelMayer$parser$Parser$symbol('>')),
										_1: {ctor: '[]'}
									}
								})),
						_1: {
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$LessSlash_Greater),
											_user$project$ParserUtils$lookAhead(
												A3(
													_MikaelMayer$parser$Parser$delayedCommitMap,
													F2(
														function (_p100, _p99) {
															return {ctor: '_Tuple0'};
														}),
													_MikaelMayer$parser$Parser$symbol('/'),
													A2(
														_MikaelMayer$parser$Parser$keep,
														_MikaelMayer$parser$Parser$Exactly(1),
														function (c) {
															return (!_elm_lang$core$Char$isUpper(c)) && ((!_elm_lang$core$Char$isLower(c)) && (!_elm_lang$core$Native_Utils.eq(
																c,
																_elm_lang$core$Native_Utils.chr('@'))));
														})))),
										_MikaelMayer$parser$Parser$symbol('/')),
									A2(
										_MikaelMayer$parser$Parser$keep,
										_MikaelMayer$parser$Parser$oneOrMore,
										function (c) {
											return !_elm_lang$core$Native_Utils.eq(
												c,
												_elm_lang$core$Native_Utils.chr('>'));
										})),
								_MikaelMayer$parser$Parser$symbol('>')),
							_1: {ctor: '[]'}
						}
					}
				}))));
var _user$project$HTMLParser$HTMLElement = F6(
	function (a, b, c, d, e, f) {
		return {ctor: 'HTMLElement', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f};
	});
var _user$project$HTMLParser$HTMLEntity = F2(
	function (a, b) {
		return {ctor: 'HTMLEntity', _0: a, _1: b};
	});
var _user$project$HTMLParser$HTMLInner = function (a) {
	return {ctor: 'HTMLInner', _0: a};
};
var _user$project$HTMLParser$parseHTMLInner = F2(
	function (parsingMode, untilEndTagNames) {
		var maybeBreakOnAt = function () {
			var _p101 = parsingMode;
			if (_p101.ctor === 'Raw') {
				return '';
			} else {
				return '|@';
			}
		}();
		var tagNameStarts = function () {
			var _p102 = parsingMode;
			if (_p102.ctor === 'Raw') {
				return '[a-zA-Z]';
			} else {
				return '[a-zA-Z@]';
			}
		}();
		var regexToParseUntil = _elm_lang$core$Regex$regex(
			_elm_lang$core$Native_Utils.eq(
				_elm_lang$core$List$head(untilEndTagNames),
				_elm_lang$core$Maybe$Just('script')) ? A2(_elm_lang$core$Basics_ops['++'], '</script>|&', maybeBreakOnAt) : (_elm_lang$core$Native_Utils.eq(
				_elm_lang$core$List$head(untilEndTagNames),
				_elm_lang$core$Maybe$Just('style')) ? A2(_elm_lang$core$Basics_ops['++'], '</style>|&', maybeBreakOnAt) : A2(
				_elm_lang$core$Basics_ops['++'],
				'<',
				A2(
					_elm_lang$core$Basics_ops['++'],
					tagNameStarts,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'|&|<\\?|<!|</|$',
						A2(
							_elm_lang$core$Basics_ops['++'],
							maybeBreakOnAt,
							A2(
								_elm_lang$core$String$join,
								'',
								A2(
									_elm_lang$core$List$map,
									function (et) {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											'|</',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Regex$escape(et),
												'\\s*>'));
									},
									untilEndTagNames))))))));
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'Inner HTML',
			_user$project$ParserUtils$trackInfo(
				_MikaelMayer$parser$Parser$oneOf(
					{
						ctor: '::',
						_0: _user$project$ParserUtils$try(
							A2(
								_MikaelMayer$parser$Parser$andThen,
								function (s) {
									return _elm_lang$core$Native_Utils.eq(s, '') ? _MikaelMayer$parser$Parser$fail('[internal failure]') : _MikaelMayer$parser$Parser$succeed(
										_user$project$HTMLParser$HTMLInner(s));
								},
								_user$project$ParserUtils$keepUntilRegex(regexToParseUntil))),
						_1: {
							ctor: '::',
							_0: _MikaelMayer$parser$Parser$fail('No innerHTML starting here, there is probably a node or the end of the string'),
							_1: {ctor: '[]'}
						}
					})));
	});
var _user$project$HTMLParser$mergeInners = function (children) {
	mergeInners:
	while (true) {
		var _p103 = children;
		if ((_p103.ctor === '::') && (_p103._1.ctor === '::')) {
			var _p107 = _p103._1._1;
			var _p106 = _p103._1._0;
			var _p105 = _p103._0;
			var _p104 = {ctor: '_Tuple2', _0: _p105.val, _1: _p106.val};
			if ((_p104.ctor === '_Tuple2') && (_p104._1.ctor === 'HTMLInner')) {
				if (_p104._0.ctor === 'HTMLInner') {
					var _v106 = {
						ctor: '::',
						_0: A3(
							_user$project$Info$withInfo,
							_user$project$HTMLParser$HTMLInner(
								A2(_elm_lang$core$Basics_ops['++'], _p104._0._0, _p104._1._0)),
							_p105.start,
							_p106.end),
						_1: _p107
					};
					children = _v106;
					continue mergeInners;
				} else {
					return {
						ctor: '::',
						_0: _p105,
						_1: _user$project$HTMLParser$mergeInners(
							{ctor: '::', _0: _p106, _1: _p107})
					};
				}
			} else {
				return {
					ctor: '::',
					_0: _p105,
					_1: {
						ctor: '::',
						_0: _p106,
						_1: _user$project$HTMLParser$mergeInners(_p107)
					}
				};
			}
		} else {
			return children;
		}
	}
};
var _user$project$HTMLParser$HTMLTagExp = function (a) {
	return {ctor: 'HTMLTagExp', _0: a};
};
var _user$project$HTMLParser$HTMLTagString = function (a) {
	return {ctor: 'HTMLTagString', _0: a};
};
var _user$project$HTMLParser$nodeElementStart = function (parsingMode) {
	var defaultParser = A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(
			function (x) {
				return {
					ctor: '_Tuple2',
					_0: _user$project$HTMLParser$HTMLTagString(x),
					_1: x.val
				};
			}),
		_user$project$ParserUtils$trackInfo(_user$project$HTMLParser$parseTagName));
	return A2(
		_MikaelMayer$parser$Parser$delayedCommit,
		_MikaelMayer$parser$Parser$symbol('<'),
		function () {
			var _p108 = parsingMode;
			if (_p108.ctor === 'Raw') {
				return defaultParser;
			} else {
				return _MikaelMayer$parser$Parser$oneOf(
					{
						ctor: '::',
						_0: defaultParser,
						_1: {
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (s, x) {
												return {
													ctor: '_Tuple2',
													_0: _user$project$HTMLParser$HTMLTagExp(x),
													_1: '@'
												};
											})),
									_MikaelMayer$parser$Parser$symbol('@')),
								_p108._0.tagName),
							_1: {ctor: '[]'}
						}
					});
			}
		}());
};
var _user$project$HTMLParser$wrapImplicitElems = F2(
	function (tagName, children) {
		var _p109 = tagName;
		if (_p109 === 'table') {
			var firstChildTag = function (childList) {
				firstChildTag:
				while (true) {
					var _p110 = childList;
					if (_p110.ctor === '[]') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						var _p112 = _p110._1;
						var _p111 = _p110._0.val;
						switch (_p111.ctor) {
							case 'HTMLInner':
								var _v111 = _p112;
								childList = _v111;
								continue firstChildTag;
							case 'HTMLElement':
								if (_p111._0.ctor === 'HTMLTagString') {
									return _elm_lang$core$Maybe$Just(_p111._0._0.val);
								} else {
									return _elm_lang$core$Maybe$Nothing;
								}
							case 'HTMLComment':
								var _v112 = _p112;
								childList = _v112;
								continue firstChildTag;
							case 'HTMLEntity':
								var _v113 = _p112;
								childList = _v113;
								continue firstChildTag;
							default:
								return _elm_lang$core$Maybe$Nothing;
						}
					}
				}
			};
			var _p113 = firstChildTag(children);
			if ((_p113.ctor === 'Just') && (_p113._0 === 'tr')) {
				return {
					ctor: '::',
					_0: _user$project$Info$withDummyInfo(
						A6(
							_user$project$HTMLParser$HTMLElement,
							_user$project$HTMLParser$HTMLTagString(
								_user$project$Info$withDummyInfo('tbody')),
							{ctor: '[]'},
							_user$project$Lang$space0,
							_user$project$HTMLParser$RegularEndOpening,
							children,
							_user$project$HTMLParser$ImplicitElem)),
					_1: {ctor: '[]'}
				};
			} else {
				return children;
			}
		} else {
			return children;
		}
	});
var _user$project$HTMLParser$Interpolation = function (a) {
	return {ctor: 'Interpolation', _0: a};
};
var _user$project$HTMLParser$Raw = {ctor: 'Raw'};
var _user$project$HTMLParser$parseHTMLElement = F3(
	function (parsingMode, surroundingTagNames, namespace) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'HTML Element',
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser$andThen,
					function (_p114) {
						var _p115 = _p114;
						var _p124 = _p115._0;
						var _p123 = _p115._1;
						var newParsingMode = function () {
							var _p116 = _p124;
							if (_p116.ctor === 'HTMLTagString') {
								return _elm_lang$core$Native_Utils.eq(_p116._0.val, 'raw') ? _user$project$HTMLParser$Raw : parsingMode;
							} else {
								return parsingMode;
							}
						}();
						return A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									_MikaelMayer$parser$Parser$succeed(
										F3(
											function (attrs, sp1, _p117) {
												var _p118 = _p117;
												return A6(
													_user$project$HTMLParser$HTMLElement,
													_p124,
													attrs,
													sp1,
													_p118._0,
													A2(
														_user$project$HTMLParser$wrapImplicitElems,
														_p123,
														_user$project$HTMLParser$mergeInners(_p118._1)),
													_p118._2);
											})),
									A2(
										_MikaelMayer$parser$Parser$repeat,
										_MikaelMayer$parser$Parser$zeroOrMore,
										_user$project$HTMLParser$parseHTMLAttribute(parsingMode))),
								_user$project$HTMLParser$attributeSpaces),
							_MikaelMayer$parser$Parser$oneOf(
								A2(
									_elm_lang$core$Basics_ops['++'],
									(_elm_lang$core$Native_Utils.eq(namespace, _user$project$HTMLParser$HTML) && _user$project$HTMLParser$isVoidElement(_p123)) ? {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser$map,
											function (_p119) {
												return {
													ctor: '_Tuple3',
													_0: _user$project$HTMLParser$RegularEndOpening,
													_1: {ctor: '[]'},
													_2: _user$project$HTMLParser$AutoClosing
												};
											},
											_MikaelMayer$parser$Parser$symbol('/>')),
										_1: {
											ctor: '::',
											_0: A2(
												_MikaelMayer$parser$Parser$map,
												function (_p120) {
													return {
														ctor: '_Tuple3',
														_0: _user$project$HTMLParser$RegularEndOpening,
														_1: {ctor: '[]'},
														_2: _user$project$HTMLParser$VoidClosing
													};
												},
												_MikaelMayer$parser$Parser$symbol('>')),
											_1: {ctor: '[]'}
										}
									} : {ctor: '[]'},
									A2(
										_elm_lang$core$Basics_ops['++'],
										((!_elm_lang$core$Native_Utils.eq(namespace, _user$project$HTMLParser$HTML)) || A2(_elm_lang$core$Set$member, _p123, _user$project$HTMLParser$possiblyAutoClosingElements)) ? {
											ctor: '::',
											_0: A2(
												_MikaelMayer$parser$Parser$map,
												function (_p121) {
													return {
														ctor: '_Tuple3',
														_0: _user$project$HTMLParser$RegularEndOpening,
														_1: {ctor: '[]'},
														_2: _user$project$HTMLParser$AutoClosing
													};
												},
												_MikaelMayer$parser$Parser$symbol('/>')),
											_1: {ctor: '[]'}
										} : {ctor: '[]'},
										{
											ctor: '::',
											_0: A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|='],
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															_MikaelMayer$parser$Parser$succeed(
																F3(
																	function (optSlash, children, ending) {
																		return {
																			ctor: '_Tuple3',
																			_0: A2(
																				_elm_lang$core$Maybe$withDefault,
																				_user$project$HTMLParser$RegularEndOpening,
																				A2(
																					_elm_lang$core$Maybe$map,
																					function (_p122) {
																						return _user$project$HTMLParser$SlashEndOpening;
																					},
																					optSlash)),
																			_1: children,
																			_2: A2(_elm_lang$core$Maybe$withDefault, _user$project$HTMLParser$ForgotClosing, ending)
																		};
																	})),
															_user$project$ParserUtils$optional(
																_MikaelMayer$parser$Parser$symbol('/'))),
														_MikaelMayer$parser$Parser$symbol('>')),
													A2(
														_MikaelMayer$parser$Parser$repeat,
														_MikaelMayer$parser$Parser$zeroOrMore,
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															A2(
																_MikaelMayer$parser$Parser_ops['|.'],
																_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
																_user$project$ParserUtils$negativeLookAhead(
																	_user$project$HTMLParser$childrenIncompatibleWith(_p123))),
															A3(
																_user$project$HTMLParser$parseNode,
																newParsingMode,
																{ctor: '::', _0: _p123, _1: surroundingTagNames},
																_user$project$HTMLParser$isForeignElement(_p123) ? _user$project$HTMLParser$Foreign : namespace)))),
												_user$project$ParserUtils$optional(
													_user$project$ParserUtils$try(
														A2(
															_MikaelMayer$parser$Parser_ops['|.'],
															A2(
																_MikaelMayer$parser$Parser_ops['|='],
																A2(
																	_MikaelMayer$parser$Parser_ops['|.'],
																	A2(
																		_MikaelMayer$parser$Parser_ops['|.'],
																		_MikaelMayer$parser$Parser$succeed(
																			function (sp) {
																				return _user$project$HTMLParser$RegularClosing(sp);
																			}),
																		_MikaelMayer$parser$Parser$symbol('</')),
																	_MikaelMayer$parser$Parser$symbol(_p123)),
																_user$project$LangParserUtils$spaces),
															_MikaelMayer$parser$Parser$symbol('>'))))),
											_1: {ctor: '[]'}
										}))));
					},
					_user$project$HTMLParser$nodeElementStart(parsingMode))));
	});
var _user$project$HTMLParser$parseNode = F3(
	function (parsingMode, surroundingTagNames, namespace) {
		return _MikaelMayer$parser$Parser$oneOf(
			function () {
				var defaultParsers = A2(
					_elm_lang$core$Basics_ops['++'],
					(_elm_lang$core$Native_Utils.eq(
						_elm_lang$core$List$head(surroundingTagNames),
						_elm_lang$core$Maybe$Just('script')) || _elm_lang$core$Native_Utils.eq(
						_elm_lang$core$List$head(surroundingTagNames),
						_elm_lang$core$Maybe$Just('style'))) ? {ctor: '[]'} : {
						ctor: '::',
						_0: A3(_user$project$HTMLParser$parseHTMLElement, parsingMode, surroundingTagNames, namespace),
						_1: {
							ctor: '::',
							_0: _user$project$HTMLParser$parseHTMLComment,
							_1: {ctor: '[]'}
						}
					},
					{
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser$map,
							function (entity) {
								var _p125 = entity.val;
								if (_p125.ctor === 'Err') {
									return A2(
										_user$project$Info$replaceInfo,
										entity,
										_user$project$HTMLParser$HTMLInner(_p125._0));
								} else {
									return A2(
										_user$project$Info$replaceInfo,
										entity,
										A2(_user$project$HTMLParser$HTMLEntity, _p125._0._0, _p125._0._1));
								}
							},
							A2(_user$project$HTMLParser$parseHTMLEntity, false, surroundingTagNames)),
						_1: {
							ctor: '::',
							_0: A2(_user$project$HTMLParser$parseHTMLInner, parsingMode, surroundingTagNames),
							_1: {ctor: '[]'}
						}
					});
				var _p126 = parsingMode;
				if (_p126.ctor === 'Raw') {
					return defaultParsers;
				} else {
					return {
						ctor: '::',
						_0: _user$project$ParserUtils$trackInfo(
							_MikaelMayer$parser$Parser$oneOf(
								{
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser_ops['|='],
										_MikaelMayer$parser$Parser$succeed(
											function (_p127) {
												return _user$project$HTMLParser$HTMLInner('@');
											}),
										_MikaelMayer$parser$Parser$symbol('@@')),
									_1: {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(_user$project$HTMLParser$HTMLListNodeExp),
												_MikaelMayer$parser$Parser$symbol('@')),
											_p126._0.childlist(_user$project$LangParserUtils$nospace)),
										_1: {ctor: '[]'}
									}
								})),
						_1: defaultParsers
					};
				}
			}());
	});
var _user$project$HTMLParser$parseOneNode = function (parsingMode) {
	return A3(
		_user$project$HTMLParser$parseNode,
		parsingMode,
		{ctor: '[]'},
		_user$project$HTMLParser$HTML);
};
var _user$project$HTMLParser$parseTopLevelNodez = A2(
	_MikaelMayer$parser$Parser$repeat,
	_MikaelMayer$parser$Parser$zeroOrMore,
	_user$project$HTMLParser$parseOneNode(_user$project$HTMLParser$Raw));
var _user$project$HTMLParser$parseHTMLString = function (s) {
	return A2(_MikaelMayer$parser$Parser$run, _user$project$HTMLParser$parseTopLevelNodez, s);
};
var _user$project$HTMLParser$UnparseSymbol = function (a) {
	return {ctor: 'UnparseSymbol', _0: a};
};
var _user$project$HTMLParser$UnparseArgument = function (a) {
	return {ctor: 'UnparseArgument', _0: a};
};
var _user$project$HTMLParser$unparseAttrValueStringElemDiff = F4(
	function (oldattrelem, newattrelem, offset, mbd) {
		var _p128 = mbd;
		if (_p128.ctor === 'Nothing') {
			var str = _user$project$HTMLParser$unparseAttrValueStringElem(newattrelem);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: str,
					_1: offset + _elm_lang$core$String$length(str),
					_2: {ctor: '[]'}
				});
		} else {
			var _p129 = {
				ctor: '_Tuple3',
				_0: oldattrelem.val,
				_1: newattrelem.val,
				_2: _user$project$HTMLParser$contructorVDiffs(_p128._0)
			};
			if (_p129._2.ctor === 'Err') {
				return _elm_lang$core$Result$Err(_p129._2._0);
			} else {
				if (_p129._0.ctor === 'HTMLAttributeEntity') {
					if (_p129._1.ctor === 'HTMLAttributeEntity') {
						return A4(
							_user$project$HTMLParser$unparseConstructor,
							'HTMLAttributeEntity',
							offset,
							_p129._2._0,
							{
								ctor: '::',
								_0: _user$project$HTMLParser$UnparseArgument(
									A2(_user$project$HTMLParser$unparseStr, _p129._0._1, _p129._1._1)),
								_1: {ctor: '[]'}
							});
					} else {
						return A4(
							_user$project$HTMLParser$unparseConstructor,
							'HTMLAttributeStringRaw',
							offset,
							_p129._2._0,
							{
								ctor: '::',
								_0: _user$project$HTMLParser$UnparseArgument(
									A2(_user$project$HTMLParser$unparseStr, _p129._0._1, _p129._1._0)),
								_1: {ctor: '[]'}
							});
					}
				} else {
					if (_p129._1.ctor === 'HTMLAttributeStringRaw') {
						return A4(
							_user$project$HTMLParser$unparseConstructor,
							'HTMLAttributeStringRaw',
							offset,
							_p129._2._0,
							{
								ctor: '::',
								_0: _user$project$HTMLParser$UnparseArgument(
									A2(_user$project$HTMLParser$unparseStr, _p129._0._0, _p129._1._0)),
								_1: {ctor: '[]'}
							});
					} else {
						return A4(
							_user$project$HTMLParser$unparseConstructor,
							'HTMLAttributeEntity',
							offset,
							_p129._2._0,
							{
								ctor: '::',
								_0: _user$project$HTMLParser$UnparseArgument(
									A2(_user$project$HTMLParser$unparseStr, _p129._0._0, _p129._1._1)),
								_1: {ctor: '[]'}
							});
					}
				}
			}
		}
	});
var _user$project$HTMLParser$unparseAttrValueDiff = F4(
	function (oldAttrVal, newAttrVal, offset, mbd) {
		var _p130 = mbd;
		if (_p130.ctor === 'Nothing') {
			var str = _user$project$HTMLParser$unparseAttrValue(newAttrVal);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: str,
					_1: offset + _elm_lang$core$String$length(str),
					_2: {ctor: '[]'}
				});
		} else {
			var _p131 = {
				ctor: '_Tuple3',
				_0: oldAttrVal.val,
				_1: newAttrVal.val,
				_2: _user$project$HTMLParser$contructorVDiffs(_p130._0)
			};
			_v123_4:
			do {
				if (_p131.ctor === '_Tuple3') {
					if (_p131._2.ctor === 'Err') {
						return _elm_lang$core$Result$Err(_p131._2._0);
					} else {
						switch (_p131._0.ctor) {
							case 'HTMLAttributeUnquoted':
								if (_p131._1.ctor === 'HTMLAttributeUnquoted') {
									return A4(
										_user$project$HTMLParser$unparseConstructor,
										'HTMLAttributeUnquoted',
										offset,
										_p131._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseArgument(
												A2(_user$project$HTMLParser$unparseStr, _p131._0._0.val, _p131._1._0.val)),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseSymbol('='),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseArgument(
														A2(_user$project$HTMLParser$unparseStr, _p131._0._1.val, _p131._1._1.val)),
													_1: {
														ctor: '::',
														_0: _user$project$HTMLParser$UnparseArgument(
															A4(_user$project$HTMLParser$unparseList, _user$project$HTMLParser$unparseAttrValueStringElemDiff, _user$project$HTMLParser$unparseAttrValueStringElem, _p131._0._2, _p131._1._2)),
														_1: {ctor: '[]'}
													}
												}
											}
										});
								} else {
									break _v123_4;
								}
							case 'HTMLAttributeString':
								if (_p131._1.ctor === 'HTMLAttributeString') {
									var _p132 = _p131._1._2;
									return A4(
										_user$project$HTMLParser$unparseConstructor,
										'HTMLAttributeString',
										offset,
										_p131._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseArgument(
												A2(_user$project$HTMLParser$unparseStr, _p131._0._0.val, _p131._1._0.val)),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseSymbol('='),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseArgument(
														A2(_user$project$HTMLParser$unparseStr, _p131._0._1.val, _p131._1._1.val)),
													_1: {
														ctor: '::',
														_0: _user$project$HTMLParser$UnparseArgument(
															A2(_user$project$HTMLParser$unparseStr, _p131._0._2, _p132)),
														_1: {
															ctor: '::',
															_0: _user$project$HTMLParser$UnparseArgument(
																A4(_user$project$HTMLParser$unparseList, _user$project$HTMLParser$unparseAttrValueStringElemDiff, _user$project$HTMLParser$unparseAttrValueStringElem, _p131._0._3, _p131._1._3)),
															_1: {
																ctor: '::',
																_0: _user$project$HTMLParser$UnparseSymbol(_p132),
																_1: {ctor: '[]'}
															}
														}
													}
												}
											}
										});
								} else {
									break _v123_4;
								}
							case 'HTMLAttributeNoValue':
								if (_p131._1.ctor === 'HTMLAttributeNoValue') {
									return _elm_lang$core$Result$Ok(
										{
											ctor: '_Tuple3',
											_0: '',
											_1: offset,
											_2: {ctor: '[]'}
										});
								} else {
									break _v123_4;
								}
							default:
								break _v123_4;
						}
					}
				} else {
					break _v123_4;
				}
			} while(false);
			var oldStr = _user$project$HTMLParser$unparseAttrValue(oldAttrVal);
			var newStr = _user$project$HTMLParser$unparseAttrValue(newAttrVal);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: newStr,
					_1: offset + _elm_lang$core$String$length(oldStr),
					_2: {
						ctor: '::',
						_0: A3(
							_user$project$Lang$StringUpdate,
							offset,
							offset + _elm_lang$core$String$length(oldStr),
							_elm_lang$core$String$length(newStr)),
						_1: {ctor: '[]'}
					}
				});
		}
	});
var _user$project$HTMLParser$unparseAttrDiffs = F4(
	function (oldAttr, newAttr, offset, mbd) {
		var _p133 = mbd;
		if (_p133.ctor === 'Nothing') {
			var str = _user$project$HTMLParser$unparseAttr(newAttr);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: str,
					_1: offset + _elm_lang$core$String$length(str),
					_2: {ctor: '[]'}
				});
		} else {
			var _p134 = {
				ctor: '_Tuple3',
				_0: oldAttr.val,
				_1: newAttr.val,
				_2: _user$project$HTMLParser$contructorVDiffs(_p133._0)
			};
			if (_p134._2.ctor === 'Err') {
				return _elm_lang$core$Result$Err(_p134._2._0);
			} else {
				if ((_p134._0.ctor === 'HTMLAttribute') && (_p134._1.ctor === 'HTMLAttribute')) {
					return A4(
						_user$project$HTMLParser$unparseConstructor,
						'HTMLAttribute',
						offset,
						_p134._2._0,
						{
							ctor: '::',
							_0: _user$project$HTMLParser$UnparseArgument(
								A2(_user$project$HTMLParser$unparseStr, _p134._0._0.val, _p134._1._0.val)),
							_1: {
								ctor: '::',
								_0: _user$project$HTMLParser$UnparseArgument(
									A2(_user$project$HTMLParser$unparseStr, _p134._0._1.val, _p134._1._1.val)),
								_1: {
									ctor: '::',
									_0: _user$project$HTMLParser$UnparseArgument(
										A2(_user$project$HTMLParser$unparseAttrValueDiff, _p134._0._2, _p134._1._2)),
									_1: {ctor: '[]'}
								}
							}
						});
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[internal error] Don\'t know how to unparseAttrDiffs ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(oldAttr.val),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' ',
									_elm_lang$core$Basics$toString(newAttr.val)))));
				}
			}
		}
	});
var _user$project$HTMLParser$unparseCommentStyleDiffs = F4(
	function (oldStyle, newStyle, offset, mbvdiffs) {
		var _p135 = mbvdiffs;
		if (_p135.ctor === 'Nothing') {
			var styleStr = _user$project$HTMLParser$unparseCommentStyle(newStyle);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: styleStr,
					_1: offset + _elm_lang$core$String$length(styleStr),
					_2: {ctor: '[]'}
				});
		} else {
			var $default = function (_p136) {
				var _p137 = _p136;
				var comment1 = _user$project$HTMLParser$unparseCommentStyle(oldStyle);
				var comment2 = _user$project$HTMLParser$unparseCommentStyle(newStyle);
				return _elm_lang$core$Result$Ok(
					{
						ctor: '_Tuple3',
						_0: comment2,
						_1: offset + _elm_lang$core$String$length(comment1),
						_2: {
							ctor: '::',
							_0: A3(
								_user$project$Lang$StringUpdate,
								offset,
								offset + _elm_lang$core$String$length(comment1),
								_elm_lang$core$String$length(comment2)),
							_1: {ctor: '[]'}
						}
					});
			};
			var _p138 = {
				ctor: '_Tuple3',
				_0: oldStyle,
				_1: newStyle,
				_2: _user$project$HTMLParser$contructorVDiffs(_p135._0)
			};
			_v128_5:
			do {
				if (_p138.ctor === '_Tuple3') {
					if (_p138._2.ctor === 'Err') {
						return _elm_lang$core$Result$Err(_p138._2._0);
					} else {
						switch (_p138._0.ctor) {
							case 'Less_Greater':
								if (_p138._1.ctor === 'Less_Greater') {
									var _p139 = _p138._1._0;
									return (A2(_elm_lang$core$String$startsWith, '?', _p139) && (!A2(_elm_lang$core$String$contains, '>', _p139))) ? A4(
										_user$project$HTMLParser$unparseConstructor,
										'Less_Greater',
										offset,
										_p138._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseSymbol('<'),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseArgument(
													A2(_user$project$HTMLParser$unparseStr, _p138._0._0, _p139)),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseSymbol('>'),
													_1: {ctor: '[]'}
												}
											}
										}) : $default(
										{ctor: '_Tuple0'});
								} else {
									break _v128_5;
								}
							case 'LessSlash_Greater':
								if (_p138._1.ctor === 'LessSlash_Greater') {
									var _p140 = _p138._1._0;
									return (A2(_elm_lang$core$String$startsWith, ' ', _p140) && (!A2(_elm_lang$core$String$contains, '>', _p140))) ? A4(
										_user$project$HTMLParser$unparseConstructor,
										'LessSlash_Greater',
										offset,
										_p138._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseSymbol('</'),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseArgument(
													A2(_user$project$HTMLParser$unparseStr, _p138._0._0, _p140)),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseSymbol('>'),
													_1: {ctor: '[]'}
												}
											}
										}) : $default(
										{ctor: '_Tuple0'});
								} else {
									break _v128_5;
								}
							case 'LessBang_Greater':
								if (_p138._1.ctor === 'LessBang_Greater') {
									var _p141 = _p138._1._0;
									return (A2(_elm_lang$core$String$startsWith, '--', _p141) && (!A2(_elm_lang$core$String$contains, '-->', _p141))) ? A4(
										_user$project$HTMLParser$unparseConstructor,
										'LessBang_Greater',
										offset,
										_p138._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseSymbol('<!'),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseArgument(
													A2(_user$project$HTMLParser$unparseStr, _p138._0._0, _p141)),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseSymbol('>'),
													_1: {ctor: '[]'}
												}
											}
										}) : $default(
										{ctor: '_Tuple0'});
								} else {
									break _v128_5;
								}
							default:
								if (_p138._1.ctor === 'LessBangDashDash_DashDashGreater') {
									var _p142 = _p138._1._0;
									return (!A2(_elm_lang$core$String$contains, '-->', _p142)) ? A4(
										_user$project$HTMLParser$unparseConstructor,
										'LessBangDashDash_DashDashGreater',
										offset,
										_p138._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseSymbol('<!--'),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseArgument(
													A2(_user$project$HTMLParser$unparseStr, _p138._0._0, _p142)),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseSymbol('>'),
													_1: {ctor: '[]'}
												}
											}
										}) : $default(
										{ctor: '_Tuple0'});
								} else {
									break _v128_5;
								}
						}
					}
				} else {
					break _v128_5;
				}
			} while(false);
			return $default(
				{ctor: '_Tuple0'});
		}
	});
var _user$project$HTMLParser$unparseNodeDiffs = F4(
	function (oldNode, newNode, offset, mbvdiffs) {
		var _p143 = mbvdiffs;
		if (_p143.ctor === 'Nothing') {
			var nodeStr = _user$project$HTMLParser$unparseNode(newNode);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: nodeStr,
					_1: offset + _elm_lang$core$String$length(nodeStr),
					_2: {ctor: '[]'}
				});
		} else {
			var _p144 = {
				ctor: '_Tuple3',
				_0: oldNode.val,
				_1: newNode.val,
				_2: _user$project$HTMLParser$contructorVDiffs(_p143._0)
			};
			_v130_4:
			do {
				if (_p144.ctor === '_Tuple3') {
					if (_p144._2.ctor === 'Err') {
						return _elm_lang$core$Result$Err(_p144._2._0);
					} else {
						switch (_p144._0.ctor) {
							case 'HTMLInner':
								if (_p144._1.ctor === 'HTMLInner') {
									return A4(
										_user$project$HTMLParser$unparseConstructor,
										'HTMLInner',
										offset,
										_p144._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseArgument(
												A2(_user$project$HTMLParser$unparseStr, _p144._0._0, _p144._1._0)),
											_1: {ctor: '[]'}
										});
								} else {
									break _v130_4;
								}
							case 'HTMLElement':
								if (_p144._1.ctor === 'HTMLElement') {
									var _p148 = _p144._1._0;
									var _p147 = _p144._0._0;
									var _p146 = _p144._1._5;
									var _p145 = _p144._0._5;
									return A4(
										_user$project$HTMLParser$unparseConstructor,
										'HTMLElement',
										offset,
										_p144._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseSymbol('<'),
											_1: {
												ctor: '::',
												_0: _user$project$HTMLParser$UnparseArgument(
													A2(_user$project$HTMLParser$unparseTagNameDiff, _p147, _p148)),
												_1: {
													ctor: '::',
													_0: _user$project$HTMLParser$UnparseArgument(
														A4(_user$project$HTMLParser$unparseList, _user$project$HTMLParser$unparseAttrDiffs, _user$project$HTMLParser$unparseAttr, _p144._0._1, _p144._1._1)),
													_1: {
														ctor: '::',
														_0: _user$project$HTMLParser$UnparseArgument(
															A2(_user$project$HTMLParser$unparseStr, _p144._0._2.val, _p144._1._2.val)),
														_1: {
															ctor: '::',
															_0: _user$project$HTMLParser$UnparseArgument(
																F2(
																	function (offset, mbdiffs) {
																		var endOpFinal1 = A2(_user$project$HTMLParser$unparseEndOp, _p144._0._3, _p145);
																		var endOpFinal2 = A2(_user$project$HTMLParser$unparseEndOp, _p144._1._3, _p146);
																		var diff = A2(
																			_elm_lang$core$Maybe$withDefault,
																			{ctor: '[]'},
																			A2(
																				_elm_lang$core$Maybe$map,
																				function (d) {
																					return {
																						ctor: '::',
																						_0: A3(
																							_user$project$Lang$StringUpdate,
																							offset,
																							offset + _elm_lang$core$String$length(endOpFinal1),
																							_elm_lang$core$String$length(endOpFinal2)),
																						_1: {ctor: '[]'}
																					};
																				},
																				mbdiffs));
																		return _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple3',
																				_0: endOpFinal2,
																				_1: offset + _elm_lang$core$String$length(endOpFinal1),
																				_2: diff
																			});
																	})),
															_1: {
																ctor: '::',
																_0: _user$project$HTMLParser$UnparseSymbol('>'),
																_1: {
																	ctor: '::',
																	_0: _user$project$HTMLParser$UnparseArgument(
																		A4(_user$project$HTMLParser$unparseList, _user$project$HTMLParser$unparseNodeDiffs, _user$project$HTMLParser$unparseNode, _p144._0._4, _p144._1._4)),
																	_1: {
																		ctor: '::',
																		_0: _user$project$HTMLParser$UnparseArgument(
																			F2(
																				function (offset, mbdiffs) {
																					var closingFinal1 = A2(_user$project$HTMLParser$unparseClosing, _p147, _p145);
																					var closingFinal2 = A2(_user$project$HTMLParser$unparseClosing, _p148, _p146);
																					var diff = A2(
																						_elm_lang$core$Maybe$withDefault,
																						{ctor: '[]'},
																						A2(
																							_elm_lang$core$Maybe$map,
																							function (d) {
																								return {
																									ctor: '::',
																									_0: A3(
																										_user$project$Lang$StringUpdate,
																										offset,
																										offset + _elm_lang$core$String$length(closingFinal1),
																										_elm_lang$core$String$length(closingFinal2)),
																									_1: {ctor: '[]'}
																								};
																							},
																							mbdiffs));
																					return _elm_lang$core$Result$Ok(
																						{
																							ctor: '_Tuple3',
																							_0: closingFinal2,
																							_1: offset + _elm_lang$core$String$length(closingFinal1),
																							_2: diff
																						});
																				})),
																		_1: {ctor: '[]'}
																	}
																}
															}
														}
													}
												}
											}
										});
								} else {
									break _v130_4;
								}
							case 'HTMLComment':
								if (_p144._1.ctor === 'HTMLComment') {
									return A4(
										_user$project$HTMLParser$unparseConstructor,
										'HTMLComment',
										offset,
										_p144._2._0,
										{
											ctor: '::',
											_0: _user$project$HTMLParser$UnparseArgument(
												A2(_user$project$HTMLParser$unparseCommentStyleDiffs, _p144._0._0, _p144._1._0)),
											_1: {ctor: '[]'}
										});
								} else {
									break _v130_4;
								}
							default:
								break _v130_4;
						}
					}
				} else {
					break _v130_4;
				}
			} while(false);
			var oldNodeStr = _user$project$HTMLParser$unparseNode(oldNode);
			var newNodeStr = _user$project$HTMLParser$unparseNode(newNode);
			var lengthOldode = _elm_lang$core$String$length(oldNodeStr);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple3',
					_0: newNodeStr,
					_1: offset + lengthOldode,
					_2: {
						ctor: '::',
						_0: A3(
							_user$project$Lang$StringUpdate,
							offset,
							offset + lengthOldode,
							_elm_lang$core$String$length(newNodeStr)),
						_1: {ctor: '[]'}
					}
				});
		}
	});
var _user$project$HTMLParser$unparseHtmlNodesDiffs = F3(
	function (diffs, oldNodes, newNodes) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p149) {
				var _p150 = _p149;
				return {ctor: '_Tuple2', _0: _p150._0, _1: _p150._2};
			},
			A6(_user$project$HTMLParser$unparseList, _user$project$HTMLParser$unparseNodeDiffs, _user$project$HTMLParser$unparseNode, oldNodes, newNodes, 0, diffs));
	});

var _user$project$LeoParser$substPlusOf_ = F2(
	function (substPlus, exp) {
		var accumulator = F2(
			function (_p0, s) {
				var _p1 = _p0;
				var _p6 = _p1._0;
				var _p2 = _user$project$Lang$unwrapExp(
					_user$project$Lang$Expr(_p6));
				if ((_p2.ctor === 'EConst') && (_p2._2.ctor === '_Tuple3')) {
					var _p5 = _p2._1;
					var _p4 = _p2._2._0;
					var _p3 = A2(_elm_lang$core$Dict$get, _p4, s);
					if (_p3.ctor === 'Nothing') {
						return A3(
							_elm_lang$core$Dict$insert,
							_p4,
							_elm_lang$core$Native_Utils.update(
								_p6,
								{val: _p5}),
							s);
					} else {
						return _elm_lang$core$Native_Utils.eq(_p5, _p3._0.val) ? s : _elm_lang$core$Native_Utils.crash(
							'LeoParser',
							{
								start: {line: 3106, column: 15},
								end: {line: 3106, column: 26}
							})(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'substPlusOf_ Duplicate locId ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(_p4),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' with differing value ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(_p5),
											A2(_elm_lang$core$Basics_ops['++'], '\n', 'BLAH'))))));
					}
				} else {
					return s;
				}
			});
		return A3(_user$project$Lang$foldExp, accumulator, substPlus, exp);
	});
var _user$project$LeoParser$recordIdentifiers = function (_p7) {
	recordIdentifiers:
	while (true) {
		var _p8 = _p7;
		var _p18 = _p8._0;
		var _p17 = _p8._1._0;
		var exp = _user$project$Lang$Expr(_p17);
		var ret = function (e__) {
			return _user$project$Lang$Expr(
				A3(
					_user$project$Info$WithInfo,
					A2(
						_user$project$Lang$makeExp_,
						e__,
						_user$project$Lang$expEId(exp)),
					_p17.start,
					_p17.end));
		};
		var _p9 = {
			ctor: '_Tuple2',
			_0: _p18.val.p__,
			_1: _user$project$Lang$unwrapExp(exp)
		};
		_v4_4:
		do {
			_v4_3:
			do {
				switch (_p9._0.ctor) {
					case 'PVar':
						switch (_p9._1.ctor) {
							case 'EConst':
								if (_p9._1._2.ctor === '_Tuple3') {
									return ret(
										A4(
											_user$project$Lang$EConst,
											_p9._1._0,
											_p9._1._1,
											{ctor: '_Tuple3', _0: _p9._1._2._0, _1: _p9._1._2._1, _2: _p9._0._1},
											_p9._1._3));
								} else {
									break _v4_4;
								}
							case 'EColonType':
								break _v4_3;
							default:
								break _v4_4;
						}
					case 'PList':
						switch (_p9._1.ctor) {
							case 'EList':
								var _p16 = _p9._1._4;
								var _p15 = _p9._1._2;
								var _p14 = _p9._1._0;
								var _p13 = _p9._1._3;
								var _p12 = _p9._1._1;
								var _p10 = A2(
									_user$project$Utils$maybeZip,
									_p9._0._1,
									_user$project$Utils$listValues(_p12));
								if (_p10.ctor === 'Nothing') {
									return ret(
										A5(_user$project$Lang$EList, _p14, _p12, _p15, _p13, _p16));
								} else {
									var es_ = A2(_elm_lang$core$List$map, _user$project$LeoParser$recordIdentifiers, _p10._0);
									var me_ = function () {
										var _p11 = {ctor: '_Tuple2', _0: _p9._0._3, _1: _p13};
										if (((_p11.ctor === '_Tuple2') && (_p11._0.ctor === 'Just')) && (_p11._1.ctor === 'Just')) {
											return _elm_lang$core$Maybe$Just(
												_user$project$LeoParser$recordIdentifiers(
													{ctor: '_Tuple2', _0: _p11._0._0, _1: _p11._1._0}));
										} else {
											return _p13;
										}
									}();
									return ret(
										A5(
											_user$project$Lang$EList,
											_p14,
											A2(_user$project$Utils$listValuesMake, _p12, es_),
											_p15,
											me_,
											_p16));
								}
							case 'EColonType':
								break _v4_3;
							default:
								break _v4_4;
						}
					case 'PAs':
						var _v7 = {ctor: '_Tuple2', _0: _p9._0._1, _1: exp};
						_p7 = _v7;
						continue recordIdentifiers;
					default:
						if (_p9._1.ctor === 'EColonType') {
							break _v4_3;
						} else {
							break _v4_4;
						}
				}
			} while(false);
			return ret(
				A5(
					_user$project$Lang$EColonType,
					_p9._1._0,
					_user$project$LeoParser$recordIdentifiers(
						{ctor: '_Tuple2', _0: _p18, _1: _p9._1._1}),
					_p9._1._2,
					_p9._1._3,
					_p9._1._4));
		} while(false);
		return ret(_p9._1);
	}
};
var _user$project$LeoParser$allIdsRaw = function (exp) {
	var pidsInPat = function (pat) {
		return A2(
			_elm_lang$core$List$map,
			function (_p19) {
				return function (_) {
					return _.pid;
				}(
					function (_) {
						return _.val;
					}(_p19));
			},
			_user$project$Lang$flattenPatTree(pat));
	};
	var pidsInPats = function (pats) {
		return A2(_elm_lang$core$List$concatMap, pidsInPat, pats);
	};
	var tidsInType = function (typ) {
		return A2(
			_elm_lang$core$List$map,
			function (_p20) {
				return function (_) {
					return _.tid;
				}(
					function (_) {
						return _.val;
					}(_p20));
			},
			_user$project$Lang$flattenTypeTree(typ));
	};
	var tidsInTypes = function (typs) {
		return A2(_elm_lang$core$List$concatMap, tidsInType, typs);
	};
	var flattened = _user$project$Lang$flattenExpTree(exp);
	var eids = A2(_elm_lang$core$List$map, _user$project$Lang$expEId, flattened);
	var otherIds = A2(
		_elm_lang$core$List$concatMap,
		function (exp) {
			var _p21 = _user$project$Lang$unwrapExp(exp);
			_v8_5:
			do {
				switch (_p21.ctor) {
					case 'EConst':
						if (_p21._2.ctor === '_Tuple3') {
							return {
								ctor: '::',
								_0: _p21._2._0,
								_1: {ctor: '[]'}
							};
						} else {
							break _v8_5;
						}
					case 'ELet':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$List$concatMap,
								function (_p22) {
									var _p23 = _p22;
									return pidsInPat(_p23._2);
								},
								_user$project$Lang$elemsOf(_p21._2._3)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$List$concatMap,
									function (_p24) {
										var _p25 = _p24;
										return A2(
											_elm_lang$core$Basics_ops['++'],
											pidsInPat(_p25._3),
											tidsInType(_p25._6));
									},
									_user$project$Lang$elemsOf(_p21._2._1)),
								A2(
									_elm_lang$core$List$concatMap,
									function (_p26) {
										var _p27 = _p26;
										return A2(
											_elm_lang$core$Basics_ops['++'],
											pidsInPat(_p27._2),
											tidsInType(_p27._5));
									},
									_p21._2._2)));
					case 'EFun':
						return pidsInPats(_p21._1);
					case 'ECase':
						return pidsInPats(
							_user$project$Lang$branchPats(_p21._2));
					case 'EColonType':
						return tidsInType(_p21._3);
					default:
						break _v8_5;
				}
			} while(false);
			return {ctor: '[]'};
		},
		flattened);
	return A2(_elm_lang$core$Basics_ops['++'], eids, otherIds);
};
var _user$project$LeoParser$freshenTypePreserving = F2(
	function (idsToPreserve, _p28) {
		var _p29 = _p28;
		var getId = function (k) {
			getId:
			while (true) {
				if (A2(_elm_lang$core$Set$member, k, idsToPreserve)) {
					var _v13 = k + 1;
					k = _v13;
					continue getId;
				} else {
					return k;
				}
			}
		};
		var assignIds = F2(
			function (typ, k) {
				if (A2(_elm_lang$core$Set$member, typ.val.tid, idsToPreserve)) {
					return {ctor: '_Tuple2', _0: typ, _1: k};
				} else {
					var tid = getId(k);
					return {
						ctor: '_Tuple2',
						_0: A2(_user$project$Lang$setTId, tid, typ),
						_1: tid + 1
					};
				}
			});
		return A3(_user$project$Lang$mapFoldTypeTopDown, assignIds, _p29._1, _p29._0);
	});
var _user$project$LeoParser$freshenPatPreserving = F2(
	function (idsToPreserve, _p30) {
		var _p31 = _p30;
		var getId = function (k) {
			getId:
			while (true) {
				if (A2(_elm_lang$core$Set$member, k, idsToPreserve)) {
					var _v15 = k + 1;
					k = _v15;
					continue getId;
				} else {
					return k;
				}
			}
		};
		var assignIds = F2(
			function (pat, k) {
				var _p32 = function () {
					var _p33 = pat.val.p__;
					if (_p33.ctor === 'PColonType') {
						var _p34 = A2(
							_user$project$LeoParser$freshenTypePreserving,
							idsToPreserve,
							{ctor: '_Tuple2', _0: _p33._3, _1: k});
						var freshTyp = _p34._0;
						var newK = _p34._1;
						return {
							ctor: '_Tuple2',
							_0: A4(_user$project$Lang$PColonType, _p33._0, _p33._1, _p33._2, freshTyp),
							_1: newK
						};
					} else {
						return {ctor: '_Tuple2', _0: pat.val.p__, _1: k};
					}
				}();
				var newP__ = _p32._0;
				var newK = _p32._1;
				if (A2(_elm_lang$core$Set$member, pat.val.pid, idsToPreserve)) {
					return {
						ctor: '_Tuple2',
						_0: A2(_user$project$Lang$replaceP__, pat, newP__),
						_1: newK
					};
				} else {
					var pid = getId(k);
					return {
						ctor: '_Tuple2',
						_0: A3(
							_user$project$Info$WithInfo,
							A2(_user$project$Lang$makePat_, newP__, pid),
							pat.start,
							pat.end),
						_1: pid + 1
					};
				}
			});
		return A3(_user$project$Lang$mapFoldPatTopDown, assignIds, _p31._1, _p31._0);
	});
var _user$project$LeoParser$freshenPatsPreserving = F2(
	function (idsToPreserve, _p35) {
		var _p36 = _p35;
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (pat, _p37) {
					var _p38 = _p37;
					var _p39 = A2(
						_user$project$LeoParser$freshenPatPreserving,
						idsToPreserve,
						{ctor: '_Tuple2', _0: pat, _1: _p38._1});
					var newPat = _p39._0;
					var newK = _p39._1;
					return {
						ctor: '_Tuple2',
						_0: A2(
							_elm_lang$core$Basics_ops['++'],
							_p38._0,
							{
								ctor: '::',
								_0: newPat,
								_1: {ctor: '[]'}
							}),
						_1: newK
					};
				}),
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: _p36._1
			},
			_p36._0);
	});
var _user$project$LeoParser$freshenPreserving = F3(
	function (idsToPreserve, initK, e) {
		var getId = function (k) {
			getId:
			while (true) {
				if (A2(_elm_lang$core$Set$member, k, idsToPreserve)) {
					var _v19 = k + 1;
					k = _v19;
					continue getId;
				} else {
					return k;
				}
			}
		};
		var assignIds = F2(
			function (_p40, k) {
				var _p41 = _p40;
				var _p73 = _p41._0;
				var exp = _user$project$Lang$Expr(_p73);
				var e__ = _user$project$Lang$unwrapExp(exp);
				var _p42 = function () {
					var _p43 = e__;
					_v21_5:
					do {
						switch (_p43.ctor) {
							case 'EConst':
								if (_p43._2.ctor === '_Tuple3') {
									if (A2(_elm_lang$core$Set$member, _p43._2._0, idsToPreserve)) {
										return {ctor: '_Tuple2', _0: e__, _1: k};
									} else {
										var locId = getId(k);
										return {
											ctor: '_Tuple2',
											_0: A4(
												_user$project$Lang$EConst,
												_p43._0,
												_p43._1,
												{ctor: '_Tuple3', _0: locId, _1: _p43._2._1, _2: _p43._2._2},
												_p43._3),
											_1: locId + 1
										};
									}
								} else {
									break _v21_5;
								}
							case 'ELet':
								var _p65 = _p43._2._1;
								var _p64 = _p43._2._3;
								var _p44 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: k
									},
									_user$project$Lang$elemsOf(_p65),
									F2(
										function (_p46, _p45) {
											var _p47 = _p46;
											var _p48 = _p45;
											var _p49 = A2(
												_user$project$LeoParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p48._3, _1: _p47._1});
											var newPat = _p49._0;
											var newK1 = _p49._1;
											var _p50 = A2(
												_user$project$LeoParser$freshenTypePreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p48._6, _1: newK1});
											var newTp = _p50._0;
											var newK2 = _p50._1;
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A7(_user$project$Lang$LetType, _p48._0, _p48._1, _p48._2, newPat, _p48._4, _p48._5, newTp),
													_1: _p47._0
												},
												_1: newK2
											};
										}));
								var newRevTpes = _p44._0;
								var newK = _p44._1;
								var _p51 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: newK
									},
									_p43._2._2,
									F2(
										function (_p53, _p52) {
											var _p54 = _p53;
											var _p55 = _p52;
											var _p56 = A2(
												_user$project$LeoParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p55._2, _1: _p54._1});
											var newPat = _p56._0;
											var newK1 = _p56._1;
											var _p57 = A2(
												_user$project$LeoParser$freshenTypePreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p55._5, _1: newK1});
											var newTp = _p57._0;
											var newK2 = _p57._1;
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A6(_user$project$Lang$LetAnnotation, _p55._0, _p55._1, newPat, _p55._3, _p55._4, newTp),
													_1: _p54._0
												},
												_1: newK2
											};
										}));
								var newRevAnn = _p51._0;
								var newK2 = _p51._1;
								var _p58 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: newK2
									},
									_user$project$Lang$elemsOf(_p64),
									F2(
										function (_p60, _p59) {
											var _p61 = _p60;
											var _p62 = _p59;
											var _p63 = A2(
												_user$project$LeoParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p62._2, _1: _p61._1});
											var newP = _p63._0;
											var newK = _p63._1;
											var newE1 = _user$project$LeoParser$recordIdentifiers(
												{ctor: '_Tuple2', _0: newP, _1: _p62._5});
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A6(_user$project$Lang$LetExp, _p62._0, _p62._1, newP, _p62._3, _p62._4, newE1),
													_1: _p61._0
												},
												_1: newK
											};
										}));
								var newRevExps = _p58._0;
								var newK3 = _p58._1;
								return {
									ctor: '_Tuple2',
									_0: A5(
										_user$project$Lang$ELet,
										_p43._0,
										_p43._1,
										A4(
											_user$project$Lang$Declarations,
											_p43._2._0,
											A2(
												_user$project$Lang$regroup,
												_p65,
												_elm_lang$core$List$reverse(newRevTpes)),
											_elm_lang$core$List$reverse(newRevAnn),
											A2(
												_user$project$Lang$regroup,
												_p64,
												_elm_lang$core$List$reverse(newRevExps))),
										_p43._3,
										_p43._4),
									_1: newK3
								};
							case 'EFun':
								var _p66 = A2(
									_user$project$LeoParser$freshenPatsPreserving,
									idsToPreserve,
									{ctor: '_Tuple2', _0: _p43._1, _1: k});
								var newPats = _p66._0;
								var newK = _p66._1;
								return {
									ctor: '_Tuple2',
									_0: A4(_user$project$Lang$EFun, _p43._0, newPats, _p43._2, _p43._3),
									_1: newK
								};
							case 'ECase':
								var _p67 = A3(
									_elm_lang$core$List$foldl,
									F2(
										function (branch, _p68) {
											var _p69 = _p68;
											var _p70 = branch.val;
											var bws1 = _p70._0;
											var pat = _p70._1;
											var ei = _p70._2;
											var bws2 = _p70._3;
											var _p71 = A2(
												_user$project$LeoParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: pat, _1: _p69._1});
											var newPi = _p71._0;
											var newK = _p71._1;
											return {
												ctor: '_Tuple2',
												_0: A2(
													_elm_lang$core$Basics_ops['++'],
													_p69._0,
													{
														ctor: '::',
														_0: _elm_lang$core$Native_Utils.update(
															branch,
															{
																val: A4(_user$project$Lang$Branch_, bws1, newPi, ei, bws2)
															}),
														_1: {ctor: '[]'}
													}),
												_1: newK
											};
										}),
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: k
									},
									_p43._2);
								var newBranches = _p67._0;
								var newK = _p67._1;
								return {
									ctor: '_Tuple2',
									_0: A4(_user$project$Lang$ECase, _p43._0, _p43._1, newBranches, _p43._3),
									_1: newK
								};
							case 'EColonType':
								var _p72 = A2(
									_user$project$LeoParser$freshenTypePreserving,
									idsToPreserve,
									{ctor: '_Tuple2', _0: _p43._3, _1: k});
								var freshTyp = _p72._0;
								var newK = _p72._1;
								return {
									ctor: '_Tuple2',
									_0: A5(_user$project$Lang$EColonType, _p43._0, _p43._1, _p43._2, freshTyp, _p43._4),
									_1: newK
								};
							default:
								break _v21_5;
						}
					} while(false);
					return {ctor: '_Tuple2', _0: e__, _1: k};
				}();
				var newE__ = _p42._0;
				var newK = _p42._1;
				if (A2(
					_elm_lang$core$Set$member,
					_user$project$Lang$expEId(exp),
					idsToPreserve)) {
					return {
						ctor: '_Tuple2',
						_0: A2(_user$project$Lang$replaceE__, exp, newE__),
						_1: newK
					};
				} else {
					var eid = getId(newK);
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$Expr(
							A3(
								_user$project$Info$WithInfo,
								A2(_user$project$Lang$makeExp_, newE__, eid),
								_p73.start,
								_p73.end)),
						_1: eid + 1
					};
				}
			});
		return A3(_user$project$Lang$mapFoldExp, assignIds, initK, e);
	});
var _user$project$LeoParser$freshenClean = F2(
	function (initK, e) {
		return A3(_user$project$LeoParser$freshenPreserving, _elm_lang$core$Set$empty, initK, e);
	});
var _user$project$LeoParser$clearAllIds = function (root) {
	return A2(_user$project$Lang$mapExp, _user$project$Lang$clearNodeIds, root);
};
var _user$project$LeoParser$isActualEId = function (eid) {
	return _elm_lang$core$Native_Utils.cmp(eid, 0) > -1;
};
var _user$project$LeoParser$validVariableIdentifierFirstChar = function (c) {
	return _elm_lang$core$Char$isLower(c) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('_'));
};
var _user$project$LeoParser$validIdentifierRestChar = function (c) {
	return _elm_lang$core$Char$isLower(c) || (_elm_lang$core$Char$isUpper(c) || (_elm_lang$core$Char$isDigit(c) || (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('_')) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('\'')))));
};
var _user$project$LeoParser$sanitizeVariableName = function (unsafeName) {
	return _elm_lang$core$String$fromList(
		A2(
			_user$project$Utils$changeTail,
			_elm_lang$core$List$filter(_user$project$LeoParser$validIdentifierRestChar),
			A2(
				_user$project$Utils$dropWhile,
				function (_p74) {
					return !function (_p75) {
						return _user$project$LeoParser$validVariableIdentifierFirstChar(
							_elm_lang$core$Char$toLower(_p75));
					}(_p74);
				},
				_elm_lang$core$String$toList(unsafeName))));
};
var _user$project$LeoParser$implicitMain = function () {
	var builder = function (p) {
		var withCorrectInfo = function (x) {
			return A3(_user$project$Info$WithInfo, x, p, p);
		};
		var withCorrectExpInfo = function (x) {
			return _user$project$Lang$Expr(
				withCorrectInfo(x));
		};
		var binding = function (_p76) {
			return withCorrectExpInfo(
				_user$project$Lang$exp_(_p76));
		}(
			A2(
				_user$project$Lang$EBase,
				_user$project$Lang$space1,
				A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, '...')));
		var body = function (_p77) {
			return withCorrectExpInfo(
				_user$project$Lang$exp_(_p77));
		}(
			A2(_user$project$Lang$EVar, _user$project$Lang$space1, 'main'));
		var name = function (_p78) {
			return withCorrectInfo(
				_user$project$Lang$pat_(_p78));
		}(
			A3(
				_user$project$Lang$PVar,
				_user$project$Lang$space1,
				'_IMPLICIT_MAIN',
				_user$project$Info$withDummyInfo(_user$project$Lang$NoWidgetDecl)));
		return function (_p79) {
			return withCorrectExpInfo(
				_user$project$Lang$exp_(_p79));
		}(
			A5(
				_user$project$Lang$ELet,
				_user$project$Lang$newline2,
				_user$project$Lang$Let,
				A4(
					_user$project$Lang$Declarations,
					{
						ctor: '::',
						_0: 0,
						_1: {ctor: '[]'}
					},
					{ctor: '[]'},
					{ctor: '[]'},
					{
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: false,
							_1: {
								ctor: '::',
								_0: A6(_user$project$Lang$LetExp, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space1, name, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, binding),
								_1: {ctor: '[]'}
							}
						},
						_1: {ctor: '[]'}
					}),
				_user$project$Lang$space1,
				body));
	};
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(builder),
		_user$project$ParserUtils$getPos);
}();
var _user$project$LeoParser$optionalTopLevelSemicolon = _user$project$ParserUtils$optional(
	A3(
		_user$project$LangParserUtils$paddedBefore,
		F3(
			function (_p82, _p81, _p80) {
				return {ctor: '_Tuple0'};
			}),
		_user$project$LangParserUtils$spaces,
		_user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$symbol(';'))));
var _user$project$LeoParser$sameLineOrIndentedByDifferentThan = F2(
	function (msg, nSpaces) {
		return _user$project$LangParserUtils$spacesCustom(
			A2(
				_user$project$LangParserUtils$SpaceCheck,
				F2(
					function (start, end) {
						return _elm_lang$core$Native_Utils.eq(start.line, end.line) || (!_elm_lang$core$Native_Utils.eq(end.col - 1, nSpaces));
					}),
				function (_p83) {
					var _p84 = _p83;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'I expect that to be on the same line or not indented by ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(nSpaces),
							' spaces.'));
				}));
	});
var _user$project$LeoParser$nextDeclarationSpace = F2(
	function (msg, nSpaces) {
		return _user$project$LangParserUtils$spacesCustom(
			A2(
				_user$project$LangParserUtils$SpaceCheck,
				F2(
					function (start, end) {
						return (_elm_lang$core$Native_Utils.eq(start.line + 1, end.line) && _elm_lang$core$Native_Utils.eq(end.col - 1, nSpaces)) || (_elm_lang$core$Native_Utils.cmp(start.line + 1, end.line) < 0);
					}),
				function (_p85) {
					var _p86 = _p85;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'I expect that to be on a different line and indented by exactly ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(nSpaces),
							' spaces.'));
				}));
	});
var _user$project$LeoParser$sameLineOrIndentedByExactly = F2(
	function (msg, nSpaces) {
		return _user$project$LangParserUtils$spacesCustom(
			A2(
				_user$project$LangParserUtils$SpaceCheck,
				F2(
					function (start, end) {
						return _elm_lang$core$Native_Utils.eq(start.line, end.line) || _elm_lang$core$Native_Utils.eq(end.col - 1, nSpaces);
					}),
				function (_p87) {
					var _p88 = _p87;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'I expect that to be on the same line or indented by exactly ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(nSpaces),
							' spaces.'));
				}));
	});
var _user$project$LeoParser$sameLineOrIndentedByAtLeast = F2(
	function (msg, nSpaces) {
		return _user$project$LangParserUtils$spacesCustom(
			A2(
				_user$project$LangParserUtils$SpaceCheck,
				F2(
					function (start, end) {
						return _elm_lang$core$Native_Utils.eq(start.line, end.line) || (_elm_lang$core$Native_Utils.cmp(end.col - 1, nSpaces) > -1);
					}),
				function (_p89) {
					var _p90 = _p89;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'I expect that to be on the same line or indented by at least ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(nSpaces),
							' spaces.'));
				}));
	});
var _user$project$LeoParser$noSpacePolicy = {
	first: _MikaelMayer$parser$Parser$succeed(_user$project$Lang$space0),
	apparg: _MikaelMayer$parser$Parser$succeed(_user$project$Lang$space0)
};
var _user$project$LeoParser$allSpacesPolicy = {first: _user$project$LangParserUtils$spaces, apparg: _user$project$LangParserUtils$spaces};
var _user$project$LeoParser$spacesWithoutNewline = {first: _user$project$LangParserUtils$spacesWithoutNewline, apparg: _user$project$LangParserUtils$spacesWithoutNewline};
var _user$project$LeoParser$topLevelInsideDefSpacePolicy = {first: _user$project$LangParserUtils$spacesNotBetweenDefs, apparg: _user$project$LangParserUtils$spacesNotBetweenDefs};
var _user$project$LeoParser$topLevelBetweenDefSpacePolicy = {first: _user$project$LangParserUtils$spacesWithoutIndentation, apparg: _user$project$LangParserUtils$spacesWithoutIndentation};
var _user$project$LeoParser$hole = A2(
	_MikaelMayer$parser$Parser$inContext,
	'hole',
	_user$project$LangParserUtils$mapWSExp_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_user$project$Lang$EHole),
			_user$project$ParserUtils$trackInfo(
				A2(_user$project$ParserUtils$token, '??', _user$project$Lang$EEmptyHole)))));
var _user$project$LeoParser$computePrintOrder = function (evaluationOrder) {
	return _elm_lang$core$Array$toList(
		A3(
			_user$project$Utils$foldLeft,
			A2(
				_elm_lang$core$Array$initialize,
				_elm_lang$core$List$length(evaluationOrder),
				function (_p91) {
					return 0;
				}),
			_user$project$Utils$zipWithIndex(evaluationOrder),
			F2(
				function (array, _p92) {
					var _p93 = _p92;
					return A3(_elm_lang$core$Array$set, _p93._0, _p93._1, array);
				})));
};
var _user$project$LeoParser$reorderDeclarations = function (letExps) {
	var _p94 = A3(
		_user$project$Utils$foldLeft,
		{
			ctor: '_Tuple4',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'},
			_2: {ctor: '[]'},
			_3: 0
		},
		letExps,
		F2(
			function (_p95, def) {
				var _p96 = _p95;
				var _p101 = _p96._3;
				var _p100 = _p96._0;
				var _p99 = _p96._2;
				var _p98 = _p96._1;
				var _p97 = def;
				switch (_p97.ctor) {
					case 'DeclType':
						return {
							ctor: '_Tuple4',
							_0: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p97._0, _1: _p101},
								_1: _p100
							},
							_1: _p98,
							_2: _p99,
							_3: _p101 + 1
						};
					case 'DeclAnnotation':
						return {
							ctor: '_Tuple4',
							_0: _p100,
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p97._0, _1: _p101},
								_1: _p98
							},
							_2: _p99,
							_3: _p101 + 1
						};
					default:
						return {
							ctor: '_Tuple4',
							_0: _p100,
							_1: _p98,
							_2: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p97._0, _1: _p101},
								_1: _p99
							},
							_3: _p101 + 1
						};
				}
			}));
	var revTypesWithIndex = _p94._0;
	var revAnnWithIndex = _p94._1;
	var revExpWithIndex = _p94._2;
	var _p102 = {
		ctor: '_Tuple3',
		_0: _elm_lang$core$List$reverse(revTypesWithIndex),
		_1: _elm_lang$core$List$reverse(revAnnWithIndex),
		_2: _elm_lang$core$List$reverse(revExpWithIndex)
	};
	var typesWithIndex = _p102._0;
	var annWithIndex = _p102._1;
	var expWithIndex = _p102._2;
	var canBeRecursive = function (_p103) {
		return !_user$project$Utils$maybeIsEmpty(
			_user$project$Lang$eFunUnapply(_p103));
	};
	var expDefsWithDependencies = A2(
		_elm_lang$core$List$map,
		function (_p104) {
			var _p105 = _p104;
			var _p106 = _p105._0._5;
			return {
				ctor: '_Tuple2',
				_0: {ctor: '_Tuple2', _0: _p105._0, _1: _p105._1},
				_1: {
					ctor: '_Tuple3',
					_0: _user$project$Lang$identifiersSetInPat(_p105._0._2),
					_1: _user$project$Lang$freeIdentifiers(_p106),
					_2: canBeRecursive(_p106)
				}
			};
		},
		expWithIndex);
	var typeDefsWithDependencies = A2(
		_elm_lang$core$List$map,
		function (_p107) {
			var _p108 = _p107;
			return {
				ctor: '_Tuple2',
				_0: {ctor: '_Tuple2', _0: _p108._0, _1: _p108._1},
				_1: {
					ctor: '_Tuple3',
					_0: _user$project$Lang$identifiersSetInPat(_p108._0._3),
					_1: _elm_lang$core$Set$empty,
					_2: false
				}
			};
		},
		typesWithIndex);
	var takeIndices = _elm_lang$core$List$map(
		function (_p109) {
			return _elm_lang$core$Tuple$second(
				_elm_lang$core$Tuple$first(_p109));
		});
	var _p110 = A2(_user$project$Utils$orderWithDependencies, expDefsWithDependencies, _elm_lang$core$Tuple$second);
	if (_p110.ctor === 'Err') {
		return _elm_lang$core$Result$Err(_p110._0);
	} else {
		var _p115 = _p110._0;
		var _p111 = A2(_user$project$Utils$orderWithDependencies, typeDefsWithDependencies, _elm_lang$core$Tuple$second);
		if (_p111.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p111._0);
		} else {
			var _p114 = _p111._0;
			var reorderingTypes = A2(_elm_lang$core$List$concatMap, takeIndices, _p114);
			var _p112 = _elm_lang$core$List$unzip(annWithIndex);
			var finalAnnotations = _p112._0;
			var reorderingAnnotations = _p112._1;
			var reorderingExp = A2(_elm_lang$core$List$concatMap, takeIndices, _p115);
			var evaluationOrder = A2(
				_elm_lang$core$Basics_ops['++'],
				reorderingTypes,
				A2(_elm_lang$core$Basics_ops['++'], reorderingAnnotations, reorderingExp));
			var ff = function (_p113) {
				return _elm_lang$core$Tuple$first(
					_elm_lang$core$Tuple$first(_p113));
			};
			var finalTypes = A3(_user$project$Lang$extractGroupInfo, ff, _user$project$Lang$isTypeMutuallyRecursive, _p114);
			var finalExps = A3(_user$project$Lang$extractGroupInfo, ff, _user$project$Lang$isMutuallyRecursive, _p115);
			var printOrder = _user$project$LeoParser$computePrintOrder(evaluationOrder);
			return _elm_lang$core$Result$Ok(
				A4(_user$project$Lang$Declarations, printOrder, finalTypes, finalAnnotations, finalExps));
		}
	}
};
var _user$project$LeoParser$moduleNames = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'Core',
		_1: {
			ctor: '::',
			_0: 'Basics',
			_1: {
				ctor: '::',
				_0: 'List',
				_1: {
					ctor: '::',
					_0: 'Tuple',
					_1: {
						ctor: '::',
						_0: 'Editor',
						_1: {
							ctor: '::',
							_0: 'Update',
							_1: {
								ctor: '::',
								_0: 'SoftFreeze',
								_1: {
									ctor: '::',
									_0: 'Html',
									_1: {
										ctor: '::',
										_0: 'TableWithButtons',
										_1: {
											ctor: '::',
											_0: 'Results',
											_1: {
												ctor: '::',
												_0: 'LensLess',
												_1: {
													ctor: '::',
													_0: 'ListLenses',
													_1: {
														ctor: '::',
														_0: 'Regex',
														_1: {
															ctor: '::',
															_0: 'String',
															_1: {
																ctor: '::',
																_0: 'Dict',
																_1: {
																	ctor: '::',
																	_0: 'Debug',
																	_1: {
																		ctor: '::',
																		_0: 'Maybe',
																		_1: {
																			ctor: '::',
																			_0: 'Result',
																			_1: {
																				ctor: '::',
																				_0: 'Set',
																				_1: {
																					ctor: '::',
																					_0: 'UI',
																					_1: {ctor: '[]'}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$LeoParser$isDataConstructor = function (name) {
	var notModule = !A2(_elm_lang$core$Set$member, name, _user$project$LeoParser$moduleNames);
	var startsLower = A2(
		_elm_lang$core$Maybe$withDefault,
		false,
		A2(
			_elm_lang$core$Maybe$map,
			function (_p116) {
				return _elm_lang$core$Char$isUpper(
					_elm_lang$core$Tuple$first(_p116));
			},
			_elm_lang$core$String$uncons(name)));
	return startsLower && notModule;
};
var _user$project$LeoParser$opFromIdentifier = function (identifier) {
	var _p117 = identifier;
	switch (_p117) {
		case 'pi':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Pi);
		case '__DictEmpty__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DictEmpty);
		case '__CurrentEnv__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$CurrentEnv);
		case '__DictFromList__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DictFromList);
		case 'cos':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Cos);
		case 'sin':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Sin);
		case 'arccos':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$ArcCos);
		case 'arcsin':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$ArcSin);
		case 'floor':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Floor);
		case 'ceiling':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Ceil);
		case 'round':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Round);
		case 'toString':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$ToStr);
		case 'sqrt':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Sqrt);
		case 'explode':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Explode);
		case '+':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Plus);
		case '-':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Minus);
		case '*':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Mult);
		case '/':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Div);
		case '<':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Lt);
		case '==':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Eq);
		case 'mod':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Mod);
		case '^':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$Pow);
		case 'arctan2':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$ArcTan2);
		case '__DictInsert__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DictInsert);
		case '__DictGet__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DictGet);
		case '__DictRemove__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DictRemove);
		case 'debug':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$DebugLog);
		case 'noWidgets':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$NoWidgets);
		case 'extractFirstIn':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$RegexExtractFirstIn);
		case '__strLength__':
			return _elm_lang$core$Maybe$Just(_user$project$Lang$StrLength);
		default:
			return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoParser$maybeConvertToOp0 = function (_p118) {
	var _p119 = _p118;
	var _p122 = _p119._0;
	var exp = _user$project$Lang$Expr(_p122);
	var _p120 = _user$project$Lang$unwrapExp(exp);
	if (_p120.ctor === 'EVar') {
		var _p121 = _user$project$LeoParser$opFromIdentifier(_p120._1);
		if (_p121.ctor === 'Just') {
			return A2(
				_user$project$Lang$replaceE__,
				exp,
				A5(
					_user$project$Lang$EOp,
					_p120._0,
					_user$project$Lang$space0,
					A3(_user$project$Info$withInfo, _p121._0, _p122.start, _p122.end),
					{ctor: '[]'},
					_user$project$Lang$space0));
		} else {
			return exp;
		}
	} else {
		return exp;
	}
};
var _user$project$LeoParser$maybeConvertToOpN = F2(
	function (_p123, rest) {
		var _p124 = _p123;
		var _p129 = _p124._0;
		var _p128 = _p124;
		var $default = A5(
			_user$project$Lang$EApp,
			_user$project$Lang$precedingWhitespaceWithInfoExp(_p128),
			A2(
				_user$project$Lang$mapPrecedingWhitespace,
				function (_p125) {
					return '';
				},
				_p128),
			A2(_elm_lang$core$List$map, _user$project$LeoParser$maybeConvertToOp0, rest),
			_user$project$Lang$SpaceApp,
			_user$project$Lang$space0);
		var _p126 = _user$project$Lang$unwrapExp(_p128);
		if (_p126.ctor === 'EVar') {
			var _p127 = _user$project$LeoParser$opFromIdentifier(_p126._1);
			if (_p127.ctor === 'Just') {
				return A5(
					_user$project$Lang$EOp,
					_p126._0,
					_user$project$Lang$space0,
					A3(_user$project$Info$withInfo, _p127._0, _p129.start, _p129.end),
					A2(_elm_lang$core$List$map, _user$project$LeoParser$maybeConvertToOp0, rest),
					_user$project$Lang$space0);
			} else {
				return $default;
			}
		} else {
			return $default;
		}
	});
var _user$project$LeoParser$builtInTypePrecedenceList = {
	ctor: '::',
	_0: {
		ctor: '_Tuple3',
		_0: 3,
		_1: {ctor: '[]'},
		_2: {
			ctor: '::',
			_0: '&',
			_1: {ctor: '[]'}
		}
	},
	_1: {
		ctor: '::',
		_0: {
			ctor: '_Tuple3',
			_0: 2,
			_1: {ctor: '[]'},
			_2: {
				ctor: '::',
				_0: '|',
				_1: {ctor: '[]'}
			}
		},
		_1: {
			ctor: '::',
			_0: {
				ctor: '_Tuple3',
				_0: 1,
				_1: {ctor: '[]'},
				_2: {
					ctor: '::',
					_0: '->',
					_1: {ctor: '[]'}
				}
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple3',
					_0: 0,
					_1: {
						ctor: '::',
						_0: '|>',
						_1: {ctor: '[]'}
					},
					_2: {
						ctor: '::',
						_0: '<|',
						_1: {ctor: '[]'}
					}
				},
				_1: {ctor: '[]'}
			}
		}
	}
};
var _user$project$LeoParser$builtInTypePrecedenceTable = _user$project$BinaryOperatorParser$buildPrecedenceTable(_user$project$LeoParser$builtInTypePrecedenceList);
var _user$project$LeoParser$builtInPatternPrecedenceList = {
	ctor: '::',
	_0: {
		ctor: '_Tuple3',
		_0: 2,
		_1: {ctor: '[]'},
		_2: {
			ctor: '::',
			_0: '::',
			_1: {ctor: '[]'}
		}
	},
	_1: {
		ctor: '::',
		_0: {
			ctor: '_Tuple3',
			_0: 1,
			_1: {
				ctor: '::',
				_0: 'as',
				_1: {ctor: '[]'}
			},
			_2: {ctor: '[]'}
		},
		_1: {ctor: '[]'}
	}
};
var _user$project$LeoParser$builtInPatternPrecedenceTable = _user$project$BinaryOperatorParser$buildPrecedenceTable(_user$project$LeoParser$builtInPatternPrecedenceList);
var _user$project$LeoParser$builtInPrecedenceList = {
	ctor: '::',
	_0: {
		ctor: '_Tuple3',
		_0: 9,
		_1: {
			ctor: '::',
			_0: '>>',
			_1: {ctor: '[]'}
		},
		_2: {
			ctor: '::',
			_0: '<<',
			_1: {ctor: '[]'}
		}
	},
	_1: {
		ctor: '::',
		_0: {
			ctor: '_Tuple3',
			_0: 8,
			_1: {ctor: '[]'},
			_2: {
				ctor: '::',
				_0: '^',
				_1: {ctor: '[]'}
			}
		},
		_1: {
			ctor: '::',
			_0: {
				ctor: '_Tuple3',
				_0: 7,
				_1: {
					ctor: '::',
					_0: '*',
					_1: {
						ctor: '::',
						_0: '/',
						_1: {
							ctor: '::',
							_0: '//',
							_1: {
								ctor: '::',
								_0: '%',
								_1: {
									ctor: '::',
									_0: 'rem',
									_1: {ctor: '[]'}
								}
							}
						}
					}
				},
				_2: {ctor: '[]'}
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple3',
					_0: 6,
					_1: {
						ctor: '::',
						_0: '+',
						_1: {
							ctor: '::',
							_0: '-',
							_1: {ctor: '[]'}
						}
					},
					_2: {ctor: '[]'}
				},
				_1: {
					ctor: '::',
					_0: {
						ctor: '_Tuple3',
						_0: 5,
						_1: {ctor: '[]'},
						_2: {
							ctor: '::',
							_0: '++',
							_1: {
								ctor: '::',
								_0: '::',
								_1: {ctor: '[]'}
							}
						}
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple3',
							_0: 4,
							_1: {
								ctor: '::',
								_0: '==',
								_1: {
									ctor: '::',
									_0: '/=',
									_1: {
										ctor: '::',
										_0: '<',
										_1: {
											ctor: '::',
											_0: '>',
											_1: {
												ctor: '::',
												_0: '<=',
												_1: {
													ctor: '::',
													_0: '>=',
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							},
							_2: {ctor: '[]'}
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple3',
								_0: 3,
								_1: {ctor: '[]'},
								_2: {
									ctor: '::',
									_0: '&&',
									_1: {ctor: '[]'}
								}
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple3',
									_0: 2,
									_1: {ctor: '[]'},
									_2: {
										ctor: '::',
										_0: '||',
										_1: {ctor: '[]'}
									}
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple3',
										_0: 1,
										_1: {ctor: '[]'},
										_2: {ctor: '[]'}
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple3',
											_0: 0,
											_1: {
												ctor: '::',
												_0: '|>',
												_1: {ctor: '[]'}
											},
											_2: {
												ctor: '::',
												_0: '<|',
												_1: {ctor: '[]'}
											}
										},
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
var _user$project$LeoParser$builtInPrecedenceTable = _user$project$BinaryOperatorParser$buildPrecedenceTable(_user$project$LeoParser$builtInPrecedenceList);
var _user$project$LeoParser$builtInOperators = A2(
	_elm_lang$core$List$concatMap,
	function (_p130) {
		var _p131 = _p130;
		return A2(_elm_lang$core$Basics_ops['++'], _p131._1, _p131._2);
	},
	_user$project$LeoParser$builtInPrecedenceList);
var _user$project$LeoParser$wildcardType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'wildcard type',
	A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(
			F2(
				function (_p132, wsBefore) {
					var _p133 = _p132;
					return A2(
						_user$project$Info$mapInfo,
						_user$project$Lang$type_,
						A3(
							_user$project$Info$withInfo,
							_user$project$Lang$TWildcard(wsBefore),
							_p133.start,
							_p133.end));
				})),
		_user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$keyword('_'))));
var _user$project$LeoParser$baseType = F3(
	function (context, combiner, token) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			context,
			_user$project$LangParserUtils$mapWSType_(
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						function (_p134) {
							var _p135 = _p134;
							return A3(_user$project$Info$withInfo, combiner, _p135.start, _p135.end);
						}),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$keyword(token)))));
	});
var _user$project$LeoParser$nullType = A3(_user$project$LeoParser$baseType, 'null type', _user$project$Lang$TNull, 'Null');
var _user$project$LeoParser$numType = A3(_user$project$LeoParser$baseType, 'num type', _user$project$Lang$TNum, 'Num');
var _user$project$LeoParser$boolType = A3(_user$project$LeoParser$baseType, 'bool type', _user$project$Lang$TBool, 'Bool');
var _user$project$LeoParser$stringType = A3(_user$project$LeoParser$baseType, 'string type', _user$project$Lang$TString, 'String');
var _user$project$LeoParser$tnamePattern = function (ident) {
	return _user$project$LangParserUtils$mapWSInfo(
		A2(
			_user$project$LangParserUtils$transferInfo,
			F2(
				function (name, wsBefore) {
					return A2(_user$project$Lang$TPatVar, wsBefore, name);
				}),
			ident));
};
var _user$project$LeoParser$wildcardPattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'wildcard pattern',
	_user$project$LangParserUtils$mapWSPat_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			function (_p136) {
				var _p137 = _p136;
				return _user$project$Lang$PWildcard;
			},
			_user$project$LangParserUtils$keywordWithSpace('_'))));
var _user$project$LeoParser$namePattern = function (ident) {
	return _user$project$LangParserUtils$mapWSPat_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			F2(
				function (name, wsBefore) {
					return A3(_user$project$Lang$PVar, wsBefore, name, _user$project$Lang$noWidgetDecl);
				}),
			ident));
};
var _user$project$LeoParser$htmlAttribElemsToExp = F2(
	function (quoteCharStr, content) {
		var contentAsExprs = A2(
			_elm_lang$core$List$map,
			function (l) {
				var _p138 = l.val;
				if (_p138.ctor === 'HTMLAttributeStringRaw') {
					return _user$project$Lang$Expr(
						A2(
							_user$project$Info$replaceInfo,
							l,
							_user$project$Lang$exp_(
								A2(
									_user$project$Lang$EBase,
									_user$project$Lang$space0,
									A2(_user$project$Lang$EString, quoteCharStr, _p138._0)))));
				} else {
					return _user$project$Lang$Expr(
						A3(
							_user$project$Info$withInfo,
							_user$project$Lang$exp_(
								A5(
									_user$project$Lang$EApp,
									_user$project$Lang$space1,
									_user$project$Lang$Expr(
										A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A2(_user$project$Lang$EVar, _user$project$Lang$space1, '__htmlStrEntity__')),
											l.start,
											l.start)),
									{
										ctor: '::',
										_0: _user$project$Lang$Expr(
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A2(
														_user$project$Lang$EBase,
														_user$project$Lang$space0,
														A2(_user$project$Lang$EString, '\"', _p138._0))),
												l.start,
												l.start)),
										_1: {
											ctor: '::',
											_0: _user$project$Lang$Expr(
												A3(
													_user$project$Info$withInfo,
													_user$project$Lang$exp_(
														A2(
															_user$project$Lang$EBase,
															_user$project$Lang$space0,
															A2(_user$project$Lang$EString, '\"', _p138._1))),
													l.start,
													l.end)),
											_1: {ctor: '[]'}
										}
									},
									_user$project$Lang$SpaceApp,
									_user$project$Lang$space0)),
							l.start,
							l.end));
				}
			},
			content);
		var precedingWs = _elm_lang$core$Native_Utils.eq(quoteCharStr, '\"') ? _user$project$Lang$ws('  ') : (_elm_lang$core$Native_Utils.eq(quoteCharStr, '') ? _user$project$Lang$space0 : _user$project$Lang$space1);
		var wrapWithHtmlRawAttribute = F2(
			function (start, content) {
				return _user$project$Lang$Expr(
					_user$project$Info$withDummyInfo(
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EApp,
								precedingWs,
								_user$project$Lang$Expr(
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$exp_(
											A2(_user$project$Lang$EVar, _user$project$Lang$space1, '__htmlRawAttribute__')),
										start,
										start)),
								{
									ctor: '::',
									_0: content,
									_1: {ctor: '[]'}
								},
								_user$project$Lang$SpaceApp,
								_user$project$Lang$space0))));
			});
		var _p139 = contentAsExprs;
		if (_p139.ctor === '[]') {
			return A2(
				wrapWithHtmlRawAttribute,
				_user$project$Pos$dummyPos,
				_user$project$Lang$withDummyExpInfo(
					A2(
						_user$project$Lang$EBase,
						_user$project$Lang$space0,
						A2(_user$project$Lang$EString, quoteCharStr, ''))));
		} else {
			return A2(
				wrapWithHtmlRawAttribute,
				_p139._0._0.start,
				A3(
					_elm_lang$core$List$foldl,
					F2(
						function (_p141, _p140) {
							var _p142 = _p141;
							var _p143 = _p140;
							return _user$project$Lang$Expr(
								A3(
									_user$project$Info$withInfo,
									_user$project$Lang$exp_(
										A5(
											_user$project$Lang$EOp,
											_user$project$Lang$space0,
											_user$project$Lang$space0,
											_user$project$Info$withDummyInfo(_user$project$Lang$Plus),
											{
												ctor: '::',
												_0: _p143,
												_1: {
													ctor: '::',
													_0: _p142,
													_1: {ctor: '[]'}
												}
											},
											_user$project$Lang$space0)),
									_p142._0.start,
									_p143._0.end));
						}),
					_p139._0,
					_p139._1));
		}
	});
var _user$project$LeoParser$wrapWithSyntax = F2(
	function (parensStyle, parser) {
		return A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				function (wsToE) {
					var e = wsToE(_user$project$Lang$space0);
					return A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A4(
								_user$project$Lang$EParens,
								_user$project$Lang$space0,
								_user$project$Lang$Expr(e),
								parensStyle,
								_user$project$Lang$space0)),
						e.start,
						e.end);
				}),
			parser);
	});
var _user$project$LeoParser$eMergeTexts = F3(
	function (start, end, _p144) {
		var _p145 = _p144;
		return _user$project$Lang$Expr(
			A3(
				_user$project$Info$withInfo,
				_user$project$Lang$exp_(
					A5(
						_user$project$Lang$EApp,
						_user$project$Lang$space1,
						_user$project$Lang$Expr(
							A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A2(_user$project$Lang$EVar, _user$project$Lang$space0, '__mergeHtmlText__')),
								start,
								start)),
						{
							ctor: '::',
							_0: _p145,
							_1: {ctor: '[]'}
						},
						_user$project$Lang$SpaceApp,
						_user$project$Lang$space0)),
				start,
				end));
	});
var _user$project$LeoParser$appendToLeft = F2(
	function (_p147, _p146) {
		var _p148 = _p147;
		var _p155 = _p148._1._0;
		var _p149 = _p146;
		var _p154 = _p149._0;
		var thisAttribute = {
			ctor: '_Tuple2',
			_0: _p148._0,
			_1: _user$project$Lang$Expr(_p155)
		};
		var _p150 = _user$project$Lang$unwrapExp(
			_user$project$Lang$Expr(_p154));
		_v58_2:
		do {
			switch (_p150.ctor) {
				case 'EList':
					return _elm_lang$core$Result$Ok(
						_user$project$Lang$Expr(
							A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A5(
										_user$project$Lang$EList,
										_p150._0,
										{ctor: '::', _0: thisAttribute, _1: _p150._1},
										_p150._2,
										_p150._3,
										_p150._4)),
								_p155.start,
								_p154.end)));
				case 'EApp':
					if (((_p150._2.ctor === '::') && (_p150._2._1.ctor === '::')) && (_p150._2._1._1.ctor === '[]')) {
						return A2(
							_elm_lang$core$Result$map,
							function (_p151) {
								var _p152 = _p151;
								var _p153 = _p152._0;
								return _user$project$Lang$Expr(
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$exp_(
											A5(
												_user$project$Lang$EApp,
												_p150._0,
												_p150._1,
												{
													ctor: '::',
													_0: _user$project$Lang$Expr(_p153),
													_1: {
														ctor: '::',
														_0: _p150._2._1._0,
														_1: {ctor: '[]'}
													}
												},
												_p150._3,
												_p150._4)),
										_p153.start,
										_p154.end));
							},
							A2(_user$project$LeoParser$appendToLeft, thisAttribute, _p150._2._0));
					} else {
						break _v58_2;
					}
				default:
					break _v58_2;
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected EList, EApp, but got something else for attributes (line ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p154.start.line),
					')')));
	});
var _user$project$LeoParser$attrsToExp = F2(
	function (lastPos, attrs) {
		var _p156 = attrs;
		if (_p156.ctor === '[]') {
			return _MikaelMayer$parser$Parser$succeed(
				A3(
					_user$project$Info$withInfo,
					_user$project$Lang$exp_(
						A5(
							_user$project$Lang$EList,
							_user$project$Lang$space0,
							{ctor: '[]'},
							_user$project$Lang$space0,
							_elm_lang$core$Maybe$Nothing,
							_user$project$Lang$space0)),
					lastPos,
					lastPos));
		} else {
			var _p171 = _p156._1;
			var _p170 = _p156._0;
			var origin = function (_p157) {
				return A2(
					_user$project$Info$replaceInfo,
					_p170,
					_user$project$Lang$exp_(_p157));
			};
			var _p158 = _p170.val;
			if (_p158.ctor === 'HTMLAttribute') {
				var _p168 = _p158._1;
				var nameExp = A2(
					_user$project$Info$replaceInfo,
					_p168,
					_user$project$Lang$exp_(
						A2(
							_user$project$Lang$EBase,
							_user$project$Lang$space0,
							A2(_user$project$Lang$EString, '\"', _p168.val))));
				var styleSplit = function (e) {
					return A2(
						_user$project$Info$replaceInfo,
						e,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EApp,
								_user$project$Lang$space0,
								_user$project$Lang$Expr(
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$exp_(
											A2(_user$project$Lang$EVar, _user$project$Lang$space1, '__mbstylesplit__')),
										e.start,
										e.start)),
								{
									ctor: '::',
									_0: _user$project$Lang$Expr(e),
									_1: {ctor: '[]'}
								},
								_user$project$Lang$SpaceApp,
								_user$project$Lang$space0)));
				};
				var attrSpaceAtValue = function () {
					var _p159 = _p158._2.val;
					switch (_p159.ctor) {
						case 'HTMLAttributeNoValue':
							return _elm_lang$core$Result$Ok(
								{
									ctor: '_Tuple4',
									_0: _user$project$Lang$space0,
									_1: _user$project$Lang$space0,
									_2: _user$project$HTMLParser$AtAbsent,
									_3: _user$project$Lang$withDummyExp_Info(
										A2(
											_user$project$Lang$EBase,
											_user$project$Lang$ws('    '),
											A2(_user$project$Lang$EString, '\"', '')))
								});
						case 'HTMLAttributeExp':
							var _p161 = _p159._3;
							var final_e = function () {
								var _p160 = _p168.val;
								if (_p160 === 'style') {
									return styleSplit(_p161);
								} else {
									return _p161;
								}
							}();
							return _elm_lang$core$Result$Ok(
								{ctor: '_Tuple4', _0: _p159._0, _1: _p159._1, _2: _p159._2, _3: final_e});
						case 'HTMLAttributeString':
							var _p162 = A2(_user$project$LeoParser$htmlAttribElemsToExp, _p159._2, _p159._3);
							var attrValue = _p162._0;
							var final_e = function () {
								var _p163 = _p168.val;
								if (_p163 === 'style') {
									return styleSplit(attrValue);
								} else {
									return attrValue;
								}
							}();
							return _elm_lang$core$Result$Ok(
								{ctor: '_Tuple4', _0: _p159._0, _1: _p159._1, _2: _user$project$HTMLParser$AtAbsent, _3: final_e});
						default:
							var _p164 = A2(_user$project$LeoParser$htmlAttribElemsToExp, '', _p159._2);
							var attrValue = _p164._0;
							var final_e = function () {
								var _p165 = _p168.val;
								if (_p165 === 'style') {
									return styleSplit(attrValue);
								} else {
									return attrValue;
								}
							}();
							return _elm_lang$core$Result$Ok(
								{ctor: '_Tuple4', _0: _p159._0, _1: _p159._1, _2: _user$project$HTMLParser$AtAbsent, _3: final_e});
					}
				}();
				var _p166 = attrSpaceAtValue;
				if (_p166.ctor === 'Err') {
					return _MikaelMayer$parser$Parser$fail(_p166._0);
				} else {
					var thisAttribute = A2(
						_user$project$Info$replaceInfo,
						_p170,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EList,
								_p158._0,
								{
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: _elm_lang$core$Native_Utils.eq(_p166._0._2, _user$project$HTMLParser$AtAbsent) ? _user$project$Lang$space0 : _user$project$Lang$space1,
										_1: _user$project$Lang$Expr(nameExp)
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: _p166._0._0,
											_1: _user$project$Lang$Expr(_p166._0._3)
										},
										_1: {ctor: '[]'}
									}
								},
								_p166._0._1,
								_elm_lang$core$Maybe$Nothing,
								_user$project$Lang$space0)));
					return A2(
						_MikaelMayer$parser$Parser$andThen,
						function (tailAttrExp) {
							var _p167 = A2(
								_user$project$LeoParser$appendToLeft,
								{
									ctor: '_Tuple2',
									_0: _user$project$Lang$space0,
									_1: _user$project$Lang$Expr(thisAttribute)
								},
								_user$project$Lang$Expr(tailAttrExp));
							if (_p167.ctor === 'Err') {
								return _MikaelMayer$parser$Parser$fail(_p167._0);
							} else {
								return _MikaelMayer$parser$Parser$succeed(_p167._0._0);
							}
						},
						A2(_user$project$LeoParser$attrsToExp, _p170.end, _p171));
				}
			} else {
				var _p169 = _p158._1;
				return A2(
					_MikaelMayer$parser$Parser$map,
					function (tailAttrExp) {
						var appendFun = A2(
							_user$project$Info$replaceInfo,
							_p170,
							_user$project$Lang$exp_(
								A2(_user$project$Lang$EVar, _user$project$Lang$space0, '++')));
						return A3(
							_user$project$Info$withInfo,
							_user$project$Lang$exp_(
								A5(
									_user$project$Lang$EApp,
									_p158._0,
									_user$project$Lang$Expr(appendFun),
									{
										ctor: '::',
										_0: _user$project$Lang$Expr(
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A5(
														_user$project$Lang$EApp,
														_user$project$Lang$space0,
														_user$project$Lang$Expr(appendFun),
														{
															ctor: '::',
															_0: _user$project$Lang$Expr(
																A3(
																	_user$project$Info$withInfo,
																	_user$project$Lang$exp_(
																		A5(
																			_user$project$Lang$EList,
																			_user$project$Lang$space0,
																			{ctor: '[]'},
																			_user$project$Lang$space0,
																			_elm_lang$core$Maybe$Nothing,
																			_user$project$Lang$space0)),
																	lastPos,
																	lastPos)),
															_1: {
																ctor: '::',
																_0: _user$project$Lang$Expr(_p169),
																_1: {ctor: '[]'}
															}
														},
														_user$project$Lang$InfixApp,
														_user$project$Lang$space0)),
												_p170.start,
												_p169.end)),
										_1: {
											ctor: '::',
											_0: _user$project$Lang$Expr(tailAttrExp),
											_1: {ctor: '[]'}
										}
									},
									_user$project$Lang$InfixApp,
									_user$project$Lang$space0)),
							_p170.start,
							tailAttrExp.end);
					},
					A2(_user$project$LeoParser$attrsToExp, _p170.end, _p171));
			}
		}
	});
var _user$project$LeoParser$htmlnode = function (source) {
	return function (tagName) {
		return function (attributes) {
			return function (spaceBeforeEndOpeningTag) {
				return function (children) {
					return function (autoclosing) {
						return function (voidClosing) {
							return function (forgotClosing) {
								return function (implicitElem) {
									return function (spaceAfterTagClosing) {
										var origin = function (_p172) {
											return A2(
												_user$project$Info$replaceInfo,
												source,
												_user$project$Lang$exp_(_p172));
										};
										var spaceBeforeTail = _user$project$Info$withDummyInfo(
											autoclosing ? _user$project$Lang$encoding_autoclosing : (voidClosing ? _user$project$Lang$encoding_voidclosing : (forgotClosing ? _user$project$Lang$encoding_forgotclosing : (implicitElem ? _user$project$Lang$encoding_implicitelem : ''))));
										var tag = function () {
											var _p173 = tagName;
											if (_p173.ctor === 'HTMLTagString') {
												var _p174 = _p173._0;
												return A3(
													_user$project$Info$withInfo,
													_user$project$Lang$exp_(
														A2(
															_user$project$Lang$EBase,
															_user$project$Lang$space0,
															A2(_user$project$Lang$EString, '\"', _p174.val))),
													_p174.start,
													_p174.end);
											} else {
												return _p173._0;
											}
										}();
										return origin(
											A5(
												_user$project$Lang$EList,
												_user$project$Lang$space0,
												{
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: _user$project$Lang$space0,
														_1: _user$project$Lang$Expr(tag)
													},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: _user$project$Lang$space0, _1: attributes},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: spaceBeforeEndOpeningTag, _1: children},
															_1: {ctor: '[]'}
														}
													}
												},
												spaceBeforeTail,
												_elm_lang$core$Maybe$Nothing,
												spaceAfterTagClosing));
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var _user$project$LeoParser$htmlComment = F2(
	function (source, comment) {
		var origin = function (_p175) {
			return A2(
				_user$project$Info$replaceInfo,
				source,
				_user$project$Lang$exp_(_p175));
		};
		var _p176 = function () {
			var _p177 = comment;
			switch (_p177.ctor) {
				case 'Less_Greater':
					return {ctor: '_Tuple3', _0: '<', _1: '>', _2: _p177._0};
				case 'LessSlash_Greater':
					return {ctor: '_Tuple3', _0: '</', _1: '>', _2: _p177._0};
				case 'LessBang_Greater':
					return {ctor: '_Tuple3', _0: '<!', _1: '>', _2: _p177._0};
				default:
					return {ctor: '_Tuple3', _0: '<!--', _1: '-->', _2: _p177._0};
			}
		}();
		var opening = _p176._0;
		var closing = _p176._1;
		var string = _p176._2;
		var startString = function () {
			var i = source.start;
			return _elm_lang$core$Native_Utils.update(
				i,
				{
					col: source.start.col + _elm_lang$core$String$length(opening)
				});
		}();
		var endString = function () {
			var i = source.end;
			return _elm_lang$core$Native_Utils.update(
				i,
				{
					col: source.start.col - _elm_lang$core$String$length(closing)
				});
		}();
		return origin(
			A5(
				_user$project$Lang$EList,
				A3(
					_user$project$Info$withInfo,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'{-',
						A2(
							_elm_lang$core$Basics_ops['++'],
							opening,
							A2(
								_elm_lang$core$Basics_ops['++'],
								':',
								A2(_elm_lang$core$Basics_ops['++'], closing, '-}')))),
					source.start,
					source.start),
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: _user$project$Lang$space0,
						_1: _user$project$Lang$Expr(
							A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A2(
										_user$project$Lang$EBase,
										_user$project$Lang$space0,
										A2(_user$project$Lang$EString, '\"', 'COMMENT'))),
								source.start,
								source.start))
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _user$project$Lang$space0,
							_1: _user$project$Lang$Expr(
								A3(
									_user$project$Info$withInfo,
									_user$project$Lang$exp_(
										A2(
											_user$project$Lang$EBase,
											_user$project$Lang$space0,
											A2(_user$project$Lang$EString, '\"', string))),
									startString,
									endString))
						},
						_1: {ctor: '[]'}
					}
				},
				_user$project$Lang$space0,
				_elm_lang$core$Maybe$Nothing,
				_user$project$Lang$space0));
	});
var _user$project$LeoParser$htmlText = F2(
	function (source, htmltext) {
		var origin = function (_p178) {
			return A2(
				_user$project$Info$replaceInfo,
				source,
				_user$project$Lang$exp_(_p178));
		};
		return origin(
			A5(
				_user$project$Lang$EList,
				_user$project$Lang$space0,
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: _user$project$Lang$space0,
						_1: _user$project$Lang$Expr(
							A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A2(
										_user$project$Lang$EBase,
										_user$project$Lang$space0,
										A2(_user$project$Lang$EString, '\"', 'TEXT'))),
								source.start,
								source.start))
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _user$project$Lang$space0,
							_1: _user$project$Lang$Expr(
								origin(
									A2(
										_user$project$Lang$EBase,
										_user$project$Lang$space0,
										A2(_user$project$Lang$EString, '\"', htmltext))))
						},
						_1: {ctor: '[]'}
					}
				},
				_user$project$Lang$space0,
				_elm_lang$core$Maybe$Nothing,
				_user$project$Lang$space0));
	});
var _user$project$LeoParser$forbiddenTagsInHtmlInner = _elm_lang$core$Regex$regex('</[^>\n]*>');
var _user$project$LeoParser$htmlToExp = F2(
	function (parentTag, node) {
		var _p179 = node.val;
		switch (_p179.ctor) {
			case 'HTMLInner':
				var _p182 = _p179._0;
				if (_elm_lang$core$Native_Utils.eq(parentTag, 'script') || _elm_lang$core$Native_Utils.eq(parentTag, 'style')) {
					return _MikaelMayer$parser$Parser$succeed(
						A2(_user$project$LeoParser$htmlText, node, _p182));
				} else {
					var _p180 = A3(_elm_lang$core$Regex$find, _elm_lang$core$Regex$All, _user$project$LeoParser$forbiddenTagsInHtmlInner, _p182);
					if (_p180.ctor === '[]') {
						return _MikaelMayer$parser$Parser$succeed(
							A2(_user$project$LeoParser$htmlText, node, _p182));
					} else {
						return _MikaelMayer$parser$Parser$succeed(
							A2(
								_user$project$LeoParser$htmlText,
								node,
								A4(
									_elm_lang$core$Regex$replace,
									_elm_lang$core$Regex$All,
									_user$project$LeoParser$forbiddenTagsInHtmlInner,
									function (_p181) {
										return '';
									},
									_p182)));
					}
				}
			case 'HTMLElement':
				var _p193 = _p179._0;
				var _p192 = _p179._2;
				var _p191 = _p179._3;
				var _p190 = _p179._5;
				var _p183 = {ctor: '_Tuple2', _0: _p190, _1: _p191};
				var _p184 = function () {
					var _p185 = _p193;
					if (_p185.ctor === 'HTMLTagString') {
						var _p186 = _p185._0;
						return {ctor: '_Tuple2', _0: _p186.end, _1: _p186.val};
					} else {
						return {ctor: '_Tuple2', _0: _p185._0.end, _1: '@'};
					}
				}();
				var endPos = _p184._0;
				var tagStr = _p184._1;
				return A2(
					_MikaelMayer$parser$Parser$andThen,
					function (finalattrs) {
						var start = {
							line: _p192.end.line,
							col: _p192.end.col + (_elm_lang$core$Native_Utils.eq(_p191, _user$project$HTMLParser$RegularEndOpening) ? 1 : 2)
						};
						return A2(
							_MikaelMayer$parser$Parser$andThen,
							function (_p187) {
								var _p188 = _p187;
								return _MikaelMayer$parser$Parser$succeed(
									_user$project$LeoParser$htmlnode(node)(_p193)(
										_user$project$Lang$Expr(finalattrs))(_p192)(
										(_p188._1 ? A2(_user$project$LeoParser$eMergeTexts, start, _p188._0) : _elm_lang$core$Basics$identity)(
											_user$project$Lang$Expr(_p188._2)))(
										_elm_lang$core$Native_Utils.eq(_p190, _user$project$HTMLParser$AutoClosing))(
										_elm_lang$core$Native_Utils.eq(_p190, _user$project$HTMLParser$VoidClosing))(
										_elm_lang$core$Native_Utils.eq(_p190, _user$project$HTMLParser$ForgotClosing))(
										_elm_lang$core$Native_Utils.eq(_p190, _user$project$HTMLParser$ImplicitElem))(
										function () {
											var _p189 = _p190;
											if (_p189.ctor === 'RegularClosing') {
												return _p189._0;
											} else {
												return _user$project$Lang$space0;
											}
										}()));
							},
							A4(_user$project$LeoParser$childrenToExp, tagStr, start, false, _p179._4));
					},
					A2(_user$project$LeoParser$attrsToExp, endPos, _p179._1));
			case 'HTMLComment':
				return _MikaelMayer$parser$Parser$succeed(
					A2(_user$project$LeoParser$htmlComment, node, _p179._0));
			case 'HTMLEntity':
				var appendFun = _user$project$Lang$Expr(
					A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A2(_user$project$Lang$EVar, _user$project$Lang$space0, '++')),
						node.start,
						node.start));
				return _MikaelMayer$parser$Parser$succeed(
					A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EApp,
								_user$project$Lang$space0,
								appendFun,
								{
									ctor: '::',
									_0: _user$project$Lang$Expr(
										A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A5(
													_user$project$Lang$EList,
													_user$project$Lang$space0,
													{ctor: '[]'},
													_user$project$Lang$space0,
													_elm_lang$core$Maybe$Nothing,
													_user$project$Lang$space0)),
											node.start,
											node.start)),
									_1: {
										ctor: '::',
										_0: _user$project$Lang$Expr(
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A5(
														_user$project$Lang$EApp,
														_user$project$Lang$space1,
														_user$project$Lang$Expr(
															A3(
																_user$project$Info$withInfo,
																_user$project$Lang$exp_(
																	A2(_user$project$Lang$EVar, _user$project$Lang$space1, '__htmlEntity__')),
																node.start,
																node.start)),
														{
															ctor: '::',
															_0: _user$project$Lang$Expr(
																A3(
																	_user$project$Info$withInfo,
																	_user$project$Lang$exp_(
																		A2(
																			_user$project$Lang$EBase,
																			_user$project$Lang$space0,
																			A2(_user$project$Lang$EString, '\"', _p179._0))),
																	node.start,
																	node.start)),
															_1: {
																ctor: '::',
																_0: _user$project$Lang$Expr(
																	A3(
																		_user$project$Info$withInfo,
																		_user$project$Lang$exp_(
																			A2(
																				_user$project$Lang$EBase,
																				_user$project$Lang$space0,
																				A2(_user$project$Lang$EString, '\"', _p179._1))),
																		node.start,
																		node.end)),
																_1: {ctor: '[]'}
															}
														},
														_user$project$Lang$SpaceApp,
														_user$project$Lang$space0)),
												node.start,
												node.end)),
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								_user$project$Lang$space0)),
						node.start,
						node.end));
			default:
				var _p194 = _p179._0;
				var appendFun = _user$project$Lang$Expr(
					A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A2(_user$project$Lang$EVar, _user$project$Lang$space0, '++')),
						node.start,
						node.start));
				return _MikaelMayer$parser$Parser$succeed(
					A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EApp,
								_user$project$Lang$space0,
								appendFun,
								{
									ctor: '::',
									_0: _user$project$Lang$Expr(
										A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A5(
													_user$project$Lang$EList,
													_user$project$Lang$space0,
													{ctor: '[]'},
													_user$project$Lang$space0,
													_elm_lang$core$Maybe$Nothing,
													_user$project$Lang$space0)),
											node.start,
											node.start)),
									_1: {
										ctor: '::',
										_0: _user$project$Lang$Expr(
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A5(
														_user$project$Lang$EApp,
														_user$project$Lang$space1,
														_user$project$Lang$Expr(
															A3(
																_user$project$Info$withInfo,
																_user$project$Lang$exp_(
																	A2(_user$project$Lang$EVar, _user$project$Lang$space1, '__mbwraphtmlnode__')),
																_p194.start,
																_p194.start)),
														{
															ctor: '::',
															_0: _user$project$Lang$Expr(_p194),
															_1: {ctor: '[]'}
														},
														_user$project$Lang$SpaceApp,
														_user$project$Lang$space0)),
												_p194.start,
												_p194.end)),
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								_user$project$Lang$space0)),
						node.start,
						_p194.end));
		}
	});
var _user$project$LeoParser$childrenToExp = F4(
	function (parentTag, lastPos, wasInterpolated, children) {
		var _p195 = children;
		if (_p195.ctor === '[]') {
			return _MikaelMayer$parser$Parser$succeed(
				A3(
					F3(
						function (v0, v1, v2) {
							return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
						}),
					lastPos,
					wasInterpolated,
					A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EList,
								_user$project$Lang$space0,
								{ctor: '[]'},
								_user$project$Lang$space0,
								_elm_lang$core$Maybe$Nothing,
								_user$project$Lang$space0)),
						lastPos,
						lastPos)));
		} else {
			var _p204 = _p195._0;
			var newWasInterpolation = function () {
				var _p196 = _p204.val;
				switch (_p196.ctor) {
					case 'HTMLListNodeExp':
						return true;
					case 'HTMLEntity':
						return true;
					default:
						return wasInterpolated;
				}
			}();
			return A2(
				_MikaelMayer$parser$Parser$andThen,
				function (headExp) {
					return A2(
						_MikaelMayer$parser$Parser$andThen,
						function (_p197) {
							var _p198 = _p197;
							var _p203 = _p198._2;
							var _p202 = _p198._1;
							var _p201 = _p198._0;
							var _p199 = _user$project$Lang$unwrapExp(
								_user$project$Lang$Expr(headExp));
							if (_p199.ctor === 'EApp') {
								var appendFun = _user$project$Lang$Expr(
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$exp_(
											A2(_user$project$Lang$EVar, _user$project$Lang$space0, '++')),
										headExp.end,
										_p203.start));
								return _MikaelMayer$parser$Parser$succeed(
									A3(
										F3(
											function (v0, v1, v2) {
												return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
											}),
										_p201,
										_p202,
										A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A5(
													_user$project$Lang$EApp,
													_user$project$Lang$space0,
													appendFun,
													{
														ctor: '::',
														_0: _user$project$Lang$Expr(headExp),
														_1: {
															ctor: '::',
															_0: _user$project$Lang$Expr(_p203),
															_1: {ctor: '[]'}
														}
													},
													_user$project$Lang$InfixApp,
													_user$project$Lang$space0)),
											headExp.start,
											_p203.end)));
							} else {
								var _p200 = A2(
									_user$project$LeoParser$appendToLeft,
									{
										ctor: '_Tuple2',
										_0: _user$project$Lang$space0,
										_1: _user$project$Lang$Expr(headExp)
									},
									_user$project$Lang$Expr(_p203));
								if (_p200.ctor === 'Err') {
									return _MikaelMayer$parser$Parser$fail(_p200._0);
								} else {
									return _MikaelMayer$parser$Parser$succeed(
										A3(
											F3(
												function (v0, v1, v2) {
													return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
												}),
											_p201,
											_p202,
											_p200._0._0));
								}
							}
						},
						A4(_user$project$LeoParser$childrenToExp, parentTag, _p204.end, newWasInterpolation, _p195._1));
				},
				A2(_user$project$LeoParser$htmlToExp, parentTag, _p204));
		}
	});
var _user$project$LeoParser$htmlEscape = _user$project$ImpureGoodies$htmlescape;
var _user$project$LeoParser$multilineConcatExp = F2(
	function (exps, startPosition) {
		var _p205 = exps;
		if (_p205.ctor === '[]') {
			return _elm_lang$core$Native_Utils.crashCase(
				'LeoParser',
				{
					start: {line: 677, column: 3},
					end: {line: 688, column: 36}
				},
				_p205)('Internal error: No expression in longstring literal');
		} else {
			if (_p205._1.ctor === '[]') {
				return _p205._0._0;
			} else {
				var _p209 = _p205._0._0;
				var tailPart = A2(_user$project$LeoParser$multilineConcatExp, _p205._1, _p209.end);
				var _p207 = _user$project$Lang$unwrapExp(
					_user$project$Lang$Expr(_p209));
				if (_p207.ctor === 'ELet') {
					var _p208 = A2(
						_user$project$Lang$replaceE__,
						_user$project$Lang$Expr(_p209),
						A5(
							_user$project$Lang$ELet,
							_p207._0,
							_p207._1,
							_p207._2,
							_p207._3,
							_user$project$Lang$Expr(tailPart)));
					var e = _p208._0;
					return e;
				} else {
					return A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$EOp,
								_user$project$Lang$space0,
								_user$project$Lang$space1,
								A3(_user$project$Info$withInfo, _user$project$Lang$Plus, _p209.end, tailPart.start),
								{
									ctor: '::',
									_0: _user$project$Lang$Expr(_p209),
									_1: {
										ctor: '::',
										_0: _user$project$Lang$Expr(tailPart),
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$space0)),
						_p209.start,
						tailPart.end);
				}
			}
		}
	});
var _user$project$LeoParser$multilineParseUntilRegex = _elm_lang$core$Regex$regex('@|\"\"\"(?!\")');
var _user$project$LeoParser$eString = A2(
	_MikaelMayer$parser$Parser$inContext,
	'single-line string',
	_user$project$ParserUtils$trackInfo(
		A2(
			_MikaelMayer$parser$Parser$map,
			function (_p210) {
				var _p211 = _p210;
				return A2(_user$project$Lang$EString, _p211._0, _p211._1);
			},
			_user$project$ParserUtils$singleLineString)));
var _user$project$LeoParser$bool = A2(
	_MikaelMayer$parser$Parser$inContext,
	'bool',
	_user$project$ParserUtils$trackInfo(
		A2(
			_MikaelMayer$parser$Parser$map,
			_user$project$Lang$EBool,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(_user$project$ParserUtils$token, 'True', true),
					_1: {
						ctor: '::',
						_0: A2(_user$project$ParserUtils$token, 'False', false),
						_1: {ctor: '[]'}
					}
				}))));
var _user$project$LeoParser$baseValue = A2(
	_MikaelMayer$parser$Parser$inContext,
	'base value',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _user$project$LeoParser$eString,
			_1: {
				ctor: '::',
				_0: _user$project$LeoParser$bool,
				_1: {ctor: '[]'}
			}
		}));
var _user$project$LeoParser$baseValuePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'base value pattern',
	_user$project$LangParserUtils$mapWSPat_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_user$project$Lang$PBase),
			_user$project$LeoParser$baseValue)));
var _user$project$LeoParser$baseValueExpression = A2(
	_MikaelMayer$parser$Parser$inContext,
	'base value expression',
	_user$project$LangParserUtils$mapWSExp_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_user$project$Lang$EBase),
			_user$project$LeoParser$baseValue)));
var _user$project$LeoParser$frozenAnnotation = A2(
	_MikaelMayer$parser$Parser$inContext,
	'frozen annotation',
	_user$project$ParserUtils$trackInfo(
		_MikaelMayer$parser$Parser$oneOf(
			A2(
				_elm_lang$core$List$map,
				function (a) {
					return A2(_user$project$ParserUtils$token, a, a);
				},
				{
					ctor: '::',
					_0: _user$project$Lang$frozen,
					_1: {
						ctor: '::',
						_0: _user$project$Lang$thawed,
						_1: {
							ctor: '::',
							_0: _user$project$Lang$assignOnlyOnce,
							_1: {
								ctor: '::',
								_0: _user$project$Lang$unann,
								_1: {ctor: '[]'}
							}
						}
					}
				}))));
var _user$project$LeoParser$isInt = function (n) {
	return _elm_lang$core$Native_Utils.eq(
		n,
		_elm_lang$core$Basics$toFloat(
			_elm_lang$core$Basics$floor(n)));
};
var _user$project$LeoParser$num = function () {
	var sign = _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				_MikaelMayer$parser$Parser$succeed(-1),
				_MikaelMayer$parser$Parser$symbol('-')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$succeed(1),
				_1: {ctor: '[]'}
			}
		});
	return _user$project$ParserUtils$try(
		A2(
			_MikaelMayer$parser$Parser$inContext,
			'number',
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (s, n) {
									return s * n;
								})),
						sign),
					_MikaelMayer$parser$Parser$float))));
}();
var _user$project$LeoParser$widgetDecl = function (cap) {
	var combiner = F3(
		function (a, tok, b) {
			return A2(
				_elm_lang$core$List$all,
				_user$project$LeoParser$isInt,
				{
					ctor: '::',
					_0: a.val,
					_1: {
						ctor: '::',
						_0: b.val,
						_1: {ctor: '[]'}
					}
				}) ? A5(
				_user$project$Lang$IntSlider,
				A2(_user$project$Info$mapInfo, _elm_lang$core$Basics$floor, a),
				tok,
				A2(_user$project$Info$mapInfo, _elm_lang$core$Basics$floor, b),
				cap,
				false) : A5(_user$project$Lang$NumSlider, a, tok, b, cap, false);
		});
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'widget declaration',
		_user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(combiner),
										_MikaelMayer$parser$Parser$symbol('{')),
									_user$project$LeoParser$num),
								_user$project$ParserUtils$trackInfo(
									A2(_user$project$ParserUtils$token, '-', '-'))),
							_user$project$LeoParser$num),
						_MikaelMayer$parser$Parser$symbol('}')),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$succeed(_user$project$Lang$NoWidgetDecl),
						_1: {ctor: '[]'}
					}
				})));
};
var _user$project$LeoParser$constantPattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'constant pattern',
	_user$project$LangParserUtils$mapWSPat_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_user$project$Lang$PConst),
			_user$project$LeoParser$num)));
var _user$project$LeoParser$constantExpression = A2(
	_MikaelMayer$parser$Parser$inContext,
	'constant expression',
	_user$project$LangParserUtils$mapWSExp_(
		A2(
			_MikaelMayer$parser$Parser$map,
			function (_p212) {
				var _p213 = _p212;
				var _p215 = _p213._2;
				var _p214 = _p213._0;
				return A3(
					_user$project$Info$withInfo,
					function (ws) {
						return A4(
							_user$project$Lang$EConst,
							ws,
							_p214.val,
							A2(_user$project$Lang$dummyLocWithDebugInfo, _p213._1.val, _p214.val),
							_p215);
					},
					_p214.start,
					_p215.end);
			},
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (v0, v1, v2) {
									return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
								})),
						_user$project$LeoParser$num),
					_user$project$LeoParser$frozenAnnotation),
				_user$project$LeoParser$widgetDecl(_elm_lang$core$Maybe$Nothing)))));
var _user$project$LeoParser$typeSymbolIdentifier = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('&')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$symbol('|')),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$source(
						_MikaelMayer$parser$Parser$symbol('->')),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$source(
							_MikaelMayer$parser$Parser$symbol('<|')),
						_1: {
							ctor: '::',
							_0: _MikaelMayer$parser$Parser$source(
								_MikaelMayer$parser$Parser$symbol('|>')),
							_1: {ctor: '[]'}
						}
					}
				}
			}
		}));
var _user$project$LeoParser$typeOperator = function (appargSpace) {
	return A3(
		_user$project$LangParserUtils$paddedBefore,
		F2(
			function (v0, v1) {
				return {ctor: '_Tuple2', _0: v0, _1: v1};
			}),
		appargSpace,
		_user$project$LeoParser$typeSymbolIdentifier);
};
var _user$project$LeoParser$patternSymbolIdentifier = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('::')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$keyword('as')),
				_1: {ctor: '[]'}
			}
		}));
var _user$project$LeoParser$patternOperator = function (appargSpace) {
	return A3(
		_user$project$LangParserUtils$paddedBefore,
		F2(
			function (v0, v1) {
				return {ctor: '_Tuple2', _0: v0, _1: v1};
			}),
		appargSpace,
		_user$project$LeoParser$patternSymbolIdentifier);
};
var _user$project$LeoParser$htmlAttributeSymbolIdentifier = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('<|')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$symbol('::')),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$source(
						_MikaelMayer$parser$Parser$symbol('||')),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser$keep,
							_MikaelMayer$parser$Parser$oneOrMore,
							function (x) {
								return _user$project$LeoLang$isSymbol(x) && (!(_elm_lang$core$Native_Utils.eq(
									x,
									_elm_lang$core$Native_Utils.chr('|')) || (_elm_lang$core$Native_Utils.eq(
									x,
									_elm_lang$core$Native_Utils.chr('>')) || _elm_lang$core$Native_Utils.eq(
									x,
									_elm_lang$core$Native_Utils.chr('/')))));
							}),
						_1: {ctor: '[]'}
					}
				}
			}
		}));
var _user$project$LeoParser$htmlAttributeOperator = function (appargSpace) {
	return A3(
		_user$project$LangParserUtils$paddedBefore,
		F2(
			function (v0, v1) {
				return {ctor: '_Tuple2', _0: v0, _1: v1};
			}),
		appargSpace,
		_user$project$LeoParser$htmlAttributeSymbolIdentifier);
};
var _user$project$LeoParser$symbolIdentifier = _user$project$ParserUtils$trackInfo(
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$source(
				_MikaelMayer$parser$Parser$symbol('<|')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$source(
					_MikaelMayer$parser$Parser$symbol('|>')),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$source(
						_MikaelMayer$parser$Parser$symbol('::')),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$source(
							_MikaelMayer$parser$Parser$symbol('||')),
						_1: {
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser$keep,
								_MikaelMayer$parser$Parser$oneOrMore,
								function (x) {
									return _user$project$LeoLang$isSymbol(x) && (!_elm_lang$core$Native_Utils.eq(
										x,
										_elm_lang$core$Native_Utils.chr('|')));
								}),
							_1: {ctor: '[]'}
						}
					}
				}
			}
		}));
var _user$project$LeoParser$operator = function (appargSpace) {
	return A3(
		_user$project$LangParserUtils$paddedBefore,
		F2(
			function (v0, v1) {
				return {ctor: '_Tuple2', _0: v0, _1: v1};
			}),
		appargSpace,
		_user$project$LeoParser$symbolIdentifier);
};
var _user$project$LeoParser$implicitOp = _MikaelMayer$parser$Parser$lazy(
	function (_p216) {
		return A2(
			_MikaelMayer$parser$Parser$andThen,
			function (op) {
				var _p217 = op.val;
				var ws0 = _p217._0;
				var identifier = _p217._1;
				var _p218 = _user$project$LeoParser$opFromIdentifier(identifier);
				if (_p218.ctor === 'Just') {
					return _MikaelMayer$parser$Parser$succeed(
						function (wsBefore) {
							return A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A5(
										_user$project$Lang$EOp,
										wsBefore,
										_user$project$Lang$space0,
										A3(_user$project$Info$withInfo, _p218._0, op.start, op.end),
										{ctor: '[]'},
										_user$project$Lang$space0)),
								op.start,
								op.end);
						});
				} else {
					return _MikaelMayer$parser$Parser$succeed(
						function (w) {
							return A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A2(_user$project$Lang$EVar, w, identifier)),
								op.start,
								op.end);
						});
				}
			},
			_user$project$LeoParser$operator(_user$project$LangParserUtils$nospace));
	});
var _user$project$LeoParser$moreKeywords = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'Null',
		_1: {
			ctor: '::',
			_0: 'Num',
			_1: {
				ctor: '::',
				_0: 'Bool',
				_1: {
					ctor: '::',
					_0: 'String',
					_1: {ctor: '[]'}
				}
			}
		}
	});
var _user$project$LeoParser$keywords = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'let',
		_1: {
			ctor: '::',
			_0: 'letrec',
			_1: {
				ctor: '::',
				_0: 'in',
				_1: {
					ctor: '::',
					_0: 'case',
					_1: {
						ctor: '::',
						_0: 'of',
						_1: {
							ctor: '::',
							_0: 'if',
							_1: {
								ctor: '::',
								_0: 'then',
								_1: {
									ctor: '::',
									_0: 'else',
									_1: {
										ctor: '::',
										_0: 'type',
										_1: {
											ctor: '::',
											_0: 'alias',
											_1: {
												ctor: '::',
												_0: 'True',
												_1: {
													ctor: '::',
													_0: 'False',
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$LeoParser$identifier = A3(_MikaelMayer$parser$Parser_LanguageKit$variable, _user$project$LangParserUtils$isFirstChar, _user$project$LangParserUtils$isRestChar, _user$project$LeoParser$keywords);
var _user$project$LeoParser$anyIdentifier = _user$project$ParserUtils$trackInfo(_user$project$LeoParser$identifier);
var _user$project$LeoParser$variablePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'variable pattern',
	_user$project$LeoParser$namePattern(_user$project$LeoParser$anyIdentifier));
var _user$project$LeoParser$variableExpression = _user$project$LangParserUtils$mapWSExp_(
	A2(
		_user$project$LangParserUtils$transferInfo,
		_elm_lang$core$Basics$flip(_user$project$Lang$EVar),
		_user$project$LeoParser$anyIdentifier));
var _user$project$LeoParser$selection = _MikaelMayer$parser$Parser$lazy(
	function (_p219) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F4(
				function (wsBeforeDot, _p220, ws2Exp, wsBefore) {
					var _p221 = _p220;
					var _p222 = _p221._1;
					var exp = ws2Exp(_user$project$Lang$space0);
					return A3(
						_user$project$Info$withInfo,
						_user$project$Lang$exp_(
							A5(
								_user$project$Lang$ESelect,
								wsBefore,
								_user$project$Lang$Expr(exp),
								wsBeforeDot,
								_p221._0,
								_p222.val)),
						exp.start,
						_p222.end);
				}),
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						function (x) {
							return x;
						}),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$source(
							_MikaelMayer$parser$Parser$symbol('')))),
				_MikaelMayer$parser$Parser$symbol('.')),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (wsAfterDot, x) {
								return {ctor: '_Tuple2', _0: wsAfterDot, _1: x};
							})),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$source(
							_MikaelMayer$parser$Parser$symbol('')))),
				_user$project$ParserUtils$trackInfo(_user$project$LeoParser$identifier)));
	});
var _user$project$LeoParser$addSelections = function (parser) {
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F2(
					function (simpExp, selections) {
						return A3(
							_elm_lang$core$List$foldl,
							F2(
								function (sel, updatedExp) {
									return sel(updatedExp);
								}),
							simpExp,
							selections);
					})),
			parser),
		A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, _user$project$LeoParser$selection));
};
var _user$project$LeoParser$littleIdentifier = _user$project$ParserUtils$trackInfo(
	A3(_MikaelMayer$parser$Parser_LanguageKit$variable, _elm_lang$core$Char$isLower, _user$project$LangParserUtils$isRestChar, _user$project$LeoParser$keywords));
var _user$project$LeoParser$typePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'type pattern',
	_user$project$LeoParser$tnamePattern(_user$project$LeoParser$littleIdentifier));
var _user$project$LeoParser$variableType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'variable type',
	_user$project$LangParserUtils$mapWSType_(
		A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (a, b) {
					return b;
				}),
			_user$project$ParserUtils$negativeLookAhead(
				_MikaelMayer$parser$Parser$symbol('forall')),
			A2(
				_user$project$LangParserUtils$transferInfo,
				_elm_lang$core$Basics$flip(_user$project$Lang$TVar),
				_user$project$LeoParser$littleIdentifier))));
var _user$project$LeoParser$bigIdentifier = _user$project$ParserUtils$trackInfo(
	A3(
		_MikaelMayer$parser$Parser_LanguageKit$variable,
		_elm_lang$core$Char$isUpper,
		_user$project$LangParserUtils$isRestChar,
		A2(_elm_lang$core$Set$union, _user$project$LeoParser$keywords, _user$project$LeoParser$moreKeywords)));
var _user$project$LeoParser$dataType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'data type',
	_user$project$LangParserUtils$mapWSType_(
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_user$project$Lang$TVar),
			_user$project$LeoParser$bigIdentifier)));
var _user$project$LeoParser$block = F4(
	function (combiner, openSymbol, closeSymbol, p) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (open, _p223) {
					var _p224 = _p223;
					return A3(
						_user$project$Info$withInfo,
						function (wsBefore) {
							return A3(combiner, wsBefore, _p224._0, _p224._1);
						},
						open.start,
						_p224._2.end);
				}),
			_user$project$ParserUtils$trackInfo(
				_MikaelMayer$parser$Parser$symbol(openSymbol)),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (v0, v1, v2) {
									return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
								})),
						p),
					_user$project$LangParserUtils$spaces),
				_user$project$ParserUtils$trackInfo(
					_MikaelMayer$parser$Parser$symbol(closeSymbol))));
	});
var _user$project$LeoParser$parenBlock = function (combiner) {
	return A3(_user$project$LeoParser$block, combiner, '(', ')');
};
var _user$project$LeoParser$bracketBlock = function (combiner) {
	return A3(_user$project$LeoParser$block, combiner, '[', ']');
};
var _user$project$LeoParser$blockIgnoreWS = _user$project$LeoParser$block(
	F3(
		function (wsBefore, x, wsEnd) {
			return x;
		}));
var _user$project$LeoParser$parenBlockIgnoreWS = A2(_user$project$LeoParser$blockIgnoreWS, '(', ')');
var _user$project$LeoParser$genericNonEmptyRecordWithInit = function (_p225) {
	var _p226 = _p225;
	var _p242 = _p226.keyValue;
	return _MikaelMayer$parser$Parser$lazy(
		function (_p227) {
			var keyValueSeqHelper = F2(
				function (keys, revKeyValues) {
					return _MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser$andThen,
								function (_p228) {
									var _p229 = _p228;
									var _p230 = _p229._2;
									return A2(_elm_lang$core$Set$member, _p230, keys) ? _MikaelMayer$parser$Parser$fail(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Records cannot have duplicate keys, but the key ',
											A2(_elm_lang$core$Basics_ops['++'], _p230, ' appears at least twice'))) : A2(
										keyValueSeqHelper,
										A2(_elm_lang$core$Set$insert, _p230, keys),
										{ctor: '::', _0: _p229, _1: revKeyValues});
								},
								A3(
									_MikaelMayer$parser$Parser$delayedCommitMap,
									F2(
										function (ws, _p231) {
											var _p232 = _p231;
											var _p234 = _p232._0;
											return {
												ctor: '_Tuple5',
												_0: A2(
													_elm_lang$core$Maybe$map,
													function (_p233) {
														return ws;
													},
													_p234),
												_1: _elm_lang$core$Native_Utils.eq(_p234, _elm_lang$core$Maybe$Nothing) ? ws : _p232._1,
												_2: _p232._2._0,
												_3: _p232._2._1,
												_4: _p232._2._2
											};
										}),
									_user$project$LangParserUtils$spaces,
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|.'],
													_MikaelMayer$parser$Parser$succeed(
														F3(
															function (v0, v1, v2) {
																return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
															})),
													_user$project$ParserUtils$negativeLookAhead(
														_MikaelMayer$parser$Parser$symbol('}'))),
												_user$project$ParserUtils$optional(
													_MikaelMayer$parser$Parser$symbol(','))),
											_user$project$LangParserUtils$spaces),
										_p242))),
							_1: {
								ctor: '::',
								_0: _MikaelMayer$parser$Parser$succeed(
									_elm_lang$core$List$reverse(revKeyValues)),
								_1: {ctor: '[]'}
							}
						});
				});
			return A2(
				_MikaelMayer$parser$Parser$inContext,
				'generic non-empty record with init',
				_user$project$ParserUtils$trackInfo(
					A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F3(
							function (_p236, _p235, wsBefore) {
								var _p237 = _p236;
								var _p238 = _p235;
								return A5(_p226.combinerInit, wsBefore, _p237._0, _p237._1, _p238._0, _p238._1);
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (init, wsBeforeBar) {
												return {ctor: '_Tuple2', _0: init, _1: wsBeforeBar};
											})),
									_MikaelMayer$parser$Parser$symbol('{')),
								_p226.initItem),
							_user$project$LangParserUtils$spaces),
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F2(
												function (keyValues, wsEnd) {
													return {ctor: '_Tuple2', _0: keyValues, _1: wsEnd};
												})),
										_MikaelMayer$parser$Parser$symbol('|')),
									A2(
										_MikaelMayer$parser$Parser$andThen,
										function (_p239) {
											var _p240 = _p239;
											var _p241 = _p240._1._0;
											return A2(
												keyValueSeqHelper,
												_elm_lang$core$Set$singleton(_p241),
												{
													ctor: '::',
													_0: {ctor: '_Tuple5', _0: _elm_lang$core$Maybe$Nothing, _1: _p240._0, _2: _p241, _3: _p240._1._1, _4: _p240._1._2},
													_1: {ctor: '[]'}
												});
										},
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												_MikaelMayer$parser$Parser$succeed(
													F2(
														function (v0, v1) {
															return {ctor: '_Tuple2', _0: v0, _1: v1};
														})),
												_user$project$LangParserUtils$spaces),
											_p242))),
								_user$project$LangParserUtils$spaces),
							_MikaelMayer$parser$Parser$symbol('}')))));
		});
};
var _user$project$LeoParser$genericNonEmptyRecord = function (_p243) {
	var _p244 = _p243;
	var _p258 = _p244.keyValue;
	return _MikaelMayer$parser$Parser$lazy(
		function (_p245) {
			var keyValueSeqHelper = F2(
				function (keys, revKeyValues) {
					return _MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser$andThen,
								function (_p246) {
									var _p247 = _p246;
									var _p248 = _p247._2;
									return A2(_elm_lang$core$Set$member, _p248, keys) ? _MikaelMayer$parser$Parser$fail(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Records cannot have duplicate keys, but the key ',
											A2(_elm_lang$core$Basics_ops['++'], _p248, ' appears at least twice'))) : A2(
										keyValueSeqHelper,
										A2(_elm_lang$core$Set$insert, _p248, keys),
										{ctor: '::', _0: _p247, _1: revKeyValues});
								},
								A3(
									_MikaelMayer$parser$Parser$delayedCommitMap,
									F2(
										function (ws, _p249) {
											var _p250 = _p249;
											var _p252 = _p250._0;
											return {
												ctor: '_Tuple5',
												_0: A2(
													_elm_lang$core$Maybe$map,
													function (_p251) {
														return ws;
													},
													_p252),
												_1: _elm_lang$core$Native_Utils.eq(_p252, _elm_lang$core$Maybe$Nothing) ? ws : _p250._1,
												_2: _p250._2._0,
												_3: _p250._2._1,
												_4: _p250._2._2
											};
										}),
									_user$project$LangParserUtils$spaces,
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|.'],
													_MikaelMayer$parser$Parser$succeed(
														F3(
															function (v0, v1, v2) {
																return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
															})),
													_user$project$ParserUtils$negativeLookAhead(
														_MikaelMayer$parser$Parser$symbol('}'))),
												_user$project$ParserUtils$optional(
													_MikaelMayer$parser$Parser$symbol(','))),
											_user$project$LangParserUtils$spaces),
										_p258))),
							_1: {
								ctor: '::',
								_0: _MikaelMayer$parser$Parser$succeed(
									_elm_lang$core$List$reverse(revKeyValues)),
								_1: {ctor: '[]'}
							}
						});
				});
			return A2(
				_MikaelMayer$parser$Parser$inContext,
				'generic non-empty record',
				A2(
					_user$project$LangParserUtils$transferInfo,
					F2(
						function (_p253, spaceBefore) {
							var _p254 = _p253;
							return A3(_p244.combiner, spaceBefore, _p254._0, _p254._1);
						}),
					_user$project$ParserUtils$trackInfo(
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F2(
												function (keyValues, wsEnd) {
													return {ctor: '_Tuple2', _0: keyValues, _1: wsEnd};
												})),
										_MikaelMayer$parser$Parser$symbol('{')),
									A2(
										_MikaelMayer$parser$Parser$andThen,
										function (_p255) {
											var _p256 = _p255;
											var _p257 = _p256._1._0;
											return A2(
												keyValueSeqHelper,
												_elm_lang$core$Set$singleton(_p257),
												{
													ctor: '::',
													_0: {ctor: '_Tuple5', _0: _elm_lang$core$Maybe$Nothing, _1: _p256._0, _2: _p257, _3: _p256._1._1, _4: _p256._1._2},
													_1: {ctor: '[]'}
												});
										},
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												_MikaelMayer$parser$Parser$succeed(
													F2(
														function (v0, v1) {
															return {ctor: '_Tuple2', _0: v0, _1: v1};
														})),
												_user$project$LangParserUtils$spaces),
											_p258))),
								_user$project$LangParserUtils$spaces),
							_MikaelMayer$parser$Parser$symbol('}')))));
		});
};
var _user$project$LeoParser$genericEmptyRecord = function (_p259) {
	var _p260 = _p259;
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'generic empty record',
		A2(
			_user$project$LangParserUtils$transferInfo,
			_elm_lang$core$Basics$flip(_p260.combiner),
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
							_MikaelMayer$parser$Parser$symbol('{')),
						_user$project$LangParserUtils$spaces),
					_MikaelMayer$parser$Parser$symbol('}')))));
};
var _user$project$LeoParser$genericRecord = function (_p261) {
	var _p262 = _p261;
	var _p271 = _p262.combiner;
	var keyValue = A2(
		_MikaelMayer$parser$Parser$andThen,
		function (keyWithInfos) {
			return A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (argList, _p263) {
								var _p264 = _p263;
								var _p267 = _p264._0;
								var _p266 = _p264._1;
								var _p265 = argList;
								if (_p265.ctor === 'Nothing') {
									return {ctor: '_Tuple3', _0: keyWithInfos.val, _1: _p267, _2: _p266};
								} else {
									return {
										ctor: '_Tuple3',
										_0: keyWithInfos.val,
										_1: _p267,
										_2: A2(_p265._0._0, _p265._0._1, _p266)
									};
								}
							})),
					A2(
						_elm_lang$core$Maybe$withDefault,
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Maybe$Nothing),
						A2(
							_elm_lang$core$Maybe$map,
							function (f) {
								return A2(
									_MikaelMayer$parser$Parser$map,
									function (r) {
										return _elm_lang$core$Maybe$Just(
											{ctor: '_Tuple2', _0: f.buildValue, _1: r});
									},
									f.$arguments);
							},
							_p262.fundef))),
				_MikaelMayer$parser$Parser$oneOf(
					{
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								A3(
									_MikaelMayer$parser$Parser$delayedCommitMap,
									F2(
										function (a, b) {
											return a;
										}),
									_user$project$LangParserUtils$spaces,
									_p262.equalSign)),
							A2(
								_MikaelMayer$parser$Parser$inContext,
								'record value',
								A2(_p262.value, _user$project$LangParserUtils$spaces, keyWithInfos.start.col + 1))),
						_1: {
							ctor: '::',
							_0: function () {
								var _p268 = _p262.optNoEqualSign;
								if (_p268.ctor === 'Nothing') {
									return _MikaelMayer$parser$Parser$fail('Expected =');
								} else {
									return A3(
										_MikaelMayer$parser$Parser$delayedCommitMap,
										F2(
											function (a, b) {
												return {ctor: '_Tuple2', _0: a, _1: b};
											}),
										_user$project$LangParserUtils$spaces,
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
												_MikaelMayer$parser$Parser$oneOf(
													{
														ctor: '::',
														_0: _user$project$ParserUtils$lookAhead(
															_MikaelMayer$parser$Parser$symbol(',')),
														_1: {
															ctor: '::',
															_0: _user$project$ParserUtils$lookAhead(
																_MikaelMayer$parser$Parser$symbol('\r')),
															_1: {
																ctor: '::',
																_0: _user$project$ParserUtils$lookAhead(
																	_MikaelMayer$parser$Parser$symbol('\n')),
																_1: {
																	ctor: '::',
																	_0: _user$project$ParserUtils$lookAhead(
																		_MikaelMayer$parser$Parser$symbol('}')),
																	_1: {ctor: '[]'}
																}
															}
														}
													})),
											_MikaelMayer$parser$Parser$succeed(
												_p268._0(keyWithInfos.val))));
								}
							}(),
							_1: {ctor: '[]'}
						}
					}));
		},
		A2(
			_MikaelMayer$parser$Parser$inContext,
			'record key or }',
			_user$project$ParserUtils$trackInfo(_p262.key)));
	return _MikaelMayer$parser$Parser$lazy(
		function (_p269) {
			return A2(
				_MikaelMayer$parser$Parser$inContext,
				'generic record',
				_MikaelMayer$parser$Parser$oneOf(
					A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: _user$project$ParserUtils$try(
								_user$project$LeoParser$genericEmptyRecord(
									{
										combiner: F2(
											function (wsBefore, wsAfter) {
												return A3(
													_p271,
													wsBefore,
													{ctor: '[]'},
													wsAfter);
											})
									})),
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$Basics_ops['++'],
							function () {
								var _p270 = _p262.optionalInitParser;
								if (_p270.ctor === 'Nothing') {
									return {ctor: '[]'};
								} else {
									return {
										ctor: '::',
										_0: _user$project$LeoParser$genericNonEmptyRecordWithInit(
											{keyValue: keyValue, combinerInit: _p270._0.combinerInit, initItem: _p270._0.initItem}),
										_1: {ctor: '[]'}
									};
								}
							}(),
							{
								ctor: '::',
								_0: _user$project$LeoParser$genericNonEmptyRecord(
									{keyValue: keyValue, combiner: _p271}),
								_1: {ctor: '[]'}
							}))));
		});
};
var _user$project$LeoParser$genericNonEmptyListWithTail = function (_p272) {
	var _p273 = _p272;
	var _p277 = _p273.item;
	return _MikaelMayer$parser$Parser$lazy(
		function (_p274) {
			var anotherWsAndItem = A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F2(
					function (v0, v1) {
						return {ctor: '_Tuple2', _0: v0, _1: v1};
					}),
				_user$project$LangParserUtils$spaces,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_MikaelMayer$parser$Parser$symbol(',')),
					_p277));
			return A2(
				_user$project$LangParserUtils$transferInfo,
				F2(
					function (_p275, spaceBefore) {
						var _p276 = _p275;
						return A5(_p273.combinerTail, spaceBefore, _p276._0, _p276._1, _p276._2, _p276._3);
					}),
				_user$project$ParserUtils$trackInfo(
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|.'],
													_MikaelMayer$parser$Parser$succeed(
														F5(
															function (e, es, wsm, t, wse) {
																return {
																	ctor: '_Tuple4',
																	_0: {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: _user$project$Lang$space0, _1: e},
																		_1: es
																	},
																	_1: wsm,
																	_2: t,
																	_3: wse
																};
															})),
													_MikaelMayer$parser$Parser$symbol('[')),
												_p277),
											A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, anotherWsAndItem)),
										_user$project$LangParserUtils$spaces),
									_MikaelMayer$parser$Parser$symbol('|')),
								_p273.tailItem),
							_user$project$LangParserUtils$spaces),
						_MikaelMayer$parser$Parser$symbol(']'))));
		});
};
var _user$project$LeoParser$genericNonEmptyList = function (_p278) {
	var _p279 = _p278;
	var _p283 = _p279.item;
	return _MikaelMayer$parser$Parser$lazy(
		function (_p280) {
			var anotherWsAndItem = A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F2(
					function (v0, v1) {
						return {ctor: '_Tuple2', _0: v0, _1: v1};
					}),
				_user$project$LangParserUtils$spaces,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_MikaelMayer$parser$Parser$symbol(',')),
					_p283));
			return A2(
				_user$project$LangParserUtils$transferInfo,
				F2(
					function (_p281, spaceBefore) {
						var _p282 = _p281;
						return A3(_p279.combiner, spaceBefore, _p282._0, _p282._1);
					}),
				_user$project$ParserUtils$trackInfo(
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F3(
												function (e, es, ws) {
													return {
														ctor: '_Tuple2',
														_0: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _user$project$Lang$space0, _1: e},
															_1: es
														},
														_1: ws
													};
												})),
										_MikaelMayer$parser$Parser$symbol('[')),
									_p283),
								A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, anotherWsAndItem)),
							_user$project$LangParserUtils$spaces),
						_MikaelMayer$parser$Parser$symbol(']'))));
		});
};
var _user$project$LeoParser$genericEmptyList = function (_p284) {
	var _p285 = _p284;
	return A2(
		_user$project$LangParserUtils$transferInfo,
		_elm_lang$core$Basics$flip(_p285.combiner),
		_user$project$ParserUtils$trackInfo(
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_MikaelMayer$parser$Parser$symbol('[')),
					_user$project$LangParserUtils$spaces),
				_MikaelMayer$parser$Parser$symbol(']'))));
};
var _user$project$LeoParser$genericList = function (_p286) {
	var _p287 = _p286;
	var _p290 = _p287.item;
	var _p289 = _p287.combiner;
	return _MikaelMayer$parser$Parser$lazy(
		function (_p288) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$ParserUtils$try(
						_user$project$LeoParser$genericEmptyList(
							{
								combiner: F2(
									function (wsBefore, wsAfter) {
										return A3(
											_p289,
											wsBefore,
											{ctor: '[]'},
											wsAfter);
									})
							})),
					_1: {
						ctor: '::',
						_0: _user$project$ParserUtils$try(
							_user$project$LeoParser$genericNonEmptyList(
								{item: _p290, combiner: _p289})),
						_1: {
							ctor: '::',
							_0: _user$project$LeoParser$genericNonEmptyListWithTail(
								{item: _p290, combinerTail: _p287.combinerTail, tailItem: _p287.tailItem}),
							_1: {ctor: '[]'}
						}
					}
				});
		});
};
var _user$project$LeoParser$wsExp_ParserToWsExpParser = _MikaelMayer$parser$Parser$map(
	F2(
		function (wsToExp_, ws) {
			return _user$project$Lang$Expr(
				wsToExp_(ws));
		}));
var _user$project$LeoParser$implicitVarName = ' i';
var _user$project$LeoParser$genericTuple = function (_p291) {
	var _p292 = _p291;
	var _p308 = _p292.term;
	var _p307 = _p292.tagger;
	var _p306 = _p292.record;
	var combinerZero = F2(
		function (wsBeforeEnd, wsBefore) {
			var name = _user$project$Lang$ctorTupleName(0);
			var ctorEntry = A3(_user$project$Lang$ctor, _p307, _user$project$Lang$TupleCtor, name);
			return A3(
				_p306,
				wsBefore,
				{
					ctor: '::',
					_0: ctorEntry,
					_1: {ctor: '[]'}
				},
				wsBeforeEnd);
		});
	var combiner = F2(
		function (_p293, wsBefore) {
			var _p294 = _p293;
			var _p297 = _p294._2;
			var _p296 = _p294._1;
			var _p295 = _p294._0;
			if (_elm_lang$core$List$isEmpty(_p296)) {
				return A3(_p292.one, wsBefore, _p295, _p297);
			} else {
				var restEntries = A3(_user$project$Utils$indexedMapFrom, 2, _user$project$Lang$numericalEntry, _p296);
				var firstEntry = A2(
					_user$project$Lang$numericalEntry,
					1,
					{ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p295});
				var name = _user$project$Lang$ctorTupleName(
					1 + _elm_lang$core$List$length(_p296));
				var ctorEntry = A3(_user$project$Lang$ctor, _p307, _user$project$Lang$TupleCtor, name);
				return A3(
					_p306,
					wsBefore,
					{
						ctor: '::',
						_0: ctorEntry,
						_1: {ctor: '::', _0: firstEntry, _1: restEntries}
					},
					_p297);
			}
		});
	var implicitTupling = A3(
		_elm_lang$core$Basics$flip,
		_elm_lang$core$Maybe$map,
		_p292.implicitFun,
		F3(
			function (_p298, numberOfCommas, wsBefore) {
				var _p299 = _p298;
				var _p302 = _p299._0;
				var _p300 = _p302(_user$project$LeoParser$implicitVarName);
				var firstPvar = _p300._0;
				var firstVar = _p300._1;
				var _p301 = _elm_lang$core$List$unzip(
					A2(
						_elm_lang$core$List$map,
						_p302,
						A2(
							_elm_lang$core$List$map,
							function (i) {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoParser$implicitVarName,
									_elm_lang$core$Basics$toString(i));
							},
							A2(_elm_lang$core$List$range, 1, numberOfCommas))));
				var restPvar = _p301._0;
				var restVar = _p301._1;
				return A3(
					_p299._1,
					wsBefore,
					{ctor: '::', _0: firstPvar, _1: restPvar},
					A2(
						combiner,
						{
							ctor: '_Tuple3',
							_0: firstVar,
							_1: A2(
								_elm_lang$core$List$map,
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})(
									_elm_lang$core$Maybe$Just(_user$project$Lang$space0)),
								restVar),
							_2: _user$project$Lang$space0
						},
						_user$project$Lang$space0));
			}));
	return _MikaelMayer$parser$Parser$lazy(
		function (_p303) {
			return A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F2(
					function (pos, posToParens) {
						return posToParens(pos);
					}),
				_user$project$ParserUtils$getPos,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_MikaelMayer$parser$Parser$symbol('(')),
					_MikaelMayer$parser$Parser$oneOf(
						A2(
							_elm_lang$core$Basics_ops['++'],
							{
								ctor: '::',
								_0: _user$project$ParserUtils$setStartInfo(
									_MikaelMayer$parser$Parser$oneOf(
										{
											ctor: '::',
											_0: A2(
												_user$project$LangParserUtils$transferInfo,
												combiner,
												_user$project$ParserUtils$trackInfo(
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															A2(
																_MikaelMayer$parser$Parser_ops['|='],
																A2(
																	_MikaelMayer$parser$Parser_ops['|='],
																	_MikaelMayer$parser$Parser$succeed(
																		F3(
																			function (v0, v1, v2) {
																				return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
																			})),
																	_p308),
																A2(
																	_MikaelMayer$parser$Parser$repeat,
																	_MikaelMayer$parser$Parser$zeroOrMore,
																	A3(
																		_MikaelMayer$parser$Parser$delayedCommitMap,
																		F2(
																			function (ws, term) {
																				return {
																					ctor: '_Tuple2',
																					_0: _elm_lang$core$Maybe$Just(ws),
																					_1: term
																				};
																			}),
																		_user$project$LangParserUtils$spaces,
																		A2(
																			_MikaelMayer$parser$Parser_ops['|='],
																			A2(
																				_MikaelMayer$parser$Parser_ops['|.'],
																				_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
																				_MikaelMayer$parser$Parser$symbol(',')),
																			_p308)))),
															_user$project$LangParserUtils$spaces),
														_MikaelMayer$parser$Parser$symbol(')')))),
											_1: {
												ctor: '::',
												_0: A2(
													_user$project$LangParserUtils$transferInfo,
													combinerZero,
													_user$project$ParserUtils$trackInfo(
														A2(
															_MikaelMayer$parser$Parser_ops['|.'],
															A2(
																_MikaelMayer$parser$Parser_ops['|='],
																_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
																_user$project$LangParserUtils$spaces),
															_MikaelMayer$parser$Parser$symbol(')')))),
												_1: {ctor: '[]'}
											}
										})),
								_1: {ctor: '[]'}
							},
							function () {
								var _p304 = implicitTupling;
								if (_p304.ctor === 'Nothing') {
									return {ctor: '[]'};
								} else {
									return {
										ctor: '::',
										_0: _user$project$ParserUtils$setStartInfo(
											_user$project$ParserUtils$trackInfo(
												A2(
													_MikaelMayer$parser$Parser$map,
													function (_p305) {
														return _p304._0(
															_elm_lang$core$String$length(_p305));
													},
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														A2(
															_MikaelMayer$parser$Parser$keep,
															_MikaelMayer$parser$Parser$oneOrMore,
															function (c) {
																return _elm_lang$core$Native_Utils.eq(
																	c,
																	_elm_lang$core$Native_Utils.chr(','));
															}),
														_MikaelMayer$parser$Parser$symbol(')'))))),
										_1: {ctor: '[]'}
									};
								}
							}()))));
		});
};
var _user$project$LeoParser$tupleType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'tuple type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p309) {
			return _user$project$LangParserUtils$mapWSType_(
				function () {
					var t = _user$project$LeoParser$genericTuple;
					return t(
						{
							term: A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, 0),
							tagger: function (_p310) {
								return _user$project$Lang$withDummyTypeInfo(
									A2(_user$project$Lang$TVar, _user$project$Lang$space0, _p310));
							},
							record: F3(
								function (ws1, entries, ws2) {
									return A4(_user$project$Lang$TRecord, ws1, _elm_lang$core$Maybe$Nothing, entries, ws2);
								}),
							one: F3(
								function (wsBefore, innerExpression, wsBeforeEnd) {
									return A3(_user$project$Lang$TParens, wsBefore, innerExpression, wsBeforeEnd);
								}),
							implicitFun: _elm_lang$core$Maybe$Just(
								{
									ctor: '_Tuple2',
									_0: function (ident) {
										return {
											ctor: '_Tuple2',
											_0: _user$project$Lang$withDummyRange(
												A2(_user$project$Lang$TPatVar, _user$project$Lang$space1, ident)),
											_1: _user$project$Lang$withDummyTypeInfo(
												A2(_user$project$Lang$TVar, _user$project$Lang$space1, ident))
										};
									},
									_1: F3(
										function (wsBefore, pvars, body) {
											return A4(
												_user$project$Lang$TForall,
												wsBefore,
												pvars,
												_user$project$Lang$withDummyTypeInfo(body),
												_user$project$Lang$space0);
										})
								})
						});
				}());
		}));
var _user$project$LeoParser$typ = F2(
	function (spFirst, minStartCol) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'type',
			_MikaelMayer$parser$Parser$lazy(
				function (_p311) {
					var b = _user$project$BinaryOperatorParser$binaryOperator;
					var operatorSpace = A2(_user$project$LangParserUtils$spaceSameLineOrNextAfter, minStartCol, _user$project$LangParserUtils$MinIndentSpace);
					return A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F2(
							function (ws, wsToType) {
								return wsToType(ws);
							}),
						spFirst,
						b(
							{
								withZeroSpace: function (wsTyp) {
									var finalTyp = wsTyp(_user$project$Lang$space0);
									return A2(
										_user$project$Lang$mapPrecedingWhitespaceTypeWS,
										function (ws) {
											return A3(_user$project$Info$withInfo, ws.val, finalTyp.start, finalTyp.start);
										},
										finalTyp);
								},
								greedySpaceParser: _user$project$LangParserUtils$spaces,
								precedenceTable: _user$project$LeoParser$builtInTypePrecedenceTable,
								minimumPrecedence: 0,
								expression: _user$project$LeoParser$simpleTypeWithPossibleArguments(minStartCol),
								operator: _user$project$LeoParser$typeOperator(operatorSpace),
								representation: function (_p312) {
									return _elm_lang$core$Tuple$second(
										function (_) {
											return _.val;
										}(_p312));
								},
								combine: F4(
									function (wsBefore, left, operator, right) {
										var _p313 = operator.val;
										var wsBeforeOp = _p313._0;
										var identifier = _p313._1;
										return A2(
											_user$project$Info$mapInfo,
											_user$project$Lang$type_,
											A3(
												_user$project$Info$withInfo,
												A4(
													_user$project$Lang$TApp,
													wsBefore,
													A2(
														_user$project$Info$mapInfo,
														_user$project$Lang$type_,
														A2(
															_user$project$Info$replaceInfo,
															operator,
															A2(_user$project$Lang$TVar, wsBeforeOp, identifier))),
													{
														ctor: '::',
														_0: left,
														_1: {
															ctor: '::',
															_0: right,
															_1: {ctor: '[]'}
														}
													},
													_user$project$Lang$InfixApp),
												left.start,
												right.end));
									})
							}));
				}));
	});
var _user$project$LeoParser$simpleTypeWithPossibleArguments = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'simple type with arguments',
		_user$project$LangParserUtils$mapWSType_(
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser$andThen,
					function (_p314) {
						var _p315 = _p314;
						var _p321 = _p315._0;
						var _p320 = _p315._1;
						var f = _p321(_user$project$Lang$space0);
						var _p316 = f.val.t__;
						_v116_2:
						do {
							if (_p316.ctor === 'TVar') {
								switch (_p316._1) {
									case 'List':
										var _p317 = _p320;
										if ((_p317.ctor === '::') && (_p317._1.ctor === '[]')) {
											return _MikaelMayer$parser$Parser$succeed(
												function (spApp) {
													return A3(_user$project$Lang$TList, spApp, _p317._0, _user$project$Lang$space0);
												});
										} else {
											return _MikaelMayer$parser$Parser$fail('List takes exactly one type argument');
										}
									case 'Dict':
										var _p318 = _p320;
										if (((_p318.ctor === '::') && (_p318._1.ctor === '::')) && (_p318._1._1.ctor === '[]')) {
											return _MikaelMayer$parser$Parser$succeed(
												function (spApp) {
													return A4(_user$project$Lang$TDict, spApp, _p318._0, _p318._1._0, _user$project$Lang$space0);
												});
										} else {
											return _MikaelMayer$parser$Parser$fail('Dict takes exactly two type arguments');
										}
									default:
										break _v116_2;
								}
							} else {
								break _v116_2;
							}
						} while(false);
						var _p319 = _p320;
						if (_p319.ctor === '[]') {
							return _MikaelMayer$parser$Parser$succeed(
								function (spApp) {
									return _p321(spApp).val.t__;
								});
						} else {
							return _MikaelMayer$parser$Parser$succeed(
								function (spApp) {
									return A4(_user$project$Lang$TApp, spApp, f, _p320, _user$project$Lang$SpaceApp);
								});
						}
					},
					A2(
						_MikaelMayer$parser$Parser$andThen,
						function (wsToMainTypeI) {
							var appargSpace = A2(
								_user$project$LangParserUtils$spaceSameLineOrNextAfter,
								A2(_elm_lang$core$Basics$min, minStartCol, wsToMainTypeI.start.col),
								_user$project$LangParserUtils$MinIndentSpace);
							return A2(
								_MikaelMayer$parser$Parser$map,
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})(wsToMainTypeI.val),
								A2(
									_MikaelMayer$parser$Parser$repeat,
									_MikaelMayer$parser$Parser$zeroOrMore,
									A3(
										_MikaelMayer$parser$Parser$delayedCommitMap,
										F2(
											function (ws, wsType) {
												return wsType(ws);
											}),
										appargSpace,
										_user$project$LeoParser$simpleType(minStartCol))));
						},
						_user$project$ParserUtils$trackInfo(
							_user$project$LeoParser$simpleType(minStartCol)))))));
};
var _user$project$LeoParser$simpleType = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'type',
		_MikaelMayer$parser$Parser$lazy(
			function (_p322) {
				return _MikaelMayer$parser$Parser$oneOf(
					{
						ctor: '::',
						_0: _user$project$LeoParser$dataType,
						_1: {
							ctor: '::',
							_0: _user$project$LeoParser$numType,
							_1: {
								ctor: '::',
								_0: _user$project$LeoParser$boolType,
								_1: {
									ctor: '::',
									_0: _user$project$LeoParser$stringType,
									_1: {
										ctor: '::',
										_0: _user$project$LeoParser$variableType,
										_1: {
											ctor: '::',
											_0: _user$project$LeoParser$wildcardType,
											_1: {
												ctor: '::',
												_0: _MikaelMayer$parser$Parser$lazy(
													function (_p323) {
														return _user$project$LeoParser$tupleType;
													}),
												_1: {
													ctor: '::',
													_0: _MikaelMayer$parser$Parser$lazy(
														function (_p324) {
															return _user$project$LeoParser$recordType;
														}),
													_1: {
														ctor: '::',
														_0: _MikaelMayer$parser$Parser$lazy(
															function (_p325) {
																return _user$project$LeoParser$forallType(minStartCol);
															}),
														_1: {ctor: '[]'}
													}
												}
											}
										}
									}
								}
							}
						}
					});
			}));
};
var _user$project$LeoParser$forallType = function (minStartCol) {
	var patVar = A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		F2(
			function (ws, name) {
				return A3(
					_user$project$Info$withInfo,
					A2(_user$project$Lang$TPatVar, ws, name.val),
					name.start,
					name.end);
			}),
		_user$project$LangParserUtils$spaces,
		_user$project$LeoParser$littleIdentifier);
	var quantifiers = A2(
		_MikaelMayer$parser$Parser$inContext,
		'forall type (one)',
		A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, patVar));
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'forall type',
		_MikaelMayer$parser$Parser$lazy(
			function (_p326) {
				return _user$project$LangParserUtils$mapWSType_(
					_user$project$ParserUtils$trackInfo(
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(
												F4(
													function (qs, spDot, t, wsBefore) {
														return A4(_user$project$Lang$TForall, wsBefore, qs, t, spDot);
													})),
											_user$project$LangParserUtils$keywordWithSpace('forall')),
										quantifiers),
									_user$project$LangParserUtils$spaces),
								_MikaelMayer$parser$Parser$symbol('.')),
							A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, minStartCol))));
			}));
};
var _user$project$LeoParser$recordType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'record type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p327) {
			return _user$project$LangParserUtils$mapWSType_(
				_user$project$LeoParser$genericRecord(
					{
						key: _user$project$LeoParser$identifier,
						equalSign: _MikaelMayer$parser$Parser$symbol(':'),
						optNoEqualSign: _elm_lang$core$Maybe$Nothing,
						value: _user$project$LeoParser$typ,
						fundef: _elm_lang$core$Maybe$Nothing,
						combiner: F3(
							function (wsBefore, keyValues, wsAfter) {
								return A4(_user$project$Lang$TRecord, wsBefore, _elm_lang$core$Maybe$Nothing, keyValues, wsAfter);
							}),
						optionalInitParser: _elm_lang$core$Maybe$Just(
							{
								initItem: _user$project$LeoParser$identifier,
								combinerInit: F5(
									function (wsBefore, init, wsBar, elems, wsEnd) {
										return A4(
											_user$project$Lang$TRecord,
											wsBefore,
											_elm_lang$core$Maybe$Just(
												{ctor: '_Tuple2', _0: init, _1: wsBar}),
											elems,
											wsEnd);
									})
							})
					}));
		}));
var _user$project$LeoParser$unionType = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'union type',
		_user$project$LangParserUtils$mapWSType_(
			A2(
				_user$project$LeoParser$parenBlock,
				_user$project$Lang$TUnion,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
						_user$project$LangParserUtils$keywordWithSpace('union')),
					A2(
						_MikaelMayer$parser$Parser$repeat,
						_MikaelMayer$parser$Parser$oneOrMore,
						A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, minStartCol))))));
};
var _user$project$LeoParser$spaceColonType = F2(
	function (minStartCol, spConstraint) {
		return _MikaelMayer$parser$Parser$lazy(
			function (_p328) {
				return _user$project$ParserUtils$try(
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								A2(_user$project$LangParserUtils$spaceSameLineOrNextAfter, minStartCol, spConstraint)),
							_MikaelMayer$parser$Parser$symbol(':')),
						A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, minStartCol)));
			});
	});
var _user$project$LeoParser$simplePatternWithMaybeColonType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'simplePatternWithMaybeColonType',
	_MikaelMayer$parser$Parser$lazy(
		function (_p329) {
			return A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F2(
					function (pos, posToRes) {
						return posToRes(pos);
					}),
				_user$project$ParserUtils$getPos,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F4(
								function (wsToP, mbT, startPos, wsBefore) {
									var _p330 = mbT;
									if (_p330.ctor === 'Just') {
										var _p331 = _p330._0._1;
										return A3(
											_user$project$Info$withInfo,
											_user$project$Lang$pat_(
												A4(
													_user$project$Lang$PColonType,
													wsBefore,
													wsToP(_user$project$Lang$space0),
													_p330._0._0,
													_p331)),
											startPos,
											_p331.end);
									} else {
										return wsToP(wsBefore);
									}
								})),
						_user$project$LeoParser$simplePattern),
					_user$project$ParserUtils$optional(
						A2(_user$project$LeoParser$spaceColonType, 0, _user$project$LangParserUtils$MinIndentSpace))));
		}));
var _user$project$LeoParser$simplePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'simple pattern',
	_MikaelMayer$parser$Parser$lazy(
		function (_p332) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$LeoParser$listPattern,
					_1: {
						ctor: '::',
						_0: _user$project$LeoParser$recordPattern,
						_1: {
							ctor: '::',
							_0: _user$project$LeoParser$tuplePattern,
							_1: {
								ctor: '::',
								_0: _user$project$LeoParser$constantPattern,
								_1: {
									ctor: '::',
									_0: _user$project$LeoParser$baseValuePattern,
									_1: {
										ctor: '::',
										_0: _user$project$LeoParser$dataConstructorPattern,
										_1: {
											ctor: '::',
											_0: _user$project$LeoParser$variablePattern,
											_1: {
												ctor: '::',
												_0: _user$project$LeoParser$wildcardPattern,
												_1: {ctor: '[]'}
											}
										}
									}
								}
							}
						}
					}
				});
		}));
var _user$project$LeoParser$dataConstructorPattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'data constructor pattern',
	_MikaelMayer$parser$Parser$lazy(
		function (_p333) {
			var combiner = F3(
				function (_p335, _p334, wsBefore) {
					var _p336 = _p335;
					var _p337 = _p334;
					var insideArgsEntries = A3(
						_user$project$Utils$indexedMapFrom,
						1,
						_user$project$Lang$numericalEntry,
						A2(
							_elm_lang$core$List$map,
							function (p) {
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
									_1: p
								};
							},
							_p337._0));
					var argsEntry = {
						ctor: '_Tuple5',
						_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
						_1: _user$project$Lang$space0,
						_2: _user$project$Lang$ctorArgs,
						_3: _user$project$Lang$space0,
						_4: _user$project$Lang$withDummyPatInfo(
							A3(_user$project$Lang$PRecord, _user$project$Lang$space0, insideArgsEntries, _user$project$Lang$space0))
					};
					var ctorEntry = A3(
						_user$project$Lang$ctor,
						function (_p338) {
							return _user$project$Lang$withDummyPatInfo(
								A2(
									_user$project$Lang$PBase,
									_user$project$Lang$space0,
									A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p338)));
						},
						_user$project$Lang$DataTypeCtor,
						_p336._1);
					return A3(
						_user$project$Info$withInfo,
						_user$project$Lang$pat_(
							A3(
								_user$project$Lang$PRecord,
								wsBefore,
								{
									ctor: '::',
									_0: ctorEntry,
									_1: {
										ctor: '::',
										_0: argsEntry,
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$space0)),
						_p336._0,
						_p337._1);
				});
			return A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				combiner,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								})),
						_user$project$ParserUtils$getPos),
					A3(
						_elm_lang$core$Basics$flip,
						_MikaelMayer$parser$Parser$andThen,
						_user$project$ParserUtils$untrackInfo(_user$project$LeoParser$bigIdentifier),
						function (id) {
							return A2(
								_MikaelMayer$parser$Parser$map,
								_elm_lang$core$Basics$always(id),
								A2(
									_user$project$ParserUtils$guard,
									'not a data constructor',
									_user$project$LeoParser$isDataConstructor(id)));
						})),
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								})),
						A2(
							_MikaelMayer$parser$Parser$repeat,
							_MikaelMayer$parser$Parser$zeroOrMore,
							A3(
								_MikaelMayer$parser$Parser$delayedCommitMap,
								F2(
									function (ws, wsToPat) {
										return wsToPat(ws);
									}),
								_user$project$LangParserUtils$spaces,
								_user$project$LeoParser$simplePattern))),
					_user$project$ParserUtils$getPos));
		}));
var _user$project$LeoParser$listPattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'list pattern',
	_MikaelMayer$parser$Parser$lazy(
		function (_p339) {
			return _user$project$LangParserUtils$mapWSPat_(
				_user$project$LeoParser$genericList(
					{
						item: A2(_user$project$LeoParser$pattern, _user$project$LangParserUtils$spaces, 0),
						tailItem: A2(_user$project$LeoParser$pattern, _user$project$LangParserUtils$spaces, 0),
						combiner: F3(
							function (wsBefore, members, wsBeforeEnd) {
								return A5(
									_user$project$Lang$PList,
									wsBefore,
									_user$project$Utils$listValues(members),
									_user$project$Lang$space0,
									_elm_lang$core$Maybe$Nothing,
									wsBeforeEnd);
							}),
						combinerTail: F5(
							function (wsBefore, members, wsMiddle, tail, wsBeforeEnd) {
								return A5(
									_user$project$Lang$PList,
									wsBefore,
									_user$project$Utils$listValues(members),
									wsMiddle,
									_elm_lang$core$Maybe$Just(tail),
									wsBeforeEnd);
							})
					}));
		}));
var _user$project$LeoParser$pattern = F2(
	function (spFirst, minStartCol) {
		return A3(_user$project$LeoParser$patternGeneral, true, spFirst, minStartCol);
	});
var _user$project$LeoParser$patternGeneral = F3(
	function (pColonTypeAllowed, spFirst, minStartCol) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'pattern',
			_MikaelMayer$parser$Parser$lazy(
				function (_p340) {
					var operatorSpace = A2(_user$project$LangParserUtils$spaceSameLineOrNextAfter, minStartCol, _user$project$LangParserUtils$MinIndentSpace);
					return A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F2(
							function (wsFront, binaryWSPat) {
								return binaryWSPat(wsFront);
							}),
						spFirst,
						_user$project$BinaryOperatorParser$binaryOperator(
							{
								greedySpaceParser: _user$project$LangParserUtils$spaces,
								precedenceTable: _user$project$LeoParser$builtInPatternPrecedenceTable,
								minimumPrecedence: 0,
								expression: pColonTypeAllowed ? _user$project$LeoParser$simplePatternWithMaybeColonType : _user$project$LeoParser$simplePattern,
								withZeroSpace: function (wsPat) {
									var finalPat = wsPat(_user$project$Lang$space0);
									return A2(
										_user$project$Lang$mapPrecedingWhitespacePatWS,
										function (ws) {
											return A3(_user$project$Info$withInfo, ws.val, finalPat.start, finalPat.start);
										},
										finalPat);
								},
								operator: _user$project$LeoParser$patternOperator(operatorSpace),
								representation: function (_p341) {
									return _elm_lang$core$Tuple$second(
										function (_) {
											return _.val;
										}(_p341));
								},
								combine: F4(
									function (wsBeforeEverything, left, operator, right) {
										var _p342 = operator.val;
										var wsBefore = _p342._0;
										var identifier = _p342._1;
										var _p343 = identifier;
										switch (_p343) {
											case '::':
												return A3(
													_user$project$Info$withInfo,
													_user$project$Lang$pat_(
														A5(
															_user$project$Lang$PList,
															wsBeforeEverything,
															{
																ctor: '::',
																_0: left,
																_1: {ctor: '[]'}
															},
															wsBefore,
															_elm_lang$core$Maybe$Just(right),
															_user$project$Lang$space0)),
													left.start,
													right.end);
											case 'as':
												return A3(
													_user$project$Info$withInfo,
													_user$project$Lang$pat_(
														A4(_user$project$Lang$PAs, wsBeforeEverything, left, wsBefore, right)),
													left.start,
													right.end);
											default:
												return _elm_lang$core$Native_Utils.crashCase(
													'LeoParser',
													{
														start: {line: 1314, column: 17},
														end: {line: 1325, column: 103}
													},
													_p343)(
													A2(_elm_lang$core$Basics_ops['++'], 'Internal error: Got pattern operator other than :: or as ', _p343));
										}
									})
							}));
				}));
	});
var _user$project$LeoParser$recordPattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'record pattern',
	_MikaelMayer$parser$Parser$lazy(
		function (_p345) {
			return _user$project$LangParserUtils$mapWSPat_(
				_user$project$LeoParser$genericRecord(
					{
						key: _user$project$LeoParser$identifier,
						equalSign: _MikaelMayer$parser$Parser$symbol('='),
						optNoEqualSign: _elm_lang$core$Maybe$Just(
							function (name) {
								return _user$project$Lang$withDummyPatInfo(
									A3(_user$project$Lang$PVar, _user$project$Lang$space0, name, _user$project$Lang$noWidgetDecl));
							}),
						value: _user$project$LeoParser$pattern,
						fundef: _elm_lang$core$Maybe$Nothing,
						combiner: F3(
							function (wsBefore, keyValues, wsAfter) {
								return A3(_user$project$Lang$PRecord, wsBefore, keyValues, wsAfter);
							}),
						optionalInitParser: _elm_lang$core$Maybe$Nothing
					}));
		}));
var _user$project$LeoParser$tuplePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'tuple pattern',
	_MikaelMayer$parser$Parser$lazy(
		function (_p346) {
			return _user$project$LangParserUtils$mapWSPat_(
				_user$project$LeoParser$genericTuple(
					{
						term: A2(_user$project$LeoParser$pattern, _user$project$LangParserUtils$spaces, 0),
						tagger: function (_p347) {
							return _user$project$Lang$withDummyPatInfo(
								A2(
									_user$project$Lang$PBase,
									_user$project$Lang$space0,
									A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p347)));
						},
						one: _user$project$Lang$PParens,
						record: _user$project$Lang$PRecord,
						implicitFun: _elm_lang$core$Maybe$Nothing
					}));
		}));
var _user$project$LeoParser$patternLet = F2(
	function (spFirst, minStartCol) {
		return A3(_user$project$LeoParser$patternGeneral, false, spFirst, minStartCol);
	});
var _user$project$LeoParser$typeDefOrAlias = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'type or type alias',
		A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(
												F8(
													function (spAfterType, mbSpaceAfterAlias, wsToName, parameters, spEq, binding_, optCommaSpace, wsBeforeType) {
														var _p348 = _elm_lang$core$List$isEmpty(parameters) ? {ctor: '_Tuple2', _0: binding_, _1: _user$project$Lang$FunArgsAfterEqual} : {
															ctor: '_Tuple2',
															_0: A2(
																_user$project$Info$mapInfo,
																_user$project$Lang$type_,
																A3(
																	_user$project$Info$withInfo,
																	A4(_user$project$Lang$TForall, _user$project$Lang$space0, parameters, binding_, _user$project$Lang$space0),
																	binding_.start,
																	binding_.end)),
															_1: _user$project$Lang$FunArgAsPats
														};
														var binding = _p348._0;
														var funArgStyle = _p348._1;
														var _p349 = function () {
															var _p350 = mbSpaceAfterAlias;
															if (_p350.ctor === 'Nothing') {
																return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: spAfterType};
															} else {
																return {
																	ctor: '_Tuple2',
																	_0: _elm_lang$core$Maybe$Just(spAfterType),
																	_1: _p350._0
																};
															}
														}();
														var mbSpaceBeforeAlias = _p349._0;
														var spaceBeforePattern = _p349._1;
														return _user$project$Lang$DeclType(
															A7(
																_user$project$Lang$LetType,
																optCommaSpace,
																wsBeforeType,
																mbSpaceBeforeAlias,
																wsToName(spaceBeforePattern),
																funArgStyle,
																spEq,
																binding));
													})),
											_MikaelMayer$parser$Parser$keyword('type')),
										_user$project$LangParserUtils$spaces),
									_user$project$ParserUtils$optional(
										A2(
											_MikaelMayer$parser$Parser_ops['|='],
											A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
												_MikaelMayer$parser$Parser$keyword('alias')),
											_user$project$LangParserUtils$spaces))),
								_user$project$LeoParser$simplePattern),
							A2(
								_MikaelMayer$parser$Parser$repeat,
								_MikaelMayer$parser$Parser$zeroOrMore,
								A3(
									_MikaelMayer$parser$Parser$delayedCommitMap,
									F2(
										function (ws, wsPat) {
											return wsPat(ws);
										}),
									_user$project$LangParserUtils$spaces,
									_user$project$LeoParser$typePattern))),
						_user$project$LangParserUtils$spaces),
					_MikaelMayer$parser$Parser$symbol('=')),
				A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, minStartCol)),
			_user$project$LeoParser$optionalTopLevelSemicolon));
};
var _user$project$LeoParser$parseT = _MikaelMayer$parser$Parser$run(
	A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, 0));
var _user$project$LeoParser$implicitSelectionFun = A2(
	_MikaelMayer$parser$Parser_ops['|='],
	_MikaelMayer$parser$Parser$succeed(
		F2(
			function (_p351, initSpace) {
				var _p352 = _p351;
				var _p353 = _p352.start;
				return A3(
					_user$project$Info$withInfo,
					_user$project$Lang$exp_(
						A4(
							_user$project$Lang$EFun,
							initSpace,
							{
								ctor: '::',
								_0: A3(
									_user$project$Info$withInfo,
									_user$project$Lang$pat_(
										A3(_user$project$Lang$PVar, _user$project$Lang$space0, _user$project$LeoParser$implicitVarName, _user$project$Lang$noWidgetDecl)),
									_p353,
									_p353),
								_1: {ctor: '[]'}
							},
							_user$project$Lang$Expr(
								A4(
									_elm_lang$core$List$foldl,
									F2(
										function (sel, updatedExp) {
											return sel(updatedExp);
										}),
									function (wsBefore) {
										return A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A2(_user$project$Lang$EVar, wsBefore, _user$project$LeoParser$implicitVarName)),
											_p353,
											_p353);
									},
									_p352.val,
									_user$project$Lang$space0)),
							_user$project$Lang$space0)),
					_p353,
					_p352.end);
			})),
	_user$project$ParserUtils$trackInfo(
		A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, _user$project$LeoParser$selection)));
var _user$project$LeoParser$simpleExpression = F2(
	function (minStartCol, spConstraint) {
		return _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: _user$project$LeoParser$addSelections(_user$project$LeoParser$variableExpression),
				_1: {
					ctor: '::',
					_0: _user$project$LeoParser$constantExpression,
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$lazy(
							function (_p354) {
								return _user$project$LeoParser$htmlliteral;
							}),
						_1: {
							ctor: '::',
							_0: A2(_user$project$LeoParser$conditional, minStartCol, spConstraint),
							_1: {
								ctor: '::',
								_0: A2(_user$project$LeoParser$caseExpression, minStartCol, spConstraint),
								_1: {
									ctor: '::',
									_0: A2(_user$project$LeoParser$letBinding, minStartCol, spConstraint),
									_1: {
										ctor: '::',
										_0: _MikaelMayer$parser$Parser$lazy(
											function (_p355) {
												return _user$project$LeoParser$multiLineInterpolatedString;
											}),
										_1: {
											ctor: '::',
											_0: _user$project$LeoParser$baseValueExpression,
											_1: {
												ctor: '::',
												_0: _MikaelMayer$parser$Parser$lazy(
													function (_p356) {
														return A2(_user$project$LeoParser$function, minStartCol, spConstraint);
													}),
												_1: {
													ctor: '::',
													_0: _MikaelMayer$parser$Parser$lazy(
														function (_p357) {
															return _user$project$LeoParser$implicitSelectionFun;
														}),
													_1: {
														ctor: '::',
														_0: _MikaelMayer$parser$Parser$lazy(
															function (_p358) {
																return _user$project$LeoParser$list;
															}),
														_1: {
															ctor: '::',
															_0: _MikaelMayer$parser$Parser$lazy(
																function (_p359) {
																	return _user$project$LeoParser$addSelections(_user$project$LeoParser$record);
																}),
															_1: {
																ctor: '::',
																_0: _MikaelMayer$parser$Parser$lazy(
																	function (_p360) {
																		return _user$project$LeoParser$addSelections(_user$project$LeoParser$tuple);
																	}),
																_1: {
																	ctor: '::',
																	_0: _MikaelMayer$parser$Parser$lazy(
																		function (_p361) {
																			return _user$project$LeoParser$addSelections(_user$project$LeoParser$hole);
																		}),
																	_1: {ctor: '[]'}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			});
	});
var _user$project$LeoParser$caseExpression = F2(
	function (minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'case expression',
			_MikaelMayer$parser$Parser$lazy(
				function (_p362) {
					var branch = function (branchsp) {
						return A3(
							_MikaelMayer$parser$Parser$delayedCommitMap,
							F2(
								function (wsBefore, _p363) {
									var _p364 = _p363;
									var _p366 = _p364._0;
									var _p365 = _p364._2._0;
									return A3(
										_user$project$Info$withInfo,
										A4(
											_user$project$Lang$Branch_,
											wsBefore,
											_p366,
											_user$project$Lang$Expr(_p365),
											_p364._1),
										_p366.start,
										_p365.end);
								}),
							A2(
								_MikaelMayer$parser$Parser$inContext,
								'Indentation for branch',
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
										branchsp),
									_user$project$ParserUtils$lookAhead(
										A2(
											_MikaelMayer$parser$Parser$ignore,
											_MikaelMayer$parser$Parser$Exactly(1),
											function (c) {
												return !_user$project$LangParserUtils$isSpace(c);
											})))),
							A2(
								_MikaelMayer$parser$Parser$inContext,
								'Branch',
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
									A2(
										_MikaelMayer$parser$Parser$andThen,
										function (p) {
											var newMinStartCol = p.start.col + 1;
											var spPolicy = A2(_user$project$LangParserUtils$spaceSameLineOrNextAfter, newMinStartCol, _user$project$LangParserUtils$MinIndentSpace);
											return A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												A2(
													_MikaelMayer$parser$Parser_ops['|='],
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															_MikaelMayer$parser$Parser$succeed(
																F2(
																	function (wsBeforeArrow, e) {
																		return {ctor: '_Tuple3', _0: p, _1: wsBeforeArrow, _2: e};
																	})),
															_user$project$LangParserUtils$spaces),
														_MikaelMayer$parser$Parser$symbol('->')),
													A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, newMinStartCol, spConstraint)),
												_user$project$ParserUtils$optional(
													A2(
														_MikaelMayer$parser$Parser$delayedCommit,
														spPolicy,
														_MikaelMayer$parser$Parser$symbol(';'))));
										},
										A2(_user$project$LeoParser$pattern, _user$project$LangParserUtils$nospace, minStartCol)))));
					};
					var branchHelper = F2(
						function (prevBranches, branchParser) {
							return _MikaelMayer$parser$Parser$oneOf(
								{
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser$andThen,
										function (b) {
											return A2(
												branchHelper,
												{ctor: '::', _0: b, _1: prevBranches},
												branchParser);
										},
										branchParser),
									_1: {
										ctor: '::',
										_0: _MikaelMayer$parser$Parser$succeed(
											_elm_lang$core$List$reverse(prevBranches)),
										_1: {ctor: '[]'}
									}
								});
						});
					return _user$project$LangParserUtils$mapWSExp_(
						A2(
							_user$project$LangParserUtils$transferInfo,
							F2(
								function (_p367, wsBefore) {
									var _p368 = _p367;
									var _p371 = _p368._1;
									var _p370 = _p368._0;
									var _p369 = _p368._2;
									return _elm_lang$core$Native_Utils.eq(
										_user$project$Lang$eVarUnapply(_p370),
										_elm_lang$core$Maybe$Just(_user$project$LeoParser$implicitVarName)) ? A4(
										_user$project$Lang$EFun,
										_user$project$Lang$space1,
										{
											ctor: '::',
											_0: _user$project$Lang$withDummyPatInfo(
												A3(_user$project$Lang$PVar, _user$project$Lang$space0, _user$project$LeoParser$implicitVarName, _user$project$Lang$noWidgetDecl)),
											_1: {ctor: '[]'}
										},
										_user$project$Lang$Expr(
											A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A4(_user$project$Lang$ECase, wsBefore, _p370, _p369, _p371)),
												wsBefore.start,
												_p371.end)),
										_user$project$Lang$space0) : A4(_user$project$Lang$ECase, wsBefore, _p370, _p369, _p371);
								}),
							_user$project$ParserUtils$trackInfo(
								A2(
									_MikaelMayer$parser$Parser$delayedCommit,
									_user$project$LangParserUtils$keywordWithSpace('case'),
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|='],
													_MikaelMayer$parser$Parser$succeed(
														F3(
															function (v0, v1, v2) {
																return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
															})),
													_MikaelMayer$parser$Parser$oneOf(
														{
															ctor: '::',
															_0: A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$MinIndentSpace),
															_1: {
																ctor: '::',
																_0: _MikaelMayer$parser$Parser$succeed(
																	_user$project$Lang$withDummyExpInfo(
																		A2(_user$project$Lang$EVar, _user$project$Lang$space1, _user$project$LeoParser$implicitVarName))),
																_1: {ctor: '[]'}
															}
														})),
												_user$project$LangParserUtils$spaces),
											_MikaelMayer$parser$Parser$keyword('of')),
										A2(
											_MikaelMayer$parser$Parser$andThen,
											function (b) {
												var _p372 = b.val;
												var branchIndentation = A2(_user$project$LeoParser$sameLineOrIndentedByExactly, 'for a branch after the first one', _p372._1.start.col - 1);
												return A2(
													branchHelper,
													{
														ctor: '::',
														_0: b,
														_1: {ctor: '[]'}
													},
													branch(branchIndentation));
											},
											branch(_user$project$LangParserUtils$spaces)))))));
				}));
	});
var _user$project$LeoParser$expression = F3(
	function (firstSpace, minStartCol, spConstraint) {
		return A4(_user$project$LeoParser$expressionGeneral, false, firstSpace, minStartCol, spConstraint);
	});
var _user$project$LeoParser$expressionGeneral = F4(
	function (isHtmlAttribute, spFirst, minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'expression',
			_MikaelMayer$parser$Parser$lazy(
				function (_p373) {
					var operatorSpace = A2(_user$project$LangParserUtils$spaceSameLineOrNextAfter, minStartCol, spConstraint);
					return A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F2(
							function (wsFront, binaryExp) {
								return binaryExp(wsFront);
							}),
						spFirst,
						_user$project$BinaryOperatorParser$binaryOperator(
							{
								greedySpaceParser: _user$project$LangParserUtils$spaces,
								precedenceTable: _user$project$LeoParser$builtInPrecedenceTable,
								minimumPrecedence: 0,
								expression: A2(_user$project$LeoParser$simpleExpressionWithPossibleArgumentsMaybeTyped, minStartCol, spConstraint),
								withZeroSpace: function (wsExp) {
									var _p374 = wsExp(_user$project$Lang$space0);
									var finalExp = _p374._0;
									return A2(
										_user$project$Lang$mapPrecedingWhitespaceWS,
										function (ws) {
											return A3(_user$project$Info$withInfo, ws.val, finalExp.start, finalExp.start);
										},
										_user$project$Lang$Expr(finalExp));
								},
								operator: isHtmlAttribute ? _user$project$LeoParser$htmlAttributeOperator(operatorSpace) : _user$project$LeoParser$operator(operatorSpace),
								representation: function (_p375) {
									return _elm_lang$core$Tuple$second(
										function (_) {
											return _.val;
										}(_p375));
								},
								combine: F4(
									function (wsBeforeEverything, _p377, operator, _p376) {
										var _p378 = _p377;
										var _p383 = _p378._0;
										var _p379 = _p376;
										var _p382 = _p379._0;
										var _p380 = operator.val;
										var wsBefore = _p380._0;
										var identifier = _p380._1;
										return _user$project$Lang$Expr(
											function () {
												var _p381 = _user$project$LeoParser$opFromIdentifier(identifier);
												if (_p381.ctor === 'Just') {
													var op = A3(_user$project$Info$withInfo, _p381._0, operator.start, operator.end);
													return A3(
														_user$project$Info$withInfo,
														_user$project$Lang$exp_(
															A5(
																_user$project$Lang$EOp,
																wsBeforeEverything,
																wsBefore,
																op,
																{
																	ctor: '::',
																	_0: _user$project$Lang$Expr(_p383),
																	_1: {
																		ctor: '::',
																		_0: _user$project$Lang$Expr(_p382),
																		_1: {ctor: '[]'}
																	}
																},
																_user$project$Lang$space0)),
														_p383.start,
														_p382.end);
												} else {
													if (_elm_lang$core$Native_Utils.eq(identifier, '::')) {
														return A3(
															_user$project$Info$withInfo,
															_user$project$Lang$exp_(
																A5(
																	_user$project$Lang$EList,
																	wsBeforeEverything,
																	{
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: _user$project$Lang$space0,
																			_1: _user$project$Lang$Expr(_p383)
																		},
																		_1: {ctor: '[]'}
																	},
																	wsBefore,
																	_elm_lang$core$Maybe$Just(
																		_user$project$Lang$Expr(_p382)),
																	_user$project$Lang$space0)),
															_p383.start,
															_p382.end);
													} else {
														if (_elm_lang$core$Native_Utils.eq(identifier, '<|')) {
															return A3(
																_user$project$Info$withInfo,
																_user$project$Lang$exp_(
																	A5(
																		_user$project$Lang$EApp,
																		wsBeforeEverything,
																		_user$project$Lang$Expr(_p383),
																		{
																			ctor: '::',
																			_0: _user$project$Lang$Expr(_p382),
																			_1: {ctor: '[]'}
																		},
																		_user$project$Lang$LeftApp(wsBefore),
																		_user$project$Lang$space0)),
																_p383.start,
																_p382.end);
														} else {
															if (_elm_lang$core$Native_Utils.eq(identifier, '|>')) {
																return A3(
																	_user$project$Info$withInfo,
																	_user$project$Lang$exp_(
																		A5(
																			_user$project$Lang$EApp,
																			wsBeforeEverything,
																			_user$project$Lang$Expr(_p382),
																			{
																				ctor: '::',
																				_0: _user$project$Lang$Expr(_p383),
																				_1: {ctor: '[]'}
																			},
																			_user$project$Lang$RightApp(wsBefore),
																			_user$project$Lang$space0)),
																	_p383.start,
																	_p382.end);
															} else {
																var opExp = _user$project$Lang$Expr(
																	A3(
																		_user$project$Info$withInfo,
																		_user$project$Lang$exp_(
																			A2(_user$project$Lang$EVar, wsBefore, identifier)),
																		operator.start,
																		operator.end));
																return A3(
																	_user$project$Info$withInfo,
																	_user$project$Lang$exp_(
																		A5(
																			_user$project$Lang$EApp,
																			wsBeforeEverything,
																			opExp,
																			{
																				ctor: '::',
																				_0: _user$project$Lang$Expr(_p383),
																				_1: {
																					ctor: '::',
																					_0: _user$project$Lang$Expr(_p382),
																					_1: {ctor: '[]'}
																				}
																			},
																			_user$project$Lang$InfixApp,
																			_user$project$Lang$space0)),
																	_p383.start,
																	_p382.end);
															}
														}
													}
												}
											}());
									})
							}));
				}));
	});
var _user$project$LeoParser$simpleExpressionWithPossibleArgumentsMaybeTyped = F2(
	function (minStartCol, spConstraint) {
		return _MikaelMayer$parser$Parser$lazy(
			function (_p384) {
				return A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (startPos, _p385) {
							var _p386 = _p385;
							var _p389 = _p386._0;
							var _p387 = _p386._1;
							if (_p387.ctor === 'Nothing') {
								return _p389;
							} else {
								var _p388 = _p387._0._1;
								return function (wsBefore) {
									return _user$project$Lang$Expr(
										A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A5(
													_user$project$Lang$EColonType,
													wsBefore,
													_p389(_user$project$Lang$space0),
													_p387._0._0,
													_p388,
													_user$project$Lang$space0)),
											startPos,
											_p388.end));
								};
							}
						}),
					_user$project$ParserUtils$getPos,
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})),
							A2(_user$project$LeoParser$simpleExpressionWithPossibleArguments, minStartCol, spConstraint)),
						_user$project$ParserUtils$optional(
							A2(_user$project$LeoParser$spaceColonType, minStartCol, spConstraint))));
			});
	});
var _user$project$LeoParser$simpleExpressionWithPossibleArguments = F2(
	function (minStartCol, spConstraint) {
		var combine = F3(
			function (wsToFirst, rest, wsBefore) {
				var _p390 = wsToFirst(wsBefore);
				var eFirst = _p390;
				var first = _p390._0;
				var start = first.start;
				var constructedRest = A3(
					_elm_lang$core$Basics$flip,
					_elm_lang$core$List$map,
					rest,
					function (_p391) {
						var _p392 = _p391;
						var _p397 = _p392;
						var _p396 = _p392._0;
						var _p393 = _user$project$Lang$unwrapExp(_p397);
						if (_p393.ctor === 'EVar') {
							var _p395 = _p393._1;
							if (_user$project$LeoParser$isDataConstructor(_p395)) {
								var argsEntry = {
									ctor: '_Tuple5',
									_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
									_1: _user$project$Lang$space0,
									_2: _user$project$Lang$ctorArgs,
									_3: _user$project$Lang$space0,
									_4: _user$project$Lang$withDummyExpInfo(
										A4(
											_user$project$Lang$eRecord__,
											_user$project$Lang$space0,
											_elm_lang$core$Maybe$Nothing,
											{ctor: '[]'},
											_user$project$Lang$space0))
								};
								var ctorEntry = A3(
									_user$project$Lang$ctor,
									function (_p394) {
										return _user$project$Lang$withDummyExpInfo(
											A2(
												_user$project$Lang$EBase,
												_user$project$Lang$space0,
												A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p394)));
									},
									_user$project$Lang$DataTypeCtor,
									_p395);
								return _user$project$Lang$Expr(
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$exp_(
											A4(
												_user$project$Lang$eRecord__,
												_p393._0,
												_elm_lang$core$Maybe$Nothing,
												{
													ctor: '::',
													_0: ctorEntry,
													_1: {
														ctor: '::',
														_0: argsEntry,
														_1: {ctor: '[]'}
													}
												},
												_user$project$Lang$space0)),
										_p396.start,
										_p396.end));
							} else {
								return _p397;
							}
						} else {
							return _p397;
						}
					});
				var maybeSpecial = function () {
					var _p398 = _user$project$Lang$unwrapExp(eFirst);
					if (_p398.ctor === 'EVar') {
						var _p401 = _p398._1;
						if (_user$project$LeoParser$isDataConstructor(_p401)) {
							var insideArgsEntries = A3(
								_user$project$Utils$indexedMapFrom,
								1,
								_user$project$Lang$numericalEntry,
								A2(
									_elm_lang$core$List$map,
									function (e) {
										return {
											ctor: '_Tuple2',
											_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
											_1: e
										};
									},
									constructedRest));
							var argsEntry = {
								ctor: '_Tuple5',
								_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
								_1: _user$project$Lang$space0,
								_2: _user$project$Lang$ctorArgs,
								_3: _user$project$Lang$space0,
								_4: _user$project$Lang$withDummyExpInfo(
									A4(_user$project$Lang$eRecord__, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, insideArgsEntries, _user$project$Lang$space0))
							};
							var ctorEntry = A3(
								_user$project$Lang$ctor,
								function (_p399) {
									return _user$project$Lang$withDummyExpInfo(
										A2(
											_user$project$Lang$EBase,
											_user$project$Lang$space0,
											A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p399)));
								},
								_user$project$Lang$DataTypeCtor,
								_p401);
							return function (_p400) {
								return _elm_lang$core$Maybe$Just(
									_user$project$Lang$exp_(_p400));
							}(
								A4(
									_user$project$Lang$eRecord__,
									_p398._0,
									_elm_lang$core$Maybe$Nothing,
									{
										ctor: '::',
										_0: ctorEntry,
										_1: {
											ctor: '::',
											_0: argsEntry,
											_1: {ctor: '[]'}
										}
									},
									_user$project$Lang$space0));
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				}();
				var end = function () {
					var _p402 = _user$project$Utils$maybeLast(constructedRest);
					if (_p402.ctor === 'Nothing') {
						return first.end;
					} else {
						return _p402._0._0.end;
					}
				}();
				var _p403 = maybeSpecial;
				if (_p403.ctor === 'Just') {
					return _user$project$Lang$Expr(
						A3(_user$project$Info$withInfo, _p403._0, start, end));
				} else {
					var _p404 = _user$project$Utils$maybeLast(constructedRest);
					if (_p404.ctor === 'Nothing') {
						return _user$project$LeoParser$maybeConvertToOp0(eFirst);
					} else {
						var e_ = _user$project$Lang$exp_(
							A2(_user$project$LeoParser$maybeConvertToOpN, eFirst, constructedRest));
						return _user$project$Lang$Expr(
							A3(_user$project$Info$withInfo, e_, first.start, _p404._0._0.end));
					}
				}
			});
		return _MikaelMayer$parser$Parser$lazy(
			function (_p405) {
				return A2(
					_MikaelMayer$parser$Parser$andThen,
					function (wsToMainExp) {
						var appargSpace = A2(
							_user$project$LangParserUtils$spaceSameLineOrNextAfter,
							A2(_elm_lang$core$Basics$min, minStartCol, wsToMainExp.start.col),
							spConstraint);
						return A2(
							_MikaelMayer$parser$Parser$map,
							combine(wsToMainExp.val),
							A2(
								_MikaelMayer$parser$Parser$repeat,
								_MikaelMayer$parser$Parser$zeroOrMore,
								A3(
									_MikaelMayer$parser$Parser$delayedCommitMap,
									F2(
										function (ws, wsExp) {
											return wsExp(ws);
										}),
									A2(
										_MikaelMayer$parser$Parser$andThen,
										function (sp) {
											return _elm_lang$core$Native_Utils.eq(sp.val, '') ? A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(sp),
												_user$project$ParserUtils$negativeLookAhead(
													_MikaelMayer$parser$Parser$symbol('-'))) : _MikaelMayer$parser$Parser$succeed(sp);
										},
										appargSpace),
									_user$project$LeoParser$wsExp_ParserToWsExpParser(
										A2(_user$project$LeoParser$simpleExpression, minStartCol, spConstraint)))));
					},
					_user$project$ParserUtils$trackInfo(
						_user$project$LeoParser$wsExp_ParserToWsExpParser(
							_MikaelMayer$parser$Parser$oneOf(
								{
									ctor: '::',
									_0: A2(_user$project$LeoParser$simpleExpression, minStartCol, spConstraint),
									_1: {
										ctor: '::',
										_0: _user$project$LeoParser$implicitOp,
										_1: {ctor: '[]'}
									}
								}))));
			});
	});
var _user$project$LeoParser$conditional = F2(
	function (minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'conditional',
			_MikaelMayer$parser$Parser$lazy(
				function (_p406) {
					return _user$project$LangParserUtils$mapWSExp_(
						A2(
							_user$project$LangParserUtils$transferInfo,
							F2(
								function (_p407, wsBefore) {
									var _p408 = _p407;
									return A7(_user$project$Lang$EIf, wsBefore, _p408._0, _p408._1, _p408._2, _p408._3, _p408._4, _user$project$Lang$space0);
								}),
							_user$project$ParserUtils$trackInfo(
								A2(
									_MikaelMayer$parser$Parser$delayedCommit,
									_user$project$LangParserUtils$keywordWithSpace('if'),
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|='],
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														A2(
															_MikaelMayer$parser$Parser_ops['|='],
															A2(
																_MikaelMayer$parser$Parser_ops['|='],
																_MikaelMayer$parser$Parser$succeed(
																	F5(
																		function (v0, v1, v2, v3, v4) {
																			return {ctor: '_Tuple5', _0: v0, _1: v1, _2: v2, _3: v3, _4: v4};
																		})),
																A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, minStartCol, _user$project$LangParserUtils$MinIndentSpace)),
															_user$project$LangParserUtils$spaces),
														_user$project$LangParserUtils$keywordWithSpace('then')),
													A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, minStartCol, _user$project$LangParserUtils$MinIndentSpace)),
												_user$project$LangParserUtils$spaces),
											_user$project$LangParserUtils$keywordWithSpace('else')),
										A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, minStartCol, spConstraint))))));
				}));
	});
var _user$project$LeoParser$function = F2(
	function (minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'function',
			_user$project$LangParserUtils$mapWSExp_(
				A2(
					_user$project$LangParserUtils$transferInfo,
					F2(
						function (_p409, wsBefore) {
							var _p410 = _p409;
							return A4(_user$project$Lang$EFun, wsBefore, _p410._0, _p410._1, _user$project$Lang$space0);
						}),
					_user$project$ParserUtils$trackInfo(
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(
												F2(
													function (v0, v1) {
														return {ctor: '_Tuple2', _0: v0, _1: v1};
													})),
											_MikaelMayer$parser$Parser$symbol('\\')),
										A2(
											_MikaelMayer$parser$Parser$repeat,
											_MikaelMayer$parser$Parser$oneOrMore,
											A2(_user$project$LeoParser$pattern, _user$project$LangParserUtils$spaces, minStartCol))),
									_user$project$LangParserUtils$spaces),
								_MikaelMayer$parser$Parser$symbol('->')),
							A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, minStartCol, spConstraint))))));
	});
var _user$project$LeoParser$htmlliteral = A2(
	_MikaelMayer$parser$Parser$inContext,
	'html literal',
	_MikaelMayer$parser$Parser$lazy(
		function (_p411) {
			return A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(
					F2(
						function (newExp, space) {
							return A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A4(
										_user$project$Lang$EParens,
										space,
										_user$project$Lang$Expr(newExp),
										_user$project$Lang$HtmlSyntax,
										_user$project$Lang$space0)),
								newExp.start,
								newExp.end);
						})),
				A2(
					_MikaelMayer$parser$Parser$andThen,
					_user$project$LeoParser$htmlToExp('top level'),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
							_user$project$ParserUtils$lookAhead(
								A2(
									_MikaelMayer$parser$Parser$delayedCommit,
									_MikaelMayer$parser$Parser$symbol('<'),
									_MikaelMayer$parser$Parser$oneOf(
										{
											ctor: '::',
											_0: _user$project$LeoParser$identifier,
											_1: {
												ctor: '::',
												_0: _MikaelMayer$parser$Parser$source(
													_MikaelMayer$parser$Parser$symbol('@')),
												_1: {ctor: '[]'}
											}
										})))),
						_user$project$HTMLParser$parseOneNode(
							_user$project$HTMLParser$Interpolation(
								{
									attributevalue: function (_p412) {
										return A2(
											_MikaelMayer$parser$Parser$inContext,
											'HTML attribute value',
											A2(
												_user$project$LeoParser$wrapWithSyntax,
												_user$project$Lang$LeoSyntax,
												function (apparg) {
													return A2(
														_MikaelMayer$parser$Parser$map,
														_elm_lang$core$Basics$always,
														A3(_user$project$LeoParser$expressionWithoutGreater, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$NoSpace));
												}(_p412)));
									},
									attributerawvalue: _user$project$LeoParser$htmlAttribElemsToExp,
									attributelist: A2(
										_MikaelMayer$parser$Parser$inContext,
										'HTML special attribute list',
										A2(
											_user$project$LeoParser$wrapWithSyntax,
											_user$project$Lang$LeoSyntax,
											A2(_user$project$LeoParser$simpleExpression, 0, _user$project$LangParserUtils$NoSpace))),
									childlist: function (_p413) {
										return A2(
											_MikaelMayer$parser$Parser$inContext,
											'HTML special child list',
											A2(
												_user$project$LeoParser$wrapWithSyntax,
												_user$project$Lang$LeoSyntax,
												function (spaceapparg) {
													return _MikaelMayer$parser$Parser$oneOf(
														{
															ctor: '::',
															_0: _user$project$LeoParser$addRightApplications(
																_user$project$LeoParser$addParenthesizedParameters(
																	_user$project$LeoParser$addSelections(_user$project$LeoParser$variableExpression))),
															_1: {
																ctor: '::',
																_0: A2(_user$project$LeoParser$letBinding, 0, _user$project$LangParserUtils$NoSpace),
																_1: {
																	ctor: '::',
																	_0: _MikaelMayer$parser$Parser$lazy(
																		function (_p414) {
																			return _user$project$LeoParser$multiLineInterpolatedString;
																		}),
																	_1: {
																		ctor: '::',
																		_0: _user$project$LeoParser$baseValueExpression,
																		_1: {
																			ctor: '::',
																			_0: _user$project$LeoParser$tuple,
																			_1: {
																				ctor: '::',
																				_0: _user$project$LeoParser$list,
																				_1: {ctor: '[]'}
																			}
																		}
																	}
																}
															}
														});
												}(_p413)));
									},
									tagName: A2(
										_MikaelMayer$parser$Parser$inContext,
										'HTML special tag name',
										A2(
											_user$project$LeoParser$wrapWithSyntax,
											_user$project$Lang$LeoSyntax,
											A2(_user$project$LeoParser$simpleExpression, 0, _user$project$LangParserUtils$NoSpace)))
								})))));
		}));
var _user$project$LeoParser$addParenthesizedParameters = function (parser) {
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F3(
					function (simpExp, $arguments, wsBefore) {
						if (_elm_lang$core$Native_Utils.eq(
							_elm_lang$core$List$length($arguments),
							0)) {
							return simpExp(wsBefore);
						} else {
							var simpExpZeroSpace = simpExp(_user$project$Lang$space0);
							var argumentsZeroSpace = A2(
								_elm_lang$core$List$map,
								function (arg) {
									return _user$project$Lang$Expr(
										arg(_user$project$Lang$space0));
								},
								$arguments);
							return A3(
								_user$project$Info$withInfo,
								_user$project$Lang$exp_(
									A5(
										_user$project$Lang$EApp,
										wsBefore,
										_user$project$Lang$Expr(simpExpZeroSpace),
										argumentsZeroSpace,
										_user$project$Lang$SpaceApp,
										_user$project$Lang$space0)),
								simpExpZeroSpace.start,
								function (_) {
									return _.end;
								}(
									A3(_user$project$Utils$last, 'addParenthesizedParameters', $arguments, _user$project$Lang$space0)));
						}
					})),
			parser),
		A2(
			_MikaelMayer$parser$Parser$repeat,
			_MikaelMayer$parser$Parser$zeroOrMore,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$LeoParser$tuple,
					_1: {
						ctor: '::',
						_0: _user$project$LeoParser$list,
						_1: {
							ctor: '::',
							_0: _user$project$LeoParser$record,
							_1: {ctor: '[]'}
						}
					}
				})));
};
var _user$project$LeoParser$list = function () {
	var mapExpr = _elm_lang$core$List$map(
		_elm_lang$core$Tuple$mapSecond(_user$project$Lang$Expr));
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'list',
		_MikaelMayer$parser$Parser$lazy(
			function (_p415) {
				return _user$project$LangParserUtils$mapWSExp_(
					_user$project$LeoParser$genericList(
						{
							item: A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$MinIndentSpace),
							tailItem: A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$MinIndentSpace),
							combiner: F3(
								function (wsBefore, members, wsBeforeEnd) {
									return A5(_user$project$Lang$EList, wsBefore, members, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, wsBeforeEnd);
								}),
							combinerTail: F5(
								function (wsBefore, members, wsMiddle, tail, wsBeforeEnd) {
									return A5(
										_user$project$Lang$EList,
										wsBefore,
										members,
										wsMiddle,
										_elm_lang$core$Maybe$Just(tail),
										wsBeforeEnd);
								})
						}));
			}));
}();
var _user$project$LeoParser$record = A2(
	_MikaelMayer$parser$Parser$inContext,
	'record expression',
	_MikaelMayer$parser$Parser$lazy(
		function (_p416) {
			return A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F2(
					function (startPos, f) {
						return f(startPos);
					}),
				_user$project$ParserUtils$getPos,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F6(
												function (mbInit, decls, wsEnd, endPos, startPos, wsBefore) {
													return A3(
														_user$project$Info$withInfo,
														_user$project$Lang$exp_(
															A4(_user$project$Lang$ERecord, wsBefore, mbInit, decls, wsEnd)),
														startPos,
														endPos);
												})),
										_MikaelMayer$parser$Parser$symbol('{')),
									_user$project$ParserUtils$optional(
										A3(
											_MikaelMayer$parser$Parser$delayedCommitMap,
											_elm_lang$core$Basics$always,
											A2(
												_MikaelMayer$parser$Parser_ops['|='],
												A2(
													_MikaelMayer$parser$Parser_ops['|='],
													_MikaelMayer$parser$Parser$succeed(
														F2(
															function (v0, v1) {
																return {ctor: '_Tuple2', _0: v0, _1: v1};
															})),
													function () {
														var customSpace = _user$project$LangParserUtils$spacesWithoutNewline;
														return A3(_user$project$LeoParser$expression, customSpace, 0, _user$project$LangParserUtils$MinIndentSpace);
													}()),
												_user$project$LangParserUtils$spaces),
											_MikaelMayer$parser$Parser$symbol('|')))),
								_MikaelMayer$parser$Parser$oneOf(
									{
										ctor: '::',
										_0: _user$project$LeoParser$declarations(0),
										_1: {
											ctor: '::',
											_0: _MikaelMayer$parser$Parser$succeed(
												A4(
													_user$project$Lang$Declarations,
													{ctor: '[]'},
													{ctor: '[]'},
													{ctor: '[]'},
													{ctor: '[]'})),
											_1: {ctor: '[]'}
										}
									})),
							_user$project$LangParserUtils$spaces),
						_MikaelMayer$parser$Parser$symbol('}')),
					_user$project$ParserUtils$getPos));
		}));
var _user$project$LeoParser$declarations = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'Declarations',
		_MikaelMayer$parser$Parser$lazy(
			function (_p417) {
				return A2(
					_MikaelMayer$parser$Parser$andThen,
					function (definitions) {
						var _p418 = _user$project$LeoParser$reorderDeclarations(definitions);
						if (_p418.ctor === 'Ok') {
							return _MikaelMayer$parser$Parser$succeed(_p418._0);
						} else {
							return _MikaelMayer$parser$Parser$fail(_p418._0);
						}
					},
					A2(
						_MikaelMayer$parser$Parser$andThen,
						function (headDecl) {
							var firstWS = _user$project$Lang$precedingWhitespaceDeclarationWithInfo(headDecl);
							return A2(
								_user$project$LeoParser$tailDeclarations,
								firstWS.end.col,
								{
									ctor: '::',
									_0: headDecl,
									_1: {ctor: '[]'}
								});
						},
						_user$project$LeoParser$headDeclaration(minStartCol)));
			}));
};
var _user$project$LeoParser$headDeclaration = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'Declaration #1',
		_MikaelMayer$parser$Parser$lazy(
			function (_p419) {
				return A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (sp, declBuilder) {
							return A2(declBuilder, _elm_lang$core$Maybe$Nothing, sp);
						}),
					_user$project$LangParserUtils$spaces,
					_MikaelMayer$parser$Parser$oneOf(
						{
							ctor: '::',
							_0: _user$project$LeoParser$typeDefOrAlias(minStartCol),
							_1: {
								ctor: '::',
								_0: _user$project$LeoParser$letExpOrAnnotation(minStartCol),
								_1: {ctor: '[]'}
							}
						}));
			}));
};
var _user$project$LeoParser$letExpOrAnnotation = function (minStartCol) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'let/def binding',
		A2(
			_MikaelMayer$parser$Parser$andThen,
			_elm_lang$core$Basics$identity,
			A3(
				_MikaelMayer$parser$Parser$delayedCommitAndThen,
				F2(
					function (_p420, $final) {
						var _p421 = _p420;
						return A3($final, _p421._0, _p421._1, _p421._2);
					}),
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F3(
									function (v0, v1, v2) {
										return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
									})),
							A2(_user$project$LeoParser$patternLet, _user$project$LangParserUtils$nospace, minStartCol)),
						A2(
							_MikaelMayer$parser$Parser$repeat,
							_MikaelMayer$parser$Parser$zeroOrMore,
							A2(_user$project$LeoParser$patternLet, _user$project$LangParserUtils$spaces, minStartCol))),
					_user$project$LangParserUtils$spaces),
				function (_p422) {
					var _p423 = _p422;
					var _p430 = _p423._0;
					return A2(
						_MikaelMayer$parser$Parser$andThen,
						function (eqSymbol) {
							return _elm_lang$core$Native_Utils.eq(eqSymbol, '=') ? A2(
								_MikaelMayer$parser$Parser$map,
								F4(
									function (_p424, pat, parameters, wsBeforeEq) {
										var _p425 = _p424;
										var _p427 = _p425._0;
										var _p426 = _elm_lang$core$List$isEmpty(parameters) ? {ctor: '_Tuple2', _0: _p427, _1: _user$project$Lang$FunArgsAfterEqual} : {
											ctor: '_Tuple2',
											_0: A3(
												_user$project$Info$withInfo,
												_user$project$Lang$exp_(
													A4(
														_user$project$Lang$EFun,
														_user$project$Lang$space0,
														parameters,
														_user$project$Lang$Expr(_p427),
														_user$project$Lang$space0)),
												_p427.start,
												_p427.end),
											_1: _user$project$Lang$FunArgAsPats
										};
										var binding = _p426._0;
										var funArgStyle = _p426._1;
										return _MikaelMayer$parser$Parser$succeed(
											F2(
												function (optCommaSpace, wsBeforePat) {
													return _user$project$Lang$DeclExp(
														A6(
															_user$project$Lang$LetExp,
															optCommaSpace,
															wsBeforePat,
															pat,
															funArgStyle,
															wsBeforeEq,
															_user$project$Lang$Expr(binding)));
												}));
									}),
								A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, _p430.start.col + 1, _user$project$LangParserUtils$MinIndentSpace)) : A2(
								_MikaelMayer$parser$Parser$map,
								F4(
									function (binding_, pat, parameters, wsBeforeEq) {
										var mbBindingsFunArgStyles = function () {
											if (_elm_lang$core$List$isEmpty(parameters)) {
												return _elm_lang$core$Result$Ok(
													{ctor: '_Tuple2', _0: binding_, _1: _user$project$Lang$FunArgsAfterEqual});
											} else {
												var _p428 = _user$project$Utils$projJusts(
													A2(_elm_lang$core$List$map, _user$project$Lang$patToTPat, parameters));
												if (_p428.ctor === 'Just') {
													return _elm_lang$core$Result$Ok(
														{
															ctor: '_Tuple2',
															_0: A2(
																_user$project$Info$mapInfo,
																_user$project$Lang$type_,
																A3(
																	_user$project$Info$withInfo,
																	A4(_user$project$Lang$TForall, _user$project$Lang$space0, _p428._0, binding_, _user$project$Lang$space0),
																	binding_.start,
																	binding_.end)),
															_1: _user$project$Lang$FunArgAsPats
														});
												} else {
													return _elm_lang$core$Result$Err('Could not interpret this pattern as a type pattern');
												}
											}
										}();
										var _p429 = mbBindingsFunArgStyles;
										if (_p429.ctor === 'Ok') {
											return _MikaelMayer$parser$Parser$succeed(
												F2(
													function (optCommaSpace, wsBeforePat) {
														return _user$project$Lang$DeclAnnotation(
															A6(_user$project$Lang$LetAnnotation, optCommaSpace, wsBeforePat, pat, _p429._0._1, wsBeforeEq, _p429._0._0));
													}));
										} else {
											return _MikaelMayer$parser$Parser$fail(_p429._0);
										}
									}),
								A2(_user$project$LeoParser$typ, _user$project$LangParserUtils$spaces, _p430.start.col + 1));
						},
						_MikaelMayer$parser$Parser$oneOf(
							{
								ctor: '::',
								_0: _MikaelMayer$parser$Parser$source(
									_MikaelMayer$parser$Parser$symbol('=')),
								_1: {
									ctor: '::',
									_0: _MikaelMayer$parser$Parser$source(
										_MikaelMayer$parser$Parser$symbol(':')),
									_1: {ctor: '[]'}
								}
							}));
				})));
};
var _user$project$LeoParser$tailDeclarations = F2(
	function (minStartCol, revPrevDeclarations) {
		var spaceBeforeNewDeclaration = _MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: _user$project$ParserUtils$try(
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (a, b) {
											return {
												ctor: '_Tuple2',
												_0: _elm_lang$core$Maybe$Just(a),
												_1: b
											};
										})),
								_user$project$LangParserUtils$spaces),
							_MikaelMayer$parser$Parser$symbol(',')),
						_user$project$LangParserUtils$spaces)),
				_1: {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								})(_elm_lang$core$Maybe$Nothing)),
						_user$project$LangParserUtils$spaceSameLineOrNextAfterOrTwoLines(minStartCol)),
					_1: {ctor: '[]'}
				}
			});
		return A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A3(
						_MikaelMayer$parser$Parser$delayedCommitAndThen,
						function (_p431) {
							return _elm_lang$core$Basics$identity;
						},
						spaceBeforeNewDeclaration,
						function (_p432) {
							var _p433 = _p432;
							var _p434 = _p433._1;
							var newMinStartCol = (_elm_lang$core$Native_Utils.cmp(_p434.start.line + 1, _p434.end.line) < 0) ? _p434.end.col : minStartCol;
							return A2(
								_MikaelMayer$parser$Parser$andThen,
								function ($final) {
									return A2(
										_user$project$LeoParser$tailDeclarations,
										newMinStartCol,
										{
											ctor: '::',
											_0: A2($final, _p433._0, _p434),
											_1: revPrevDeclarations
										});
								},
								A2(
									_MikaelMayer$parser$Parser$inContext,
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Declaration #',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(revPrevDeclarations) + 1)),
									_MikaelMayer$parser$Parser$oneOf(
										{
											ctor: '::',
											_0: _user$project$LeoParser$typeDefOrAlias(newMinStartCol),
											_1: {
												ctor: '::',
												_0: _user$project$LeoParser$letExpOrAnnotation(newMinStartCol),
												_1: {ctor: '[]'}
											}
										})));
						}),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$succeed(
							_elm_lang$core$List$reverse(revPrevDeclarations)),
						_1: {ctor: '[]'}
					}
				}));
	});
var _user$project$LeoParser$tuple = A2(
	_MikaelMayer$parser$Parser$inContext,
	'tuple',
	_MikaelMayer$parser$Parser$lazy(
		function (_p435) {
			return _user$project$LangParserUtils$mapWSExp_(
				_user$project$LeoParser$genericTuple(
					{
						term: A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$MinIndentSpace),
						tagger: function (_p436) {
							return _user$project$Lang$withDummyExpInfo(
								A2(
									_user$project$Lang$EBase,
									_user$project$Lang$space0,
									A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p436)));
						},
						record: F3(
							function (ws1, entries, ws2) {
								return A4(_user$project$Lang$eRecord__, ws1, _elm_lang$core$Maybe$Nothing, entries, ws2);
							}),
						one: F3(
							function (wsBefore, innerExpression, wsBeforeEnd) {
								return A4(_user$project$Lang$EParens, wsBefore, innerExpression, _user$project$Lang$Parens, wsBeforeEnd);
							}),
						implicitFun: _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: function (ident) {
									return {
										ctor: '_Tuple2',
										_0: _user$project$Lang$pVar(ident),
										_1: _user$project$Lang$eVar(ident)
									};
								},
								_1: F3(
									function (wsBefore, pvars, body) {
										return A4(
											_user$project$Lang$EFun,
											wsBefore,
											pvars,
											_user$project$Lang$withDummyExpInfo(body),
											_user$project$Lang$space0);
									})
							})
					}));
		}));
var _user$project$LeoParser$addRightApplications = function (parser) {
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			_MikaelMayer$parser$Parser$succeed(
				F3(
					function (simpExp, apps, wsBefore) {
						var finalExps = {
							ctor: '::',
							_0: simpExp(wsBefore),
							_1: apps
						};
						var _p437 = _user$project$Utils$maybeInitLast(finalExps);
						if ((_p437.ctor === 'Just') && (_p437._0.ctor === '_Tuple2')) {
							return A3(
								_elm_lang$core$List$foldr,
								F2(
									function (simpExp, argExp) {
										return A3(
											_user$project$Info$withInfo,
											_user$project$Lang$exp_(
												A5(
													_user$project$Lang$EApp,
													_user$project$Lang$space0,
													_user$project$Lang$Expr(simpExp),
													{
														ctor: '::',
														_0: _user$project$Lang$Expr(argExp),
														_1: {ctor: '[]'}
													},
													_user$project$Lang$LeftApp(_user$project$Lang$space0),
													_user$project$Lang$space0)),
											simpExp.start,
											argExp.end);
									}),
								_p437._0._1,
								_p437._0._0);
						} else {
							return _elm_lang$core$Native_Utils.crashCase(
								'LeoParser',
								{
									start: {line: 982, column: 6},
									end: {line: 987, column: 43}
								},
								_p437)('Finally, P = NP.');
						}
					})),
			parser),
		A2(
			_MikaelMayer$parser$Parser$repeat,
			_MikaelMayer$parser$Parser$zeroOrMore,
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (sp, spToExp) {
									return spToExp(sp);
								})),
						_MikaelMayer$parser$Parser$symbol('<|')),
					_user$project$LangParserUtils$spaces),
				_user$project$LeoParser$addParenthesizedParameters(
					A2(_user$project$LeoParser$simpleExpression, 0, _user$project$LangParserUtils$NoSpace)))));
};
var _user$project$LeoParser$expressionWithoutGreater = F3(
	function (firstSpace, minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$map,
			function (_p439) {
				var _p440 = _p439;
				return _p440._0;
			},
			A4(_user$project$LeoParser$expressionGeneral, true, firstSpace, minStartCol, spConstraint));
	});
var _user$project$LeoParser$letBinding = F2(
	function (minStartCol, spConstraint) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'let binding',
			_user$project$LeoParser$genericLetBinding(
				A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, minStartCol, spConstraint)));
	});
var _user$project$LeoParser$genericLetBinding = function (bodyParser) {
	return _MikaelMayer$parser$Parser$lazy(
		function (_p441) {
			return A3(
				_MikaelMayer$parser$Parser$delayedCommitMap,
				F3(
					function (startPos, _p442, wsBefore) {
						var _p443 = _p442;
						return A3(
							_user$project$Info$withInfo,
							_user$project$Lang$exp_(
								A5(_user$project$Lang$ELet, wsBefore, _user$project$Lang$Let, _p443._0, _p443._1, _p443._2)),
							startPos,
							_p443._3);
					}),
				_user$project$ParserUtils$getPos,
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F4(
												function (v0, v1, v2, v3) {
													return {ctor: '_Tuple4', _0: v0, _1: v1, _2: v2, _3: v3};
												})),
										_MikaelMayer$parser$Parser$keyword('let')),
									A2(
										_MikaelMayer$parser$Parser$andThen,
										function (pos) {
											return _user$project$LeoParser$declarations(pos.col - 3);
										},
										_user$project$ParserUtils$getPos)),
								_user$project$LangParserUtils$spaces),
							_user$project$LangParserUtils$keywordWithSpace('in')),
						bodyParser),
					_user$project$ParserUtils$getPos));
		});
};
var _user$project$LeoParser$multiLineInterpolatedString = A2(
	_MikaelMayer$parser$Parser$inContext,
	'multi-line interpolated string',
	_MikaelMayer$parser$Parser$lazy(
		function (_p444) {
			return _user$project$LangParserUtils$mapWSExp_(
				_user$project$ParserUtils$trackInfo(
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (e, wsBefore) {
											return A4(
												_user$project$Lang$EParens,
												wsBefore,
												_user$project$Lang$Expr(e),
												_user$project$Lang$LongStringSyntax,
												_user$project$Lang$space0);
										})),
								_MikaelMayer$parser$Parser$symbol('\"\"\"')),
							_user$project$LeoParser$multilineContentParser),
						_MikaelMayer$parser$Parser$symbol('\"\"\"'))));
		}));
var _user$project$LeoParser$multilineContentParser = A2(
	_MikaelMayer$parser$Parser$inContext,
	'multi-line string content',
	A2(
		_MikaelMayer$parser$Parser$andThen,
		function (exp) {
			return _user$project$LeoParser$multilineContentParserHelp(
				{
					ctor: '::',
					_0: _user$project$Lang$Expr(exp),
					_1: {ctor: '[]'}
				});
		},
		_user$project$LangParserUtils$mapExp_(
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						function (str) {
							return A2(
								_user$project$Lang$EBase,
								_user$project$Lang$space0,
								A2(_user$project$Lang$EString, '\"', str));
						}),
					_user$project$ParserUtils$keepUntilRegex(_user$project$LeoParser$multilineParseUntilRegex))))));
var _user$project$LeoParser$multilineContentParserHelp = function (prevExps) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'multi-line string end or escape',
		_MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: _user$project$ParserUtils$try(
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(
								_user$project$LeoParser$multilineConcatExp(
									_elm_lang$core$List$reverse(prevExps))),
							_user$project$ParserUtils$lookAhead(
								_MikaelMayer$parser$Parser$symbol('\"\"\"'))),
						_user$project$ParserUtils$getPos)),
				_1: {
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser$andThen,
						function (_p445) {
							var _p446 = _p445;
							var _p451 = _p446._1;
							var stringExp = _user$project$Lang$Expr(_p451);
							var potentialExp = _user$project$Lang$Expr(_p446._0);
							var _p447 = prevExps;
							if (_p447.ctor === '::') {
								var _p449 = _p447._0._0;
								var _p448 = {
									ctor: '_Tuple3',
									_0: _user$project$Lang$unwrapExp(
										_user$project$Lang$Expr(_p449)),
									_1: _user$project$Lang$unwrapExp(potentialExp),
									_2: _user$project$Lang$unwrapExp(stringExp)
								};
								if (((((((_p448.ctor === '_Tuple3') && (_p448._0.ctor === 'EBase')) && (_p448._0._1.ctor === 'EString')) && (_p448._1.ctor === 'EBase')) && (_p448._1._1.ctor === 'EString')) && (_p448._2.ctor === 'EBase')) && (_p448._2._1.ctor === 'EString')) {
									return _user$project$LeoParser$multilineContentParserHelp(
										{
											ctor: '::',
											_0: _user$project$Lang$Expr(
												A3(
													_user$project$Info$withInfo,
													_user$project$Lang$exp_(
														A2(
															_user$project$Lang$EBase,
															_p448._0._0,
															A2(
																_user$project$Lang$EString,
																_p448._0._1._0,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_p448._0._1._1,
																	A2(_elm_lang$core$Basics_ops['++'], _p448._1._1._1, _p448._2._1._1))))),
													_p449.start,
													_p451.end)),
											_1: _p447._1
										});
								} else {
									return _user$project$LeoParser$multilineContentParserHelp(
										{
											ctor: '::',
											_0: stringExp,
											_1: {ctor: '::', _0: potentialExp, _1: prevExps}
										});
								}
							} else {
								return _elm_lang$core$Native_Utils.crashCase(
									'LeoParser',
									{
										start: {line: 714, column: 9},
										end: {line: 723, column: 118}
									},
									_p447)('Internal error: There should be always at least one expression in a longstring literal.');
							}
						},
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (potentialExp, strAfterExp) {
											return {ctor: '_Tuple2', _0: potentialExp, _1: strAfterExp};
										})),
								A2(
									_MikaelMayer$parser$Parser$inContext,
									'multi-line string @expression',
									_MikaelMayer$parser$Parser$oneOf(
										{
											ctor: '::',
											_0: _user$project$LangParserUtils$mapExp_(
												_user$project$ParserUtils$trackInfo(
													A2(
														_MikaelMayer$parser$Parser$map,
														function (_p452) {
															return A2(
																_user$project$Lang$EBase,
																_user$project$Lang$space0,
																A2(_user$project$Lang$EString, '\"', '@'));
														},
														_MikaelMayer$parser$Parser$symbol('@@')))),
											_1: {
												ctor: '::',
												_0: A2(
													_MikaelMayer$parser$Parser_ops['|='],
													A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
														_MikaelMayer$parser$Parser$symbol('@')),
													_MikaelMayer$parser$Parser$lazy(
														function (_p453) {
															return _user$project$LeoParser$multilineEscapedElmExpression;
														})),
												_1: {ctor: '[]'}
											}
										}))),
							_user$project$LangParserUtils$mapExp_(
								_user$project$ParserUtils$trackInfo(
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										_MikaelMayer$parser$Parser$succeed(
											function (str) {
												return A2(
													_user$project$Lang$EBase,
													_user$project$Lang$space0,
													A2(_user$project$Lang$EString, '\"', str));
											}),
										_user$project$ParserUtils$keepUntilRegex(_user$project$LeoParser$multilineParseUntilRegex)))))),
					_1: {ctor: '[]'}
				}
			}));
};
var _user$project$LeoParser$multilineEscapedElmExpression = A2(
	_MikaelMayer$parser$Parser$inContext,
	'expression in multi-line string',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$lazy(
				function (_p454) {
					return _user$project$ParserUtils$trackInfo(
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								function (wsv) {
									var v = wsv(_user$project$Lang$space0);
									return _user$project$Lang$exp_(
										A5(
											_user$project$Lang$EOp,
											_user$project$Lang$space0,
											_user$project$Lang$space1,
											A3(_user$project$Info$withInfo, _user$project$Lang$ToStrExceptStr, v.start, v.start),
											{
												ctor: '::',
												_0: _user$project$Lang$Expr(v),
												_1: {ctor: '[]'}
											},
											_user$project$Lang$space0));
								}),
							_user$project$LeoParser$addSelections(_user$project$LeoParser$variableExpression)));
				}),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$lazy(
					function (_p455) {
						return _user$project$LeoParser$multilineGenericLetBinding;
					}),
				_1: {
					ctor: '::',
					_0: _MikaelMayer$parser$Parser$lazy(
						function (_p456) {
							return _user$project$LangParserUtils$mapExp_(
								_user$project$ParserUtils$trackInfo(
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										_MikaelMayer$parser$Parser$succeed(
											function (wsToExp) {
												var exp = wsToExp(_user$project$Lang$space0);
												return A5(
													_user$project$Lang$EOp,
													_user$project$Lang$space0,
													_user$project$Lang$space1,
													A3(_user$project$Info$withInfo, _user$project$Lang$ToStrExceptStr, exp.start, exp.start),
													{
														ctor: '::',
														_0: _user$project$Lang$Expr(
															A3(
																_user$project$Info$withInfo,
																_user$project$Lang$exp_(
																	A4(
																		_user$project$Lang$EParens,
																		_user$project$Lang$space0,
																		_user$project$Lang$Expr(exp),
																		_user$project$Lang$LeoSyntax,
																		_user$project$Lang$space0)),
																exp.start,
																exp.end)),
														_1: {ctor: '[]'}
													},
													_user$project$Lang$space0);
											}),
										_user$project$LeoParser$tuple)));
						}),
					_1: {ctor: '[]'}
				}
			}
		}));
var _user$project$LeoParser$multilineGenericLetBinding = A2(
	_MikaelMayer$parser$Parser$inContext,
	'let binding within a long string',
	A2(
		_MikaelMayer$parser$Parser$map,
		function (p) {
			return p(_user$project$Lang$space0);
		},
		_user$project$LeoParser$genericLetBinding(
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
					_MikaelMayer$parser$Parser$symbol('\n')),
				_MikaelMayer$parser$Parser$succeed(_user$project$Lang$eEmptyHoleVal0)))));
var _user$project$LeoParser$program = A2(
	_MikaelMayer$parser$Parser$andThen,
	function (declsOpt) {
		return A2(
			_MikaelMayer$parser$Parser$map,
			function (_p457) {
				var _p458 = _p457;
				var _p461 = _p458._0;
				var _p459 = {ctor: '_Tuple2', _0: declsOpt, _1: _p461.val};
				if (_p459._0.ctor === 'Nothing') {
					return _p461.val;
				} else {
					var _p460 = _p459._0._0;
					return _user$project$Lang$Expr(
						A3(
							_user$project$Info$withInfo,
							_user$project$Lang$exp_(
								A5(_user$project$Lang$ELet, _p458._1, _user$project$Lang$Def, _p460.val, _user$project$Lang$space0, _p461.val)),
							_p460.start,
							_p459._1._0.end));
				}
			},
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								})),
						_user$project$ParserUtils$trackInfo(
							_MikaelMayer$parser$Parser$oneOf(
								A2(
									_elm_lang$core$Basics_ops['++'],
									{
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser$inContext,
											'Main expression',
											A3(_user$project$LeoParser$expression, _user$project$LangParserUtils$spaces, 0, _user$project$LangParserUtils$MinIndentSpace)),
										_1: {ctor: '[]'}
									},
									function () {
										var isMainDefined = A2(
											_elm_lang$core$Maybe$withDefault,
											false,
											A2(
												_elm_lang$core$Maybe$andThen,
												function (_p462) {
													var _p463 = _p462;
													var _p464 = _p463.val;
													var letexps = _p464._3;
													return A2(
														_user$project$Utils$mapFirstSuccess,
														function (_p465) {
															var _p466 = _p465;
															return A2(
																_user$project$Utils$mapFirstSuccess,
																function (_p467) {
																	var _p468 = _p467;
																	return A2(
																		_user$project$Utils$mapFirstSuccess,
																		function (i) {
																			return _elm_lang$core$Native_Utils.eq(i, 'main') ? _elm_lang$core$Maybe$Just(true) : _elm_lang$core$Maybe$Nothing;
																		},
																		_user$project$Lang$identifiersListInPat(_p468._2));
																},
																_p466._1);
														},
														letexps);
												},
												declsOpt));
										return isMainDefined ? {
											ctor: '::',
											_0: _user$project$LeoParser$implicitMain,
											_1: {ctor: '[]'}
										} : {ctor: '[]'};
									}())))),
					_user$project$LangParserUtils$spaces),
				_MikaelMayer$parser$Parser$end));
	},
	_user$project$ParserUtils$optional(
		_user$project$ParserUtils$trackInfo(
			_user$project$LeoParser$declarations(0))));
var _user$project$LeoParser$_p469 = function () {
	var _p470 = A2(_MikaelMayer$parser$Parser$run, _user$project$LeoParser$program, _user$project$PreludeGenerated$preludeLeo);
	if (_p470.ctor === 'Ok') {
		return {
			ctor: '_Tuple2',
			_0: _elm_lang$core$Maybe$Nothing,
			_1: A2(_user$project$LeoParser$freshenClean, 1, _p470._0)
		};
	} else {
		var msg = _user$project$ParserUtils$showError(_p470._0);
		var _p471 = A2(_MikaelMayer$parser$Parser$run, _user$project$LeoParser$program, '0');
		if (_p471.ctor === 'Ok') {
			return {
				ctor: '_Tuple2',
				_0: _elm_lang$core$Maybe$Just(msg),
				_1: A2(_user$project$LeoParser$freshenClean, 1, _p471._0)
			};
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'LeoParser',
				{
					start: {line: 2813, column: 7},
					end: {line: 2817, column: 79}
				},
				_p471)(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'LeoParser: \"0\" failed to parse?',
					_user$project$ParserUtils$showError(_p471._0)));
		}
	}
}();
var _user$project$LeoParser$preludeNotParsed = _user$project$LeoParser$_p469._0;
var _user$project$LeoParser$prelude = _user$project$LeoParser$_p469._1._0;
var _user$project$LeoParser$initK = _user$project$LeoParser$_p469._1._1;
var _user$project$LeoParser$isPreludeLocId = function (k) {
	return _elm_lang$core$Native_Utils.cmp(k, _user$project$LeoParser$initK) < 0;
};
var _user$project$LeoParser$isPreludeLoc = function (_p473) {
	var _p474 = _p473;
	return _user$project$LeoParser$isPreludeLocId(_p474._0);
};
var _user$project$LeoParser$isPreludeEId = function (k) {
	return _elm_lang$core$Native_Utils.cmp(k, _user$project$LeoParser$initK) < 0;
};
var _user$project$LeoParser$isProgramEId = function (eid) {
	return _user$project$LeoParser$isActualEId(eid) && (!_user$project$LeoParser$isPreludeEId(eid));
};
var _user$project$LeoParser$duplicateAndAllIds = function (exp) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (id, _p475) {
				var _p476 = _p475;
				var _p478 = _p476._1;
				var _p477 = _p476._0;
				return (_elm_lang$core$Native_Utils.cmp(id, _user$project$LeoParser$initK) > -1) ? (A2(_elm_lang$core$Set$member, id, _p478) ? {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Set$insert, id, _p477),
					_1: _p478
				} : {
					ctor: '_Tuple2',
					_0: _p477,
					_1: A2(_elm_lang$core$Set$insert, id, _p478)
				}) : {ctor: '_Tuple2', _0: _p477, _1: _p478};
			}),
		{ctor: '_Tuple2', _0: _elm_lang$core$Set$empty, _1: _elm_lang$core$Set$empty},
		_user$project$LeoParser$allIdsRaw(exp));
};
var _user$project$LeoParser$freshen = function (e) {
	var _p479 = _user$project$LeoParser$duplicateAndAllIds(e);
	var duplicateIds = _p479._0;
	var allIds = _p479._1;
	var idsToPreserve = A2(_elm_lang$core$Set$diff, allIds, duplicateIds);
	var startK = A2(
		_user$project$Utils$fromJust_,
		'freshen',
		_elm_lang$core$List$maximum(
			{
				ctor: '::',
				_0: _user$project$LeoParser$initK,
				_1: _elm_lang$core$Set$toList(allIds)
			})) + 1;
	var _p480 = A3(_user$project$LeoParser$freshenPreserving, idsToPreserve, startK, e);
	var result = _p480._0;
	return result;
};
var _user$project$LeoParser$parse = _MikaelMayer$parser$Parser$run(
	A2(_MikaelMayer$parser$Parser$map, _user$project$LeoParser$freshen, _user$project$LeoParser$program));
var _user$project$LeoParser$allIds = function (exp) {
	return _elm_lang$core$Tuple$second(
		_user$project$LeoParser$duplicateAndAllIds(exp));
};
var _user$project$LeoParser$preludeIds = _user$project$LeoParser$allIds(_user$project$LeoParser$prelude);
var _user$project$LeoParser$maxId = function (exp) {
	var ids = _user$project$LeoParser$allIds(exp);
	return A2(
		_user$project$Utils$fromJust_,
		'maxId',
		_elm_lang$core$List$maximum(
			{
				ctor: '::',
				_0: _user$project$LeoParser$initK,
				_1: _elm_lang$core$Set$toList(ids)
			}));
};
var _user$project$LeoParser$preludeSubst = A2(_user$project$LeoParser$substPlusOf_, _elm_lang$core$Dict$empty, _user$project$LeoParser$prelude);
var _user$project$LeoParser$substPlusOf = function (e) {
	return A2(_user$project$LeoParser$substPlusOf_, _user$project$LeoParser$preludeSubst, e);
};
var _user$project$LeoParser$substOf = function (_p481) {
	return A2(
		_elm_lang$core$Dict$map,
		_elm_lang$core$Basics$always(
			function (_) {
				return _.val;
			}),
		_user$project$LeoParser$substPlusOf(_p481));
};
var _user$project$LeoParser$substStrOf = function (_p482) {
	return A2(
		_elm_lang$core$Dict$map,
		_elm_lang$core$Basics$always(_elm_lang$core$Basics$toString),
		_user$project$LeoParser$substOf(_p482));
};

var _user$project$TopLevelExp$fuseTopLevelExp = F2(
	function (tld, rest) {
		return A3(
			_user$project$Info$withInfo,
			tld.val(
				_user$project$Lang$Expr(rest)),
			tld.start,
			tld.end);
	});
var _user$project$TopLevelExp$fuseTopLevelExps = F2(
	function (tlds, rest) {
		return A3(_elm_lang$core$List$foldr, _user$project$TopLevelExp$fuseTopLevelExp, rest, tlds);
	});

var _user$project$LangUnparser$unparseTPat = function (pat) {
	var _p0 = pat.val;
	return A2(_elm_lang$core$Basics_ops['++'], _p0._0.val, _p0._1);
};
var _user$project$LangUnparser$unparseTypeWithUniformWhitespace = function (tipe) {
	var recurse = function (t) {
		return _user$project$LangUnparser$unparseTypeWithUniformWhitespace(t);
	};
	var _p1 = tipe.val.t__;
	switch (_p1.ctor) {
		case 'TNum':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', 'Num');
		case 'TBool':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', 'Bool');
		case 'TString':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', 'String');
		case 'TNull':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', 'Null');
		case 'TList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(List',
					A2(
						_elm_lang$core$Basics_ops['++'],
						recurse(_p1._1),
						A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))));
		case 'TDict':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(Dict',
					A2(
						_elm_lang$core$Basics_ops['++'],
						recurse(_p1._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							recurse(_p1._2),
							A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
		case 'TTuple':
			var _p3 = _p1._1;
			var _p2 = _p1._3;
			if (_p2.ctor === 'Just') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, recurse, _p3)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										recurse(_p2._0),
										A2(_elm_lang$core$Basics_ops['++'], ' ', ']')))))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, recurse, _p3)),
							A2(_elm_lang$core$Basics_ops['++'], ' ', ']'))));
			}
		case 'TRecord':
			return '[internal error] Cannot unparse record type in Langunparser';
		case 'TArrow':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(->',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, recurse, _p1._1)),
						A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))));
		case 'TUnion':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(union',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, recurse, _p1._1)),
						A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))));
		case 'TApp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparseTypeWithUniformWhitespace(_p1._1),
					_elm_lang$core$String$concat(
						A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseTypeWithUniformWhitespace, _p1._2))));
		case 'TVar':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', _p1._1);
		case 'TWildcard':
			return A2(_elm_lang$core$Basics_ops['++'], ' ', '_');
		case 'TForall':
			var sVars = function () {
				var _p4 = _p1._1;
				if ((_p4.ctor === '::') && (_p4._1.ctor === '[]')) {
					return _user$project$LangUnparser$unparseTPat(_p4._0);
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						_user$project$Utils$parens(
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseTPat, _p4)),
								' ')));
				}
			}();
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				_user$project$Utils$parens(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'forall',
						A2(
							_elm_lang$core$Basics_ops['++'],
							sVars,
							A2(
								_elm_lang$core$Basics_ops['++'],
								recurse(_p1._2),
								' ')))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				' (',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparseTypeWithUniformWhitespace(_p1._1),
					')'));
	}
};
var _user$project$LangUnparser$unparseType = function (tipe) {
	var _p5 = tipe.val.t__;
	switch (_p5.ctor) {
		case 'TNum':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, 'Num');
		case 'TBool':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, 'Bool');
		case 'TString':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, 'String');
		case 'TNull':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, 'Null');
		case 'TList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(List',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseType(_p5._1),
						A2(_elm_lang$core$Basics_ops['++'], _p5._2.val, ')'))));
		case 'TDict':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(Dict',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseType(_p5._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparseType(_p5._2),
							A2(_elm_lang$core$Basics_ops['++'], _p5._3.val, ')')))));
		case 'TTuple':
			var _p9 = _p5._4;
			var _p8 = _p5._0;
			var _p7 = _p5._1;
			var _p6 = _p5._3;
			if (_p6.ctor === 'Just') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p8.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseType, _p7)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p5._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseType(_p6._0),
										A2(_elm_lang$core$Basics_ops['++'], _p9.val, ']')))))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p8.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseType, _p7)),
							A2(_elm_lang$core$Basics_ops['++'], _p9.val, ']'))));
			}
		case 'TRecord':
			return 'internal error: cannot unparse TRecord in LangUnparser';
		case 'TArrow':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(->',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseType, _p5._1)),
						A2(_elm_lang$core$Basics_ops['++'], _p5._2.val, ')'))));
		case 'TUnion':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(union',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseType, _p5._1)),
						A2(_elm_lang$core$Basics_ops['++'], _p5._2.val, ')'))));
		case 'TApp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparseType(_p5._1),
					_elm_lang$core$String$concat(
						A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseType, _p5._2))));
		case 'TVar':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, _p5._1);
		case 'TWildcard':
			return A2(_elm_lang$core$Basics_ops['++'], _p5._0.val, '_');
		case 'TForall':
			var _p12 = _p5._3;
			var _p11 = _p5._0;
			var sVars = function () {
				var _p10 = _p5._1;
				if ((_p10.ctor === '::') && (_p10._1.ctor === '[]')) {
					return _user$project$LangUnparser$unparseTPat(_p10._0);
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p11.val,
						_user$project$Utils$parens(
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseTPat, _p10)),
								_p12.val)));
				}
			}();
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p11.val,
				_user$project$Utils$parens(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'forall',
						A2(
							_elm_lang$core$Basics_ops['++'],
							sVars,
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUnparser$unparseType(_p5._2),
								_p12.val)))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p5._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseType(_p5._1),
						A2(_elm_lang$core$Basics_ops['++'], _p5._2.val, ')'))));
	}
};
var _user$project$LangUnparser$unparseWD = function (wd) {
	var strHidden = function (bool) {
		return bool ? ',\"hidden\"' : '';
	};
	var _p13 = wd.val;
	switch (_p13.ctor) {
		case 'NoWidgetDecl':
			return '';
		case 'IntSlider':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'{',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p13._0.val),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p13._1.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(_p13._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								strHidden(_p13._4),
								'}')))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'{',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p13._0.val),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p13._1.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(_p13._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								strHidden(_p13._4),
								'}')))));
	}
};
var _user$project$LangUnparser$unparseWDWithUniformWhitespace = _user$project$LangUnparser$unparseWD;
var _user$project$LangUnparser$escapeQuotes = F2(
	function (quoteChar, string) {
		return A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex(quoteChar),
			function (_p14) {
				return A2(_elm_lang$core$Basics_ops['++'], '\\', quoteChar);
			},
			A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$All,
				_elm_lang$core$Regex$regex(
					_elm_lang$core$Regex$escape('\\')),
				function (_p15) {
					return '\\\\';
				},
				string));
	});
var _user$project$LangUnparser$unparseBaseVal = function (bv) {
	var _p16 = bv;
	switch (_p16.ctor) {
		case 'EBool':
			if (_p16._0 === true) {
				return 'true';
			} else {
				return 'false';
			}
		case 'EString':
			var _p17 = _p16._0;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p17,
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_user$project$LangUnparser$escapeQuotes, _p17, _p16._1),
					_p17));
		default:
			return 'null';
	}
};
var _user$project$LangUnparser$unparseBaseValWithUniformWhitespace = _user$project$LangUnparser$unparseBaseVal;
var _user$project$LangUnparser$unparsePatWithUniformWhitespace = F2(
	function (includeWidgetDecls, pat) {
		var recurse = function (p) {
			return A2(_user$project$LangUnparser$unparsePatWithUniformWhitespace, includeWidgetDecls, p);
		};
		var _p18 = pat.val.p__;
		switch (_p18.ctor) {
			case 'PWildcard':
				return A2(_elm_lang$core$Basics_ops['++'], ' ', '_');
			case 'PVar':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p18._1,
						includeWidgetDecls ? _user$project$LangUnparser$unparseWDWithUniformWhitespace(_p18._2) : ''));
			case 'PList':
				if (_p18._3.ctor === 'Nothing') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, recurse, _p18._1)),
								A2(_elm_lang$core$Basics_ops['++'], ' ', ']'))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, recurse, _p18._1)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										'|',
										A2(
											_elm_lang$core$Basics_ops['++'],
											recurse(_p18._3._0),
											A2(_elm_lang$core$Basics_ops['++'], ' ', ']')))))));
				}
			case 'PRecord':
				return 'internal error, cannot unparse pattern in LangUnparser';
			case 'PConst':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					_user$project$ValUnparser$strNum(_p18._1));
			case 'PBase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					_user$project$LangUnparser$unparseBaseValWithUniformWhitespace(_p18._1));
			case 'PAs':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						recurse(_p18._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								'@',
								recurse(_p18._3)))));
			case 'PParens':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' (',
					A2(
						_elm_lang$core$Basics_ops['++'],
						recurse(_p18._1),
						' )'));
			default:
				return 'internal error, cannot unparse pcolontype in LangUnparser';
		}
	});
var _user$project$LangUnparser$unparseWithUniformWhitespace = F3(
	function (includeWidgetDecls, includeConstAnnotations, exp) {
		var recurse = function (e) {
			return A3(_user$project$LangUnparser$unparseWithUniformWhitespace, includeWidgetDecls, includeConstAnnotations, e);
		};
		var recursePat = function (e) {
			return A2(_user$project$LangUnparser$unparsePatWithUniformWhitespace, includeWidgetDecls, e);
		};
		var recurseDecls = function (_p19) {
			var _p20 = _p19;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				A3(
					_user$project$Lang$foldLeftGroup,
					'',
					_p20._1,
					F3(
						function (acc, group, isRec) {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								acc,
								A2(
									_elm_lang$core$String$join,
									'',
									A2(
										_elm_lang$core$List$map,
										function (_p21) {
											var _p22 = _p21;
											return A2(
												_elm_lang$core$Basics_ops['++'],
												' ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													'(def',
													A2(
														_elm_lang$core$Basics_ops['++'],
														recursePat(_p22._3),
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$LangUnparser$unparseTypeWithUniformWhitespace(_p22._6),
															A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
										},
										group)));
						})),
				A2(
					_elm_lang$core$Basics_ops['++'],
					A3(
						_user$project$Utils$foldLeft,
						'',
						_p20._2,
						F2(
							function (acc, _p23) {
								var _p24 = _p23;
								return A2(
									_elm_lang$core$Basics_ops['++'],
									acc,
									A2(
										_elm_lang$core$Basics_ops['++'],
										' ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											'(typ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												recursePat(_p24._2),
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$LangUnparser$unparseTypeWithUniformWhitespace(_p24._5),
													A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))))));
							})),
					A3(
						_user$project$Lang$foldLeftGroup,
						'',
						_p20._3,
						F3(
							function (acc, group, isRec) {
								var tok = isRec ? 'defrec' : 'def';
								return A2(
									_elm_lang$core$Basics_ops['++'],
									acc,
									A2(
										_elm_lang$core$String$join,
										'',
										A2(
											_elm_lang$core$List$map,
											function (_p25) {
												var _p26 = _p25;
												return A2(
													_elm_lang$core$Basics_ops['++'],
													' ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														'(',
														A2(
															_elm_lang$core$Basics_ops['++'],
															tok,
															A2(
																_elm_lang$core$Basics_ops['++'],
																recursePat(_p26._2),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	recurse(_p26._5),
																	A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))))));
											},
											group)));
							}))));
		};
		var _p27 = _user$project$Lang$unwrapExp(exp);
		switch (_p27.ctor) {
			case 'EBase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					_user$project$LangUnparser$unparseBaseValWithUniformWhitespace(_p27._1));
			case 'EConst':
				var _p28 = _p27._2;
				var b = _p28._1;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(_p27._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							includeConstAnnotations ? b : '',
							includeWidgetDecls ? _user$project$LangUnparser$unparseWDWithUniformWhitespace(_p27._3) : '')));
			case 'EVar':
				return A2(_elm_lang$core$Basics_ops['++'], ' ', _p27._1);
			case 'EFun':
				if ((_p27._1.ctor === '::') && (_p27._1._1.ctor === '[]')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(\\',
							A2(
								_elm_lang$core$Basics_ops['++'],
								recursePat(_p27._1._0),
								A2(
									_elm_lang$core$Basics_ops['++'],
									recurse(_p27._2),
									A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(\\(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, recursePat, _p27._1)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									')',
									A2(
										_elm_lang$core$Basics_ops['++'],
										recurse(_p27._2),
										A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))))));
				}
			case 'EApp':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							recurse(_p27._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, recurse, _p27._2)),
								A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
			case 'EList':
				if (_p27._3.ctor === 'Nothing') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(
										_elm_lang$core$List$map,
										function (_p29) {
											return recurse(
												_elm_lang$core$Tuple$second(_p29));
										},
										_p27._1)),
								A2(_elm_lang$core$Basics_ops['++'], ' ', ']'))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(
										_elm_lang$core$List$map,
										function (_p30) {
											return recurse(
												_elm_lang$core$Tuple$second(_p30));
										},
										_p27._1)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										'|',
										A2(
											_elm_lang$core$Basics_ops['++'],
											recurse(_p27._3._0),
											A2(_elm_lang$core$Basics_ops['++'], ' ', ']')))))));
				}
			case 'ERecord':
				return '[Internal error] Cannot unparse records in FastParse';
			case 'ESelect':
				return '[Internal error] Cannot unparse records in FastParse';
			case 'EOp':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$ValUnparser$strOp(_p27._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, recurse, _p27._3)),
								A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
			case 'EIf':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(if',
						A2(
							_elm_lang$core$Basics_ops['++'],
							recurse(_p27._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								recurse(_p27._3),
								A2(
									_elm_lang$core$Basics_ops['++'],
									recurse(_p27._5),
									A2(_elm_lang$core$Basics_ops['++'], ' ', ')'))))));
			case 'ELet':
				if (_p27._1.ctor === 'Let') {
					if (((((((_p27._2._1.ctor === '[]') && (_p27._2._2.ctor === '[]')) && (_p27._2._3.ctor === '::')) && (_p27._2._3._0.ctor === '_Tuple2')) && (_p27._2._3._0._1.ctor === '::')) && (_p27._2._3._0._1._1.ctor === '[]')) && (_p27._2._3._1.ctor === '[]')) {
						var tok = _p27._2._3._0._0 ? 'letrec' : 'let';
						return A2(
							_elm_lang$core$Basics_ops['++'],
							' ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								'(',
								A2(
									_elm_lang$core$Basics_ops['++'],
									tok,
									A2(
										_elm_lang$core$Basics_ops['++'],
										recursePat(_p27._2._3._0._1._0._2),
										A2(
											_elm_lang$core$Basics_ops['++'],
											recurse(_p27._2._3._0._1._0._5),
											A2(
												_elm_lang$core$Basics_ops['++'],
												recurse(_p27._4),
												A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))))));
					} else {
						return '[Internal error] do not support more than 1 definition in ELet/Let in LangUnparser';
					}
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						recurseDecls(_p27._2),
						recurse(_p27._4));
				}
			case 'ECase':
				var branchesStr = _elm_lang$core$String$concat(
					A2(
						_elm_lang$core$List$map,
						function (_p31) {
							var _p32 = _p31;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								' ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									'(',
									A2(
										_elm_lang$core$Basics_ops['++'],
										recursePat(_p32._1),
										A2(
											_elm_lang$core$Basics_ops['++'],
											recurse(_p32._2),
											A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
						},
						A2(
							_elm_lang$core$List$map,
							function (_) {
								return _.val;
							},
							_p27._2)));
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(case',
						A2(
							_elm_lang$core$Basics_ops['++'],
							recurse(_p27._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								branchesStr,
								A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))));
			case 'EColonType':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							recurse(_p27._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									':',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseTypeWithUniformWhitespace(_p27._3),
										A2(_elm_lang$core$Basics_ops['++'], ' ', ')')))))));
			case 'EParens':
				return recurse(_p27._1);
			default:
				return ' ??';
		}
	});
var _user$project$LangUnparser$unparsePat = function (pat) {
	var _p33 = pat.val.p__;
	switch (_p33.ctor) {
		case 'PWildcard':
			return A2(_elm_lang$core$Basics_ops['++'], _p33._0.val, '_');
		case 'PVar':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p33._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_p33._1,
					_user$project$LangUnparser$unparseWD(_p33._2)));
		case 'PList':
			if (_p33._3.ctor === 'Nothing') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p33._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePat, _p33._1)),
							A2(_elm_lang$core$Basics_ops['++'], _p33._4.val, ']'))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p33._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePat, _p33._1)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p33._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparsePat(_p33._3._0),
										A2(_elm_lang$core$Basics_ops['++'], _p33._4.val, ']')))))));
			}
		case 'PRecord':
			return 'internal error, cannot unparse pattern in LangUnparser';
		case 'PConst':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p33._0.val,
				_user$project$ValUnparser$strNum(_p33._1));
		case 'PBase':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p33._0.val,
				_user$project$LangUnparser$unparseBaseVal(_p33._1));
		case 'PAs':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p33._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparsePat(_p33._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p33._2.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'@',
							_user$project$LangUnparser$unparsePat(_p33._3)))));
		case 'PParens':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p33._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparsePat(_p33._1),
						A2(_elm_lang$core$Basics_ops['++'], _p33._2.val, ')'))));
		default:
			return 'internal error, cannot unparse pcolontype in LangUnparser';
	}
};
var _user$project$LangUnparser$unparsePatWithIds = function (pat) {
	var pidTag = A2(
		_elm_lang$core$Basics_ops['++'],
		'Â«',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$Basics$toString(pat.val.pid),
			'Â»'));
	var _p34 = pat.val.p__;
	switch (_p34.ctor) {
		case 'PWildcard':
			return A2(_elm_lang$core$Basics_ops['++'], _p34._0.val, '_');
		case 'PVar':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p34._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_p34._1,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseWD(_p34._2),
						pidTag)));
		case 'PList':
			if (_p34._3.ctor === 'Nothing') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p34._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePatWithIds, _p34._1)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p34._4.val,
								A2(_elm_lang$core$Basics_ops['++'], ']', pidTag)))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p34._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePatWithIds, _p34._1)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p34._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparsePatWithIds(_p34._3._0),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p34._4.val,
											A2(_elm_lang$core$Basics_ops['++'], ']', pidTag))))))));
			}
		case 'PConst':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p34._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$ValUnparser$strNum(_p34._1),
					pidTag));
		case 'PRecord':
			return 'internal error, cannot unparse pattern with ids in LangUnparser';
		case 'PBase':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p34._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparseBaseVal(_p34._1),
					pidTag));
		case 'PAs':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p34._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparsePatWithIds(_p34._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						pidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p34._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'@',
								_user$project$LangUnparser$unparsePatWithIds(_p34._3))))));
		case 'PParens':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p34._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						pidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparsePatWithIds(_p34._1),
							A2(_elm_lang$core$Basics_ops['++'], _p34._2.val, ')')))));
		default:
			return 'internal error, cannot unparse pcolontype in LangUnparser';
	}
};
var _user$project$LangUnparser$unparseWithIds = function (e) {
	var eidTag = A2(
		_elm_lang$core$Basics_ops['++'],
		'<',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$Basics$toString(
				_user$project$Lang$expEId(e)),
			'>'));
	var _p35 = _user$project$Lang$unwrapExp(e);
	switch (_p35.ctor) {
		case 'EBase':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUnparser$unparseBaseVal(_p35._1),
					eidTag));
		case 'EConst':
			var _p36 = _p35._2;
			var locId = _p36._0;
			var b = _p36._1;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p35._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						b,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparseWD(_p35._3),
							A2(
								_elm_lang$core$Basics_ops['++'],
								'{',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(locId),
									A2(_elm_lang$core$Basics_ops['++'], '}', eidTag)))))));
		case 'EVar':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(_elm_lang$core$Basics_ops['++'], _p35._1, eidTag));
		case 'EFun':
			if ((_p35._1.ctor === '::') && (_p35._1._1.ctor === '[]')) {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p35._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							eidTag,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'\\',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUnparser$unparsePatWithIds(_p35._1._0),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseWithIds(_p35._2),
										A2(_elm_lang$core$Basics_ops['++'], _p35._3.val, ')')))))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p35._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							eidTag,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'\\(',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$String$concat(
										A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePatWithIds, _p35._1)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										')',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUnparser$unparseWithIds(_p35._2),
											A2(_elm_lang$core$Basics_ops['++'], _p35._3.val, ')'))))))));
			}
		case 'EApp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseWithIds(_p35._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseWithIds, _p35._2)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p35._4.val,
								A2(_elm_lang$core$Basics_ops['++'], ')', eidTag))))));
		case 'EList':
			if (_p35._3.ctor === 'Nothing') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p35._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(
									_elm_lang$core$List$map,
									function (_p37) {
										return _user$project$LangUnparser$unparseWithIds(
											_elm_lang$core$Tuple$second(_p37));
									},
									_p35._1)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p35._4.val,
								A2(_elm_lang$core$Basics_ops['++'], ']', eidTag)))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p35._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(
									_elm_lang$core$List$map,
									function (_p38) {
										return _user$project$LangUnparser$unparseWithIds(
											_elm_lang$core$Tuple$second(_p38));
									},
									_p35._1)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p35._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseWithIds(_p35._3._0),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p35._4.val,
											A2(_elm_lang$core$Basics_ops['++'], ']', eidTag))))))));
			}
		case 'ERecord':
			return 'internal error, cannot unparse record in LangUnparser';
		case 'ESelect':
			return 'internal error, cannot unparse select in LangUnparser';
		case 'EOp':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						eidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$ValUnparser$strOp(_p35._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparseWithIds, _p35._3)),
								A2(_elm_lang$core$Basics_ops['++'], _p35._4.val, ')'))))));
		case 'EIf':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						eidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'if',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUnparser$unparseWithIds(_p35._1),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUnparser$unparseWithIds(_p35._3),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseWithIds(_p35._5),
										A2(_elm_lang$core$Basics_ops['++'], _p35._6.val, ')'))))))));
		case 'ELet':
			if (_p35._1.ctor === 'Let') {
				if (((((((_p35._2._1.ctor === '[]') && (_p35._2._2.ctor === '[]')) && (_p35._2._3.ctor === '::')) && (_p35._2._3._0.ctor === '_Tuple2')) && (_p35._2._3._0._1.ctor === '::')) && (_p35._2._3._0._1._1.ctor === '[]')) && (_p35._2._3._1.ctor === '[]')) {
					var tok = _p35._2._3._0._0 ? 'letrec' : 'let';
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p35._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								eidTag,
								A2(
									_elm_lang$core$Basics_ops['++'],
									tok,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparsePatWithIds(_p35._2._3._0._1._0._2),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUnparser$unparseWithIds(_p35._2._3._0._1._0._5),
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$LangUnparser$unparseWithIds(_p35._4),
												A2(_elm_lang$core$Basics_ops['++'], _p35._3.val, ')'))))))));
				} else {
					return A2(_elm_lang$core$Basics_ops['++'], eidTag, 'internal error, cannot unparse ELet/Let in LangUnparser if more than one exp declaration');
				}
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					eidTag,
					A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_user$project$LangUnparser$unparseDecls, true, _p35._2),
						_user$project$LangUnparser$unparseWithIds(_p35._4)));
			}
		case 'ECase':
			var branchesStr = _elm_lang$core$String$concat(
				A2(
					_elm_lang$core$List$map,
					function (_p39) {
						var _p40 = _p39;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p40._0.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'(',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUnparser$unparsePatWithIds(_p40._1),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseWithIds(_p40._2),
										A2(_elm_lang$core$Basics_ops['++'], _p40._3.val, ')')))));
					},
					A2(
						_elm_lang$core$List$map,
						function (_) {
							return _.val;
						},
						_p35._2)));
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						eidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'case',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUnparser$unparseWithIds(_p35._1),
								A2(
									_elm_lang$core$Basics_ops['++'],
									branchesStr,
									A2(_elm_lang$core$Basics_ops['++'], _p35._3.val, ')')))))));
		case 'EColonType':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseWithIds(_p35._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p35._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								':',
								A2(
									_elm_lang$core$Basics_ops['++'],
									eidTag,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseType(_p35._3),
										A2(_elm_lang$core$Basics_ops['++'], _p35._4.val, ')'))))))));
		case 'EParens':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						eidTag,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparseWithIds(_p35._1),
							A2(_elm_lang$core$Basics_ops['++'], _p35._3.val, ')')))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p35._0.val,
				A2(_elm_lang$core$Basics_ops['++'], '??', eidTag));
	}
};
var _user$project$LangUnparser$unparseDecls = F2(
	function (withIds, _p41) {
		var _p42 = _p41;
		var patu = withIds ? _user$project$LangUnparser$unparsePatWithIds : _user$project$LangUnparser$unparsePat;
		var typu = withIds ? _user$project$LangUnparser$unparseType : _user$project$LangUnparser$unparseType;
		var expu = withIds ? _user$project$LangUnparser$unparseWithIds : _user$project$LangUnparser$unparse_;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A3(
				_user$project$Lang$foldLeftGroup,
				'',
				_p42._1,
				F3(
					function (acc, group, isRec) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							acc,
							A2(
								_elm_lang$core$String$join,
								'',
								A2(
									_elm_lang$core$List$map,
									function (_p43) {
										var _p44 = _p43;
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_p44._1.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'(def',
												A2(
													_elm_lang$core$Basics_ops['++'],
													patu(_p44._3),
													A2(
														_elm_lang$core$Basics_ops['++'],
														typu(_p44._6),
														A2(_elm_lang$core$Basics_ops['++'], _p44._5.val, ')')))));
									},
									group)));
					})),
			A2(
				_elm_lang$core$Basics_ops['++'],
				A3(
					_user$project$Utils$foldLeft,
					'',
					_p42._2,
					F2(
						function (acc, _p45) {
							var _p46 = _p45;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								acc,
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p46._1.val,
									A2(
										_elm_lang$core$Basics_ops['++'],
										'(typ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											patu(_p46._2),
											A2(
												_elm_lang$core$Basics_ops['++'],
												typu(_p46._5),
												A2(_elm_lang$core$Basics_ops['++'], _p46._4.val, ')'))))));
						})),
				A3(
					_user$project$Lang$foldLeftGroup,
					'',
					_p42._3,
					F3(
						function (acc, group, isRec) {
							var tok = isRec ? 'defrec' : 'def';
							return A2(
								_elm_lang$core$Basics_ops['++'],
								acc,
								A2(
									_elm_lang$core$String$join,
									'',
									A2(
										_elm_lang$core$List$map,
										function (_p47) {
											var _p48 = _p47;
											return A2(
												_elm_lang$core$Basics_ops['++'],
												_p48._1.val,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'(',
													A2(
														_elm_lang$core$Basics_ops['++'],
														tok,
														A2(
															_elm_lang$core$Basics_ops['++'],
															patu(_p48._2),
															A2(
																_elm_lang$core$Basics_ops['++'],
																expu(_p48._5),
																A2(_elm_lang$core$Basics_ops['++'], _p48._4.val, ')'))))));
										},
										group)));
						}))));
	});
var _user$project$LangUnparser$unparse_ = function (e) {
	unparse_:
	while (true) {
		var _p49 = _user$project$Lang$unwrapExp(e);
		switch (_p49.ctor) {
			case 'EBase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					_user$project$LangUnparser$unparseBaseVal(_p49._1));
			case 'EConst':
				var _p50 = _p49._2;
				var b = _p50._1;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(_p49._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							b,
							_user$project$LangUnparser$unparseWD(_p49._3))));
			case 'EVar':
				return A2(_elm_lang$core$Basics_ops['++'], _p49._0.val, _p49._1);
			case 'EFun':
				if ((_p49._1.ctor === '::') && (_p49._1._1.ctor === '[]')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p49._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(\\',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUnparser$unparsePat(_p49._1._0),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUnparser$unparse_(_p49._2),
									A2(_elm_lang$core$Basics_ops['++'], _p49._3.val, ')')))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p49._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(\\(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparsePat, _p49._1)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									')',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparse_(_p49._2),
										A2(_elm_lang$core$Basics_ops['++'], _p49._3.val, ')'))))));
				}
			case 'EApp':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparse_(_p49._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparse_, _p49._2)),
								A2(_elm_lang$core$Basics_ops['++'], _p49._4.val, ')')))));
			case 'EList':
				if (_p49._3.ctor === 'Nothing') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p49._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(
										_elm_lang$core$List$map,
										function (_p51) {
											return _user$project$LangUnparser$unparse_(
												_elm_lang$core$Tuple$second(_p51));
										},
										_p49._1)),
								A2(_elm_lang$core$Basics_ops['++'], _p49._4.val, ']'))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p49._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(
										_elm_lang$core$List$map,
										function (_p52) {
											return _user$project$LangUnparser$unparse_(
												_elm_lang$core$Tuple$second(_p52));
										},
										_p49._1)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p49._2.val,
									A2(
										_elm_lang$core$Basics_ops['++'],
										'|',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUnparser$unparse_(_p49._3._0),
											A2(_elm_lang$core$Basics_ops['++'], _p49._4.val, ']')))))));
				}
			case 'ERecord':
				return 'internal error, cannot unparse record in LangUnparser';
			case 'ESelect':
				return 'internal error, cannot unparse recordselect in LangUnparser';
			case 'EOp':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$ValUnparser$strOp(_p49._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LangUnparser$unparse_, _p49._3)),
								A2(_elm_lang$core$Basics_ops['++'], _p49._4.val, ')')))));
			case 'EIf':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(if',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparse_(_p49._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUnparser$unparse_(_p49._3),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUnparser$unparse_(_p49._5),
									A2(_elm_lang$core$Basics_ops['++'], _p49._6.val, ')'))))));
			case 'ELet':
				if (_p49._1.ctor === 'Let') {
					if (((((((_p49._2._1.ctor === '[]') && (_p49._2._2.ctor === '[]')) && (_p49._2._3.ctor === '::')) && (_p49._2._3._0.ctor === '_Tuple2')) && (_p49._2._3._0._1.ctor === '::')) && (_p49._2._3._0._1._1.ctor === '[]')) && (_p49._2._3._1.ctor === '[]')) {
						var _p54 = _p49._2._3._0._1._0._2;
						var _p53 = _p54.val.p__;
						if ((_p53.ctor === 'PVar') && (_p53._1 === '_IMPLICIT_MAIN')) {
							return '';
						} else {
							var tok = _p49._2._3._0._0 ? 'letrec' : 'let';
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p49._0.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'(',
									A2(
										_elm_lang$core$Basics_ops['++'],
										tok,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p49._2._3._0._1._0._1.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$LangUnparser$unparsePat(_p54),
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$LangUnparser$unparse_(_p49._2._3._0._1._0._5),
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUnparser$unparse_(_p49._4),
														A2(_elm_lang$core$Basics_ops['++'], _p49._3.val, ')'))))))));
						}
					} else {
						return 'internal error, cannot unparse ELet/Let in LangUnparser if more than one exp declaration';
					}
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_user$project$LangUnparser$unparseDecls, false, _p49._2),
						_user$project$LangUnparser$unparse_(_p49._4));
				}
			case 'ECase':
				var branchesStr = _elm_lang$core$String$concat(
					A2(
						_elm_lang$core$List$map,
						function (_p55) {
							var _p56 = _p55;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p56._0.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'(',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparsePat(_p56._1),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUnparser$unparse_(_p56._2),
											A2(_elm_lang$core$Basics_ops['++'], _p56._3.val, ')')))));
						},
						A2(
							_elm_lang$core$List$map,
							function (_) {
								return _.val;
							},
							_p49._2)));
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(case',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparse_(_p49._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								branchesStr,
								A2(_elm_lang$core$Basics_ops['++'], _p49._3.val, ')')))));
			case 'EColonType':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p49._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUnparser$unparse_(_p49._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p49._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									':',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUnparser$unparseType(_p49._3),
										A2(_elm_lang$core$Basics_ops['++'], _p49._4.val, ')')))))));
			case 'EParens':
				var _v27 = _p49._1;
				e = _v27;
				continue unparse_;
			default:
				return A2(_elm_lang$core$Basics_ops['++'], _p49._0.val, '??');
		}
	}
};
var _user$project$LangUnparser$unparse = function (e) {
	return _user$project$LangUnparser$unparse_(e);
};
var _user$project$LangUnparser$patsEquivalent = F2(
	function (pat1, pat2) {
		return _elm_lang$core$Native_Utils.eq(
			A2(_user$project$LangUnparser$unparsePatWithUniformWhitespace, true, pat1),
			A2(_user$project$LangUnparser$unparsePatWithUniformWhitespace, true, pat2));
	});
var _user$project$LangUnparser$expsEquivalent = F2(
	function (exp1, exp2) {
		return _elm_lang$core$Native_Utils.eq(
			A3(_user$project$LangUnparser$unparseWithUniformWhitespace, true, true, exp1),
			A3(_user$project$LangUnparser$unparseWithUniformWhitespace, true, true, exp2));
	});
var _user$project$LangUnparser$bumpCol = F2(
	function (n, pos) {
		return _elm_lang$core$Native_Utils.update(
			pos,
			{col: n + pos.col});
	});
var _user$project$LangUnparser$incCol = _user$project$LangUnparser$bumpCol(1);
var _user$project$LangUnparser$debugLog = _user$project$Config$debugLog(_user$project$Config$debugParser);

var _user$project$FastParser$substPlusOf_ = F2(
	function (substPlus, exp) {
		var accumulator = F2(
			function (_p0, s) {
				var _p1 = _p0;
				var _p6 = _p1._0;
				var _p2 = _user$project$Lang$unwrapExp(
					_user$project$Lang$Expr(_p6));
				if ((_p2.ctor === 'EConst') && (_p2._2.ctor === '_Tuple3')) {
					var _p5 = _p2._1;
					var _p4 = _p2._2._0;
					var _p3 = A2(_elm_lang$core$Dict$get, _p4, s);
					if (_p3.ctor === 'Nothing') {
						return A3(
							_elm_lang$core$Dict$insert,
							_p4,
							_elm_lang$core$Native_Utils.update(
								_p6,
								{val: _p5}),
							s);
					} else {
						return _elm_lang$core$Native_Utils.eq(_p5, _p3._0.val) ? s : _elm_lang$core$Native_Utils.crash(
							'FastParser',
							{
								start: {line: 1578, column: 15},
								end: {line: 1578, column: 26}
							})(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'substPlusOf_ Duplicate locId ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(_p4),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' with differing value ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(_p5),
											A2(
												_elm_lang$core$Basics_ops['++'],
												'\n',
												_user$project$LangUnparser$unparseWithIds(exp)))))));
					}
				} else {
					return s;
				}
			});
		return A3(_user$project$Lang$foldExp, accumulator, substPlus, exp);
	});
var _user$project$FastParser$recordIdentifiers = function (_p7) {
	recordIdentifiers:
	while (true) {
		var _p8 = _p7;
		var _p18 = _p8._0;
		var _p17 = _p8._1._0;
		var exp = _user$project$Lang$Expr(_p17);
		var ret = function (e__) {
			return _user$project$Lang$Expr(
				A3(
					_user$project$Info$WithInfo,
					A2(
						_user$project$Lang$makeExp_,
						e__,
						_user$project$Lang$expEId(exp)),
					_p17.start,
					_p17.end));
		};
		var _p9 = {
			ctor: '_Tuple2',
			_0: _p18.val.p__,
			_1: _user$project$Lang$unwrapExp(exp)
		};
		_v4_4:
		do {
			_v4_3:
			do {
				switch (_p9._0.ctor) {
					case 'PVar':
						switch (_p9._1.ctor) {
							case 'EConst':
								if (_p9._1._2.ctor === '_Tuple3') {
									return ret(
										A4(
											_user$project$Lang$EConst,
											_p9._1._0,
											_p9._1._1,
											{ctor: '_Tuple3', _0: _p9._1._2._0, _1: _p9._1._2._1, _2: _p9._0._1},
											_p9._1._3));
								} else {
									break _v4_4;
								}
							case 'EColonType':
								break _v4_3;
							default:
								break _v4_4;
						}
					case 'PList':
						switch (_p9._1.ctor) {
							case 'EList':
								var _p16 = _p9._1._4;
								var _p15 = _p9._1._2;
								var _p14 = _p9._1._0;
								var _p13 = _p9._1._3;
								var _p12 = _p9._1._1;
								var _p10 = A2(
									_user$project$Utils$maybeZip,
									_p9._0._1,
									_user$project$Utils$listValues(_p12));
								if (_p10.ctor === 'Nothing') {
									return ret(
										A5(_user$project$Lang$EList, _p14, _p12, _p15, _p13, _p16));
								} else {
									var es_ = A2(_elm_lang$core$List$map, _user$project$FastParser$recordIdentifiers, _p10._0);
									var me_ = function () {
										var _p11 = {ctor: '_Tuple2', _0: _p9._0._3, _1: _p13};
										if (((_p11.ctor === '_Tuple2') && (_p11._0.ctor === 'Just')) && (_p11._1.ctor === 'Just')) {
											return _elm_lang$core$Maybe$Just(
												_user$project$FastParser$recordIdentifiers(
													{ctor: '_Tuple2', _0: _p11._0._0, _1: _p11._1._0}));
										} else {
											return _p13;
										}
									}();
									return ret(
										A5(
											_user$project$Lang$EList,
											_p14,
											A2(_user$project$Utils$listValuesMake, _p12, es_),
											_p15,
											me_,
											_p16));
								}
							case 'EColonType':
								break _v4_3;
							default:
								break _v4_4;
						}
					case 'PAs':
						var _v7 = {
							ctor: '_Tuple2',
							_0: _p9._0._1,
							_1: _user$project$FastParser$recordIdentifiers(
								{ctor: '_Tuple2', _0: _p9._0._3, _1: exp})
						};
						_p7 = _v7;
						continue recordIdentifiers;
					default:
						if (_p9._1.ctor === 'EColonType') {
							break _v4_3;
						} else {
							break _v4_4;
						}
				}
			} while(false);
			return ret(
				A5(
					_user$project$Lang$EColonType,
					_p9._1._0,
					_user$project$FastParser$recordIdentifiers(
						{ctor: '_Tuple2', _0: _p18, _1: _p9._1._1}),
					_p9._1._2,
					_p9._1._3,
					_p9._1._4));
		} while(false);
		return ret(_p9._1);
	}
};
var _user$project$FastParser$allIdsRaw = function (exp) {
	var pidsInPat = function (pat) {
		return A2(
			_elm_lang$core$List$map,
			function (_p19) {
				return function (_) {
					return _.pid;
				}(
					function (_) {
						return _.val;
					}(_p19));
			},
			_user$project$Lang$flattenPatTree(pat));
	};
	var pidsInPats = function (pats) {
		return A2(_elm_lang$core$List$concatMap, pidsInPat, pats);
	};
	var pidsInDecls = function (_p20) {
		var _p21 = _p20;
		return pidsInPats(
			A2(
				_elm_lang$core$Basics_ops['++'],
				A2(
					_elm_lang$core$List$map,
					function (_p22) {
						var _p23 = _p22;
						return _p23._3;
					},
					_user$project$Lang$elemsOf(_p21._1)),
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$List$map,
						function (_p24) {
							var _p25 = _p24;
							return _p25._2;
						},
						_p21._2),
					A2(
						_elm_lang$core$List$map,
						function (_p26) {
							var _p27 = _p26;
							return _p27._2;
						},
						_user$project$Lang$elemsOf(_p21._3)))));
	};
	var flattened = _user$project$Lang$flattenExpTree(exp);
	var eids = A2(_elm_lang$core$List$map, _user$project$Lang$expEId, flattened);
	var otherIds = A2(
		_elm_lang$core$List$concatMap,
		function (exp) {
			var _p28 = _user$project$Lang$unwrapExp(exp);
			_v12_5:
			do {
				switch (_p28.ctor) {
					case 'EConst':
						if (_p28._2.ctor === '_Tuple3') {
							return {
								ctor: '::',
								_0: _p28._2._0,
								_1: {ctor: '[]'}
							};
						} else {
							break _v12_5;
						}
					case 'EFun':
						return pidsInPats(_p28._1);
					case 'ECase':
						return pidsInPats(
							_user$project$Lang$branchPats(_p28._2));
					case 'ELet':
						return pidsInDecls(_p28._2);
					case 'ERecord':
						return pidsInDecls(_p28._2);
					default:
						break _v12_5;
				}
			} while(false);
			return {ctor: '[]'};
		},
		flattened);
	return A2(_elm_lang$core$Basics_ops['++'], eids, otherIds);
};
var _user$project$FastParser$freshenPatPreserving = F2(
	function (idsToPreserve, _p29) {
		var _p30 = _p29;
		var getId = function (k) {
			getId:
			while (true) {
				if (A2(_elm_lang$core$Set$member, k, idsToPreserve)) {
					var _v14 = k + 1;
					k = _v14;
					continue getId;
				} else {
					return k;
				}
			}
		};
		var assignIds = F2(
			function (pat, k) {
				if (A2(_elm_lang$core$Set$member, pat.val.pid, idsToPreserve)) {
					return {ctor: '_Tuple2', _0: pat, _1: k};
				} else {
					var pid = getId(k);
					return {
						ctor: '_Tuple2',
						_0: A2(_user$project$Lang$setPId, pid, pat),
						_1: pid + 1
					};
				}
			});
		return A3(_user$project$Lang$mapFoldPatTopDown, assignIds, _p30._1, _p30._0);
	});
var _user$project$FastParser$freshenPatsPreserving = F3(
	function (idsToPreserve, initK, pats) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (pat, _p31) {
					var _p32 = _p31;
					var _p33 = A2(
						_user$project$FastParser$freshenPatPreserving,
						idsToPreserve,
						{ctor: '_Tuple2', _0: pat, _1: _p32._1});
					var newPat = _p33._0;
					var newK = _p33._1;
					return {
						ctor: '_Tuple2',
						_0: A2(
							_elm_lang$core$Basics_ops['++'],
							_p32._0,
							{
								ctor: '::',
								_0: newPat,
								_1: {ctor: '[]'}
							}),
						_1: newK
					};
				}),
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: initK
			},
			pats);
	});
var _user$project$FastParser$freshenPreserving = F3(
	function (idsToPreserve, initK, e) {
		var getId = function (k) {
			getId:
			while (true) {
				if (A2(_elm_lang$core$Set$member, k, idsToPreserve)) {
					var _v16 = k + 1;
					k = _v16;
					continue getId;
				} else {
					return k;
				}
			}
		};
		var assignIds = F2(
			function (_p34, k) {
				var _p35 = _p34;
				var _p64 = _p35._0;
				var exp = _user$project$Lang$Expr(_p64);
				var e__ = _user$project$Lang$unwrapExp(exp);
				var _p36 = function () {
					var _p37 = e__;
					_v18_4:
					do {
						switch (_p37.ctor) {
							case 'EConst':
								if (_p37._2.ctor === '_Tuple3') {
									if (A2(_elm_lang$core$Set$member, _p37._2._0, idsToPreserve)) {
										return {ctor: '_Tuple2', _0: e__, _1: k};
									} else {
										var locId = getId(k);
										return {
											ctor: '_Tuple2',
											_0: A4(
												_user$project$Lang$EConst,
												_p37._0,
												_p37._1,
												{ctor: '_Tuple3', _0: locId, _1: _p37._2._1, _2: _p37._2._2},
												_p37._3),
											_1: locId + 1
										};
									}
								} else {
									break _v18_4;
								}
							case 'ELet':
								var _p57 = _p37._2._1;
								var _p56 = _p37._2._3;
								var _p38 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: k
									},
									_user$project$Lang$elemsOf(_p57),
									F2(
										function (_p40, _p39) {
											var _p41 = _p40;
											var _p42 = _p39;
											var _p43 = A2(
												_user$project$FastParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p42._3, _1: _p41._1});
											var newPat = _p43._0;
											var newK = _p43._1;
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A7(_user$project$Lang$LetType, _p42._0, _p42._1, _p42._2, newPat, _p42._4, _p42._5, _p42._6),
													_1: _p41._0
												},
												_1: newK
											};
										}));
								var newRevTpes = _p38._0;
								var newK = _p38._1;
								var _p44 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: newK
									},
									_p37._2._2,
									F2(
										function (_p46, _p45) {
											var _p47 = _p46;
											var _p48 = _p45;
											var _p49 = A2(
												_user$project$FastParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p48._2, _1: _p47._1});
											var newPat = _p49._0;
											var newK = _p49._1;
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A6(_user$project$Lang$LetAnnotation, _p48._0, _p48._1, newPat, _p48._3, _p48._4, _p48._5),
													_1: _p47._0
												},
												_1: newK
											};
										}));
								var newRevAnn = _p44._0;
								var newK2 = _p44._1;
								var _p50 = A3(
									_user$project$Utils$foldLeft,
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: newK2
									},
									_user$project$Lang$elemsOf(_p56),
									F2(
										function (_p52, _p51) {
											var _p53 = _p52;
											var _p54 = _p51;
											var _p55 = A2(
												_user$project$FastParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: _p54._2, _1: _p53._1});
											var newP = _p55._0;
											var newK = _p55._1;
											var newE1 = _user$project$FastParser$recordIdentifiers(
												{ctor: '_Tuple2', _0: newP, _1: _p54._5});
											return {
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: A6(_user$project$Lang$LetExp, _p54._0, _p54._1, newP, _p54._3, _p54._4, newE1),
													_1: _p53._0
												},
												_1: newK
											};
										}));
								var newRevExps = _p50._0;
								var newK3 = _p50._1;
								return {
									ctor: '_Tuple2',
									_0: A5(
										_user$project$Lang$ELet,
										_p37._0,
										_p37._1,
										A4(
											_user$project$Lang$Declarations,
											_p37._2._0,
											A2(
												_user$project$Lang$regroup,
												_p57,
												_elm_lang$core$List$reverse(newRevTpes)),
											_elm_lang$core$List$reverse(newRevAnn),
											A2(
												_user$project$Lang$regroup,
												_p56,
												_elm_lang$core$List$reverse(newRevExps))),
										_p37._3,
										_p37._4),
									_1: newK3
								};
							case 'EFun':
								var _p58 = A3(_user$project$FastParser$freshenPatsPreserving, idsToPreserve, k, _p37._1);
								var newPats = _p58._0;
								var newK = _p58._1;
								return {
									ctor: '_Tuple2',
									_0: A4(_user$project$Lang$EFun, _p37._0, newPats, _p37._2, _p37._3),
									_1: newK
								};
							case 'ECase':
								var _p59 = A3(
									_elm_lang$core$List$foldl,
									F2(
										function (branch, _p60) {
											var _p61 = _p60;
											var _p62 = branch.val;
											var bws1 = _p62._0;
											var pat = _p62._1;
											var ei = _p62._2;
											var bws2 = _p62._3;
											var _p63 = A2(
												_user$project$FastParser$freshenPatPreserving,
												idsToPreserve,
												{ctor: '_Tuple2', _0: pat, _1: _p61._1});
											var newPi = _p63._0;
											var newK = _p63._1;
											return {
												ctor: '_Tuple2',
												_0: A2(
													_elm_lang$core$Basics_ops['++'],
													_p61._0,
													{
														ctor: '::',
														_0: _elm_lang$core$Native_Utils.update(
															branch,
															{
																val: A4(_user$project$Lang$Branch_, bws1, newPi, ei, bws2)
															}),
														_1: {ctor: '[]'}
													}),
												_1: newK
											};
										}),
									{
										ctor: '_Tuple2',
										_0: {ctor: '[]'},
										_1: k
									},
									_p37._2);
								var newBranches = _p59._0;
								var newK = _p59._1;
								return {
									ctor: '_Tuple2',
									_0: A4(_user$project$Lang$ECase, _p37._0, _p37._1, newBranches, _p37._3),
									_1: newK
								};
							default:
								break _v18_4;
						}
					} while(false);
					return {ctor: '_Tuple2', _0: e__, _1: k};
				}();
				var newE__ = _p36._0;
				var newK = _p36._1;
				if (A2(
					_elm_lang$core$Set$member,
					_user$project$Lang$expEId(exp),
					idsToPreserve)) {
					return {
						ctor: '_Tuple2',
						_0: A2(_user$project$Lang$replaceE__, exp, newE__),
						_1: newK
					};
				} else {
					var eid = getId(newK);
					return {
						ctor: '_Tuple2',
						_0: _user$project$Lang$Expr(
							A3(
								_user$project$Info$WithInfo,
								A2(_user$project$Lang$makeExp_, newE__, eid),
								_p64.start,
								_p64.end)),
						_1: eid + 1
					};
				}
			});
		return A3(_user$project$Lang$mapFoldExp, assignIds, initK, e);
	});
var _user$project$FastParser$freshenClean = F2(
	function (initK, e) {
		return A3(_user$project$FastParser$freshenPreserving, _elm_lang$core$Set$empty, initK, e);
	});
var _user$project$FastParser$clearAllIds = function (root) {
	return A2(_user$project$Lang$mapExp, _user$project$Lang$clearNodeIds, root);
};
var _user$project$FastParser$isActualEId = function (eid) {
	return _elm_lang$core$Native_Utils.cmp(eid, 0) > -1;
};
var _user$project$FastParser$_p65 = {
	ctor: '_Tuple2',
	_0: _user$project$Lang$withDummyExpInfo(
		A4(_user$project$Lang$EConst, _user$project$Lang$space0, 0, _user$project$Lang$dummyLoc, _user$project$Lang$noWidgetDecl)),
	_1: 1
};
var _user$project$FastParser$prelude = _user$project$FastParser$_p65._0;
var _user$project$FastParser$initK = _user$project$FastParser$_p65._1;
var _user$project$FastParser$isPreludeLocId = function (k) {
	return _elm_lang$core$Native_Utils.cmp(k, _user$project$FastParser$initK) < 0;
};
var _user$project$FastParser$isPreludeLoc = function (_p66) {
	var _p67 = _p66;
	return _user$project$FastParser$isPreludeLocId(_p67._0);
};
var _user$project$FastParser$isPreludeEId = function (k) {
	return _elm_lang$core$Native_Utils.cmp(k, _user$project$FastParser$initK) < 0;
};
var _user$project$FastParser$isProgramEId = function (eid) {
	return _user$project$FastParser$isActualEId(eid) && (!_user$project$FastParser$isPreludeEId(eid));
};
var _user$project$FastParser$duplicateAndAllIds = function (exp) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (id, _p68) {
				var _p69 = _p68;
				var _p71 = _p69._1;
				var _p70 = _p69._0;
				return (_elm_lang$core$Native_Utils.cmp(id, _user$project$FastParser$initK) > -1) ? (A2(_elm_lang$core$Set$member, id, _p71) ? {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Set$insert, id, _p70),
					_1: _p71
				} : {
					ctor: '_Tuple2',
					_0: _p70,
					_1: A2(_elm_lang$core$Set$insert, id, _p71)
				}) : {ctor: '_Tuple2', _0: _p70, _1: _p71};
			}),
		{ctor: '_Tuple2', _0: _elm_lang$core$Set$empty, _1: _elm_lang$core$Set$empty},
		_user$project$FastParser$allIdsRaw(exp));
};
var _user$project$FastParser$freshen = function (e) {
	var _p72 = _user$project$FastParser$duplicateAndAllIds(e);
	var duplicateIds = _p72._0;
	var allIds = _p72._1;
	var idsToPreserve = A2(_elm_lang$core$Set$diff, allIds, duplicateIds);
	var startK = A2(
		_user$project$Utils$fromJust_,
		'freshen',
		_elm_lang$core$List$maximum(
			{
				ctor: '::',
				_0: _user$project$FastParser$initK,
				_1: _elm_lang$core$Set$toList(allIds)
			})) + 1;
	var _p73 = A3(_user$project$FastParser$freshenPreserving, idsToPreserve, startK, e);
	var result = _p73._0;
	return result;
};
var _user$project$FastParser$allIds = function (exp) {
	return _elm_lang$core$Tuple$second(
		_user$project$FastParser$duplicateAndAllIds(exp));
};
var _user$project$FastParser$preludeIds = _user$project$FastParser$allIds(_user$project$FastParser$prelude);
var _user$project$FastParser$maxId = function (exp) {
	var ids = _user$project$FastParser$allIds(exp);
	return A2(
		_user$project$Utils$fromJust_,
		'maxId',
		_elm_lang$core$List$maximum(
			{
				ctor: '::',
				_0: _user$project$FastParser$initK,
				_1: _elm_lang$core$Set$toList(ids)
			}));
};
var _user$project$FastParser$preludeSubst = A2(_user$project$FastParser$substPlusOf_, _elm_lang$core$Dict$empty, _user$project$FastParser$prelude);
var _user$project$FastParser$substPlusOf = function (e) {
	return A2(_user$project$FastParser$substPlusOf_, _user$project$FastParser$preludeSubst, e);
};
var _user$project$FastParser$substOf = function (_p74) {
	return A2(
		_elm_lang$core$Dict$map,
		_elm_lang$core$Basics$always(
			function (_) {
				return _.val;
			}),
		_user$project$FastParser$substPlusOf(_p74));
};
var _user$project$FastParser$substStrOf = function (_p75) {
	return A2(
		_elm_lang$core$Dict$map,
		_elm_lang$core$Basics$always(_elm_lang$core$Basics$toString),
		_user$project$FastParser$substOf(_p75));
};
var _user$project$FastParser$implicitMain = function () {
	var builder = function (p) {
		var withCorrectInfo = function (x) {
			return A3(_user$project$Info$WithInfo, x, p, p);
		};
		var name = function (_p76) {
			return withCorrectInfo(
				_user$project$Lang$pat_(_p76));
		}(
			A3(
				_user$project$Lang$PVar,
				_user$project$Lang$space1,
				'_IMPLICIT_MAIN',
				_user$project$Info$withDummyInfo(_user$project$Lang$NoWidgetDecl)));
		var binding = _user$project$Lang$Expr(
			function (_p77) {
				return withCorrectInfo(
					_user$project$Lang$exp_(_p77));
			}(
				A2(
					_user$project$Lang$EBase,
					_user$project$Lang$space1,
					A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, '...'))));
		var body = _user$project$Lang$Expr(
			function (_p78) {
				return withCorrectInfo(
					_user$project$Lang$exp_(_p78));
			}(
				A2(_user$project$Lang$EVar, _user$project$Lang$space1, 'main')));
		return function (_p79) {
			return withCorrectInfo(
				_user$project$Lang$exp_(_p79));
		}(
			A5(
				_user$project$Lang$ELet,
				_user$project$Lang$newline2,
				_user$project$Lang$Let,
				A4(
					_user$project$Lang$Declarations,
					{
						ctor: '::',
						_0: 0,
						_1: {ctor: '[]'}
					},
					{ctor: '[]'},
					{ctor: '[]'},
					{
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: false,
							_1: {
								ctor: '::',
								_0: A6(_user$project$Lang$LetExp, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space1, name, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, binding),
								_1: {ctor: '[]'}
							}
						},
						_1: {ctor: '[]'}
					}),
				_user$project$Lang$space1,
				body));
	};
	return A2(
		_MikaelMayer$parser$Parser_ops['|='],
		_MikaelMayer$parser$Parser$succeed(builder),
		_user$project$ParserUtils$getPos);
}();
var _user$project$FastParser$validTypeIdentifierFirstChar = function (c) {
	return _elm_lang$core$Char$isUpper(c);
};
var _user$project$FastParser$validVariableIdentifierFirstChar = function (c) {
	return _elm_lang$core$Char$isLower(c) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('_'));
};
var _user$project$FastParser$keywords = _elm_lang$core$Set$fromList(
	{
		ctor: '::',
		_0: 'true',
		_1: {
			ctor: '::',
			_0: 'false',
			_1: {
				ctor: '::',
				_0: 'pi',
				_1: {
					ctor: '::',
					_0: 'cos',
					_1: {
						ctor: '::',
						_0: 'sin',
						_1: {
							ctor: '::',
							_0: 'arccos',
							_1: {
								ctor: '::',
								_0: 'arcsin',
								_1: {
									ctor: '::',
									_0: 'floor',
									_1: {
										ctor: '::',
										_0: 'ceiling',
										_1: {
											ctor: '::',
											_0: 'round',
											_1: {
												ctor: '::',
												_0: 'toString',
												_1: {
													ctor: '::',
													_0: 'sqrt',
													_1: {
														ctor: '::',
														_0: 'explode',
														_1: {
															ctor: '::',
															_0: 'mod',
															_1: {
																ctor: '::',
																_0: 'arctan2',
																_1: {
																	ctor: '::',
																	_0: 'if',
																	_1: {
																		ctor: '::',
																		_0: 'case',
																		_1: {
																			ctor: '::',
																			_0: 'typecase',
																			_1: {
																				ctor: '::',
																				_0: 'let',
																				_1: {
																					ctor: '::',
																					_0: 'letrec',
																					_1: {
																						ctor: '::',
																						_0: 'def',
																						_1: {
																							ctor: '::',
																							_0: 'defrec',
																							_1: {
																								ctor: '::',
																								_0: 'typ',
																								_1: {
																									ctor: '::',
																									_0: '__DictEmpty__',
																									_1: {
																										ctor: '::',
																										_0: '__DictInsert__',
																										_1: {
																											ctor: '::',
																											_0: '__DictGet__',
																											_1: {
																												ctor: '::',
																												_0: '__DictRemove__',
																												_1: {
																													ctor: '::',
																													_0: '__DictFromList__',
																													_1: {
																														ctor: '::',
																														_0: 'debug',
																														_1: {
																															ctor: '::',
																															_0: 'noWidgets',
																															_1: {ctor: '[]'}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$FastParser$validIdentifierRestChar = function (c) {
	return _elm_lang$core$Char$isLower(c) || (_elm_lang$core$Char$isUpper(c) || (_elm_lang$core$Char$isDigit(c) || (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('_')) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('\'')))));
};
var _user$project$FastParser$variableIdentifierString = A2(
	_MikaelMayer$parser$Parser$inContext,
	'variable identifier string',
	_user$project$ParserUtils$trackInfo(
		A3(_MikaelMayer$parser$Parser_LanguageKit$variable, _user$project$FastParser$validVariableIdentifierFirstChar, _user$project$FastParser$validIdentifierRestChar, _user$project$FastParser$keywords)));
var _user$project$FastParser$typeIdentifierString = A2(
	_MikaelMayer$parser$Parser$inContext,
	'type identifier string',
	_user$project$ParserUtils$trackInfo(
		A3(_MikaelMayer$parser$Parser_LanguageKit$variable, _user$project$FastParser$validTypeIdentifierFirstChar, _user$project$FastParser$validIdentifierRestChar, _user$project$FastParser$keywords)));
var _user$project$FastParser$sanitizeVariableName = function (unsafeName) {
	return _elm_lang$core$String$fromList(
		A2(
			_user$project$Utils$changeTail,
			_elm_lang$core$List$filter(_user$project$FastParser$validIdentifierRestChar),
			A2(
				_user$project$Utils$mapHead,
				_elm_lang$core$Char$toLower,
				A2(
					_user$project$Utils$dropWhile,
					function (_p80) {
						return !function (_p81) {
							return _user$project$FastParser$validVariableIdentifierFirstChar(
								_elm_lang$core$Char$toLower(_p81));
						}(_p80);
					},
					_elm_lang$core$String$toList(unsafeName)))));
};
var _user$project$FastParser$null = A2(
	_MikaelMayer$parser$Parser$inContext,
	'null',
	_user$project$ParserUtils$trackInfo(
		A2(
			_MikaelMayer$parser$Parser$map,
			_elm_lang$core$Basics$always(_user$project$Lang$ENull),
			_MikaelMayer$parser$Parser$keyword('null'))));
var _user$project$FastParser$bool = A2(
	_MikaelMayer$parser$Parser$inContext,
	'bool',
	_user$project$ParserUtils$trackInfo(
		A2(
			_MikaelMayer$parser$Parser$map,
			_user$project$Lang$EBool,
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser$map,
						_elm_lang$core$Basics$always(true),
						_MikaelMayer$parser$Parser$keyword('true')),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser$map,
							_elm_lang$core$Basics$always(false),
							_MikaelMayer$parser$Parser$keyword('false')),
						_1: {ctor: '[]'}
					}
				}))));
var _user$project$FastParser$string = function () {
	var stringHelper = function (quoteChar) {
		var quoteString = _elm_lang$core$String$fromChar(quoteChar);
		return A2(
			_MikaelMayer$parser$Parser_ops['|.'],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$succeed(
						_user$project$Lang$EString(quoteString)),
					_MikaelMayer$parser$Parser$symbol(quoteString)),
				A2(
					_MikaelMayer$parser$Parser$keep,
					_MikaelMayer$parser$Parser$zeroOrMore,
					function (c) {
						return !_elm_lang$core$Native_Utils.eq(c, quoteChar);
					})),
			_MikaelMayer$parser$Parser$symbol(quoteString));
	};
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'string',
		_user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$oneOf(
				A2(
					_elm_lang$core$List$map,
					stringHelper,
					{
						ctor: '::',
						_0: _elm_lang$core$Native_Utils.chr('\''),
						_1: {
							ctor: '::',
							_0: _elm_lang$core$Native_Utils.chr('\"'),
							_1: {ctor: '[]'}
						}
					}))));
}();
var _user$project$FastParser$baseValue = A2(
	_MikaelMayer$parser$Parser$inContext,
	'base value',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _user$project$FastParser$string,
			_1: {
				ctor: '::',
				_0: _user$project$FastParser$bool,
				_1: {
					ctor: '::',
					_0: _user$project$FastParser$null,
					_1: {ctor: '[]'}
				}
			}
		}));
var _user$project$FastParser$frozenAnnotation = A2(
	_MikaelMayer$parser$Parser$inContext,
	'frozen annotation',
	_user$project$ParserUtils$trackInfo(
		_MikaelMayer$parser$Parser$oneOf(
			A2(
				_elm_lang$core$List$map,
				function (a) {
					return A2(_user$project$ParserUtils$token, a, a);
				},
				{
					ctor: '::',
					_0: _user$project$Lang$frozen,
					_1: {
						ctor: '::',
						_0: _user$project$Lang$thawed,
						_1: {
							ctor: '::',
							_0: _user$project$Lang$assignOnlyOnce,
							_1: {
								ctor: '::',
								_0: _user$project$Lang$unann,
								_1: {ctor: '[]'}
							}
						}
					}
				}))));
var _user$project$FastParser$isInt = function (n) {
	return _elm_lang$core$Native_Utils.eq(
		n,
		_elm_lang$core$Basics$toFloat(
			_elm_lang$core$Basics$floor(n)));
};
var _user$project$FastParser$num = function () {
	var sign = _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				_MikaelMayer$parser$Parser$succeed(-1),
				_MikaelMayer$parser$Parser$symbol('-')),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$succeed(1),
				_1: {ctor: '[]'}
			}
		});
	return _user$project$ParserUtils$try(
		A2(
			_MikaelMayer$parser$Parser$inContext,
			'number',
			_user$project$ParserUtils$trackInfo(
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F2(
								function (s, n) {
									return s * n;
								})),
						sign),
					_MikaelMayer$parser$Parser$float))));
}();
var _user$project$FastParser$widgetDecl = function (cap) {
	var combiner = F3(
		function (a, tok, b) {
			return A2(
				_elm_lang$core$List$all,
				_user$project$FastParser$isInt,
				{
					ctor: '::',
					_0: a.val,
					_1: {
						ctor: '::',
						_0: b.val,
						_1: {ctor: '[]'}
					}
				}) ? A5(
				_user$project$Lang$IntSlider,
				A2(_user$project$Info$mapInfo, _elm_lang$core$Basics$floor, a),
				tok,
				A2(_user$project$Info$mapInfo, _elm_lang$core$Basics$floor, b),
				cap,
				false) : A5(_user$project$Lang$NumSlider, a, tok, b, cap, false);
		});
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'widget declaration',
		_user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(combiner),
										_MikaelMayer$parser$Parser$symbol('{')),
									_user$project$FastParser$num),
								_user$project$ParserUtils$trackInfo(
									A2(_user$project$ParserUtils$token, '-', '-'))),
							_user$project$FastParser$num),
						_MikaelMayer$parser$Parser$symbol('}')),
					_1: {
						ctor: '::',
						_0: _MikaelMayer$parser$Parser$succeed(_user$project$Lang$NoWidgetDecl),
						_1: {ctor: '[]'}
					}
				})));
};
var _user$project$FastParser$spaces = _user$project$LangParserUtils$oldSpaces;
var _user$project$FastParser$block = F4(
	function (combiner, openSymbol, closeSymbol, p) {
		return A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (_p83, _p82) {
					var _p84 = _p83;
					var _p85 = _p82;
					return A3(
						_user$project$Info$WithInfo,
						A3(combiner, _p84._0, _p85._0, _p85._1),
						_p84._1.start,
						_p85._2.end);
				}),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							})),
					_user$project$FastParser$spaces),
				_user$project$ParserUtils$trackInfo(
					_MikaelMayer$parser$Parser$symbol(openSymbol))),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (v0, v1, v2) {
									return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
								})),
						p),
					_user$project$FastParser$spaces),
				_user$project$ParserUtils$trackInfo(
					_MikaelMayer$parser$Parser$symbol(closeSymbol))));
	});
var _user$project$FastParser$parenBlock = function (combiner) {
	return A3(_user$project$FastParser$block, combiner, '(', ')');
};
var _user$project$FastParser$bracketBlock = function (combiner) {
	return A3(_user$project$FastParser$block, combiner, '[', ']');
};
var _user$project$FastParser$listLiteralInternal = F3(
	function (context, combiner, elem) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			context,
			A2(
				_user$project$FastParser$bracketBlock,
				combiner,
				A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, elem)));
	});
var _user$project$FastParser$blockIgnoreWS = _user$project$FastParser$block(
	F3(
		function (wsStart, x, wsEnd) {
			return x;
		}));
var _user$project$FastParser$parenBlockIgnoreWS = A2(_user$project$FastParser$blockIgnoreWS, '(', ')');
var _user$project$FastParser$multiConsInternal = F3(
	function (context, combiner, elem) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			context,
			A2(
				_user$project$FastParser$bracketBlock,
				F3(
					function (wsStart, _p86, wsEnd) {
						var _p87 = _p86;
						return A5(combiner, wsStart, _p87._0, _p87._1, _p87._2, wsEnd);
					}),
				A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (_p88, tail) {
							var _p89 = _p88;
							return {ctor: '_Tuple3', _0: _p89._0, _1: _p89._1, _2: tail};
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, elem)),
							_user$project$FastParser$spaces),
						_MikaelMayer$parser$Parser$symbol('|')),
					elem)));
	});
var _user$project$FastParser$genericList = function (args) {
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		args.generalContext,
		_MikaelMayer$parser$Parser$oneOf(
			{
				ctor: '::',
				_0: A3(_user$project$FastParser$multiConsInternal, args.multiConsContext, args.multiConsCombiner, args.elem),
				_1: {
					ctor: '::',
					_0: A3(_user$project$FastParser$listLiteralInternal, args.listLiteralContext, args.listLiteralCombiner, args.elem),
					_1: {ctor: '[]'}
				}
			}));
};
var _user$project$FastParser$namePattern = function (ident) {
	return _user$project$LangParserUtils$mapPat_(
		A3(
			_user$project$LangParserUtils$paddedBefore,
			F2(
				function (ws, name) {
					return A3(_user$project$Lang$PVar, ws, name, _user$project$Lang$noWidgetDecl);
				}),
			_user$project$FastParser$spaces,
			ident));
};
var _user$project$FastParser$variablePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'variable pattern',
	_user$project$FastParser$namePattern(_user$project$FastParser$variableIdentifierString));
var _user$project$FastParser$typePattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'type pattern',
	_user$project$FastParser$namePattern(_user$project$FastParser$typeIdentifierString));
var _user$project$FastParser$constantPattern = _user$project$LangParserUtils$mapPat_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'constant pattern',
		A3(_user$project$LangParserUtils$paddedBefore, _user$project$Lang$PConst, _user$project$FastParser$spaces, _user$project$FastParser$num)));
var _user$project$FastParser$baseValuePattern = _user$project$LangParserUtils$mapPat_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'base value pattern',
		A3(_user$project$LangParserUtils$paddedBefore, _user$project$Lang$PBase, _user$project$FastParser$spaces, _user$project$FastParser$baseValue)));
var _user$project$FastParser$asPattern = _user$project$LangParserUtils$mapPat_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'as pattern',
		_MikaelMayer$parser$Parser$lazy(
			function (_p90) {
				return A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (_p91, pat) {
							var _p92 = _p91;
							var _p93 = _p92._1;
							return A3(
								_user$project$Info$WithInfo,
								A4(
									_user$project$Lang$PAs,
									_p92._0,
									A3(
										_user$project$Info$withInfo,
										_user$project$Lang$pat_(
											A3(_user$project$Lang$PVar, _user$project$Lang$space1, _p93.val, _user$project$Lang$noWidgetDecl)),
										_p93.start,
										_p93.end),
									_p92._2,
									pat),
								_p93.start,
								pat.end);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									_MikaelMayer$parser$Parser$succeed(
										F3(
											function (v0, v1, v2) {
												return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
											})),
									_user$project$FastParser$spaces),
								_user$project$FastParser$variableIdentifierString),
							_user$project$FastParser$spaces),
						_MikaelMayer$parser$Parser$symbol('@')),
					_user$project$FastParser$pattern);
			})));
var _user$project$FastParser$pattern = A2(
	_MikaelMayer$parser$Parser$inContext,
	'pattern',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _MikaelMayer$parser$Parser$lazy(
				function (_p94) {
					return _user$project$FastParser$patternList;
				}),
			_1: {
				ctor: '::',
				_0: _MikaelMayer$parser$Parser$lazy(
					function (_p95) {
						return _user$project$FastParser$asPattern;
					}),
				_1: {
					ctor: '::',
					_0: _user$project$FastParser$constantPattern,
					_1: {
						ctor: '::',
						_0: _user$project$FastParser$baseValuePattern,
						_1: {
							ctor: '::',
							_0: _user$project$FastParser$variablePattern,
							_1: {ctor: '[]'}
						}
					}
				}
			}
		}));
var _user$project$FastParser$patternList = _user$project$LangParserUtils$mapPat_(
	_MikaelMayer$parser$Parser$lazy(
		function (_p96) {
			return _user$project$FastParser$genericList(
				{
					generalContext: 'pattern list',
					listLiteralContext: 'pattern list literal',
					multiConsContext: 'pattern multi cons literal',
					listLiteralCombiner: F3(
						function (wsStart, heads, wsEnd) {
							return A5(_user$project$Lang$PList, wsStart, heads, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, wsEnd);
						}),
					multiConsCombiner: F5(
						function (wsStart, heads, wsBar, tail, wsEnd) {
							return A5(
								_user$project$Lang$PList,
								wsStart,
								heads,
								wsBar,
								_elm_lang$core$Maybe$Just(tail),
								wsEnd);
						}),
					elem: _user$project$FastParser$pattern
				});
		}));
var _user$project$FastParser$baseType = F3(
	function (context, combiner, token) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			context,
			_user$project$LangParserUtils$mapType_(
				A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (ws, _p97) {
							return A3(
								_user$project$Info$WithInfo,
								combiner(ws),
								ws.start,
								ws.end);
						}),
					_user$project$FastParser$spaces,
					_MikaelMayer$parser$Parser$keyword(token))));
	});
var _user$project$FastParser$nullType = A3(_user$project$FastParser$baseType, 'null type', _user$project$Lang$TNull, 'Null');
var _user$project$FastParser$numType = A3(_user$project$FastParser$baseType, 'num type', _user$project$Lang$TNum, 'Num');
var _user$project$FastParser$boolType = A3(_user$project$FastParser$baseType, 'bool type', _user$project$Lang$TBool, 'Bool');
var _user$project$FastParser$stringType = A3(_user$project$FastParser$baseType, 'string type', _user$project$Lang$TString, 'String');
var _user$project$FastParser$variableType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'variable type',
	_user$project$LangParserUtils$mapType_(
		A3(_user$project$LangParserUtils$paddedBefore, _user$project$Lang$TVar, _user$project$FastParser$spaces, _user$project$FastParser$variableIdentifierString)));
var _user$project$FastParser$namedType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'named type',
	_user$project$LangParserUtils$mapType_(
		A3(
			_user$project$LangParserUtils$paddedBefore,
			F2(
				function (wsBefore, ident) {
					return A2(_user$project$Lang$TVar, wsBefore, ident);
				}),
			_user$project$FastParser$spaces,
			_user$project$FastParser$typeIdentifierString)));
var _user$project$FastParser$wildcardType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'wildcard type',
	_user$project$LangParserUtils$mapType_(
		A3(_user$project$LangParserUtils$spaceSaverKeyword, _user$project$FastParser$spaces, '_', _user$project$Lang$TWildcard)));
var _user$project$FastParser$typ = A2(
	_MikaelMayer$parser$Parser$inContext,
	'type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p98) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$FastParser$nullType,
					_1: {
						ctor: '::',
						_0: _user$project$FastParser$numType,
						_1: {
							ctor: '::',
							_0: _user$project$FastParser$boolType,
							_1: {
								ctor: '::',
								_0: _user$project$FastParser$stringType,
								_1: {
									ctor: '::',
									_0: _user$project$FastParser$wildcardType,
									_1: {
										ctor: '::',
										_0: _MikaelMayer$parser$Parser$lazy(
											function (_p99) {
												return _user$project$FastParser$functionType;
											}),
										_1: {
											ctor: '::',
											_0: _MikaelMayer$parser$Parser$lazy(
												function (_p100) {
													return _user$project$FastParser$listType;
												}),
											_1: {
												ctor: '::',
												_0: _MikaelMayer$parser$Parser$lazy(
													function (_p101) {
														return _user$project$FastParser$dictType;
													}),
												_1: {
													ctor: '::',
													_0: _MikaelMayer$parser$Parser$lazy(
														function (_p102) {
															return _user$project$FastParser$tupleType;
														}),
													_1: {
														ctor: '::',
														_0: _MikaelMayer$parser$Parser$lazy(
															function (_p103) {
																return _user$project$FastParser$forallType;
															}),
														_1: {
															ctor: '::',
															_0: _MikaelMayer$parser$Parser$lazy(
																function (_p104) {
																	return _user$project$FastParser$unionType;
																}),
															_1: {
																ctor: '::',
																_0: _user$project$FastParser$namedType,
																_1: {
																	ctor: '::',
																	_0: _user$project$FastParser$variableType,
																	_1: {ctor: '[]'}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				});
		}));
var _user$project$FastParser$dictType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'dictionary type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p105) {
			return _user$project$LangParserUtils$mapType_(
				A2(
					_user$project$FastParser$parenBlock,
					F3(
						function (wsStart, _p106, wsEnd) {
							var _p107 = _p106;
							return A4(_user$project$Lang$TDict, wsStart, _p107._0, _p107._1, wsEnd);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								_user$project$LangParserUtils$keywordWithSpace('TDict')),
							_user$project$FastParser$typ),
						_user$project$FastParser$typ)));
		}));
var _user$project$FastParser$forallType = function () {
	var patVar = A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		F2(
			function (ws, name) {
				return A3(
					_user$project$Info$withInfo,
					A2(_user$project$Lang$TPatVar, ws, name.val),
					name.start,
					name.end);
			}),
		_user$project$FastParser$spaces,
		_user$project$FastParser$variableIdentifierString);
	var quantifiers = A2(
		_MikaelMayer$parser$Parser$inContext,
		'forall type (one)',
		A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, patVar));
	return A2(
		_MikaelMayer$parser$Parser$inContext,
		'forall type',
		_MikaelMayer$parser$Parser$lazy(
			function (_p108) {
				return _user$project$LangParserUtils$mapType_(
					A2(
						_user$project$FastParser$parenBlock,
						F3(
							function (wsBefore, _p109, wsEnd) {
								var _p110 = _p109;
								return A4(_user$project$Lang$TForall, wsBefore, _p110._0, _p110._1, wsEnd);
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})),
									_user$project$LangParserUtils$keywordWithSpace('forall')),
								quantifiers),
							_user$project$FastParser$typ)));
			}));
}();
var _user$project$FastParser$functionType = _MikaelMayer$parser$Parser$lazy(
	function (_p111) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'function type',
			_user$project$LangParserUtils$mapType_(
				A2(
					_user$project$FastParser$parenBlock,
					_user$project$Lang$TArrow,
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
							_user$project$LangParserUtils$keywordWithSpace('->')),
						A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, _user$project$FastParser$typ)))));
	});
var _user$project$FastParser$listType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'list type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p112) {
			return _user$project$LangParserUtils$mapType_(
				A2(
					_user$project$FastParser$parenBlock,
					_user$project$Lang$TList,
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
							_user$project$LangParserUtils$keywordWithSpace('List')),
						_user$project$FastParser$typ)));
		}));
var _user$project$FastParser$tupleType = _MikaelMayer$parser$Parser$lazy(
	function (_p113) {
		return _user$project$LangParserUtils$mapType_(
			_user$project$FastParser$genericList(
				{
					generalContext: 'tuple type',
					listLiteralContext: 'tuple type list literal',
					multiConsContext: 'tuple type multi cons literal',
					listLiteralCombiner: F3(
						function (wsStart, heads, wsEnd) {
							return A5(_user$project$Lang$TTuple, wsStart, heads, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, wsEnd);
						}),
					multiConsCombiner: F5(
						function (wsStart, heads, wsBar, tail, wsEnd) {
							return A5(
								_user$project$Lang$TTuple,
								wsStart,
								heads,
								wsBar,
								_elm_lang$core$Maybe$Just(tail),
								wsEnd);
						}),
					elem: _user$project$FastParser$typ
				}));
	});
var _user$project$FastParser$unionType = A2(
	_MikaelMayer$parser$Parser$inContext,
	'union type',
	_MikaelMayer$parser$Parser$lazy(
		function (_p114) {
			return _user$project$LangParserUtils$mapType_(
				A2(
					_user$project$FastParser$parenBlock,
					_user$project$Lang$TUnion,
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_elm_lang$core$Basics$identity),
							_user$project$LangParserUtils$keywordWithSpace('union')),
						A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, _user$project$FastParser$typ))));
		}));
var _user$project$FastParser$topLevelTypeDeclaration = A2(
	_MikaelMayer$parser$Parser$inContext,
	'top-level type declaration',
	A2(
		_user$project$FastParser$parenBlock,
		F4(
			function (wsStart, _p115, wsEnd, rest) {
				var _p116 = _p115;
				return _user$project$Lang$exp_(
					A5(_user$project$Lang$eTyp_, wsStart, _p116._0, _p116._1, rest, wsEnd));
			}),
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							})),
					_user$project$LangParserUtils$keywordWithSpace('typ')),
				_user$project$FastParser$variablePattern),
			_user$project$FastParser$typ)));
var _user$project$FastParser$parseT = _MikaelMayer$parser$Parser$run(_user$project$FastParser$typ);
var _user$project$FastParser$variableExpression = _user$project$LangParserUtils$mapExp_(
	A3(_user$project$LangParserUtils$paddedBefore, _user$project$Lang$EVar, _user$project$FastParser$spaces, _user$project$FastParser$variableIdentifierString));
var _user$project$FastParser$constantExpression = _user$project$LangParserUtils$mapExp_(
	A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		F2(
			function (ws, _p117) {
				var _p118 = _p117;
				var _p120 = _p118._2;
				var _p119 = _p118._0;
				return A3(
					_user$project$Info$WithInfo,
					A4(
						_user$project$Lang$EConst,
						ws,
						_p119.val,
						A2(_user$project$Lang$dummyLocWithDebugInfo, _p118._1.val, _p119.val),
						_p120),
					_p119.start,
					_p120.end);
			}),
		_user$project$FastParser$spaces,
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F3(
							function (v0, v1, v2) {
								return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
							})),
					_user$project$FastParser$num),
				_user$project$FastParser$frozenAnnotation),
			_user$project$FastParser$widgetDecl(_elm_lang$core$Maybe$Nothing))));
var _user$project$FastParser$baseValueExpression = A2(
	_MikaelMayer$parser$Parser$inContext,
	'base value expression',
	_user$project$LangParserUtils$mapExp_(
		A3(_user$project$LangParserUtils$paddedBefore, _user$project$Lang$EBase, _user$project$FastParser$spaces, _user$project$FastParser$baseValue)));
var _user$project$FastParser$hole = A2(
	_MikaelMayer$parser$Parser$inContext,
	'hole',
	_user$project$LangParserUtils$mapExp_(
		A3(
			_user$project$LangParserUtils$paddedBefore,
			_user$project$Lang$EHole,
			_user$project$FastParser$spaces,
			_user$project$ParserUtils$trackInfo(
				A2(_user$project$ParserUtils$token, '??', _user$project$Lang$EEmptyHole)))));
var _user$project$FastParser$typeAnnotation = _user$project$LangParserUtils$mapExp_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'type annotation',
		_MikaelMayer$parser$Parser$lazy(
			function (_p121) {
				return A2(
					_user$project$FastParser$parenBlock,
					F3(
						function (wsStart, _p122, wsEnd) {
							var _p123 = _p122;
							return A5(
								_user$project$Lang$EColonType,
								wsStart,
								_user$project$Lang$Expr(_p123._0),
								_p123._1,
								_p123._2,
								wsEnd);
						}),
					A3(
						_MikaelMayer$parser$Parser$delayedCommitMap,
						F2(
							function (_p124, t) {
								var _p125 = _p124;
								return {ctor: '_Tuple3', _0: _p125._0, _1: _p125._1, _2: t};
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})),
									_user$project$FastParser$exp),
								_user$project$FastParser$spaces),
							_MikaelMayer$parser$Parser$symbol(':')),
						_user$project$FastParser$typ));
			})));
var _user$project$FastParser$exp = A2(
	_MikaelMayer$parser$Parser$inContext,
	'expression',
	_MikaelMayer$parser$Parser$lazy(
		function (_p126) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$FastParser$constantExpression,
					_1: {
						ctor: '::',
						_0: _user$project$FastParser$baseValueExpression,
						_1: {
							ctor: '::',
							_0: _MikaelMayer$parser$Parser$lazy(
								function (_p127) {
									return _user$project$FastParser$typeAlias;
								}),
							_1: {
								ctor: '::',
								_0: _MikaelMayer$parser$Parser$lazy(
									function (_p128) {
										return _user$project$FastParser$conditional;
									}),
								_1: {
									ctor: '::',
									_0: _MikaelMayer$parser$Parser$lazy(
										function (_p129) {
											return _user$project$FastParser$letBinding;
										}),
									_1: {
										ctor: '::',
										_0: _MikaelMayer$parser$Parser$lazy(
											function (_p130) {
												return _user$project$FastParser$caseExpression;
											}),
										_1: {
											ctor: '::',
											_0: _MikaelMayer$parser$Parser$lazy(
												function (_p131) {
													return _user$project$FastParser$typeCaseExpression;
												}),
											_1: {
												ctor: '::',
												_0: _MikaelMayer$parser$Parser$lazy(
													function (_p132) {
														return _user$project$FastParser$typeDeclaration;
													}),
												_1: {
													ctor: '::',
													_0: _MikaelMayer$parser$Parser$lazy(
														function (_p133) {
															return _user$project$FastParser$typeAnnotation;
														}),
													_1: {
														ctor: '::',
														_0: _MikaelMayer$parser$Parser$lazy(
															function (_p134) {
																return _user$project$FastParser$list;
															}),
														_1: {
															ctor: '::',
															_0: _MikaelMayer$parser$Parser$lazy(
																function (_p135) {
																	return _user$project$FastParser$function;
																}),
															_1: {
																ctor: '::',
																_0: _MikaelMayer$parser$Parser$lazy(
																	function (_p136) {
																		return _user$project$FastParser$functionApplication;
																	}),
																_1: {
																	ctor: '::',
																	_0: _MikaelMayer$parser$Parser$lazy(
																		function (_p137) {
																			return _user$project$FastParser$operator;
																		}),
																	_1: {
																		ctor: '::',
																		_0: _MikaelMayer$parser$Parser$lazy(
																			function (_p138) {
																				return _user$project$FastParser$hole;
																			}),
																		_1: {
																			ctor: '::',
																			_0: _user$project$FastParser$variableExpression,
																			_1: {ctor: '[]'}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				});
		}));
var _user$project$FastParser$caseExpression = _MikaelMayer$parser$Parser$lazy(
	function (_p139) {
		return A6(
			_user$project$FastParser$genericCase,
			'case expression',
			'case',
			_user$project$Lang$ECase,
			_user$project$Lang$Branch_,
			A2(_MikaelMayer$parser$Parser$map, _user$project$Lang$Expr, _user$project$FastParser$exp),
			_user$project$FastParser$pattern);
	});
var _user$project$FastParser$genericCase = F6(
	function (context, kword, combiner, branchCombiner, parser, branchParser) {
		var path = A2(
			_MikaelMayer$parser$Parser$inContext,
			A2(_elm_lang$core$Basics_ops['++'], context, ' path'),
			_MikaelMayer$parser$Parser$lazy(
				function (_p140) {
					return A2(
						_user$project$FastParser$parenBlock,
						F3(
							function (wsStart, _p141, wsEnd) {
								var _p142 = _p141;
								return A4(
									branchCombiner,
									wsStart,
									_p142._0,
									_user$project$Lang$Expr(_p142._1),
									wsEnd);
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								branchParser),
							_user$project$FastParser$exp));
				}));
		return _user$project$LangParserUtils$mapExp_(
			A2(
				_MikaelMayer$parser$Parser$inContext,
				context,
				_MikaelMayer$parser$Parser$lazy(
					function (_p143) {
						return A2(
							_user$project$FastParser$parenBlock,
							F3(
								function (wsStart, _p144, wsEnd) {
									var _p145 = _p144;
									return A4(combiner, wsStart, _p145._0, _p145._1, wsEnd);
								}),
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})),
										_user$project$LangParserUtils$keywordWithSpace(kword)),
									parser),
								A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, path)));
					})));
	});
var _user$project$FastParser$conditional = _user$project$LangParserUtils$mapExp_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'conditional',
		_MikaelMayer$parser$Parser$lazy(
			function (_p146) {
				return A2(
					_user$project$FastParser$parenBlock,
					F3(
						function (wsStart, _p147, wsEnd) {
							var _p148 = _p147;
							return A7(
								_user$project$Lang$EIf,
								wsStart,
								_user$project$Lang$Expr(_p148._0),
								_user$project$Lang$ws(''),
								_user$project$Lang$Expr(_p148._1),
								_user$project$Lang$ws(''),
								_user$project$Lang$Expr(_p148._2),
								wsEnd);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F3(
											function (v0, v1, v2) {
												return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
											})),
									_user$project$LangParserUtils$keywordWithSpace('if')),
								_user$project$FastParser$exp),
							_user$project$FastParser$exp),
						_user$project$FastParser$exp));
			})));
var _user$project$FastParser$function = function () {
	var parameters = _MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: A2(_MikaelMayer$parser$Parser$map, _elm_lang$core$List$singleton, _user$project$FastParser$pattern),
			_1: {
				ctor: '::',
				_0: _user$project$ParserUtils$untrackInfo(
					_user$project$FastParser$parenBlockIgnoreWS(
						A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, _user$project$FastParser$pattern))),
				_1: {ctor: '[]'}
			}
		});
	return _user$project$LangParserUtils$mapExp_(
		A2(
			_MikaelMayer$parser$Parser$inContext,
			'function',
			_MikaelMayer$parser$Parser$lazy(
				function (_p149) {
					return A2(
						_user$project$FastParser$parenBlock,
						F3(
							function (wsStart, _p150, wsEnd) {
								var _p151 = _p150;
								return A4(
									_user$project$Lang$EFun,
									wsStart,
									_p151._0,
									_user$project$Lang$Expr(_p151._1),
									wsEnd);
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})),
									_MikaelMayer$parser$Parser$symbol('\\')),
								parameters),
							_user$project$FastParser$exp));
				})));
}();
var _user$project$FastParser$functionApplication = _user$project$LangParserUtils$mapExp_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'function application',
		_MikaelMayer$parser$Parser$lazy(
			function (_p152) {
				return A2(
					_user$project$FastParser$parenBlock,
					F3(
						function (wsStart, _p153, wsEnd) {
							var _p154 = _p153;
							return A5(
								_user$project$Lang$EApp,
								wsStart,
								_user$project$Lang$Expr(_p154._0),
								A2(_elm_lang$core$List$map, _user$project$Lang$Expr, _p154._1),
								_user$project$Lang$SpaceApp,
								wsEnd);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})),
							_user$project$FastParser$exp),
						A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$oneOrMore, _user$project$FastParser$exp)));
			})));
var _user$project$FastParser$letBinding = A2(
	_MikaelMayer$parser$Parser$inContext,
	'let binding',
	_MikaelMayer$parser$Parser$lazy(
		function (_p155) {
			return _MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: _user$project$FastParser$recursiveLetBinding,
					_1: {
						ctor: '::',
						_0: _user$project$FastParser$simpleLetBinding,
						_1: {
							ctor: '::',
							_0: _user$project$FastParser$recursiveDefBinding,
							_1: {
								ctor: '::',
								_0: _user$project$FastParser$simpleDefBinding,
								_1: {ctor: '[]'}
							}
						}
					}
				});
		}));
var _user$project$FastParser$recursiveDefBinding = _MikaelMayer$parser$Parser$lazy(
	function (_p156) {
		return A3(_user$project$FastParser$genericDefBinding, 'recursive def binding', 'defrec', true);
	});
var _user$project$FastParser$genericDefBinding = F3(
	function (context, kword, isRec) {
		return _user$project$LangParserUtils$mapExp_(
			A2(
				_MikaelMayer$parser$Parser$inContext,
				context,
				A3(
					_MikaelMayer$parser$Parser$delayedCommitMap,
					F2(
						function (_p158, _p157) {
							var _p159 = _p158;
							var _p160 = _p157;
							return A3(
								_user$project$Info$WithInfo,
								A9(
									_user$project$Lang$eLet__,
									_p159._0,
									_user$project$Lang$Def,
									isRec,
									_p160._0,
									_user$project$Lang$space1,
									_user$project$Lang$Expr(_p160._1),
									_user$project$Lang$space1,
									_user$project$Lang$Expr(_p160._4),
									_p160._2),
								_p159._1.start,
								_p160._3.end);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})),
							_user$project$FastParser$spaces),
						_user$project$ParserUtils$trackInfo(
							_MikaelMayer$parser$Parser$symbol('('))),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|='],
									A2(
										_MikaelMayer$parser$Parser_ops['|='],
										A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(
												F5(
													function (v0, v1, v2, v3, v4) {
														return {ctor: '_Tuple5', _0: v0, _1: v1, _2: v2, _3: v3, _4: v4};
													})),
											_user$project$LangParserUtils$keywordWithSpace(kword)),
										_user$project$FastParser$pattern),
									_user$project$FastParser$exp),
								_user$project$FastParser$spaces),
							_user$project$ParserUtils$trackInfo(
								_MikaelMayer$parser$Parser$symbol(')'))),
						_user$project$FastParser$exp))));
	});
var _user$project$FastParser$recursiveLetBinding = _MikaelMayer$parser$Parser$lazy(
	function (_p161) {
		return A3(_user$project$FastParser$genericLetBinding, 'recursive let binding', 'letrec', true);
	});
var _user$project$FastParser$genericLetBinding = F3(
	function (context, kword, isRec) {
		return _user$project$LangParserUtils$mapExp_(
			A2(
				_MikaelMayer$parser$Parser$inContext,
				context,
				A2(
					_user$project$FastParser$parenBlock,
					F3(
						function (wsStart, _p162, wsEnd) {
							var _p163 = _p162;
							return A9(
								_user$project$Lang$eLet__,
								wsStart,
								_user$project$Lang$Let,
								isRec,
								_p163._0,
								_user$project$Lang$space1,
								_user$project$Lang$Expr(_p163._1),
								_user$project$Lang$space1,
								_user$project$Lang$Expr(_p163._2),
								wsEnd);
						}),
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F3(
											function (v0, v1, v2) {
												return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
											})),
									_user$project$LangParserUtils$keywordWithSpace(kword)),
								_user$project$FastParser$pattern),
							_user$project$FastParser$exp),
						_user$project$FastParser$exp))));
	});
var _user$project$FastParser$simpleDefBinding = _MikaelMayer$parser$Parser$lazy(
	function (_p164) {
		return A3(_user$project$FastParser$genericDefBinding, 'non-recursive def binding', 'def', false);
	});
var _user$project$FastParser$simpleLetBinding = _MikaelMayer$parser$Parser$lazy(
	function (_p165) {
		return A3(_user$project$FastParser$genericLetBinding, 'non-recursive let binding', 'let', false);
	});
var _user$project$FastParser$list = _user$project$LangParserUtils$mapExp_(
	_MikaelMayer$parser$Parser$lazy(
		function (_p166) {
			return _user$project$FastParser$genericList(
				{
					generalContext: 'list',
					listLiteralContext: 'list literal',
					multiConsContext: 'multi cons literal',
					listLiteralCombiner: F3(
						function (wsStart, heads, wsEnd) {
							return A5(
								_user$project$Lang$EList,
								wsStart,
								A2(
									_elm_lang$core$List$map,
									function (e_) {
										return {
											ctor: '_Tuple2',
											_0: _user$project$Lang$space0,
											_1: _user$project$Lang$Expr(e_)
										};
									},
									heads),
								_user$project$Lang$space0,
								_elm_lang$core$Maybe$Nothing,
								wsEnd);
						}),
					multiConsCombiner: F5(
						function (wsStart, heads, wsBar, tail, wsEnd) {
							return A5(
								_user$project$Lang$EList,
								wsStart,
								A2(
									_elm_lang$core$List$map,
									function (e_) {
										return {
											ctor: '_Tuple2',
											_0: _user$project$Lang$space0,
											_1: _user$project$Lang$Expr(e_)
										};
									},
									heads),
								wsBar,
								_elm_lang$core$Maybe$Just(
									_user$project$Lang$Expr(tail)),
								wsEnd);
						}),
					elem: _user$project$FastParser$exp
				});
		}));
var _user$project$FastParser$operator = _user$project$LangParserUtils$mapExp_(
	function () {
		var op = _user$project$ParserUtils$trackInfo(
			_MikaelMayer$parser$Parser$oneOf(
				{
					ctor: '::',
					_0: A2(
						_MikaelMayer$parser$Parser_ops['|.'],
						_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Pi),
						_MikaelMayer$parser$Parser$keyword('pi')),
					_1: {
						ctor: '::',
						_0: A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DictEmpty),
							_MikaelMayer$parser$Parser$keyword('__DictEmpty__')),
						_1: {
							ctor: '::',
							_0: A2(
								_MikaelMayer$parser$Parser_ops['|.'],
								_MikaelMayer$parser$Parser$succeed(_user$project$Lang$CurrentEnv),
								_MikaelMayer$parser$Parser$keyword('__CurrentEnv__')),
							_1: {
								ctor: '::',
								_0: A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DictFromList),
									_MikaelMayer$parser$Parser$keyword('__DictFromList__')),
								_1: {
									ctor: '::',
									_0: A2(
										_MikaelMayer$parser$Parser_ops['|.'],
										_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Cos),
										_user$project$LangParserUtils$keywordWithSpace('cos')),
									_1: {
										ctor: '::',
										_0: A2(
											_MikaelMayer$parser$Parser_ops['|.'],
											_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Sin),
											_user$project$LangParserUtils$keywordWithSpace('sin')),
										_1: {
											ctor: '::',
											_0: A2(
												_MikaelMayer$parser$Parser_ops['|.'],
												_MikaelMayer$parser$Parser$succeed(_user$project$Lang$ArcCos),
												_user$project$LangParserUtils$keywordWithSpace('arccos')),
											_1: {
												ctor: '::',
												_0: A2(
													_MikaelMayer$parser$Parser_ops['|.'],
													_MikaelMayer$parser$Parser$succeed(_user$project$Lang$ArcSin),
													_user$project$LangParserUtils$keywordWithSpace('arcsin')),
												_1: {
													ctor: '::',
													_0: A2(
														_MikaelMayer$parser$Parser_ops['|.'],
														_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Floor),
														_user$project$LangParserUtils$keywordWithSpace('floor')),
													_1: {
														ctor: '::',
														_0: A2(
															_MikaelMayer$parser$Parser_ops['|.'],
															_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Ceil),
															_user$project$LangParserUtils$keywordWithSpace('ceiling')),
														_1: {
															ctor: '::',
															_0: A2(
																_MikaelMayer$parser$Parser_ops['|.'],
																_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Round),
																_user$project$LangParserUtils$keywordWithSpace('round')),
															_1: {
																ctor: '::',
																_0: A2(
																	_MikaelMayer$parser$Parser_ops['|.'],
																	_MikaelMayer$parser$Parser$succeed(_user$project$Lang$ToStr),
																	_user$project$LangParserUtils$keywordWithSpace('toString')),
																_1: {
																	ctor: '::',
																	_0: A2(
																		_MikaelMayer$parser$Parser_ops['|.'],
																		_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Sqrt),
																		_user$project$LangParserUtils$keywordWithSpace('sqrt')),
																	_1: {
																		ctor: '::',
																		_0: A2(
																			_MikaelMayer$parser$Parser_ops['|.'],
																			_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Explode),
																			_user$project$LangParserUtils$keywordWithSpace('explode')),
																		_1: {
																			ctor: '::',
																			_0: A2(
																				_MikaelMayer$parser$Parser_ops['|.'],
																				_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Plus),
																				_user$project$LangParserUtils$keywordWithSpace('+')),
																			_1: {
																				ctor: '::',
																				_0: A2(
																					_MikaelMayer$parser$Parser_ops['|.'],
																					_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Minus),
																					_user$project$LangParserUtils$keywordWithSpace('-')),
																				_1: {
																					ctor: '::',
																					_0: A2(
																						_MikaelMayer$parser$Parser_ops['|.'],
																						_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Mult),
																						_user$project$LangParserUtils$keywordWithSpace('*')),
																					_1: {
																						ctor: '::',
																						_0: A2(
																							_MikaelMayer$parser$Parser_ops['|.'],
																							_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Div),
																							_user$project$LangParserUtils$keywordWithSpace('/')),
																						_1: {
																							ctor: '::',
																							_0: A2(
																								_MikaelMayer$parser$Parser_ops['|.'],
																								_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Lt),
																								_user$project$LangParserUtils$keywordWithSpace('<')),
																							_1: {
																								ctor: '::',
																								_0: A2(
																									_MikaelMayer$parser$Parser_ops['|.'],
																									_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Eq),
																									_user$project$LangParserUtils$keywordWithSpace('=')),
																								_1: {
																									ctor: '::',
																									_0: A2(
																										_MikaelMayer$parser$Parser_ops['|.'],
																										_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Mod),
																										_user$project$LangParserUtils$keywordWithSpace('mod')),
																									_1: {
																										ctor: '::',
																										_0: A2(
																											_MikaelMayer$parser$Parser_ops['|.'],
																											_MikaelMayer$parser$Parser$succeed(_user$project$Lang$Pow),
																											_user$project$LangParserUtils$keywordWithSpace('^')),
																										_1: {
																											ctor: '::',
																											_0: A2(
																												_MikaelMayer$parser$Parser_ops['|.'],
																												_MikaelMayer$parser$Parser$succeed(_user$project$Lang$ArcTan2),
																												_user$project$LangParserUtils$keywordWithSpace('arctan2')),
																											_1: {
																												ctor: '::',
																												_0: A2(
																													_MikaelMayer$parser$Parser_ops['|.'],
																													_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DictInsert),
																													_user$project$LangParserUtils$keywordWithSpace('__DictInsert__')),
																												_1: {
																													ctor: '::',
																													_0: A2(
																														_MikaelMayer$parser$Parser_ops['|.'],
																														_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DictGet),
																														_user$project$LangParserUtils$keywordWithSpace('__DictGet__')),
																													_1: {
																														ctor: '::',
																														_0: A2(
																															_MikaelMayer$parser$Parser_ops['|.'],
																															_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DictRemove),
																															_user$project$LangParserUtils$keywordWithSpace('__DictRemove__')),
																														_1: {
																															ctor: '::',
																															_0: A2(
																																_MikaelMayer$parser$Parser_ops['|.'],
																																_MikaelMayer$parser$Parser$succeed(_user$project$Lang$DebugLog),
																																_user$project$LangParserUtils$keywordWithSpace('debug')),
																															_1: {
																																ctor: '::',
																																_0: A2(
																																	_MikaelMayer$parser$Parser_ops['|.'],
																																	_MikaelMayer$parser$Parser$succeed(_user$project$Lang$NoWidgets),
																																	_user$project$LangParserUtils$keywordWithSpace('noWidgets')),
																																_1: {ctor: '[]'}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}));
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			'operator',
			_MikaelMayer$parser$Parser$lazy(
				function (_p167) {
					return A2(
						_user$project$FastParser$parenBlock,
						F3(
							function (wsStart, _p168, wsEnd) {
								var _p169 = _p168;
								return A5(
									_user$project$Lang$EOp,
									wsStart,
									_user$project$Lang$space0,
									_p169._0,
									A2(_elm_lang$core$List$map, _user$project$Lang$Expr, _p169._1),
									wsEnd);
							}),
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								_MikaelMayer$parser$Parser$succeed(
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										})),
								op),
							A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, _user$project$FastParser$exp)));
				}));
	}());
var _user$project$FastParser$typeAlias = _user$project$LangParserUtils$mapExp_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'type alias',
		A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (_p171, _p170) {
					var _p172 = _p171;
					var _p173 = _p170;
					return A3(
						_user$project$Info$WithInfo,
						A5(
							_user$project$Lang$eTypeAlias__,
							_p172._0,
							_p172._2,
							_p173._0,
							_user$project$Lang$Expr(_p173._3),
							_p173._1),
						_p172._1.start,
						_p173._2.end);
				}),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|.'],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F3(
									function (v0, v1, v2) {
										return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
									})),
							_user$project$FastParser$spaces),
						_user$project$ParserUtils$trackInfo(
							_MikaelMayer$parser$Parser$symbol('('))),
					_user$project$LangParserUtils$keywordWithSpace('def ')),
				_user$project$FastParser$typePattern),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							_MikaelMayer$parser$Parser$succeed(
								F4(
									function (v0, v1, v2, v3) {
										return {ctor: '_Tuple4', _0: v0, _1: v1, _2: v2, _3: v3};
									})),
							_user$project$FastParser$typ),
						_user$project$FastParser$spaces),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$symbol(')'))),
				_user$project$FastParser$exp))));
var _user$project$FastParser$typeCaseExpression = _MikaelMayer$parser$Parser$lazy(
	function (_p174) {
		return A6(
			_user$project$FastParser$genericCase,
			'type case expression',
			'typecase',
			_user$project$Lang$ECase,
			F4(
				function (wsStart, tp, e, wsEnd) {
					return A4(
						_user$project$Lang$Branch_,
						_user$project$Lang$space1,
						_user$project$Lang$withDummyPatInfo(
							A4(
								_user$project$Lang$PColonType,
								_user$project$Lang$space0,
								_user$project$Lang$withDummyPatInfo(
									_user$project$Lang$PWildcard(_user$project$Lang$space0)),
								_user$project$Lang$space1,
								tp)),
						e,
						_user$project$Lang$space1);
				}),
			A2(_MikaelMayer$parser$Parser$map, _user$project$Lang$Expr, _user$project$FastParser$exp),
			_user$project$FastParser$typ);
	});
var _user$project$FastParser$typeDeclaration = _user$project$LangParserUtils$mapExp_(
	A2(
		_MikaelMayer$parser$Parser$inContext,
		'type declaration',
		A3(
			_MikaelMayer$parser$Parser$delayedCommitMap,
			F2(
				function (_p176, _p175) {
					var _p177 = _p176;
					var _p178 = _p175;
					return A3(
						_user$project$Info$WithInfo,
						A5(
							_user$project$Lang$eTyp_,
							_p177._0,
							_p178._0,
							_p178._1,
							_user$project$Lang$Expr(_p178._4),
							_p178._2),
						_p177._1.start,
						_p178._3.end);
				}),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							})),
					_user$project$FastParser$spaces),
				_user$project$ParserUtils$trackInfo(
					_MikaelMayer$parser$Parser$symbol('('))),
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|='],
							A2(
								_MikaelMayer$parser$Parser_ops['|='],
								A2(
									_MikaelMayer$parser$Parser_ops['|.'],
									_MikaelMayer$parser$Parser$succeed(
										F5(
											function (v0, v1, v2, v3, v4) {
												return {ctor: '_Tuple5', _0: v0, _1: v1, _2: v2, _3: v3, _4: v4};
											})),
									_user$project$LangParserUtils$keywordWithSpace('typ')),
								_user$project$FastParser$variablePattern),
							_user$project$FastParser$typ),
						_user$project$FastParser$spaces),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$symbol(')'))),
				_user$project$FastParser$exp))));
var _user$project$FastParser$genericTopLevelDef = F3(
	function (context, kword, isRec) {
		return A2(
			_MikaelMayer$parser$Parser$inContext,
			context,
			A2(
				_user$project$FastParser$parenBlock,
				F4(
					function (wsStart, _p179, wsEnd, rest) {
						var _p180 = _p179;
						return _user$project$Lang$exp_(
							A9(
								_user$project$Lang$eLet__,
								wsStart,
								_user$project$Lang$Def,
								isRec,
								_p180._0,
								_user$project$Lang$space1,
								_user$project$Lang$Expr(_p180._1),
								_user$project$Lang$space1,
								rest,
								wsEnd));
					}),
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						A2(
							_MikaelMayer$parser$Parser_ops['|.'],
							_MikaelMayer$parser$Parser$succeed(
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})),
							_user$project$LangParserUtils$keywordWithSpace(kword)),
						_user$project$FastParser$pattern),
					_user$project$FastParser$exp)));
	});
var _user$project$FastParser$recursiveTopLevelDef = A3(_user$project$FastParser$genericTopLevelDef, 'top-level recursive def binding', 'defrec', true);
var _user$project$FastParser$simpleTopLevelDef = A3(_user$project$FastParser$genericTopLevelDef, 'top-level non-recursive def binding', 'def', false);
var _user$project$FastParser$topLevelDef = A2(
	_MikaelMayer$parser$Parser$inContext,
	'top-level def binding',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _user$project$FastParser$recursiveTopLevelDef,
			_1: {
				ctor: '::',
				_0: _user$project$FastParser$simpleTopLevelDef,
				_1: {ctor: '[]'}
			}
		}));
var _user$project$FastParser$mainExp = _MikaelMayer$parser$Parser$oneOf(
	{
		ctor: '::',
		_0: _user$project$FastParser$exp,
		_1: {
			ctor: '::',
			_0: _user$project$FastParser$implicitMain,
			_1: {ctor: '[]'}
		}
	});
var _user$project$FastParser$topLevelTypeAlias = A2(
	_MikaelMayer$parser$Parser$inContext,
	'top-level type alias',
	A3(
		_MikaelMayer$parser$Parser$delayedCommitMap,
		F2(
			function (_p182, _p181) {
				var _p183 = _p182;
				var _p184 = _p181;
				return A3(
					_user$project$Info$WithInfo,
					function (rest) {
						return _user$project$Lang$exp_(
							A5(_user$project$Lang$eTypeAlias__, _p183._0, _p183._2, _p184._0, rest, _p184._1));
					},
					_p183._1.start,
					_p184._2.end);
			}),
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|.'],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					A2(
						_MikaelMayer$parser$Parser_ops['|='],
						_MikaelMayer$parser$Parser$succeed(
							F3(
								function (v0, v1, v2) {
									return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
								})),
						_user$project$FastParser$spaces),
					_user$project$ParserUtils$trackInfo(
						_MikaelMayer$parser$Parser$symbol('('))),
				_user$project$LangParserUtils$keywordWithSpace('def')),
			_user$project$FastParser$typePattern),
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				A2(
					_MikaelMayer$parser$Parser_ops['|='],
					_MikaelMayer$parser$Parser$succeed(
						F3(
							function (v0, v1, v2) {
								return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
							})),
					_user$project$FastParser$typ),
				_user$project$FastParser$spaces),
			_user$project$ParserUtils$trackInfo(
				_MikaelMayer$parser$Parser$symbol(')')))));
var _user$project$FastParser$topLevelExp = A2(
	_MikaelMayer$parser$Parser$inContext,
	'top-level expression',
	_MikaelMayer$parser$Parser$oneOf(
		{
			ctor: '::',
			_0: _user$project$FastParser$topLevelTypeAlias,
			_1: {
				ctor: '::',
				_0: _user$project$FastParser$topLevelDef,
				_1: {
					ctor: '::',
					_0: _user$project$FastParser$topLevelTypeDeclaration,
					_1: {ctor: '[]'}
				}
			}
		}));
var _user$project$FastParser$allTopLevelExps = A2(_MikaelMayer$parser$Parser$repeat, _MikaelMayer$parser$Parser$zeroOrMore, _user$project$FastParser$topLevelExp);
var _user$project$FastParser$program = A2(
	_MikaelMayer$parser$Parser_ops['|.'],
	A2(
		_MikaelMayer$parser$Parser_ops['|.'],
		A2(
			_MikaelMayer$parser$Parser_ops['|='],
			A2(
				_MikaelMayer$parser$Parser_ops['|='],
				_MikaelMayer$parser$Parser$succeed(_user$project$TopLevelExp$fuseTopLevelExps),
				_user$project$FastParser$allTopLevelExps),
			_user$project$FastParser$mainExp),
		_user$project$FastParser$spaces),
	_MikaelMayer$parser$Parser$end);
var _user$project$FastParser$parseE_ = function (f) {
	return _MikaelMayer$parser$Parser$run(
		A2(
			_MikaelMayer$parser$Parser$map,
			function (_p185) {
				return f(
					_user$project$Lang$Expr(_p185));
			},
			_user$project$FastParser$program));
};
var _user$project$FastParser$parseE = _user$project$FastParser$parseE_(_user$project$FastParser$freshen);
var _user$project$FastParser$parse = _user$project$FastParser$parseE;

var _user$project$LeoUnparser$getPatAssociativity = function (pat) {
	var _p0 = pat.val.p__;
	_v0_2:
	do {
		switch (_p0.ctor) {
			case 'PList':
				if (_p0._3.ctor === 'Just') {
					var _p1 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, '::', _user$project$LeoParser$builtInPatternPrecedenceTable);
					if (_p1.ctor === 'Nothing') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Just(_p1._0._0);
					}
				} else {
					break _v0_2;
				}
			case 'PAs':
				var _p2 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, 'as', _user$project$LeoParser$builtInPatternPrecedenceTable);
				if (_p2.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(_p2._0._0);
				}
			default:
				break _v0_2;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$LeoUnparser$getPatPrecedence = function (pat) {
	var _p3 = pat.val.p__;
	_v3_3:
	do {
		switch (_p3.ctor) {
			case 'PList':
				if (_p3._3.ctor === 'Just') {
					var _p4 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, '::', _user$project$LeoParser$builtInPatternPrecedenceTable);
					if (_p4.ctor === 'Nothing') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Just(_p4._0._1);
					}
				} else {
					break _v3_3;
				}
			case 'PAs':
				var _p5 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, 'as', _user$project$LeoParser$builtInPatternPrecedenceTable);
				if (_p5.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(_p5._0._1);
				}
			case 'PColonType':
				return _elm_lang$core$Maybe$Just(9);
			default:
				break _v3_3;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$LeoUnparser$regexEscapeStyle = _elm_lang$core$Regex$regex('&(?=\\w+)|</style');
var _user$project$LeoUnparser$regexEscapeScript = _elm_lang$core$Regex$regex('&(?=\\w+)|</script');
var _user$project$LeoUnparser$regexExcape = _elm_lang$core$Regex$regex('&(?=\\w+)|<(?!\\s)|>(?!\\s)');
var _user$project$LeoUnparser$htmlContentRegexEscape = _elm_lang$core$Regex$regex('@');
var _user$project$LeoUnparser$elmToHTMLEscapeRegex = _elm_lang$core$Regex$regex('\\\\\"|\\\\\'|\\\\t|(\\\\r)?\\\\n|\\\\\\\\');
var _user$project$LeoUnparser$elmToHTMLEscape = function (text) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$All,
		_user$project$LeoUnparser$elmToHTMLEscapeRegex,
		function (m) {
			var _p6 = m.match;
			switch (_p6) {
				case '\\\"':
					return '&quot;';
				case '\\\'':
					return '&#x27;';
				case '\\t':
					return '&#x9;';
				case '\\r\\n':
					return '&#10;';
				case '\\n':
					return '&#10;';
				case '\\r':
					return '&#10;';
				case '\\\\':
					return '\\';
				default:
					return _p6;
			}
		},
		text);
};
var _user$project$LeoUnparser$dummyExp = _user$project$Lang$withDummyExpInfo(
	A5(
		_user$project$Lang$EApp,
		_user$project$Lang$space0,
		_user$project$Lang$eVar('x'),
		{ctor: '[]'},
		_user$project$Lang$SpaceApp,
		_user$project$Lang$space0));
var _user$project$LeoUnparser$noInterpolationConflict = F2(
	function (varString, rightString) {
		return A2(_elm_lang$core$String$endsWith, ')', varString) || (A2(_elm_lang$core$String$endsWith, ']', varString) || (A2(
			_elm_lang$core$Regex$contains,
			_elm_lang$core$Regex$regex('[\\w_\\$]$'),
			varString) && A2(
			_elm_lang$core$Regex$contains,
			_elm_lang$core$Regex$regex('^[^\\w_\\$\\.]|^$'),
			rightString)));
	});
var _user$project$LeoUnparser$multilineRegexEscape = _elm_lang$core$Regex$regex('@|\"\"\"');
var _user$project$LeoUnparser$unparseLongStringContent = function (s) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$All,
		_user$project$LeoUnparser$multilineRegexEscape,
		function (m) {
			var _p7 = m.match;
			switch (_p7) {
				case '@':
					return '@@';
				case '\"\"\"':
					return '@(\"\\\"\\\"\\\"\")';
				default:
					return m.match;
			}
		},
		s);
};
var _user$project$LeoUnparser$onlyImplicitMain = function (letExps) {
	var _p8 = letExps;
	if (((((_p8.ctor === '::') && (_p8._0.ctor === '_Tuple2')) && (_p8._0._1.ctor === '::')) && (_p8._0._1._1.ctor === '[]')) && (_p8._1.ctor === '[]')) {
		var _p9 = _p8._0._1._0._2.val.p__;
		if ((_p9.ctor === 'PVar') && (_p9._1 === '_IMPLICIT_MAIN')) {
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
var _user$project$LeoUnparser$wrapWithTightParens = function (unparsed) {
	var trimmed = _elm_lang$core$String$trimLeft(unparsed);
	var lengthDiff = _elm_lang$core$String$length(unparsed) - _elm_lang$core$String$length(trimmed);
	var ws = A2(_elm_lang$core$String$left, lengthDiff, unparsed);
	return A2(
		_elm_lang$core$Basics_ops['++'],
		ws,
		A2(
			_elm_lang$core$Basics_ops['++'],
			'(',
			A2(_elm_lang$core$Basics_ops['++'], trimmed, ')')));
};
var _user$project$LeoUnparser$unparseOp = function (op) {
	var _p10 = op.val;
	switch (_p10.ctor) {
		case 'Pi':
			return 'pi';
		case 'DictEmpty':
			return '__DictEmpty__';
		case 'CurrentEnv':
			return '__CurrentEnv__';
		case 'DictFromList':
			return '__DictFromList__';
		case 'Cos':
			return 'cos';
		case 'Sin':
			return 'sin';
		case 'ArcCos':
			return 'arccos';
		case 'ArcSin':
			return 'arcsin';
		case 'Floor':
			return 'floor';
		case 'Ceil':
			return 'ceiling';
		case 'Round':
			return 'round';
		case 'ToStr':
			return 'toString';
		case 'Sqrt':
			return 'sqrt';
		case 'Explode':
			return 'explode';
		case 'Plus':
			return '+';
		case 'Minus':
			return '-';
		case 'Mult':
			return '*';
		case 'Div':
			return '/';
		case 'Lt':
			return '<';
		case 'Eq':
			return '==';
		case 'Mod':
			return 'mod';
		case 'Pow':
			return '^';
		case 'ArcTan2':
			return 'arctan2';
		case 'DictInsert':
			return '__DictInsert__';
		case 'DictGet':
			return '__DictGet__';
		case 'DictRemove':
			return '__DictRemove__';
		case 'DebugLog':
			return 'debug';
		case 'NoWidgets':
			return 'noWidgets';
		case 'ToStrExceptStr':
			return 'ToStrExceptStr';
		case 'RegexExtractFirstIn':
			return 'extractFirstIn';
		default:
			return '__strLength__';
	}
};
var _user$project$LeoUnparser$getExpAssociativity = function (exp) {
	var _p11 = _user$project$Lang$unwrapExp(exp);
	_v11_6:
	do {
		switch (_p11.ctor) {
			case 'EList':
				if (((_p11._1.ctor === '::') && (_p11._1._1.ctor === '[]')) && (_p11._3.ctor === 'Just')) {
					return _elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Right);
				} else {
					break _v11_6;
				}
			case 'EApp':
				switch (_p11._3.ctor) {
					case 'LeftApp':
						return _elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Right);
					case 'RightApp':
						return _elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Left);
					case 'InfixApp':
						var _p12 = _user$project$Lang$unwrapExp(_p11._1);
						if (_p12.ctor === 'EVar') {
							var _p13 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, _p12._1, _user$project$LeoParser$builtInPrecedenceTable);
							if (_p13.ctor === 'Nothing') {
								return _elm_lang$core$Maybe$Nothing;
							} else {
								return _elm_lang$core$Maybe$Just(_p13._0._0);
							}
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					default:
						break _v11_6;
				}
			case 'EColonType':
				return _elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Left);
			case 'EOp':
				var _p14 = A2(
					_user$project$BinaryOperatorParser$getOperatorInfo,
					_user$project$LeoUnparser$unparseOp(_p11._2),
					_user$project$LeoParser$builtInPrecedenceTable);
				if (_p14.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(_p14._0._0);
				}
			default:
				break _v11_6;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$LeoUnparser$unparseTypePattern = function (p) {
	var _p15 = p.val;
	return A2(_elm_lang$core$Basics_ops['++'], _p15._0.val, _p15._1);
};
var _user$project$LeoUnparser$getTypeParametersBinding = F2(
	function (funArgStyle, binding_) {
		var _p16 = function () {
			var _p17 = {ctor: '_Tuple2', _0: funArgStyle, _1: binding_.val.t__};
			if (((_p17.ctor === '_Tuple2') && (_p17._0.ctor === 'FunArgAsPats')) && (_p17._1.ctor === 'TForall')) {
				var _p19 = _p17._1._1;
				var $default = {ctor: '_Tuple2', _0: _p19, _1: _p17._1._2};
				var _p18 = _p19;
				if ((_p18.ctor === '::') && (_p18._1.ctor === '[]')) {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$tpVarUnapply(_p18._0),
						_elm_lang$core$Maybe$Just(_user$project$LeoParser$implicitVarName)) ? {
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: binding_
					} : $default;
				} else {
					return $default;
				}
			} else {
				return {
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: binding_
				};
			}
		}();
		var parameters = _p16._0;
		var binding = _p16._1;
		var strParametersDefault = _elm_lang$core$String$concat(
			A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseTypePattern, parameters));
		var strParameters = function () {
			var _p20 = {
				ctor: '_Tuple2',
				_0: parameters,
				_1: A2(_elm_lang$core$String$startsWith, ' ', strParametersDefault)
			};
			if (((_p20.ctor === '_Tuple2') && (_p20._0.ctor === '::')) && (_p20._1 === false)) {
				return A2(_elm_lang$core$Basics_ops['++'], ' ', strParametersDefault);
			} else {
				return strParametersDefault;
			}
		}();
		return {ctor: '_Tuple2', _0: strParameters, _1: binding};
	});
var _user$project$LeoUnparser$getArgConstructorNameString = function (keyValues) {
	return A2(_user$project$Utils$maybeFind, _user$project$Lang$ctorArgs, keyValues);
};
var _user$project$LeoUnparser$getDataConstructorNameString = function (keyValues) {
	var ctorString = _user$project$Lang$stringifyCtorKind(_user$project$Lang$DataTypeCtor);
	return A2(_user$project$Utils$maybeFind, ctorString, keyValues);
};
var _user$project$LeoUnparser$tryUnparseDataConstructor = F6(
	function (unparseTerm, name, args, wsBefore, fields, wsBeforeEnd) {
		var keyValues = A2(
			_elm_lang$core$List$map,
			function (_p21) {
				var _p22 = _p21;
				return {ctor: '_Tuple2', _0: _p22._2, _1: _p22._4};
			},
			fields);
		var maybeNameString = A2(
			_elm_lang$core$Maybe$andThen,
			name,
			_user$project$LeoUnparser$getDataConstructorNameString(keyValues));
		var maybeArgs = A2(
			_elm_lang$core$Maybe$andThen,
			args,
			A2(_user$project$Utils$maybeFind, _user$project$Lang$ctorArgs, keyValues));
		var ctorString = _user$project$Lang$stringifyCtorKind(_user$project$Lang$DataTypeCtor);
		var _p23 = {ctor: '_Tuple2', _0: maybeNameString, _1: maybeArgs};
		if (((_p23.ctor === '_Tuple2') && (_p23._0.ctor === 'Just')) && (_p23._1.ctor === 'Just')) {
			var argsString = _elm_lang$core$String$concat(
				A2(
					_elm_lang$core$List$map,
					function (_p24) {
						var _p25 = _p24;
						return unparseTerm(_p25._4);
					},
					A2(
						_elm_lang$core$List$sortBy,
						function (_p26) {
							var _p27 = _p26;
							return A2(
								_elm_lang$core$Result$withDefault,
								-1,
								_elm_lang$core$String$toInt(
									A2(_elm_lang$core$String$dropLeft, 1, _p27._2)));
						},
						A2(
							_elm_lang$core$List$filter,
							function (_p28) {
								var _p29 = _p28;
								return A2(_elm_lang$core$String$startsWith, '_', _p29._2);
							},
							_p23._1._0))));
			return _elm_lang$core$Maybe$Just(
				A2(
					_elm_lang$core$Basics_ops['++'],
					wsBefore.val,
					A2(_elm_lang$core$Basics_ops['++'], _p23._0._0, argsString)));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$LeoUnparser$getKeyValuesFromDecls = function (_p30) {
	var _p31 = _p30;
	return _user$project$Utils$projJusts(
		A2(
			_elm_lang$core$List$map,
			function (_p32) {
				var _p33 = _p32;
				var _p34 = _p33._2.val.p__;
				if (_p34.ctor === 'PVar') {
					return _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple2', _0: _p34._1, _1: _p33._5});
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			_user$project$Lang$elemsOf(_p31._3)));
};
var _user$project$LeoUnparser$getExpPrecedence = function (exp) {
	getExpPrecedence:
	while (true) {
		var _p35 = _user$project$Lang$unwrapExp(exp);
		_v27_9:
		do {
			switch (_p35.ctor) {
				case 'EList':
					if (((_p35._1.ctor === '::') && (_p35._1._1.ctor === '[]')) && (_p35._3.ctor === 'Just')) {
						return _elm_lang$core$Maybe$Just(5);
					} else {
						break _v27_9;
					}
				case 'EApp':
					switch (_p35._3.ctor) {
						case 'LeftApp':
							return _elm_lang$core$Maybe$Just(0);
						case 'RightApp':
							return _elm_lang$core$Maybe$Just(0);
						case 'InfixApp':
							var _p36 = _user$project$Lang$unwrapExp(_p35._1);
							if (_p36.ctor === 'EVar') {
								var _p37 = A2(_user$project$BinaryOperatorParser$getOperatorInfo, _p36._1, _user$project$LeoParser$builtInPrecedenceTable);
								if (_p37.ctor === 'Nothing') {
									return _elm_lang$core$Maybe$Nothing;
								} else {
									return _elm_lang$core$Maybe$Just(_p37._0._1);
								}
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						default:
							return _elm_lang$core$Maybe$Just(10);
					}
				case 'ERecord':
					var _p38 = _user$project$LeoUnparser$getKeyValuesFromDecls(_p35._2);
					if (_p38.ctor === 'Just') {
						var _p42 = _p38._0;
						var _p39 = _user$project$LeoUnparser$getDataConstructorNameString(_p42);
						if (_p39.ctor === 'Just') {
							var _p40 = _user$project$LeoUnparser$getArgConstructorNameString(_p42);
							if (_p40.ctor === 'Just') {
								var _p41 = _user$project$Lang$eRecord__Unapply(
									_user$project$Lang$unwrapExp(_p40._0));
								if (((_p41.ctor === 'Just') && (_p41._0.ctor === '_Tuple3')) && (_p41._0._1.ctor === '[]')) {
									return _elm_lang$core$Maybe$Just(10);
								} else {
									return _elm_lang$core$Maybe$Just(9);
								}
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				case 'EColonType':
					return _elm_lang$core$Maybe$Just(-1);
				case 'EOp':
					var _p43 = A2(
						_user$project$BinaryOperatorParser$getOperatorInfo,
						_user$project$LeoUnparser$unparseOp(_p35._2),
						_user$project$LeoParser$builtInPrecedenceTable);
					if (_p43.ctor === 'Nothing') {
						return _elm_lang$core$Maybe$Just(10);
					} else {
						return _elm_lang$core$Maybe$Just(_p43._0._1);
					}
				case 'EParens':
					if (_p35._2.ctor === 'LeoSyntax') {
						var _v35 = _p35._1;
						exp = _v35;
						continue getExpPrecedence;
					} else {
						break _v27_9;
					}
				default:
					break _v27_9;
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$tryUnparseTuple = F4(
	function (unparseTerm, wsBefore, keyValues, wsBeforeEnd) {
		var _p44 = _user$project$Lang$tupleEncodingUnapply(keyValues);
		if (_p44.ctor === 'Nothing') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var inside = A2(
				_elm_lang$core$String$join,
				'',
				A2(
					_elm_lang$core$List$map,
					function (_p45) {
						var _p46 = _p45;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$Maybe$withDefault,
								'',
								A2(
									_elm_lang$core$Maybe$map,
									function (spc) {
										return A2(_elm_lang$core$Basics_ops['++'], spc.val, ',');
									},
									_p46._0)),
							unparseTerm(_p46._1));
					},
					_p44._0));
			return _elm_lang$core$Maybe$Just(
				A2(
					_elm_lang$core$Basics_ops['++'],
					wsBefore.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							inside,
							A2(_elm_lang$core$Basics_ops['++'], wsBeforeEnd.val, ')')))));
		}
	});
var _user$project$LeoUnparser$tryUnparseRecordSugars = F7(
	function (unparseTerm, name, args, wsBefore, decls, wsBeforeEnd, $default) {
		var _p47 = A4(_user$project$LeoUnparser$tryUnparseTuple, unparseTerm, wsBefore, decls, wsBeforeEnd);
		if (_p47.ctor === 'Just') {
			return _p47._0;
		} else {
			var _p48 = A6(_user$project$LeoUnparser$tryUnparseDataConstructor, unparseTerm, name, args, wsBefore, decls, wsBeforeEnd);
			if (_p48.ctor === 'Just') {
				return _p48._0;
			} else {
				return $default(
					{ctor: '_Tuple0'});
			}
		}
	});
var _user$project$LeoUnparser$typeArgs = function (t) {
	var _p49 = t.val.t__;
	if (_p49.ctor === 'TRecord') {
		return _elm_lang$core$Maybe$Just(_p49._2);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$patArgs = function (p) {
	var _p50 = p.val.p__;
	if (_p50.ctor === 'PRecord') {
		return _elm_lang$core$Maybe$Just(_p50._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$expArgs = function (e) {
	var _p51 = _user$project$Lang$unwrapExp(e);
	if (_p51.ctor === 'ERecord') {
		return _user$project$Lang$recordEntriesFromDeclarations(_p51._2);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$typeName = function (t) {
	var _p52 = t.val.t__;
	if (_p52.ctor === 'TVar') {
		return _elm_lang$core$Maybe$Just(_p52._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$unparseType = function (tipe) {
	var _p53 = tipe.val.t__;
	switch (_p53.ctor) {
		case 'TNum':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, 'Num');
		case 'TBool':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, 'Bool');
		case 'TString':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, 'String');
		case 'TNull':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, 'Null');
		case 'TList':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'List',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparseType(_p53._1),
						_p53._2.val)));
		case 'TDict':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Dict',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparseType(_p53._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparseType(_p53._2),
							_p53._3.val))));
		case 'TTuple':
			var _p57 = _p53._4;
			var _p56 = _p53._0;
			var _p55 = _p53._1;
			var _p54 = _p53._3;
			if (_p54.ctor === 'Just') {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p56.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseType, _p55)),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p53._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'|',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparseType(_p54._0),
										A2(_elm_lang$core$Basics_ops['++'], _p57.val, ']')))))));
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p56.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$String$concat(
								A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseType, _p55)),
							A2(_elm_lang$core$Basics_ops['++'], _p57.val, ']'))));
			}
		case 'TRecord':
			var _p64 = _p53._0;
			var _p63 = _p53._3;
			var _p62 = _p53._2;
			return A7(
				_user$project$LeoUnparser$tryUnparseRecordSugars,
				_user$project$LeoUnparser$unparseType,
				_user$project$LeoUnparser$typeName,
				_user$project$LeoUnparser$typeArgs,
				_p64,
				_p62,
				_p63,
				function (_p58) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p64.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'{',
							A2(
								_elm_lang$core$Basics_ops['++'],
								function () {
									var _p59 = _p53._1;
									if (_p59.ctor === 'Just') {
										return A2(_elm_lang$core$Basics_ops['++'], _p59._0._0, _p59._0._1.val);
									} else {
										return '';
									}
								}(),
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(
										_elm_lang$core$String$join,
										',',
										A2(
											_elm_lang$core$List$map,
											function (_p60) {
												var _p61 = _p60;
												return A2(
													_elm_lang$core$Basics_ops['++'],
													A2(
														_elm_lang$core$Maybe$withDefault,
														'',
														A2(
															_elm_lang$core$Maybe$map,
															function (_) {
																return _.val;
															},
															_p61._0)),
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p61._1.val,
														A2(
															_elm_lang$core$Basics_ops['++'],
															_p61._2,
															A2(
																_elm_lang$core$Basics_ops['++'],
																_p61._3.val,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	':',
																	_user$project$LeoUnparser$unparseType(_p61._4))))));
											},
											_p62)),
									A2(_elm_lang$core$Basics_ops['++'], _p63.val, '}')))));
				});
		case 'TArrow':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(->',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseType, _p53._1)),
						A2(_elm_lang$core$Basics_ops['++'], _p53._2.val, ')'))));
		case 'TUnion':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(union',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$String$concat(
							A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseType, _p53._1)),
						A2(_elm_lang$core$Basics_ops['++'], _p53._2.val, ')'))));
		case 'TApp':
			var _p68 = _p53._0;
			var _p67 = _p53._2;
			var _p66 = _p53._1;
			var _p65 = {ctor: '_Tuple2', _0: _p53._3, _1: _p67};
			_v48_3:
			do {
				if (_p65._1.ctor === '::') {
					if (_p65._1._1.ctor === '[]') {
						switch (_p65._0.ctor) {
							case 'LeftApp':
								return A2(
									_elm_lang$core$Basics_ops['++'],
									_p68.val,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparseType(_p66),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p65._0._0.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'<|',
												_user$project$LeoUnparser$unparseType(_p65._1._0)))));
							case 'RightApp':
								return A2(
									_elm_lang$core$Basics_ops['++'],
									_p68.val,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparseType(_p65._1._0),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p65._0._0.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'|>',
												_user$project$LeoUnparser$unparseType(_p66)))));
							default:
								break _v48_3;
						}
					} else {
						if ((_p65._0.ctor === 'InfixApp') && (_p65._1._1._1.ctor === '[]')) {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p68.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparseType(_p65._1._0),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparseType(_p66),
										_user$project$LeoUnparser$unparseType(_p65._1._1._0))));
						} else {
							break _v48_3;
						}
					}
				} else {
					break _v48_3;
				}
			} while(false);
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p68.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LeoUnparser$unparseType(_p66),
					_elm_lang$core$String$concat(
						A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseType, _p67))));
		case 'TVar':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, _p53._1);
		case 'TWildcard':
			return A2(_elm_lang$core$Basics_ops['++'], _p53._0.val, '_');
		case 'TForall':
			var sVars = _elm_lang$core$String$concat(
				A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparseTypePattern, _p53._1));
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'forall',
					A2(
						_elm_lang$core$Basics_ops['++'],
						sVars,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p53._3.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'.',
								_user$project$LeoUnparser$unparseType(_p53._2))))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p53._0.val,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparseType(_p53._1),
						A2(_elm_lang$core$Basics_ops['++'], _p53._2.val, ')'))));
	}
};
var _user$project$LeoUnparser$patName = function (p) {
	var _p69 = p.val.p__;
	if (_p69.ctor === 'PBase') {
		var _p70 = _p69._1;
		if (_p70.ctor === 'EString') {
			return _elm_lang$core$Maybe$Just(_p70._1);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$expName = function (e) {
	var _p71 = _user$project$Lang$unwrapExp(e);
	if (_p71.ctor === 'EBase') {
		var _p72 = _p71._1;
		if (_p72.ctor === 'EString') {
			return _elm_lang$core$Maybe$Just(_p72._1);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LeoUnparser$unparseBaseValue = function (ebv) {
	var _p73 = ebv;
	switch (_p73.ctor) {
		case 'EBool':
			return _p73._0 ? 'True' : 'False';
		case 'EString':
			var _p74 = _p73._0;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				_p74,
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_user$project$ParserUtils$unparseStringContent, _p74, _p73._1),
					_p74));
		default:
			return 'null';
	}
};
var _user$project$LeoUnparser$unparseWD = function (wd) {
	var strHidden = function (bool) {
		return bool ? ',\"hidden\"' : '';
	};
	var _p75 = wd.val;
	switch (_p75.ctor) {
		case 'NoWidgetDecl':
			return '';
		case 'IntSlider':
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'{',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p75._0.val),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p75._1.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(_p75._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								strHidden(_p75._4),
								'}')))));
		default:
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'{',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(_p75._0.val),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p75._1.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(_p75._2.val),
							A2(
								_elm_lang$core$Basics_ops['++'],
								strHidden(_p75._4),
								'}')))));
	}
};
var _user$project$LeoUnparser$StyleInterpolated = {ctor: 'StyleInterpolated'};
var _user$project$LeoUnparser$ScriptInterpolated = {ctor: 'ScriptInterpolated'};
var _user$project$LeoUnparser$Raw = {ctor: 'Raw'};
var _user$project$LeoUnparser$unparseHtmlTextContent = F2(
	function (style, content) {
		return (_elm_lang$core$Native_Utils.eq(style, _user$project$LeoUnparser$Raw) ? _elm_lang$core$Basics$identity : (_elm_lang$core$Native_Utils.eq(style, _user$project$LeoUnparser$ScriptInterpolated) ? A3(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_user$project$LeoUnparser$regexEscapeScript,
			function (m) {
				var _p76 = m.match;
				switch (_p76) {
					case '&':
						return '&amp;';
					case '</script':
						return '&lt;/script';
					default:
						return m.match;
				}
			}) : (_elm_lang$core$Native_Utils.eq(style, _user$project$LeoUnparser$StyleInterpolated) ? A3(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_user$project$LeoUnparser$regexEscapeScript,
			function (m) {
				var _p77 = m.match;
				switch (_p77) {
					case '&':
						return '&amp;';
					case '</style':
						return '&lt;/style';
					default:
						return m.match;
				}
			}) : A3(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_user$project$LeoUnparser$regexExcape,
			function (m) {
				var _p78 = m.match;
				switch (_p78) {
					case '&':
						return '&amp;';
					case '<':
						return '&lt;';
					case '>':
						return '&gt;';
					default:
						return m.match;
				}
			}))))(
			(_elm_lang$core$Native_Utils.eq(style, _user$project$LeoUnparser$Raw) ? _elm_lang$core$Basics$identity : A3(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$All,
				_user$project$LeoUnparser$htmlContentRegexEscape,
				function (m) {
					return '@@';
				}))(content));
	});
var _user$project$LeoUnparser$Interpolated = {ctor: 'Interpolated'};
var _user$project$LeoUnparser$OpRight = {ctor: 'OpRight'};
var _user$project$LeoUnparser$OpLeft = {ctor: 'OpLeft'};
var _user$project$LeoUnparser$wrapWithParensIfLessPrecedence_ = F6(
	function (getPrecedence, getAssociativity, opDir, outsideExp, insideExp, unparsedInsideExpr) {
		var inPrecedenceMb = getPrecedence(insideExp);
		var _p79 = inPrecedenceMb;
		if (_p79.ctor === 'Nothing') {
			return unparsedInsideExpr;
		} else {
			var _p82 = _p79._0;
			var precedenceMb = getPrecedence(outsideExp);
			var _p80 = precedenceMb;
			if (_p80.ctor === 'Nothing') {
				return unparsedInsideExpr;
			} else {
				var _p81 = _p80._0;
				var inAssociativity = getAssociativity(insideExp);
				var associativity = getAssociativity(outsideExp);
				return (_elm_lang$core$Native_Utils.cmp(_p82, _p81) < 0) ? _user$project$LeoUnparser$wrapWithTightParens(unparsedInsideExpr) : (_elm_lang$core$Native_Utils.eq(_p82, _p81) ? ((_elm_lang$core$Native_Utils.eq(associativity, inAssociativity) && ((_elm_lang$core$Native_Utils.eq(
					associativity,
					_elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Left)) && _elm_lang$core$Native_Utils.eq(opDir, _user$project$LeoUnparser$OpLeft)) || (_elm_lang$core$Native_Utils.eq(
					associativity,
					_elm_lang$core$Maybe$Just(_user$project$BinaryOperatorParser$Right)) && _elm_lang$core$Native_Utils.eq(opDir, _user$project$LeoUnparser$OpRight)))) ? unparsedInsideExpr : _user$project$LeoUnparser$wrapWithTightParens(unparsedInsideExpr)) : unparsedInsideExpr);
			}
		}
	});
var _user$project$LeoUnparser$wrapWithParensIfLessPrecedence = A2(_user$project$LeoUnparser$wrapWithParensIfLessPrecedence_, _user$project$LeoUnparser$getExpPrecedence, _user$project$LeoUnparser$getExpAssociativity);
var _user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence = A2(_user$project$LeoUnparser$wrapWithParensIfLessPrecedence_, _user$project$LeoUnparser$getPatPrecedence, _user$project$LeoUnparser$getPatAssociativity);
var _user$project$LeoUnparser$unparsePattern = function (p) {
	unparsePattern:
	while (true) {
		var _p83 = p.val.p__;
		switch (_p83.ctor) {
			case 'PVar':
				return A2(_elm_lang$core$Basics_ops['++'], _p83._0.val, _p83._1);
			case 'PConst':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p83._0.val,
					_elm_lang$core$Basics$toString(_p83._1));
			case 'PBase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p83._0.val,
					_user$project$LeoUnparser$unparseBaseValue(_p83._1));
			case 'PWildcard':
				return A2(_elm_lang$core$Basics_ops['++'], _p83._0.val, '_');
			case 'PParens':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p83._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparsePattern(_p83._1),
							A2(_elm_lang$core$Basics_ops['++'], _p83._2.val, ')'))));
			case 'PList':
				if (_p83._3.ctor === 'Nothing') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p83._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$String$join,
									',',
									A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparsePattern, _p83._1)),
								A2(_elm_lang$core$Basics_ops['++'], _p83._4.val, ']'))));
				} else {
					if (_p83._1.ctor === '::') {
						if (_p83._1._1.ctor === '[]') {
							var _p85 = _p83._3._0;
							var _p84 = _p83._1._0;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p83._0.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A4(
										_user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence,
										_user$project$LeoUnparser$OpLeft,
										p,
										_p84,
										_user$project$LeoUnparser$unparsePattern(_p84)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p83._2.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'::',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A4(
													_user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence,
													_user$project$LeoUnparser$OpRight,
													p,
													_p85,
													_user$project$LeoUnparser$unparsePattern(_p85)),
												_p83._4.val)))));
						} else {
							var _p88 = _p83._2;
							var _p87 = _p83._4;
							var _p86 = _p83._0;
							var _v61 = A2(
								_user$project$Lang$replaceP__,
								p,
								A5(
									_user$project$Lang$PList,
									_p86,
									{
										ctor: '::',
										_0: _p83._1._0,
										_1: {ctor: '[]'}
									},
									_p88,
									_elm_lang$core$Maybe$Just(
										A2(
											_user$project$Lang$replaceP__,
											p,
											A5(
												_user$project$Lang$PList,
												_p86,
												_p83._1._1,
												_p88,
												_elm_lang$core$Maybe$Just(_p83._3._0),
												_p87))),
									_p87));
							p = _v61;
							continue unparsePattern;
						}
					} else {
						var _v62 = _p83._3._0;
						p = _v62;
						continue unparsePattern;
					}
				}
			case 'PRecord':
				var _p96 = _p83._0;
				var _p95 = _p83._2;
				var _p94 = _p83._1;
				return A7(
					_user$project$LeoUnparser$tryUnparseRecordSugars,
					_user$project$LeoUnparser$unparsePattern,
					_user$project$LeoUnparser$patName,
					_user$project$LeoUnparser$patArgs,
					_p96,
					_p94,
					_p95,
					function (_p89) {
						var maybeJustKey = F3(
							function (eqSpace, key, value) {
								var $default = A2(
									_elm_lang$core$Basics_ops['++'],
									eqSpace,
									A2(
										_elm_lang$core$Basics_ops['++'],
										'=',
										_user$project$LeoUnparser$unparsePattern(value)));
								if (_elm_lang$core$Native_Utils.eq(eqSpace, '')) {
									var _p90 = value.val.p__;
									if (_p90.ctor === 'PVar') {
										return _elm_lang$core$Native_Utils.eq(_p90._1, key) ? '' : $default;
									} else {
										return $default;
									}
								} else {
									return $default;
								}
							});
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p96.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'{',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$String$concat(
										A2(
											_elm_lang$core$List$map,
											function (_p91) {
												var _p92 = _p91;
												var _p93 = _p92._2;
												return A2(
													_elm_lang$core$Basics_ops['++'],
													A2(
														_elm_lang$core$Maybe$withDefault,
														'',
														A2(
															_elm_lang$core$Maybe$map,
															function (wsComma) {
																return A2(_elm_lang$core$Basics_ops['++'], wsComma.val, ',');
															},
															_p92._0)),
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p92._1.val,
														A2(
															_elm_lang$core$Basics_ops['++'],
															_p93,
															A3(maybeJustKey, _p92._3.val, _p93, _p92._4))));
											},
											_p94)),
									A2(_elm_lang$core$Basics_ops['++'], _p95.val, '}'))));
					});
			case 'PAs':
				var _p98 = _p83._3;
				var _p97 = _p83._1;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p83._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						A4(
							_user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence,
							_user$project$LeoUnparser$OpLeft,
							p,
							_p97,
							_user$project$LeoUnparser$unparsePattern(_p97)),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p83._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'as',
								A4(
									_user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence,
									_user$project$LeoUnparser$OpLeft,
									p,
									_p98,
									_user$project$LeoUnparser$unparsePattern(_p98))))));
			default:
				var _p99 = _p83._1;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p83._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						A4(
							_user$project$LeoUnparser$wrapPatternWithParensIfLessPrecedence,
							_user$project$LeoUnparser$OpLeft,
							p,
							_p99,
							_user$project$LeoUnparser$unparsePattern(_p99)),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p83._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								':',
								_user$project$LeoUnparser$unparseType(_p83._3)))));
		}
	}
};
var _user$project$LeoUnparser$getParametersBinding = F2(
	function (funArgStyle, binding_) {
		var _p100 = function () {
			var _p101 = {
				ctor: '_Tuple2',
				_0: funArgStyle,
				_1: _user$project$Lang$unwrapExp(binding_)
			};
			if (((_p101.ctor === '_Tuple2') && (_p101._0.ctor === 'FunArgAsPats')) && (_p101._1.ctor === 'EFun')) {
				var _p103 = _p101._1._1;
				var $default = {ctor: '_Tuple2', _0: _p103, _1: _p101._1._2};
				var _p102 = _p103;
				if ((_p102.ctor === '::') && (_p102._1.ctor === '[]')) {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$pVarUnapply(_p102._0),
						_elm_lang$core$Maybe$Just(_user$project$LeoParser$implicitVarName)) ? {
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: binding_
					} : $default;
				} else {
					return $default;
				}
			} else {
				return {
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: binding_
				};
			}
		}();
		var parameters = _p100._0;
		var binding = _p100._1;
		var strParametersDefault = _elm_lang$core$String$concat(
			A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparsePattern, parameters));
		var strParameters = function () {
			var _p104 = {
				ctor: '_Tuple2',
				_0: parameters,
				_1: A2(_elm_lang$core$String$startsWith, ' ', strParametersDefault)
			};
			if (((_p104.ctor === '_Tuple2') && (_p104._0.ctor === '::')) && (_p104._1 === false)) {
				return A2(_elm_lang$core$Basics_ops['++'], ' ', strParametersDefault);
			} else {
				return strParametersDefault;
			}
		}();
		return {ctor: '_Tuple2', _0: strParameters, _1: binding};
	});
var _user$project$LeoUnparser$unparseDeclarations = function (declarations) {
	return A3(
		_user$project$Utils$foldLeft,
		'',
		_user$project$Lang$getDeclarationsInOrder(declarations),
		F2(
			function (acc, decl) {
				return A2(
					F2(
						function (x, y) {
							return A2(_elm_lang$core$Basics_ops['++'], x, y);
						}),
					acc,
					function () {
						var _p105 = decl;
						switch (_p105.ctor) {
							case 'DeclExp':
								return A2(
									_elm_lang$core$Basics_ops['++'],
									function () {
										var _p106 = _p105._0._0;
										if (_p106.ctor === 'Just') {
											return A2(_elm_lang$core$Basics_ops['++'], _p106._0.val, ',');
										} else {
											return '';
										}
									}(),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p105._0._1.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparsePattern(_p105._0._2),
											function () {
												var _p107 = A2(_user$project$LeoUnparser$getParametersBinding, _p105._0._3, _p105._0._5);
												var params = _p107._0;
												var body = _p107._1;
												return A2(
													_elm_lang$core$Basics_ops['++'],
													params,
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p105._0._4.val,
														A2(
															_elm_lang$core$Basics_ops['++'],
															'=',
															_user$project$LeoUnparser$unparse(body))));
											}())));
							case 'DeclAnnotation':
								return A2(
									_elm_lang$core$Basics_ops['++'],
									function () {
										var _p108 = _p105._0._0;
										if (_p108.ctor === 'Just') {
											return A2(_elm_lang$core$Basics_ops['++'], _p108._0.val, ',');
										} else {
											return '';
										}
									}(),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p105._0._1.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparsePattern(_p105._0._2),
											function () {
												var _p109 = A2(_user$project$LeoUnparser$getTypeParametersBinding, _p105._0._3, _p105._0._5);
												var params = _p109._0;
												var body = _p109._1;
												return A2(
													_elm_lang$core$Basics_ops['++'],
													params,
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p105._0._4.val,
														A2(
															_elm_lang$core$Basics_ops['++'],
															':',
															_user$project$LeoUnparser$unparseType(body))));
											}())));
							default:
								return A2(
									_elm_lang$core$Basics_ops['++'],
									function () {
										var _p110 = _p105._0._0;
										if (_p110.ctor === 'Just') {
											return A2(_elm_lang$core$Basics_ops['++'], _p110._0.val, ',');
										} else {
											return '';
										}
									}(),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p105._0._1.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'type',
											A2(
												_elm_lang$core$Basics_ops['++'],
												function () {
													var _p111 = _p105._0._2;
													if (_p111.ctor === 'Just') {
														return A2(_elm_lang$core$Basics_ops['++'], _p111._0.val, 'alias');
													} else {
														return '';
													}
												}(),
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$LeoUnparser$unparsePattern(_p105._0._3),
													function () {
														var _p112 = A2(_user$project$LeoUnparser$getTypeParametersBinding, _p105._0._4, _p105._0._6);
														var params = _p112._0;
														var body = _p112._1;
														return A2(
															_elm_lang$core$Basics_ops['++'],
															params,
															A2(
																_elm_lang$core$Basics_ops['++'],
																_p105._0._5.val,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'=',
																	_user$project$LeoUnparser$unparseType(body))));
													}())))));
						}
					}());
			}));
};
var _user$project$LeoUnparser$unparse = function (e) {
	unparse:
	while (true) {
		var _p113 = _user$project$Lang$unwrapExp(e);
		switch (_p113.ctor) {
			case 'EConst':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(_p113._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p113._2._1,
							_user$project$LeoUnparser$unparseWD(_p113._3))));
			case 'EBase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					_user$project$LeoUnparser$unparseBaseValue(_p113._1));
			case 'EVar':
				return A2(_elm_lang$core$Basics_ops['++'], _p113._0.val, _p113._1);
			case 'EFun':
				var _p122 = _p113._0;
				var _p121 = _p113._1;
				var _p120 = _p113._2;
				var $default = function (_p114) {
					var _p115 = _p114;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p122.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'\\',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$String$concat(
									A2(_elm_lang$core$List$map, _user$project$LeoUnparser$unparsePattern, _p121)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' ->',
									_user$project$LeoUnparser$unparse(_p120)))));
				};
				var _p116 = _p121;
				if (_p116.ctor === '::') {
					if (_elm_lang$core$Native_Utils.eq(
						_user$project$Lang$pVarUnapply(_p116._0),
						_elm_lang$core$Maybe$Just(_user$project$LeoParser$implicitVarName))) {
						var _p117 = _user$project$Lang$unwrapExp(_p120);
						_v76_4:
						do {
							switch (_p117.ctor) {
								case 'ECase':
									var _p118 = _p117._1;
									if (_elm_lang$core$Native_Utils.eq(
										_user$project$Lang$eVarUnapply(_p118),
										_elm_lang$core$Maybe$Just(_user$project$LeoParser$implicitVarName))) {
										var _v77 = A2(
											_user$project$Lang$replaceE__,
											_p120,
											A4(
												_user$project$Lang$ECase,
												_p117._0,
												A2(
													_user$project$Lang$replaceE__,
													_p118,
													A2(_user$project$Lang$EVar, _user$project$Lang$space0, '')),
												_p117._2,
												_p117._3));
										e = _v77;
										continue unparse;
									} else {
										return $default(
											{ctor: '_Tuple0'});
									}
								case 'ESelect':
									var res = _user$project$LeoUnparser$unparse(_p120);
									if (A2(_elm_lang$core$String$startsWith, _user$project$LeoParser$implicitVarName, res)) {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_p122.val,
											A2(
												_elm_lang$core$String$dropLeft,
												_elm_lang$core$String$length(_user$project$LeoParser$implicitVarName),
												res));
									} else {
										var _p119 = A2(
											_elm_lang$core$Debug$log,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Could not find the implicit var name at the start of \'',
												A2(_elm_lang$core$Basics_ops['++'], res, '\' reverting to default')),
											{ctor: '_Tuple0'});
										return $default(
											{ctor: '_Tuple0'});
									}
								case 'ERecord':
									if (((_p117._1.ctor === 'Nothing') && (_p117._2._1.ctor === '[]')) && (_p117._2._2.ctor === '[]')) {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_p122.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'(',
												A2(
													_elm_lang$core$Basics_ops['++'],
													A2(
														_elm_lang$core$String$repeat,
														_elm_lang$core$List$length(_p117._2._3) - 2,
														','),
													')')));
									} else {
										break _v76_4;
									}
								case 'EOp':
									return $default(
										{ctor: '_Tuple0'});
								default:
									break _v76_4;
							}
						} while(false);
						return $default(
							{ctor: '_Tuple0'});
					} else {
						return $default(
							{ctor: '_Tuple0'});
					}
				} else {
					return $default(
						{ctor: '_Tuple0'});
				}
			case 'EApp':
				var _p134 = _p113._0;
				var _p133 = _p113._1;
				var _p132 = _p113._2;
				var unparseArg = function (e) {
					var _p123 = _user$project$Lang$unwrapExp(e);
					switch (_p123.ctor) {
						case 'EApp':
							return _user$project$LeoUnparser$wrapWithTightParens(
								_user$project$LeoUnparser$unparse(e));
						case 'EOp':
							return _user$project$LeoUnparser$wrapWithTightParens(
								_user$project$LeoUnparser$unparse(e));
						case 'EColonType':
							return _user$project$LeoUnparser$wrapWithTightParens(
								_user$project$LeoUnparser$unparse(e));
						default:
							return _user$project$LeoUnparser$unparse(e);
					}
				};
				var _p124 = _p113._3;
				switch (_p124.ctor) {
					case 'SpaceApp':
						return A2(
							F2(
								function (x, y) {
									return A2(_elm_lang$core$Basics_ops['++'], x, y);
								}),
							_p134.val,
							A3(
								_user$project$Utils$foldLeft,
								_user$project$LeoUnparser$unparse(_p133),
								_p132,
								F2(
									function (currentRendering, arg) {
										var argStr = unparseArg(arg);
										var mbWrapArg = A2(_user$project$Utils$wouldNotRecognizeTokenSplit, currentRendering, argStr) ? A2(
											_elm_lang$core$Basics_ops['++'],
											'(',
											A2(_elm_lang$core$Basics_ops['++'], argStr, ')')) : argStr;
										return A2(_elm_lang$core$Basics_ops['++'], currentRendering, mbWrapArg);
									})));
					case 'LeftApp':
						var _p125 = _p132;
						if ((_p125.ctor === '::') && (_p125._1.ctor === '[]')) {
							var _p126 = _p125._0;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p134.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A4(
										_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
										_user$project$LeoUnparser$OpLeft,
										e,
										_p133,
										_user$project$LeoUnparser$unparse(_p133)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p124._0.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'<|',
											A4(
												_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
												_user$project$LeoUnparser$OpRight,
												e,
												_p126,
												_user$project$LeoUnparser$unparse(_p126))))));
						} else {
							return '?[internal error EApp LeftApp wrong number of arguments]?';
						}
					case 'RightApp':
						var _p127 = _p132;
						if ((_p127.ctor === '::') && (_p127._1.ctor === '[]')) {
							var _p128 = _p127._0;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p134.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A4(
										_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
										_user$project$LeoUnparser$OpLeft,
										e,
										_p128,
										_user$project$LeoUnparser$unparse(_p128)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p124._0.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'|>',
											A4(
												_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
												_user$project$LeoUnparser$OpRight,
												e,
												_p133,
												_user$project$LeoUnparser$unparse(_p133))))));
						} else {
							return '?[internal error EApp RightApp did not have exactly 1 argument]?';
						}
					default:
						var _p129 = _p132;
						if (((_p129.ctor === '::') && (_p129._1.ctor === '::')) && (_p129._1._1.ctor === '[]')) {
							var _p131 = _p129._1._0;
							var _p130 = _p129._0;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p134.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A4(
										_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
										_user$project$LeoUnparser$OpLeft,
										e,
										_p130,
										_user$project$LeoUnparser$unparse(_p130)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparse(_p133),
										A4(
											_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
											_user$project$LeoUnparser$OpRight,
											e,
											_p131,
											_user$project$LeoUnparser$unparse(_p131)))));
						} else {
							return '?[internal error EApp InfixApp did not have exactly 2 arguments]?';
						}
				}
			case 'EOp':
				var _p141 = _p113._1;
				var _p140 = _p113._0;
				var _p139 = _p113._2;
				var _p138 = _p113._3;
				var $default = A2(
					_elm_lang$core$Basics_ops['++'],
					_p140.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p141.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparseOp(_p139),
							_elm_lang$core$String$concat(
								A2(
									_elm_lang$core$List$map,
									function (x) {
										return A4(
											_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
											_user$project$LeoUnparser$OpRight,
											e,
											x,
											_user$project$LeoUnparser$unparse(x));
									},
									_p138)))));
				if (_user$project$LeoLang$isInfixOperator(_p139)) {
					var _p135 = _p138;
					if (((_p135.ctor === '::') && (_p135._1.ctor === '::')) && (_p135._1._1.ctor === '[]')) {
						var _p137 = _p135._1._0;
						var _p136 = _p135._0;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p140.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								A4(
									_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
									_user$project$LeoUnparser$OpLeft,
									e,
									_p136,
									_user$project$LeoUnparser$unparse(_p136)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p141.val,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparseOp(_p139),
										A4(
											_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
											_user$project$LeoUnparser$OpRight,
											e,
											_p137,
											_user$project$LeoUnparser$unparse(_p137))))));
					} else {
						return $default;
					}
				} else {
					return $default;
				}
			case 'EList':
				if (_p113._3.ctor === 'Nothing') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p113._0.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[',
							A2(
								_elm_lang$core$Basics_ops['++'],
								function () {
									var _p142 = _p113._1;
									if (_p142.ctor === '[]') {
										return '';
									} else {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparse(_p142._0._1),
											_elm_lang$core$String$concat(
												A2(
													_elm_lang$core$List$map,
													function (_p143) {
														var _p144 = _p143;
														return A2(
															_elm_lang$core$Basics_ops['++'],
															_p144._0.val,
															A2(
																_elm_lang$core$Basics_ops['++'],
																',',
																_user$project$LeoUnparser$unparse(_p144._1)));
													},
													_p142._1)));
									}
								}(),
								A2(_elm_lang$core$Basics_ops['++'], _p113._4.val, ']'))));
				} else {
					if (_p113._1.ctor === '::') {
						if ((_p113._1._0.ctor === '_Tuple2') && (_p113._1._1.ctor === '[]')) {
							var _p146 = _p113._3._0;
							var _p145 = _p113._1._0._1;
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_p113._0.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A4(
										_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
										_user$project$LeoUnparser$OpLeft,
										e,
										_p145,
										_user$project$LeoUnparser$unparse(_p145)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p113._2.val,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'::',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A4(
													_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
													_user$project$LeoUnparser$OpRight,
													e,
													_p146,
													_user$project$LeoUnparser$unparse(_p146)),
												_p113._4.val)))));
						} else {
							var _p149 = _p113._2;
							var _p148 = _p113._4;
							var _p147 = _p113._0;
							var _v86 = A2(
								_user$project$Lang$replaceE__,
								e,
								A5(
									_user$project$Lang$EList,
									_p147,
									{
										ctor: '::',
										_0: _p113._1._0,
										_1: {ctor: '[]'}
									},
									_p149,
									_elm_lang$core$Maybe$Just(
										A2(
											_user$project$Lang$replaceE__,
											e,
											A5(
												_user$project$Lang$EList,
												_p147,
												_p113._1._1,
												_p149,
												_elm_lang$core$Maybe$Just(_p113._3._0),
												_p148))),
									_p148));
							e = _v86;
							continue unparse;
						}
					} else {
						var _v87 = _p113._3._0;
						e = _v87;
						continue unparse;
					}
				}
			case 'ERecord':
				var _p155 = _p113._0;
				var _p154 = _p113._3;
				var _p153 = _p113._2;
				var $default = function (_p150) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p155.val,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'{',
							A2(
								_elm_lang$core$Basics_ops['++'],
								function () {
									var _p151 = _p113._1;
									if (_p151.ctor === 'Just') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparse(_p151._0._0),
											A2(_elm_lang$core$Basics_ops['++'], _p151._0._1.val, '|'));
									} else {
										return '';
									}
								}(),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparseDeclarations(_p153),
									A2(_elm_lang$core$Basics_ops['++'], _p154.val, '}')))));
				};
				var _p152 = _user$project$Lang$recordEntriesFromDeclarations(_p153);
				if (_p152.ctor === 'Nothing') {
					return $default(
						{ctor: '_Tuple0'});
				} else {
					return A7(
						_user$project$LeoUnparser$tryUnparseRecordSugars,
						function (arg) {
							return A4(
								_user$project$LeoUnparser$wrapWithParensIfLessPrecedence,
								_user$project$LeoUnparser$OpRight,
								e,
								arg,
								_user$project$LeoUnparser$unparse(arg));
						},
						_user$project$LeoUnparser$expName,
						_user$project$LeoUnparser$expArgs,
						_p155,
						_p152._0,
						_p154,
						$default);
				}
			case 'ESelect':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparse(_p113._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p113._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'.',
								A2(_elm_lang$core$Basics_ops['++'], _p113._3.val, _p113._4)))));
			case 'EIf':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'if',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparse(_p113._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p113._2.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'then',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparse(_p113._3),
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p113._4.val,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'else',
												_user$project$LeoUnparser$unparse(_p113._5)))))))));
			case 'ECase':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'case',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparse(_p113._1),
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p113._3.val,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'of',
									_user$project$LeoUnparser$unparseBranches(_p113._2))))));
			case 'ELet':
				var _p162 = _p113._0;
				var _p161 = _p113._2._3;
				var _p160 = _p113._1;
				var _p159 = _p113._4;
				return (_user$project$LeoUnparser$onlyImplicitMain(_p161) || (_elm_lang$core$Native_Utils.eq(
					_p161,
					{ctor: '[]'}) && _elm_lang$core$Native_Utils.eq(
					_user$project$Lang$eVarUnapply(_p159),
					_elm_lang$core$Maybe$Just('main')))) ? '' : A2(
					_elm_lang$core$Basics_ops['++'],
					function () {
						var _p156 = _p160;
						if (_p156.ctor === 'Let') {
							return A2(_elm_lang$core$Basics_ops['++'], _p162.val, 'let');
						} else {
							return '';
						}
					}(),
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparseDeclarations(_p113._2),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p113._3.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								function () {
									var _p157 = _p160;
									if (_p157.ctor === 'Let') {
										return 'in';
									} else {
										return '';
									}
								}(),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparse(_p159),
									function () {
										var _p158 = _p160;
										if (_p158.ctor === 'Let') {
											return '';
										} else {
											return _p162.val;
										}
									}())))));
			case 'EParens':
				var _p166 = _p113._0;
				var _p165 = _p113._3;
				var _p164 = _p113._1;
				var _p163 = _p113._2;
				switch (_p163.ctor) {
					case 'CustomSyntax':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p166.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'{-CustomXyntax ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(_p163._0),
									A2(
										_elm_lang$core$Basics_ops['++'],
										'-}(',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparse(_p164),
											A2(_elm_lang$core$Basics_ops['++'], _p165.val, ')'))))));
					case 'Parens':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p166.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'(',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparse(_p164),
									A2(_elm_lang$core$Basics_ops['++'], _p165.val, ')'))));
					case 'LongStringSyntax':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p166.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'\"\"\"',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$multilineContentUnparse(_p164),
									'\"\"\"')));
					case 'HtmlSyntax':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_p166.val,
							A2(_user$project$LeoUnparser$unparseHtmlNode, _user$project$LeoUnparser$Interpolated, _p164));
					default:
						var _v94 = _p164;
						e = _v94;
						continue unparse;
				}
			case 'EHole':
				return A2(_elm_lang$core$Basics_ops['++'], _p113._0.val, '??');
			default:
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p113._0.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparse(_p113._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p113._2.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								':',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparseType(_p113._3),
									_p113._4.val)))));
		}
	}
};
var _user$project$LeoUnparser$multilineContentUnparse = function (e) {
	var _p167 = _user$project$Lang$unwrapExp(e);
	_v95_3:
	do {
		switch (_p167.ctor) {
			case 'EBase':
				if (_p167._1.ctor === 'EString') {
					return _user$project$LeoUnparser$unparseLongStringContent(_p167._1._1);
				} else {
					break _v95_3;
				}
			case 'EOp':
				if (((_p167._3.ctor === '::') && (_p167._3._1.ctor === '::')) && (_p167._3._1._1.ctor === '[]')) {
					var _p181 = _p167._3._1._0;
					var _p180 = _p167._3._0;
					var _p168 = _p167._2.val;
					if (_p168.ctor === 'Plus') {
						var unwrapToStrExceptStr = function (x) {
							var _p169 = A2(_user$project$Lang$eOpUnapply1, _user$project$Lang$ToStrExceptStr, x);
							if (_p169.ctor === 'Just') {
								var _p172 = _p169._0;
								var _p170 = A2(_user$project$Lang$eParensUnapplyIf, _user$project$Lang$LeoSyntax, _p172);
								if (_p170.ctor === 'Just') {
									var _p171 = _p170._0;
									return {
										ctor: '_Tuple2',
										_0: _p171,
										_1: _user$project$Lang$unwrapExp(_p171)
									};
								} else {
									return {
										ctor: '_Tuple2',
										_0: _p172,
										_1: _user$project$Lang$unwrapExp(_p172)
									};
								}
							} else {
								return {
									ctor: '_Tuple2',
									_0: _p180,
									_1: _user$project$Lang$unwrapExp(x)
								};
							}
						};
						var _p173 = unwrapToStrExceptStr(_p180);
						_v99_2:
						do {
							switch (_p173._1.ctor) {
								case 'EBase':
									if (_p173._1._1.ctor === 'EString') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$multilineContentUnparse(_p180),
											_user$project$LeoUnparser$multilineContentUnparse(_p181));
									} else {
										break _v99_2;
									}
								case 'EVar':
									var _p179 = _p173._1._1;
									var _p174 = _user$project$Lang$unwrapExp(_p181);
									_v100_2:
									do {
										switch (_p174.ctor) {
											case 'EOp':
												if (((_p174._3.ctor === '::') && (_p174._3._1.ctor === '::')) && (_p174._3._1._1.ctor === '[]')) {
													var _p175 = _p174._2.val;
													if (_p175.ctor === 'Plus') {
														var _p176 = _user$project$Lang$unwrapExp(_p174._3._0);
														if ((_p176.ctor === 'EBase') && (_p176._1.ctor === 'EString')) {
															var varRep = function () {
																var _p177 = _elm_lang$core$String$uncons(_p176._1._1);
																if (_p177.ctor === 'Nothing') {
																	return A2(_elm_lang$core$Basics_ops['++'], '@', _p179);
																} else {
																	return _user$project$LangParserUtils$isRestChar(_p177._0._0) ? A2(
																		_elm_lang$core$Basics_ops['++'],
																		'@(',
																		A2(_elm_lang$core$Basics_ops['++'], _p179, ')')) : A2(_elm_lang$core$Basics_ops['++'], '@', _p179);
																}
															}();
															return A2(
																_elm_lang$core$Basics_ops['++'],
																varRep,
																_user$project$LeoUnparser$multilineContentUnparse(_p181));
														} else {
															return A2(
																_elm_lang$core$Basics_ops['++'],
																'@',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_p179,
																	_user$project$LeoUnparser$multilineContentUnparse(_p181)));
														}
													} else {
														return A2(
															_elm_lang$core$Basics_ops['++'],
															'@',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_p179,
																_user$project$LeoUnparser$multilineContentUnparse(_p181)));
													}
												} else {
													break _v100_2;
												}
											case 'EBase':
												if (_p174._1.ctor === 'EString') {
													var varRep = function () {
														var _p178 = _elm_lang$core$String$uncons(_p174._1._1);
														if (_p178.ctor === 'Nothing') {
															return A2(_elm_lang$core$Basics_ops['++'], '@', _p179);
														} else {
															return _user$project$LangParserUtils$isRestChar(_p178._0._0) ? A2(
																_elm_lang$core$Basics_ops['++'],
																'@(',
																A2(_elm_lang$core$Basics_ops['++'], _p179, ')')) : A2(_elm_lang$core$Basics_ops['++'], '@', _p179);
														}
													}();
													return A2(
														_elm_lang$core$Basics_ops['++'],
														varRep,
														_user$project$LeoUnparser$multilineContentUnparse(_p181));
												} else {
													break _v100_2;
												}
											default:
												break _v100_2;
										}
									} while(false);
									return A2(
										_elm_lang$core$Basics_ops['++'],
										'@',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p179,
											_user$project$LeoUnparser$multilineContentUnparse(_p181)));
								default:
									break _v99_2;
							}
						} while(false);
						var sx = _user$project$LeoUnparser$unparse(_p173._0);
						var sy = _user$project$LeoUnparser$multilineContentUnparse(_p181);
						return A2(_user$project$LeoUnparser$noInterpolationConflict, sx, sy) ? A2(
							_elm_lang$core$Basics_ops['++'],
							'@',
							A2(_elm_lang$core$Basics_ops['++'], sx, sy)) : A2(
							_elm_lang$core$Basics_ops['++'],
							'@(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								sx,
								A2(_elm_lang$core$Basics_ops['++'], ')', sy)));
					} else {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							'@(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LeoUnparser$unparse(e),
								')'));
					}
				} else {
					break _v95_3;
				}
			case 'ELet':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'@let',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparseDeclarations(_p167._2),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p167._3.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'in\n',
								_user$project$LeoUnparser$multilineContentUnparse(_p167._4)))));
			default:
				break _v95_3;
		}
	} while(false);
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'@(',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_user$project$LeoUnparser$unparse(e),
			')'));
};
var _user$project$LeoUnparser$unparseBranches = function () {
	var aux = F2(
		function (isNotFirst, branches) {
			var _p182 = branches;
			if (_p182.ctor === '[]') {
				return '';
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					A2(_user$project$LeoUnparser$unparseBranch, isNotFirst, _p182._0),
					A2(aux, true, _p182._1));
			}
		});
	return aux(false);
}();
var _user$project$LeoUnparser$unparseBranch = F2(
	function (isNotFirst, branch) {
		var _p183 = branch.val;
		var _p184 = _p183._0;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			(isNotFirst && (!A2(_elm_lang$core$String$contains, '\n', _p184.val))) ? A2(_elm_lang$core$Basics_ops['++'], ';', _p184.val) : _p184.val,
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$LeoUnparser$unparsePattern(_p183._1),
				A2(
					_elm_lang$core$Basics_ops['++'],
					_p183._3.val,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'->',
						_user$project$LeoUnparser$unparse(_p183._2)))));
	});
var _user$project$LeoUnparser$unparseHtmlNode = F2(
	function (interpolationStyle, e) {
		var _p185 = _user$project$Lang$unwrapExp(e);
		_v107_2:
		do {
			if (((((_p185.ctor === 'EList') && (_p185._1.ctor === '::')) && (_p185._1._0.ctor === '_Tuple2')) && (_p185._1._1.ctor === '::')) && (_p185._1._1._0.ctor === '_Tuple2')) {
				if (_p185._1._1._1.ctor === '[]') {
					if (_p185._3.ctor === 'Nothing') {
						var _p197 = _p185._1._1._0._1;
						var _p186 = _user$project$Lang$unwrapExp(_p185._1._0._1);
						if (((_p186.ctor === 'EBase') && (_p186._1.ctor === 'EString')) && (_p186._1._1 === 'COMMENT')) {
							var _p187 = _user$project$Lang$unwrapExp(_p197);
							if ((_p187.ctor === 'EBase') && (_p187._1.ctor === 'EString')) {
								var _p194 = _p187._1._1;
								var _p188 = function () {
									var _p189 = A3(
										_elm_lang$core$Regex$find,
										_elm_lang$core$Regex$AtMost(1),
										_elm_lang$core$Regex$regex('\\{-(.*):(.*)-\\}'),
										_p185._0.val);
									if ((_p189.ctor === '::') && (_p189._1.ctor === '[]')) {
										var _p190 = _p189._0.submatches;
										if (((((_p190.ctor === '::') && (_p190._0.ctor === 'Just')) && (_p190._1.ctor === '::')) && (_p190._1._0.ctor === 'Just')) && (_p190._1._1.ctor === '[]')) {
											var _p193 = _p190._0._0;
											return (_elm_lang$core$Native_Utils.eq(_p193, '<') && (!A2(_elm_lang$core$String$startsWith, '?', _p194))) ? {ctor: '_Tuple2', _0: '<!--', _1: '-->'} : ((_elm_lang$core$Native_Utils.eq(_p193, '</') && function () {
												var _p191 = _elm_lang$core$String$uncons(_p194);
												if ((_p191.ctor === 'Just') && (_p191._0.ctor === '_Tuple2')) {
													var _p192 = _p191._0._0;
													return _elm_lang$core$Char$isUpper(_p192) || (_elm_lang$core$Char$isLower(_p192) || _elm_lang$core$Native_Utils.eq(
														_p192,
														_elm_lang$core$Native_Utils.chr('@')));
												} else {
													return false;
												}
											}()) ? {ctor: '_Tuple2', _0: '<!--', _1: '-->'} : ((_elm_lang$core$Native_Utils.eq(_p193, '<!') && A2(_elm_lang$core$String$startsWith, '--', _p194)) ? {ctor: '_Tuple2', _0: '<!--', _1: '-->'} : {ctor: '_Tuple2', _0: _p193, _1: _p190._1._0._0}));
										} else {
											return {ctor: '_Tuple2', _0: '<!--', _1: '-->'};
										}
									} else {
										return {ctor: '_Tuple2', _0: '<!--', _1: '-->'};
									}
								}();
								var opening = _p188._0;
								var closing = _p188._1;
								return A2(
									_elm_lang$core$Basics_ops['++'],
									opening,
									A2(_elm_lang$core$Basics_ops['++'], _p194, closing));
							} else {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									'@[',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparse(e),
										']'));
							}
						} else {
							var _p195 = _user$project$Lang$unwrapExp(_p197);
							_v113_3:
							do {
								switch (_p195.ctor) {
									case 'EBase':
										if (_p195._1.ctor === 'EString') {
											return A2(_user$project$LeoUnparser$unparseHtmlTextContent, interpolationStyle, _p195._1._1);
										} else {
											break _v113_3;
										}
									case 'EParens':
										if (_p195._2.ctor === 'LongStringSyntax') {
											var _p196 = _user$project$Lang$unwrapExp(_p195._1);
											if ((_p196.ctor === 'EBase') && (_p196._1.ctor === 'EString')) {
												return A2(_user$project$LeoUnparser$unparseHtmlTextContent, interpolationStyle, _p196._1._1);
											} else {
												return A2(
													_elm_lang$core$Basics_ops['++'],
													'@[',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LeoUnparser$unparse(e),
														']'));
											}
										} else {
											break _v113_3;
										}
									case 'EVar':
										return A2(_elm_lang$core$Basics_ops['++'], '@', _p195._1);
									default:
										break _v113_3;
								}
							} while(false);
							return A2(
								_elm_lang$core$Basics_ops['++'],
								'@[',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparse(e),
									']'));
						}
					} else {
						break _v107_2;
					}
				} else {
					if (((_p185._1._1._1._0.ctor === '_Tuple2') && (_p185._1._1._1._1.ctor === '[]')) && (_p185._3.ctor === 'Nothing')) {
						var _p205 = _p185._1._0._1;
						var _p204 = _p185._2;
						var _p203 = _p185._1._1._1._0._1;
						var _p202 = _p185._1._1._0._1;
						var _p198 = function () {
							var _p199 = _user$project$Lang$unwrapExp(_p205);
							if ((_p199.ctor === 'EBase') && (_p199._1.ctor === 'EString')) {
								var _p200 = _p199._1._1;
								return {ctor: '_Tuple2', _0: _p200, _1: _p200};
							} else {
								return {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										'@',
										_user$project$LeoUnparser$unparse(_p205)),
									_1: '@'
								};
							}
						}();
						var tagStart = _p198._0;
						var tagEnd = _p198._1;
						var newIsRaw = function () {
							if (_elm_lang$core$Native_Utils.eq(interpolationStyle, _user$project$LeoUnparser$Raw)) {
								return _user$project$LeoUnparser$Raw;
							} else {
								var _p201 = tagStart;
								switch (_p201) {
									case 'raw':
										return _user$project$LeoUnparser$Raw;
									case 'script':
										return _user$project$LeoUnparser$ScriptInterpolated;
									case 'style':
										return _user$project$LeoUnparser$StyleInterpolated;
									default:
										return interpolationStyle;
								}
							}
						}();
						return (_elm_lang$core$Native_Utils.eq(_p204.val, _user$project$Lang$encoding_implicitelem) && _elm_lang$core$Native_Utils.eq(
							_user$project$Lang$eListUnapply(_p202),
							_elm_lang$core$Maybe$Just(
								{ctor: '[]'}))) ? A2(_user$project$LeoUnparser$unparseHtmlChildList, newIsRaw, _p203) : A2(
							_elm_lang$core$Basics_ops['++'],
							'<',
							A2(
								_elm_lang$core$Basics_ops['++'],
								tagStart,
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(_user$project$LeoUnparser$unparseHtmlAttributes, interpolationStyle, _p202),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p185._1._1._1._0._0.val,
										_elm_lang$core$Native_Utils.eq(_p204.val, _user$project$Lang$encoding_autoclosing) ? '/>' : (_elm_lang$core$Native_Utils.eq(_p204.val, _user$project$Lang$encoding_voidclosing) ? '>' : (_elm_lang$core$Native_Utils.eq(_p204.val, _user$project$Lang$encoding_forgotclosing) ? A2(
											_elm_lang$core$Basics_ops['++'],
											'>',
											A2(_user$project$LeoUnparser$unparseHtmlChildList, newIsRaw, _p203)) : (_user$project$HTMLParser$isVoidElement(tagStart) ? '>' : A2(
											_elm_lang$core$Basics_ops['++'],
											'>',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A2(_user$project$LeoUnparser$unparseHtmlChildList, newIsRaw, _p203),
												A2(
													_elm_lang$core$Basics_ops['++'],
													'</',
													A2(
														_elm_lang$core$Basics_ops['++'],
														tagEnd,
														A2(_elm_lang$core$Basics_ops['++'], _p185._4.val, '>'))))))))))));
					} else {
						break _v107_2;
					}
				}
			} else {
				break _v107_2;
			}
		} while(false);
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'@[',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$LeoUnparser$unparse(e),
				']'));
	});
var _user$project$LeoUnparser$unparseHtmlAttributes = F2(
	function (interpolationStyle, attrExp) {
		var _p206 = _user$project$Lang$eListUnapply(attrExp);
		if (_p206.ctor === 'Just') {
			return A2(
				_elm_lang$core$String$join,
				'',
				A2(
					_elm_lang$core$List$map,
					function (attr) {
						var _p207 = _user$project$Lang$unwrapExp(attr);
						if (((((((_p207.ctor === 'EList') && (_p207._1.ctor === '::')) && (_p207._1._0.ctor === '_Tuple2')) && (_p207._1._1.ctor === '::')) && (_p207._1._1._0.ctor === '_Tuple2')) && (_p207._1._1._1.ctor === '[]')) && (_p207._3.ctor === 'Nothing')) {
							var _p238 = _p207._1._1._0._0;
							var _p237 = _p207._2;
							var _p236 = _p207._1._1._0._1;
							var _p235 = _p207._0;
							var atAfterEqual = (_elm_lang$core$Native_Utils.eq(_p207._1._0._0.val, ' ') && (!_elm_lang$core$Native_Utils.eq(interpolationStyle, _user$project$LeoUnparser$Raw))) ? '@' : '';
							var beforeSpace = _elm_lang$core$Native_Utils.eq(_p235.val, '') ? ' ' : _p235.val;
							var mbAttrName = function () {
								var _p208 = _user$project$Lang$unwrapExp(_p207._1._0._1);
								_v119_2:
								do {
									switch (_p208.ctor) {
										case 'EBase':
											if (_p208._1.ctor === 'EString') {
												return _elm_lang$core$Maybe$Just(_p208._1._1);
											} else {
												break _v119_2;
											}
										case 'EApp':
											if ((_p208._2.ctor === '::') && (_p208._2._1.ctor === '[]')) {
												var _p209 = _user$project$Lang$unwrapExp(_p208._1);
												if ((_p209.ctor === 'EVar') && (_p209._1 === '__htmlRawAttribute__')) {
													var _p210 = _user$project$Lang$unwrapExp(_p208._2._0);
													if ((_p210.ctor === 'EBase') && (_p210._1.ctor === 'EString')) {
														return _elm_lang$core$Maybe$Just(_p210._1._1);
													} else {
														return _elm_lang$core$Maybe$Nothing;
													}
												} else {
													return _elm_lang$core$Maybe$Nothing;
												}
											} else {
												break _v119_2;
											}
										default:
											break _v119_2;
									}
								} while(false);
								return _elm_lang$core$Maybe$Nothing;
							}();
							var _p211 = mbAttrName;
							if (_p211.ctor === 'Just') {
								var _p234 = _p211._0;
								var attrValueToConsider1 = function () {
									var _p212 = _p234;
									if (_p212 === 'style') {
										return A2(
											_elm_lang$core$Maybe$withDefault,
											_p236,
											A2(
												_elm_lang$core$Maybe$map,
												_elm_lang$core$Tuple$second,
												_user$project$Lang$eAppUnapply1(_p236)));
									} else {
										return _p236;
									}
								}();
								var attrValueToConsider = function () {
									var _p213 = _user$project$Lang$unwrapExp(attrValueToConsider1);
									if ((_p213.ctor === 'EParens') && (_p213._2.ctor === 'LongStringSyntax')) {
										var _p215 = _p213._1;
										var _p214 = _user$project$Lang$unwrapExp(_p215);
										if (_p214.ctor === 'EBase') {
											return A2(
												_user$project$Lang$replaceE__,
												_p215,
												A2(_user$project$Lang$EBase, _user$project$Lang$space0, _p214._1));
										} else {
											return attrValueToConsider1;
										}
									} else {
										return attrValueToConsider1;
									}
								}();
								var $default = function (_p216) {
									var _p217 = _p216;
									var defaultValue = function (_p218) {
										var _p219 = _p218;
										var d = _user$project$LeoUnparser$unparse(attrValueToConsider);
										var _p220 = _user$project$Lang$unwrapExp(attrValueToConsider);
										if (_p220.ctor === 'EBase') {
											return _user$project$LeoUnparser$elmToHTMLEscape(d);
										} else {
											return d;
										}
									};
									var value = function () {
										if (_elm_lang$core$Native_Utils.eq(interpolationStyle, _user$project$LeoUnparser$Raw) && _elm_lang$core$Native_Utils.eq(_p234, 'style')) {
											var _p221 = _user$project$Lang$unwrapExp(attrValueToConsider);
											if (_p221.ctor === 'EList') {
												var resUnparsed = _user$project$Utils$projOk(
													A2(
														_elm_lang$core$List$map,
														function (_p222) {
															var _p223 = _p222;
															var _p224 = _user$project$Lang$unwrapExp(_p223._1);
															if ((((((_p224.ctor === 'EList') && (_p224._1.ctor === '::')) && (_p224._1._0.ctor === '_Tuple2')) && (_p224._1._1.ctor === '::')) && (_p224._1._1._0.ctor === '_Tuple2')) && (_p224._1._1._1.ctor === '[]')) {
																var _p225 = {
																	ctor: '_Tuple2',
																	_0: _user$project$Lang$eStrUnapply(_p224._1._0._1),
																	_1: _user$project$Lang$eStrUnapply(_p224._1._1._0._1)
																};
																if (((_p225.ctor === '_Tuple2') && (_p225._0.ctor === 'Just')) && (_p225._1.ctor === 'Just')) {
																	return _elm_lang$core$Result$Ok(
																		{ctor: '_Tuple2', _0: _p225._0._0, _1: _p225._1._0});
																} else {
																	return _elm_lang$core$Result$Err('not a valid style key/value pair');
																}
															} else {
																return _elm_lang$core$Result$Err('not a valid style key/value pair');
															}
														},
														_p221._1));
												var _p226 = resUnparsed;
												if (_p226.ctor === 'Err') {
													return defaultValue(
														{ctor: '_Tuple0'});
												} else {
													return A2(
														_user$project$HTMLParser$printAttrValueRaw,
														false,
														_user$project$LangParserUtils$implodeStyleValue(_p226._0));
												}
											} else {
												return defaultValue(
													{ctor: '_Tuple0'});
											}
										} else {
											return defaultValue(
												{ctor: '_Tuple0'});
										}
									}();
									return A2(
										_elm_lang$core$Basics_ops['++'],
										beforeSpace,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p234,
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p238.val,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'=',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p237.val,
														A2(
															_elm_lang$core$Basics_ops['++'],
															atAfterEqual,
															A4(_user$project$LeoUnparser$wrapWithParensIfLessPrecedence, _user$project$LeoUnparser$OpRight, _user$project$LeoUnparser$dummyExp, attrValueToConsider, value)))))));
								};
								var _p227 = _user$project$Lang$unwrapExp(attrValueToConsider);
								_v134_2:
								do {
									switch (_p227.ctor) {
										case 'EBase':
											if (_p227._1.ctor === 'EString') {
												if (_elm_lang$core$Native_Utils.eq(_p227._1._1, '') && _elm_lang$core$Native_Utils.eq(_p227._0.val, '    ')) {
													return A2(_elm_lang$core$Basics_ops['++'], beforeSpace, _p234);
												} else {
													var unparsedAttr = _user$project$LeoUnparser$unparse(attrValueToConsider);
													return A2(
														_elm_lang$core$Basics_ops['++'],
														beforeSpace,
														A2(
															_elm_lang$core$Basics_ops['++'],
															_p234,
															A2(
																_elm_lang$core$Basics_ops['++'],
																_p238.val,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'=',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_p237.val,
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			atAfterEqual,
																			_user$project$LeoUnparser$elmToHTMLEscape(
																				A4(_user$project$LeoUnparser$wrapWithParensIfLessPrecedence, _user$project$LeoUnparser$OpRight, _user$project$LeoUnparser$dummyExp, attrValueToConsider, unparsedAttr))))))));
												}
											} else {
												break _v134_2;
											}
										case 'EApp':
											if ((_p227._2.ctor === '::') && (_p227._2._1.ctor === '[]')) {
												var _p233 = _p227._0;
												var _p228 = _user$project$Lang$unwrapExp(_p227._1);
												if ((_p228.ctor === 'EVar') && (_p228._1 === '__htmlRawAttribute__')) {
													var unparseHtmlStringContent = function (elem) {
														var _p229 = _user$project$Lang$unwrapExp(elem);
														_v136_3:
														do {
															switch (_p229.ctor) {
																case 'EBase':
																	if (_p229._1.ctor === 'EString') {
																		return _elm_lang$core$Result$Ok(_p229._1._1);
																	} else {
																		break _v136_3;
																	}
																case 'EOp':
																	if (((_p229._3.ctor === '::') && (_p229._3._1.ctor === '::')) && (_p229._3._1._1.ctor === '[]')) {
																		return _elm_lang$core$Native_Utils.eq(_p229._2.val, _user$project$Lang$Plus) ? A3(
																			_elm_lang$core$Result$map2,
																			F2(
																				function (x, y) {
																					return A2(_elm_lang$core$Basics_ops['++'], x, y);
																				}),
																			unparseHtmlStringContent(_p229._3._0),
																			unparseHtmlStringContent(_p229._3._1._0)) : _elm_lang$core$Result$Err('Unexpected AST. reverting to standard rendering');
																	} else {
																		break _v136_3;
																	}
																case 'EApp':
																	if (((_p229._2.ctor === '::') && (_p229._2._1.ctor === '::')) && (_p229._2._1._1.ctor === '[]')) {
																		var _p230 = _user$project$Lang$unwrapExp(_p229._1);
																		if ((_p230.ctor === 'EVar') && (_p230._1 === '__htmlStrEntity__')) {
																			var _p231 = _user$project$Lang$unwrapExp(_p229._2._1._0);
																			if ((_p231.ctor === 'EBase') && (_p231._1.ctor === 'EString')) {
																				return _elm_lang$core$Result$Ok(_p231._1._1);
																			} else {
																				return _elm_lang$core$Result$Err('Unexpected AST. Reverting to standard rendering');
																			}
																		} else {
																			return _elm_lang$core$Result$Err('Unexpected AST. Reverting to standard rendering');
																		}
																	} else {
																		break _v136_3;
																	}
																default:
																	break _v136_3;
															}
														} while(false);
														return _elm_lang$core$Result$Err('Unexpected AST. Reverting to standard rendering');
													};
													var quoteChar = _elm_lang$core$Native_Utils.eq(_p233.val, ' ') ? '\'' : (_elm_lang$core$Native_Utils.eq(_p233.val, '  ') ? '\"' : '');
													var _p232 = unparseHtmlStringContent(_p227._2._0);
													if (_p232.ctor === 'Err') {
														return $default(
															{ctor: '_Tuple0'});
													} else {
														var unparsedContentFixed = _user$project$LeoUnparser$elmToHTMLEscape(_p232._0);
														if ((!_elm_lang$core$Native_Utils.eq(quoteChar, '')) || A2(
															_elm_lang$core$Regex$contains,
															_elm_lang$core$Regex$regex('>|\\s'),
															unparsedContentFixed)) {
															var rawcontent = A4(
																_elm_lang$core$Regex$replace,
																_elm_lang$core$Regex$All,
																_elm_lang$core$Regex$regex(quoteChar),
																function (m) {
																	return _elm_lang$core$Native_Utils.eq(m.match, '\"') ? '&quot;' : '&#39;';
																},
																unparsedContentFixed);
															return A2(
																_elm_lang$core$Basics_ops['++'],
																beforeSpace,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_p234,
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_p238.val,
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'=',
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_p237.val,
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					quoteChar,
																					A2(_elm_lang$core$Basics_ops['++'], rawcontent, quoteChar)))))));
														} else {
															return A2(
																_elm_lang$core$Basics_ops['++'],
																beforeSpace,
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_p234,
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_p238.val,
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'=',
																			A2(_elm_lang$core$Basics_ops['++'], _p237.val, unparsedContentFixed)))));
														}
													}
												} else {
													return $default(
														{ctor: '_Tuple0'});
												}
											} else {
												break _v134_2;
											}
										default:
											break _v134_2;
									}
								} while(false);
								return $default(
									{ctor: '_Tuple0'});
							} else {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									' @[',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LeoUnparser$unparse(attr),
										']'));
							}
						} else {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								' @[',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparse(attr),
									']'));
						}
					},
					_p206._0));
		} else {
			var _p239 = _user$project$Lang$unwrapExp(attrExp);
			if ((((_p239.ctor === 'EApp') && (_p239._2.ctor === '::')) && (_p239._2._1.ctor === '::')) && (_p239._2._1._1.ctor === '[]')) {
				var _p240 = _user$project$Lang$eAppUnapply2(_p239._2._0);
				if (_p240.ctor === 'Just') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_user$project$LeoUnparser$unparseHtmlAttributes, interpolationStyle, _p240._0._1),
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p239._0.val,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'@',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LeoUnparser$unparse(_p240._0._2),
									A2(_user$project$LeoUnparser$unparseHtmlAttributes, interpolationStyle, _p239._2._1._0)))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						' @(',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoUnparser$unparse(attrExp),
							')'));
				}
			} else {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					' @(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparse(attrExp),
						')'));
			}
		}
	});
var _user$project$LeoUnparser$unparseHtmlChildList = F2(
	function (interpolationStyle, childExp) {
		unparseHtmlChildList:
		while (true) {
			var _p241 = _user$project$Lang$eListUnapply(childExp);
			if (_p241.ctor === 'Just') {
				return A2(
					_elm_lang$core$String$join,
					'',
					A2(
						_elm_lang$core$List$map,
						_user$project$LeoUnparser$unparseHtmlNode(interpolationStyle),
						_p241._0));
			} else {
				var _p242 = _user$project$Lang$unwrapExp(childExp);
				_v143_2:
				do {
					if ((_p242.ctor === 'EApp') && (_p242._2.ctor === '::')) {
						if (_p242._2._1.ctor === '[]') {
							if (_p242._3.ctor === 'SpaceApp') {
								var _p243 = _user$project$Lang$unwrapExp(_p242._1);
								if ((_p243.ctor === 'EVar') && (_p243._1 === '__mergeHtmlText__')) {
									var _v145 = interpolationStyle,
										_v146 = _p242._2._0;
									interpolationStyle = _v145;
									childExp = _v146;
									continue unparseHtmlChildList;
								} else {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										'@(',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparse(childExp),
											')'));
								}
							} else {
								break _v143_2;
							}
						} else {
							if (_p242._2._1._1.ctor === '[]') {
								var _p244 = _user$project$Lang$unwrapExp(_p242._2._0);
								if ((((_p244.ctor === 'EApp') && (_p244._2.ctor === '::')) && (_p244._2._1.ctor === '::')) && (_p244._2._1._1.ctor === '[]')) {
									var _p250 = _p244._2._1._0;
									var _p249 = _p244._2._0;
									var rightRendered = A2(_user$project$LeoUnparser$unparseHtmlChildList, interpolationStyle, _p242._2._1._0);
									var mbEntity = function () {
										var _p245 = _user$project$Lang$unwrapExp(_p250);
										if ((((_p245.ctor === 'EApp') && (_p245._2.ctor === '::')) && (_p245._2._1.ctor === '::')) && (_p245._2._1._1.ctor === '[]')) {
											var _p246 = _user$project$Lang$unwrapExp(_p245._2._1._0);
											if ((_p246.ctor === 'EBase') && (_p246._1.ctor === 'EString')) {
												return _elm_lang$core$Maybe$Just(_p246._1._1);
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										} else {
											return _elm_lang$core$Maybe$Nothing;
										}
									}();
									var _p247 = mbEntity;
									if (_p247.ctor === 'Just') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											A2(_user$project$LeoUnparser$unparseHtmlChildList, interpolationStyle, _p249),
											A2(_elm_lang$core$Basics_ops['++'], _p247._0, rightRendered));
									} else {
										var interpolated = function () {
											var _p248 = _user$project$Lang$unwrapExp(_p250);
											if (((_p248.ctor === 'EApp') && (_p248._2.ctor === '::')) && (_p248._2._1.ctor === '[]')) {
												return _user$project$LeoUnparser$unparse(_p248._2._0);
											} else {
												return _user$project$LeoUnparser$unparse(_p250);
											}
										}();
										return A2(_user$project$LeoUnparser$noInterpolationConflict, interpolated, rightRendered) ? A2(
											_elm_lang$core$Basics_ops['++'],
											A2(_user$project$LeoUnparser$unparseHtmlChildList, interpolationStyle, _p249),
											A2(
												_elm_lang$core$Basics_ops['++'],
												'@',
												A2(_elm_lang$core$Basics_ops['++'], interpolated, rightRendered))) : A2(
											_elm_lang$core$Basics_ops['++'],
											A2(_user$project$LeoUnparser$unparseHtmlChildList, interpolationStyle, _p249),
											A2(
												_elm_lang$core$Basics_ops['++'],
												'@(',
												A2(
													_elm_lang$core$Basics_ops['++'],
													interpolated,
													A2(_elm_lang$core$Basics_ops['++'], ')', rightRendered))));
									}
								} else {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										'@(',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LeoUnparser$unparse(childExp),
											')'));
								}
							} else {
								break _v143_2;
							}
						}
					} else {
						break _v143_2;
					}
				} while(false);
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'@(',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LeoUnparser$unparse(childExp),
						')'));
			}
		}
	});
var _user$project$LeoUnparser$unparseAnyHtml = function (e) {
	var _p251 = _user$project$Lang$unwrapExp(e);
	_v152_2:
	do {
		if (((((_p251.ctor === 'EList') && (_p251._1.ctor === '::')) && (_p251._1._0.ctor === '_Tuple2')) && (_p251._1._1.ctor === '::')) && (_p251._1._1._0.ctor === '_Tuple2')) {
			if (_p251._1._1._1.ctor === '[]') {
				if (_p251._3.ctor === 'Nothing') {
					var _p252 = _user$project$Lang$eStrUnapply(_p251._1._0._1);
					if (_p252.ctor === 'Just') {
						switch (_p252._0) {
							case 'TEXT':
								return A2(_user$project$LeoUnparser$unparseHtmlNode, _user$project$LeoUnparser$Interpolated, e);
							case 'COMMENT':
								return A2(_user$project$LeoUnparser$unparseHtmlNode, _user$project$LeoUnparser$Interpolated, e);
							default:
								return A2(
									_user$project$LeoUnparser$unparseHtmlAttributes,
									_user$project$LeoUnparser$Interpolated,
									A2(
										_user$project$Lang$eList,
										{
											ctor: '::',
											_0: e,
											_1: {ctor: '[]'}
										},
										_elm_lang$core$Maybe$Nothing));
						}
					} else {
						return _user$project$LeoUnparser$unparse(e);
					}
				} else {
					break _v152_2;
				}
			} else {
				if (((_p251._1._1._1._0.ctor === '_Tuple2') && (_p251._1._1._1._1.ctor === '[]')) && (_p251._3.ctor === 'Nothing')) {
					var _p260 = _p251._1._0._1;
					var _p259 = _p251._1._1._0._1;
					var _p253 = _user$project$Lang$eStrUnapply(_p260);
					if (_p253.ctor === 'Just') {
						var _p254 = _user$project$Lang$eListUnapply(_p259);
						if (_p254.ctor === 'Just') {
							return A2(
								_user$project$LeoUnparser$unparseHtmlNode,
								function () {
									var _p255 = _p253._0;
									switch (_p255) {
										case 'raw':
											return _user$project$LeoUnparser$Raw;
										case 'script':
											return _user$project$LeoUnparser$ScriptInterpolated;
										case 'style':
											return _user$project$LeoUnparser$StyleInterpolated;
										default:
											return _user$project$LeoUnparser$Interpolated;
									}
								}(),
								e);
						} else {
							var _p256 = _user$project$Lang$eAppUnapply2(_p259);
							if ((_p256.ctor === 'Just') && (_p256._0.ctor === '_Tuple3')) {
								var _p257 = _user$project$Lang$eVarUnapply(_p256._0._0);
								if ((_p257.ctor === 'Just') && (_p257._0 === '++')) {
									return A2(_user$project$LeoUnparser$unparseHtmlNode, _user$project$LeoUnparser$Interpolated, e);
								} else {
									return _user$project$LeoUnparser$unparse(e);
								}
							} else {
								return _user$project$LeoUnparser$unparse(e);
							}
						}
					} else {
						var _p258 = _user$project$Lang$unwrapExp(_p260);
						if ((_p258.ctor === 'EParens') && (_p258._2.ctor === 'LeoSyntax')) {
							return A2(_user$project$LeoUnparser$unparseHtmlNode, _user$project$LeoUnparser$Interpolated, e);
						} else {
							return _user$project$LeoUnparser$unparse(e);
						}
					}
				} else {
					break _v152_2;
				}
			}
		} else {
			break _v152_2;
		}
	} while(false);
	return A2(_user$project$LeoUnparser$unparseHtmlChildList, _user$project$LeoUnparser$Interpolated, e);
};

var _user$project$File$backupFilename = function (filename) {
	return _elm_lang$core$Native_Utils.update(
		filename,
		{
			name: A2(_elm_lang$core$Basics_ops['++'], filename.name, '~BACKUP')
		});
};
var _user$project$File$fileExtensionToString = function (fe) {
	var _p0 = fe;
	switch (_p0.ctor) {
		case 'LittleFile':
			return 'little';
		case 'LeoFile':
			return 'elm';
		case 'LittleIcon':
			return 'licon';
		default:
			return 'eicon';
	}
};
var _user$project$File$encodeFileExtension = function (fe) {
	return _elm_lang$core$Json_Encode$string(
		_user$project$File$fileExtensionToString(fe));
};
var _user$project$File$encodeFilename = function (_p1) {
	var _p2 = _p1;
	return _elm_lang$core$Json_Encode$object(
		{
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 'name',
				_1: _elm_lang$core$Json_Encode$string(_p2.name)
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: 'extension',
					_1: _user$project$File$encodeFileExtension(_p2.extension)
				},
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$File$encodeFile = function (file) {
	return _elm_lang$core$Json_Encode$object(
		{
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 'filename',
				_1: _user$project$File$encodeFilename(file.filename)
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: 'contents',
					_1: _elm_lang$core$Json_Encode$string(file.contents)
				},
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$File$Filename = F2(
	function (a, b) {
		return {name: a, extension: b};
	});
var _user$project$File$File = F2(
	function (a, b) {
		return {filename: a, contents: b};
	});
var _user$project$File$LeoIcon = {ctor: 'LeoIcon'};
var _user$project$File$LittleIcon = {ctor: 'LittleIcon'};
var _user$project$File$iconExtensionPrecedences = {
	ctor: '::',
	_0: _user$project$File$LeoIcon,
	_1: {
		ctor: '::',
		_0: _user$project$File$LittleIcon,
		_1: {ctor: '[]'}
	}
};
var _user$project$File$LeoFile = {ctor: 'LeoFile'};
var _user$project$File$LittleFile = {ctor: 'LittleFile'};
var _user$project$File$fileExtensionFromString = function (s) {
	var _p3 = s;
	switch (_p3) {
		case 'little':
			return _elm_lang$core$Maybe$Just(_user$project$File$LittleFile);
		case 'elm':
			return _elm_lang$core$Maybe$Just(_user$project$File$LeoFile);
		case 'licon':
			return _elm_lang$core$Maybe$Just(_user$project$File$LittleIcon);
		case 'eicon':
			return _elm_lang$core$Maybe$Just(_user$project$File$LeoIcon);
		default:
			return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$File$fileExtensionDecoder = A3(
	_elm_lang$core$Basics$flip,
	_elm_lang$core$Json_Decode$andThen,
	_elm_lang$core$Json_Decode$string,
	function (s) {
		var _p4 = _user$project$File$fileExtensionFromString(s);
		if (_p4.ctor === 'Just') {
			return _elm_lang$core$Json_Decode$succeed(_p4._0);
		} else {
			return _elm_lang$core$Json_Decode$fail(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Unknown file extension \'.',
					A2(_elm_lang$core$Basics_ops['++'], s, '\'')));
		}
	});
var _user$project$File$filenameDecoder = A3(
	_elm_lang$core$Json_Decode$map2,
	_user$project$File$Filename,
	A2(_elm_lang$core$Json_Decode$field, 'name', _elm_lang$core$Json_Decode$string),
	A2(_elm_lang$core$Json_Decode$field, 'extension', _user$project$File$fileExtensionDecoder));
var _user$project$File$fileDecoder = A3(
	_elm_lang$core$Json_Decode$map2,
	_user$project$File$File,
	A2(_elm_lang$core$Json_Decode$field, 'filename', _user$project$File$filenameDecoder),
	A2(_elm_lang$core$Json_Decode$field, 'contents', _elm_lang$core$Json_Decode$string));
var _user$project$File$fileIndexDecoder = _elm_lang$core$Json_Decode$list(_user$project$File$filenameDecoder);
var _user$project$File$parseFilename = function (s) {
	var $default = {name: s, extension: _user$project$File$LeoFile};
	var _p5 = _user$project$Utils$maybeLast(
		A2(_elm_lang$core$String$indexes, '.', s));
	if (_p5.ctor === 'Just') {
		var _p7 = _p5._0;
		var extensionString = A2(_elm_lang$core$String$dropLeft, _p7 + 1, s);
		var name = A2(_elm_lang$core$String$left, _p7, s);
		var _p6 = _user$project$File$fileExtensionFromString(extensionString);
		if (_p6.ctor === 'Just') {
			return {name: name, extension: _p6._0};
		} else {
			return $default;
		}
	} else {
		return $default;
	}
};

var _user$project$Syntax$encode = function (syntax) {
	return _elm_lang$core$Json_Encode$string(
		function () {
			var _p0 = syntax;
			if (_p0.ctor === 'Leo') {
				return 'Leo';
			} else {
				return 'Little';
			}
		}());
};
var _user$project$Syntax$iconExtension = function (syntax) {
	var _p1 = syntax;
	if (_p1.ctor === 'Leo') {
		return _user$project$File$LeoIcon;
	} else {
		return _user$project$File$LittleIcon;
	}
};
var _user$project$Syntax$sourceExtension = function (syntax) {
	var _p2 = syntax;
	if (_p2.ctor === 'Leo') {
		return _user$project$File$LeoFile;
	} else {
		return _user$project$File$LittleFile;
	}
};
var _user$project$Syntax$typeUnparser = function (syntax) {
	var _p3 = syntax;
	if (_p3.ctor === 'Little') {
		return _user$project$LangUnparser$unparseType;
	} else {
		return _user$project$LeoUnparser$unparseType;
	}
};
var _user$project$Syntax$patternUnparser = function (syntax) {
	var _p4 = syntax;
	if (_p4.ctor === 'Little') {
		return _user$project$LangUnparser$unparsePat;
	} else {
		return _user$project$LeoUnparser$unparsePattern;
	}
};
var _user$project$Syntax$unparser = function (syntax) {
	var _p5 = syntax;
	if (_p5.ctor === 'Little') {
		return _user$project$LangUnparser$unparse;
	} else {
		return _user$project$LeoUnparser$unparse;
	}
};
var _user$project$Syntax$parser = function (syntax) {
	var _p6 = syntax;
	if (_p6.ctor === 'Little') {
		return _user$project$FastParser$parseE;
	} else {
		return _user$project$LeoParser$parse;
	}
};
var _user$project$Syntax$convertSyntax = F3(
	function (oldSyntax, newSyntax, code) {
		return A2(
			_elm_lang$core$Result$map,
			_user$project$Syntax$unparser(newSyntax),
			A2(_user$project$Syntax$parser, oldSyntax, code));
	});
var _user$project$Syntax$Leo = {ctor: 'Leo'};
var _user$project$Syntax$Little = {ctor: 'Little'};
var _user$project$Syntax$fromFileExtension = function (extension) {
	var _p7 = extension;
	switch (_p7.ctor) {
		case 'LeoFile':
			return _user$project$Syntax$Leo;
		case 'LeoIcon':
			return _user$project$Syntax$Leo;
		case 'LittleFile':
			return _user$project$Syntax$Little;
		default:
			return _user$project$Syntax$Little;
	}
};

var _user$project$Types$dummyAceTypeInfo = {
	annotations: {ctor: '[]'},
	highlights: {ctor: '[]'},
	tooltips: {ctor: '[]'}
};
var _user$project$Types$aceTypeInfo = function (typeInfo) {
	var errorAnnots = A2(
		_elm_lang$core$List$map,
		function (i) {
			return {row: i, text: 'Type Error...', type_: 'error'};
		},
		_elm_lang$core$Set$toList(
			A3(
				_elm_lang$core$List$foldr,
				F2(
					function (typeError, acc) {
						return A2(_elm_lang$core$Set$insert, typeError.pos.line - 1, acc);
					}),
				_elm_lang$core$Set$empty,
				typeInfo.typeErrors)));
	var _p0 = A3(
		_elm_lang$core$List$foldr,
		F2(
			function (typeError, _p1) {
				var _p2 = _p1;
				var _p3 = {ctor: '_Tuple2', _0: typeError.pos.line - 1, _1: typeError.pos.col - 1};
				var i = _p3._0;
				var j = _p3._1;
				var tip = {row: i, col: j, text: typeError.val};
				var marker = {
					color: 'orange',
					range: {
						start: {row: i + 1, column: j + 1},
						end: {row: i + 1, column: j + 2}
					}
				};
				return {
					ctor: '_Tuple2',
					_0: {ctor: '::', _0: tip, _1: _p2._0},
					_1: {ctor: '::', _0: marker, _1: _p2._1}
				};
			}),
		{
			ctor: '_Tuple2',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'}
		},
		typeInfo.typeErrors);
	var errorTips = _p0._0;
	var errorHighlights = _p0._1;
	var varTypeTips = A3(
		_elm_lang$core$List$foldr,
		F2(
			function (_p4, acc) {
				var _p5 = _p4;
				var _p8 = _p5._0;
				var _p7 = _p5._1;
				var s1 = _elm_lang$core$String$trim(
					_user$project$LangUnparser$unparsePat(_p8));
				var _p6 = {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Dict$get, _p7, typeInfo.finalTypes),
					_1: A2(_elm_lang$core$Dict$get, _p7, typeInfo.rawTypes)
				};
				_v2_2:
				do {
					if (_p6.ctor === '_Tuple2') {
						if ((_p6._0.ctor === 'Just') && (_p6._0._0.ctor === 'Just')) {
							var text = A2(
								_elm_lang$core$Basics_ops['++'],
								s1,
								A2(
									_elm_lang$core$Basics_ops['++'],
									' : ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$String$trim(
											_user$project$LangUnparser$unparseType(_p6._0._0._0)),
										' ')));
							return {
								ctor: '::',
								_0: {row: _p8.start.line - 1, col: _p8.start.col - 1, text: text},
								_1: acc
							};
						} else {
							if (((_p6._1.ctor === 'Just') && (_p6._1._0.ctor === '_Tuple2')) && (_p6._1._0._1.ctor === 'Just')) {
								var text = A2(
									_elm_lang$core$Basics_ops['++'],
									s1,
									A2(
										_elm_lang$core$Basics_ops['++'],
										' : ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$String$trim(
												_user$project$LangUnparser$unparseType(_p6._1._0._1._0)),
											' ')));
								return {
									ctor: '::',
									_0: {row: _p8.start.line - 1, col: _p8.start.col - 1, text: text},
									_1: acc
								};
							} else {
								break _v2_2;
							}
						}
					} else {
						break _v2_2;
					}
				} while(false);
				return acc;
			}),
		{ctor: '[]'},
		typeInfo.namedExps);
	var expTypeTips = A3(
		_elm_lang$core$Dict$foldr,
		F3(
			function (eid, _p9, acc) {
				var _p10 = _p9;
				var _p12 = _p10._0;
				var record = function (t) {
					var text = _elm_lang$core$String$trim(
						_user$project$LangUnparser$unparseType(t));
					return {row: _p12.line - 1, col: _p12.col - 1, text: text};
				};
				var _p11 = {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Dict$get, eid, typeInfo.finalTypes),
					_1: _p10._1
				};
				_v4_2:
				do {
					if (_p11.ctor === '_Tuple2') {
						if ((_p11._0.ctor === 'Just') && (_p11._0._0.ctor === 'Just')) {
							return {
								ctor: '::',
								_0: record(_p11._0._0._0),
								_1: acc
							};
						} else {
							if (_p11._1.ctor === 'Just') {
								return {
									ctor: '::',
									_0: record(_p11._1._0),
									_1: acc
								};
							} else {
								break _v4_2;
							}
						}
					} else {
						break _v4_2;
					}
				} while(false);
				return acc;
			}),
		{ctor: '[]'},
		typeInfo.rawTypes);
	return {
		annotations: errorAnnots,
		highlights: errorHighlights,
		tooltips: A2(
			_elm_lang$core$Basics_ops['++'],
			varTypeTips,
			A2(_elm_lang$core$Basics_ops['++'], expTypeTips, errorTips))
	};
};
var _user$project$Types$preludeTypeEnv = {ctor: '[]'};
var _user$project$Types$initTypeInfo = {
	constraints: {ctor: '[]'},
	activeConstraints: {ctor: '[]'},
	typeErrors: {ctor: '[]'},
	rawTypes: _elm_lang$core$Dict$empty,
	finalTypes: _elm_lang$core$Dict$empty,
	namedExps: {ctor: '[]'},
	constraintCount: 0,
	constraintVarCount: 0,
	preludeTypeEnv: _elm_lang$core$Maybe$Nothing
};
var _user$project$Types$applyUnifier = function (unifier) {
	return _user$project$Lang$mapType(
		function (t) {
			var _p13 = t.val.t__;
			if (_p13.ctor === 'TVar') {
				var _p14 = A2(_user$project$Utils$maybeFind, _p13._1, unifier);
				if (_p14.ctor === 'Just') {
					return _p14._0;
				} else {
					return t;
				}
			} else {
				return t;
			}
		});
};
var _user$project$Types$applyUnifierToConstraints = function (unifier) {
	return _elm_lang$core$List$map(
		_elm_lang$core$Tuple$mapSecond(
			function (_p15) {
				var _p16 = _p15;
				return {
					ctor: '_Tuple2',
					_0: A2(_user$project$Types$applyUnifier, unifier, _p16._0),
					_1: A2(_user$project$Types$applyUnifier, unifier, _p16._1)
				};
			}));
};
var _user$project$Types$rewriteArrow = F2(
	function (unifier, _p17) {
		var _p18 = _p17;
		var argTypes_ = A2(
			_elm_lang$core$List$map,
			_user$project$Types$applyUnifier(unifier),
			_p18._0);
		var retType_ = A2(_user$project$Types$applyUnifier, unifier, _p18._1);
		return {ctor: '_Tuple2', _0: argTypes_, _1: retType_};
	});
var _user$project$Types$strUnifier = function (_p19) {
	return _user$project$Utils$bracks(
		_user$project$Utils$spaces(
			A2(
				_elm_lang$core$List$map,
				function (_p20) {
					var _p21 = _p20;
					return A2(
						_elm_lang$core$Basics_ops['++'],
						_p21._0,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'=',
							_elm_lang$core$String$trim(
								_user$project$LangUnparser$unparseType(_p21._1))));
				},
				_p19)));
};
var _user$project$Types$bindSubtypeResult = F2(
	function (f, res1) {
		var _p22 = res1.result;
		if (_p22.ctor === 'Err') {
			return {
				result: _elm_lang$core$Result$Err(_p22._0),
				typeInfo: res1.typeInfo
			};
		} else {
			return f(res1.typeInfo);
		}
	});
var _user$project$Types$tryCatchAlls = F2(
	function (err, list) {
		tryCatchAlls:
		while (true) {
			var _p23 = list;
			if (_p23.ctor === '[]') {
				return err;
			} else {
				var _p24 = _p23._0(
					{ctor: '_Tuple0'});
				if (_p24.ctor === 'Nothing') {
					var _v13 = err,
						_v14 = _p23._1;
					err = _v13;
					list = _v14;
					continue tryCatchAlls;
				} else {
					return {
						result: _elm_lang$core$Result$Ok(
							{ctor: '_Tuple0'}),
						typeInfo: _p24._0
					};
				}
			}
		}
	});
var _user$project$Types$intersect = F2(
	function (type1, type2) {
		var _p25 = {ctor: '_Tuple2', _0: type1.val.t__, _1: type2.val.t__};
		if ((_p25._0.ctor === 'TRecord') && (_p25._1.ctor === 'TRecord')) {
			return _elm_lang$core$Result$Ok(
				_user$project$Lang$withDummyTypeInfo(
					A4(
						_user$project$Lang$TRecord,
						_user$project$Lang$space1,
						_p25._0._1,
						A3(
							_user$project$Record$mergeLabelValues,
							F2(
								function (_p27, _p26) {
									var _p28 = _p27;
									var _p29 = _p26;
									return _elm_lang$core$Native_Utils.eq(_p28._2, _p29._2);
								}),
							_p25._0._2,
							_p25._1._2),
						_user$project$Lang$space0)));
		} else {
			return _elm_lang$core$Result$Err('Cannnot interect record types with anything else than records.');
		}
	});
var _user$project$Types$propagateResult = function (result) {
	return result;
};
var _user$project$Types$isWellFormed = F2(
	function (typeEnv, tipe) {
		return false;
	});
var _user$project$Types$isConstraintVar = function (a) {
	var _p30 = A2(_user$project$Utils$munchString, '_x', a);
	if (_p30.ctor === 'Nothing') {
		return false;
	} else {
		return true;
	}
};
var _user$project$Types$constraintVarsOf = function (ts) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (argType, acc) {
				var _p31 = argType.val.t__;
				if (_p31.ctor === 'TVar') {
					var _p32 = _p31._1;
					return _user$project$Types$isConstraintVar(_p32) ? A2(_elm_lang$core$Set$insert, _p32, acc) : acc;
				} else {
					return acc;
				}
			}),
		_elm_lang$core$Set$empty,
		ts);
};
var _user$project$Types$constraintVarsOfArrow = function (_p33) {
	var _p34 = _p33;
	return _user$project$Types$constraintVarsOf(
		A2(
			_elm_lang$core$Basics_ops['++'],
			_p34._0,
			{
				ctor: '::',
				_0: _p34._1,
				_1: {ctor: '[]'}
			}));
};
var _user$project$Types$checkSubtypeTVar = F3(
	function (t, okConstrain, err) {
		var _p35 = t.val.t__;
		if (_p35.ctor === 'TVar') {
			if (_user$project$Types$isConstraintVar(_p35._1)) {
				var result = okConstrain;
				return _elm_lang$core$Maybe$Just(result.typeInfo);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$splitTypesInArrow = function (ts) {
	var n = _elm_lang$core$List$length(ts);
	var argTypes = A2(_elm_lang$core$List$take, n - 1, ts);
	var _p36 = A2(_elm_lang$core$List$drop, n - 1, ts);
	if ((_p36.ctor === '::') && (_p36._1.ctor === '[]')) {
		return {ctor: '_Tuple2', _0: argTypes, _1: _p36._0};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Types',
			{
				start: {line: 559, column: 3},
				end: {line: 561, column: 52}
			},
			_p36)('splitTypesInArrow');
	}
};
var _user$project$Types$isArrowTemplate = function (tipe) {
	var _p38 = tipe.val.t__;
	if (_p38.ctor === 'TArrow') {
		var _p39 = _p38._1;
		return _elm_lang$core$Set$isEmpty(
			_user$project$Types$constraintVarsOf(_p39)) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
			_user$project$Types$splitTypesInArrow(_p39));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Types$stripArrow = function (t) {
	var _p40 = t.val.t__;
	if (_p40.ctor === 'TArrow') {
		return _elm_lang$core$Maybe$Just(
			_user$project$Types$splitTypesInArrow(_p40._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Types$stripPolymorphicArrow = function (t) {
	var _p41 = t.val.t__;
	if (_p41.ctor === 'TForall') {
		return A2(
			_user$project$Utils$bindMaybe,
			function (arrow) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: A2(
							_elm_lang$core$List$map,
							function (_p42) {
								return A2(
									_user$project$Utils$fromJust_,
									'Types',
									_user$project$Lang$tpVarUnapply(_p42));
							},
							_p41._1),
						_1: arrow
					});
			},
			_user$project$Types$stripArrow(_p41._2));
	} else {
		return A2(
			_user$project$Utils$bindMaybe,
			function (arrow) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: arrow
					});
			},
			_user$project$Types$stripArrow(t));
	}
};
var _user$project$Types$generateConstraintVars = F2(
	function (n, typeInfo) {
		var k = typeInfo.constraintVarCount;
		var vars = A2(
			_elm_lang$core$List$map,
			function (i) {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'_x',
					_elm_lang$core$Basics$toString(i));
			},
			A2(_elm_lang$core$List$range, k + 1, k + n));
		return {
			ctor: '_Tuple2',
			_0: vars,
			_1: _elm_lang$core$Native_Utils.update(
				typeInfo,
				{constraintVarCount: k + n})
		};
	});
var _user$project$Types$addTypeErrorAt = F3(
	function (pos, typeError, typeInfo) {
		return _elm_lang$core$Native_Utils.update(
			typeInfo,
			{
				typeErrors: {
					ctor: '::',
					_0: A2(_user$project$Pos$WithPos, typeError, pos),
					_1: typeInfo.typeErrors
				}
			});
	});
var _user$project$Types$finishSynthesizeWithError = F3(
	function (pos, error, typeInfo) {
		return {
			result: _elm_lang$core$Maybe$Nothing,
			typeInfo: A3(_user$project$Types$addTypeErrorAt, pos, error, typeInfo)
		};
	});
var _user$project$Types$addFinalType = F3(
	function (eid, mt, typeInfo) {
		return _elm_lang$core$Native_Utils.update(
			typeInfo,
			{
				finalTypes: A3(_elm_lang$core$Dict$insert, eid, mt, typeInfo.finalTypes)
			});
	});
var _user$project$Types$addRawType = F4(
	function (eid, pos, mt, typeInfo) {
		return _elm_lang$core$Native_Utils.update(
			typeInfo,
			{
				rawTypes: A3(
					_elm_lang$core$Dict$insert,
					eid,
					{ctor: '_Tuple2', _0: pos, _1: mt},
					typeInfo.rawTypes)
			});
	});
var _user$project$Types$finishSynthesizeWithType = F4(
	function (eid, pos, tipe, typeInfo) {
		return {
			result: _elm_lang$core$Maybe$Just(tipe),
			typeInfo: A4(
				_user$project$Types$addRawType,
				eid,
				pos,
				_elm_lang$core$Maybe$Just(tipe),
				typeInfo)
		};
	});
var _user$project$Types$addNamedExp = F3(
	function (p, eid, typeInfo) {
		return _elm_lang$core$Native_Utils.update(
			typeInfo,
			{
				namedExps: {
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: p, _1: eid},
					_1: typeInfo.namedExps
				}
			});
	});
var _user$project$Types$addRawConstraints = F2(
	function (constraints, typeInfo) {
		var k = typeInfo.constraintCount;
		var n = _elm_lang$core$List$length(constraints);
		var constraints_ = A2(
			_user$project$Utils$zip,
			A2(_elm_lang$core$List$range, k + 1, k + n),
			constraints);
		return _elm_lang$core$Native_Utils.update(
			typeInfo,
			{
				constraints: A2(_elm_lang$core$Basics_ops['++'], constraints_, typeInfo.constraints),
				activeConstraints: A2(_elm_lang$core$Basics_ops['++'], constraints_, typeInfo.activeConstraints),
				constraintCount: k + n
			});
	});
var _user$project$Types$expandTypeAlias = F2(
	function (typeEnv, x) {
		expandTypeAlias:
		while (true) {
			var check = function (pts) {
				check:
				while (true) {
					var _p43 = pts;
					if (_p43.ctor === '[]') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						var _p46 = _p43._0._1;
						var _p45 = _p43._1;
						var _p44 = {ctor: '_Tuple2', _0: _p43._0._0.val.p__, _1: _p46.val.t__};
						_v27_2:
						do {
							if (_p44.ctor === '_Tuple2') {
								switch (_p44._0.ctor) {
									case 'PVar':
										if (_elm_lang$core$Native_Utils.eq(x, _p44._0._1)) {
											return _elm_lang$core$Maybe$Just(_p46);
										} else {
											var _v28 = _p45;
											pts = _v28;
											continue check;
										}
									case 'PList':
										if (((_p44._0._3.ctor === 'Nothing') && (_p44._1.ctor === 'TTuple')) && (_p44._1._3.ctor === 'Nothing')) {
											var _v29 = A2(
												_elm_lang$core$Basics_ops['++'],
												A2(_user$project$Utils$zip, _p44._0._1, _p44._1._1),
												_p45);
											pts = _v29;
											continue check;
										} else {
											break _v27_2;
										}
									default:
										break _v27_2;
								}
							} else {
								break _v27_2;
							}
						} while(false);
						return _elm_lang$core$Maybe$Nothing;
					}
				}
			};
			var _p47 = typeEnv;
			if (_p47.ctor === '::') {
				if (_p47._0.ctor === 'TypeAlias') {
					var _p48 = check(
						{
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p47._0._0, _1: _p47._0._1},
							_1: {ctor: '[]'}
						});
					if (_p48.ctor === 'Just') {
						return _elm_lang$core$Maybe$Just(_p48._0);
					} else {
						var _v32 = _p47._1,
							_v33 = x;
						typeEnv = _v32;
						x = _v33;
						continue expandTypeAlias;
					}
				} else {
					var _v34 = _p47._1,
						_v35 = x;
					typeEnv = _v34;
					x = _v35;
					continue expandTypeAlias;
				}
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		}
	});
var _user$project$Types$lookupTypeAlias = F2(
	function (typeEnv, x) {
		var _p49 = A2(_user$project$Types$expandTypeAlias, typeEnv, x);
		if (_p49.ctor === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var _user$project$Types$lookupTypAnnotation_ = F2(
	function (typeEnv, x) {
		lookupTypAnnotation_:
		while (true) {
			var _p50 = typeEnv;
			if (_p50.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				switch (_p50._0.ctor) {
					case 'TypeVar':
						var _v38 = _p50._1,
							_v39 = x;
						typeEnv = _v38;
						x = _v39;
						continue lookupTypAnnotation_;
					case 'TypeAlias':
						var _v40 = _p50._1,
							_v41 = x;
						typeEnv = _v40;
						x = _v41;
						continue lookupTypAnnotation_;
					case 'CheckType':
						if (_elm_lang$core$Native_Utils.eq(x, _p50._0._0)) {
							return _elm_lang$core$Maybe$Just(_p50._0._1);
						} else {
							var _v42 = _p50._1,
								_v43 = x;
							typeEnv = _v42;
							x = _v43;
							continue lookupTypAnnotation_;
						}
					default:
						if (_elm_lang$core$Native_Utils.eq(x, _p50._0._0)) {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							var _v44 = _p50._1,
								_v45 = x;
							typeEnv = _v44;
							x = _v45;
							continue lookupTypAnnotation_;
						}
				}
			}
		}
	});
var _user$project$Types$lookupTypAnnotation = F2(
	function (typeEnv, p) {
		var _p51 = p.val.p__;
		if (_p51.ctor === 'PVar') {
			return A2(_user$project$Types$lookupTypAnnotation_, typeEnv, _p51._1);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$lookupVar = F2(
	function (typeEnv, x) {
		lookupVar:
		while (true) {
			var _p52 = typeEnv;
			if (_p52.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				switch (_p52._0.ctor) {
					case 'TypeVar':
						var _v48 = _p52._1,
							_v49 = x;
						typeEnv = _v48;
						x = _v49;
						continue lookupVar;
					case 'TypeAlias':
						var _v50 = _p52._1,
							_v51 = x;
						typeEnv = _v50;
						x = _v51;
						continue lookupVar;
					case 'HasType':
						if (_elm_lang$core$Native_Utils.eq(x, _p52._0._0)) {
							return _elm_lang$core$Maybe$Just(_p52._0._1);
						} else {
							var _v52 = _p52._1,
								_v53 = x;
							typeEnv = _v52;
							x = _v53;
							continue lookupVar;
						}
					default:
						if (_elm_lang$core$Native_Utils.eq(x, _p52._0._0)) {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							var _v54 = _p52._1,
								_v55 = x;
							typeEnv = _v54;
							x = _v55;
							continue lookupVar;
						}
				}
			}
		}
	});
var _user$project$Types$strRawConstraint = function (_p53) {
	var _p54 = _p53;
	return _user$project$Utils$spaces(
		{
			ctor: '::',
			_0: _elm_lang$core$String$trim(
				_user$project$LangUnparser$unparseType(_p54._0)),
			_1: {
				ctor: '::',
				_0: '=',
				_1: {
					ctor: '::',
					_0: _elm_lang$core$String$trim(
						_user$project$LangUnparser$unparseType(_p54._1)),
					_1: {ctor: '[]'}
				}
			}
		});
};
var _user$project$Types$strConstraint = function (_p55) {
	var _p56 = _p55;
	return _user$project$Utils$spaces(
		{
			ctor: '::',
			_0: _user$project$Utils$bracks(
				_elm_lang$core$Basics$toString(_p56._0)),
			_1: {
				ctor: '::',
				_0: _user$project$Types$strRawConstraint(_p56._1),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$Types$strEInfo = function (eInfo) {
	return _user$project$Utils$spaces(
		{
			ctor: '::',
			_0: _elm_lang$core$Basics$toString(eInfo.val),
			_1: {
				ctor: '::',
				_0: _user$project$Lang$strPos(eInfo.start),
				_1: {ctor: '[]'}
			}
		});
};
var _user$project$Types$eInfoOf = function (_p57) {
	var _p58 = _p57;
	var _p59 = _p58._0;
	return {
		val: _user$project$Lang$expEId(
			_user$project$Lang$Expr(_p59)),
		start: _p59.start,
		end: _p59.end
	};
};
var _user$project$Types$tForall = F2(
	function (vars, t) {
		var _p60 = vars;
		if (_p60.ctor === '[]') {
			return _elm_lang$core$Native_Utils.crashCase(
				'Types',
				{
					start: {line: 223, column: 3},
					end: {line: 227, column: 66}
				},
				_p60)('tForall: no vars');
		} else {
			if (_p60._1.ctor === '[]') {
				return _user$project$Lang$withDummyTypeInfo(
					A4(
						_user$project$Lang$TForall,
						_user$project$Lang$space1,
						{
							ctor: '::',
							_0: _user$project$Lang$withDummyRange(
								A2(_user$project$Lang$TPatVar, _user$project$Lang$space1, _p60._0)),
							_1: {ctor: '[]'}
						},
						t,
						_user$project$Lang$space0));
			} else {
				var typeVars = {
					ctor: '::',
					_0: _user$project$Lang$withDummyRange(
						A2(_user$project$Lang$TPatVar, _user$project$Lang$space0, _p60._0)),
					_1: A2(
						_elm_lang$core$List$map,
						function (a) {
							return _user$project$Lang$withDummyRange(
								A2(_user$project$Lang$TPatVar, _user$project$Lang$space1, a));
						},
						_p60._1)
				};
				return _user$project$Lang$withDummyTypeInfo(
					A4(_user$project$Lang$TForall, _user$project$Lang$space1, typeVars, t, _user$project$Lang$space0));
			}
		}
	});
var _user$project$Types$tArrow = function (_p62) {
	var _p63 = _p62;
	return _user$project$Lang$withDummyTypeInfo(
		A3(
			_user$project$Lang$TArrow,
			_user$project$Lang$space1,
			A2(
				_elm_lang$core$Basics_ops['++'],
				_p63._0,
				{
					ctor: '::',
					_0: _p63._1,
					_1: {ctor: '[]'}
				}),
			_user$project$Lang$space0));
};
var _user$project$Types$tPolyArrow = F2(
	function (vars, arrowType) {
		return A2(
			_user$project$Types$tForall,
			vars,
			_user$project$Types$tArrow(arrowType));
	});
var _user$project$Types$tUnion = function (ts) {
	return _user$project$Lang$withDummyTypeInfo(
		A3(_user$project$Lang$TUnion, _user$project$Lang$space1, ts, _user$project$Lang$space0));
};
var _user$project$Types$tList = function (t) {
	return _user$project$Lang$withDummyTypeInfo(
		A3(_user$project$Lang$TList, _user$project$Lang$space1, t, _user$project$Lang$space0));
};
var _user$project$Types$joinTypes_ = F2(
	function (t1, t2) {
		var err = _elm_lang$core$Result$Err(
			_user$project$Utils$spaces(
				{
					ctor: '::',
					_0: 'joinTypes failed:',
					_1: {
						ctor: '::',
						_0: _user$project$LangUnparser$unparseType(t1),
						_1: {
							ctor: '::',
							_0: _user$project$LangUnparser$unparseType(t2),
							_1: {ctor: '[]'}
						}
					}
				}));
		var _p64 = {ctor: '_Tuple2', _0: t1.val.t__, _1: t2.val.t__};
		_v61_3:
		do {
			if (_p64.ctor === '_Tuple2') {
				switch (_p64._1.ctor) {
					case 'TList':
						if (((_p64._0.ctor === 'TTuple') && (_p64._0._1.ctor === '[]')) && (_p64._0._3.ctor === 'Nothing')) {
							return _elm_lang$core$Result$Ok(t2);
						} else {
							break _v61_3;
						}
					case 'TTuple':
						if (((_p64._0.ctor === 'TTuple') && (_p64._0._1.ctor === '[]')) && (_p64._0._3.ctor === 'Nothing')) {
							var _p65 = _user$project$Types$joinManyTypes(_p64._1._1);
							if (_p65.ctor === 'Err') {
								return err;
							} else {
								var _p68 = _p65._0;
								var _p66 = _p64._1._3;
								if (_p66.ctor === 'Nothing') {
									return _elm_lang$core$Result$Ok(
										_user$project$Types$tList(_p68));
								} else {
									var _p67 = A2(
										_user$project$Types$joinTypes,
										_user$project$Types$tList(_p68),
										_p66._0);
									if (_p67.ctor === 'Err') {
										return err;
									} else {
										return _elm_lang$core$Result$Ok(_p67._0);
									}
								}
							}
						} else {
							break _v61_3;
						}
					case 'TUnion':
						var _p71 = _p64._1._1;
						var someEqualType = A3(
							_elm_lang$core$List$foldl,
							F2(
								function (tipe2, acc) {
									var _p69 = acc;
									if (_p69.ctor === 'Just') {
										return _elm_lang$core$Maybe$Just(
											{ctor: '_Tuple0'});
									} else {
										return A2(_user$project$Types$checkEqualType, t1, tipe2) ? _elm_lang$core$Maybe$Just(
											{ctor: '_Tuple0'}) : _elm_lang$core$Maybe$Nothing;
									}
								}),
							_elm_lang$core$Maybe$Nothing,
							_p71);
						var _p70 = someEqualType;
						if (_p70.ctor === 'Just') {
							return _elm_lang$core$Result$Ok(t2);
						} else {
							return _elm_lang$core$Result$Ok(
								_user$project$Types$tUnion(
									{ctor: '::', _0: t1, _1: _p71}));
						}
					default:
						break _v61_3;
				}
			} else {
				break _v61_3;
			}
		} while(false);
		return _elm_lang$core$Result$Ok(
			_user$project$Types$tUnion(
				{
					ctor: '::',
					_0: t1,
					_1: {
						ctor: '::',
						_0: t2,
						_1: {ctor: '[]'}
					}
				}));
	});
var _user$project$Types$checkEqualType = F2(
	function (tipe1, tipe2) {
		var dummyTypeEnv = {ctor: '[]'};
		var result = A4(_user$project$Types$checkEquivType, _user$project$Types$initTypeInfo, dummyTypeEnv, tipe1, tipe2);
		var _p72 = result.result;
		if (_p72.ctor === 'Err') {
			return false;
		} else {
			return _elm_lang$core$Native_Utils.eq(
				result.typeInfo.constraints,
				{ctor: '[]'});
		}
	});
var _user$project$Types$checkEquivType = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		return A2(
			_user$project$Types$bindSubtypeResult,
			function (typeInfo_) {
				return A4(_user$project$Types$checkSubtype, typeInfo_, typeEnv, tipe2, tipe1);
			},
			A4(_user$project$Types$checkSubtype, typeInfo, typeEnv, tipe1, tipe2));
	});
var _user$project$Types$checkSubtype = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		checkSubtype:
		while (true) {
			var errAdd = function (msg) {
				return {
					typeInfo: typeInfo,
					result: _elm_lang$core$Result$Err(
						_user$project$Utils$spaces(
							{
								ctor: '::',
								_0: 'checkSubtype failed:',
								_1: {
									ctor: '::',
									_0: _elm_lang$core$String$trim(
										_user$project$LangUnparser$unparseType(tipe1)),
									_1: {
										ctor: '::',
										_0: ' <: ',
										_1: {
											ctor: '::',
											_0: _elm_lang$core$String$trim(
												_user$project$LangUnparser$unparseType(tipe2)),
											_1: {
												ctor: '::',
												_0: msg,
												_1: {ctor: '[]'}
											}
										}
									}
								}
							}))
				};
			};
			var err = errAdd('');
			var ok = {
				typeInfo: typeInfo,
				result: _elm_lang$core$Result$Ok(
					{ctor: '_Tuple0'})
			};
			var okConstrain = {
				result: _elm_lang$core$Result$Ok(
					{ctor: '_Tuple0'}),
				typeInfo: A2(
					_user$project$Types$addRawConstraints,
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: tipe1, _1: tipe2},
						_1: {ctor: '[]'}
					},
					typeInfo)
			};
			var _p73 = {ctor: '_Tuple2', _0: tipe1.val.t__, _1: tipe2.val.t__};
			_v68_15:
			do {
				_v68_6:
				do {
					if (_p73.ctor === '_Tuple2') {
						switch (_p73._0.ctor) {
							case 'TNum':
								switch (_p73._1.ctor) {
									case 'TNum':
										return ok;
									case 'TApp':
										break _v68_6;
									default:
										break _v68_15;
								}
							case 'TBool':
								switch (_p73._1.ctor) {
									case 'TBool':
										return ok;
									case 'TApp':
										break _v68_6;
									default:
										break _v68_15;
								}
							case 'TString':
								switch (_p73._1.ctor) {
									case 'TString':
										return ok;
									case 'TApp':
										break _v68_6;
									default:
										break _v68_15;
								}
							case 'TNull':
								switch (_p73._1.ctor) {
									case 'TNull':
										return ok;
									case 'TApp':
										break _v68_6;
									default:
										break _v68_15;
								}
							case 'TApp':
								if (_p73._1.ctor === 'TApp') {
									return errAdd('TODO: Implement this part');
								} else {
									return errAdd('TODO: Implement this part Types.elm');
								}
							case 'TUnion':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TUnion':
										var allOk = A3(
											_elm_lang$core$List$foldl,
											function (t1) {
												return _user$project$Utils$bindMaybe(
													function (acc) {
														return A4(_user$project$Types$checkSubtypeSomeRight, acc, typeEnv, t1, _p73._1._1);
													});
											},
											_elm_lang$core$Maybe$Just(typeInfo),
											_p73._0._1);
										var _p74 = allOk;
										if (_p74.ctor === 'Nothing') {
											return err;
										} else {
											return {
												result: _elm_lang$core$Result$Ok(
													{ctor: '_Tuple0'}),
												typeInfo: _p74._0
											};
										}
									default:
										break _v68_15;
								}
							case 'TList':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TList':
										var _v70 = typeInfo,
											_v71 = typeEnv,
											_v72 = _p73._0._1,
											_v73 = _p73._1._1;
										typeInfo = _v70;
										typeEnv = _v71;
										tipe1 = _v72;
										tipe2 = _v73;
										continue checkSubtype;
									default:
										break _v68_15;
								}
							case 'TDict':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TDict':
										return A2(
											_user$project$Types$bindSubtypeResult,
											function (typeInfo_) {
												return A4(_user$project$Types$checkSubtype, typeInfo_, typeEnv, _p73._0._2, _p73._1._2);
											},
											A4(_user$project$Types$checkEquivType, typeInfo, typeEnv, _p73._0._1, _p73._1._1));
									default:
										break _v68_15;
								}
							case 'TTuple':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TTuple':
										var _p75 = A2(_user$project$Utils$maybeZip, _p73._0._1, _p73._1._1);
										if (_p75.ctor === 'Nothing') {
											return errAdd('lengths of tuple types are not equal');
										} else {
											return A2(
												_user$project$Types$bindSubtypeResult,
												function (typeInfo_) {
													return A4(_user$project$Types$checkSubMaybeType, typeInfo_, typeEnv, _p73._0._3, _p73._1._3);
												},
												A3(_user$project$Types$checkSubtypeList, typeInfo, typeEnv, _p75._0));
										}
									case 'TList':
										if (_p73._0._3.ctor === 'Nothing') {
											var _p76 = _p73._0._1;
											var n = _elm_lang$core$List$length(_p76);
											return A3(
												_user$project$Types$checkSubtypeList,
												typeInfo,
												typeEnv,
												A2(
													_user$project$Utils$zip,
													_p76,
													A2(_elm_lang$core$List$repeat, n, _p73._1._1)));
										} else {
											var _p77 = _p73._0._3._0.val.t__;
											if (_p77.ctor === 'TList') {
												var ts_ = A2(
													_elm_lang$core$Basics_ops['++'],
													_p73._0._1,
													{
														ctor: '::',
														_0: _p77._1,
														_1: {ctor: '[]'}
													});
												var n = _elm_lang$core$List$length(ts_);
												return A3(
													_user$project$Types$checkSubtypeList,
													typeInfo,
													typeEnv,
													A2(
														_user$project$Utils$zip,
														ts_,
														A2(_elm_lang$core$List$repeat, n, _p73._1._1)));
											} else {
												return errAdd('the rest type of the tuple is not a list type');
											}
										}
									default:
										break _v68_15;
								}
							case 'TArrow':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TArrow':
										var _p78 = _user$project$Types$splitTypesInArrow(_p73._0._1);
										var args1 = _p78._0;
										var ret1 = _p78._1;
										var _p79 = _user$project$Types$splitTypesInArrow(_p73._1._1);
										var args2 = _p79._0;
										var ret2 = _p79._1;
										var _p80 = A2(_user$project$Utils$maybeZip, args2, args1);
										if (_p80.ctor === 'Nothing') {
											return err;
										} else {
											var result = A3(_user$project$Types$checkSubtypeList, typeInfo, typeEnv, _p80._0);
											var _p81 = result.result;
											if (_p81.ctor === 'Err') {
												return err;
											} else {
												var _v78 = result.typeInfo,
													_v79 = typeEnv,
													_v80 = ret1,
													_v81 = ret2;
												typeInfo = _v78;
												typeEnv = _v79;
												tipe1 = _v80;
												tipe2 = _v81;
												continue checkSubtype;
											}
										}
									default:
										break _v68_15;
								}
							case 'TVar':
								switch (_p73._1.ctor) {
									case 'TApp':
										break _v68_6;
									case 'TVar':
										var _p83 = _p73._1._1;
										var _p82 = _p73._0._1;
										return (_user$project$Types$isConstraintVar(_p82) && _user$project$Types$isConstraintVar(_p83)) ? (_elm_lang$core$Native_Utils.eq(_p82, _p83) ? ok : okConstrain) : (_user$project$Types$isConstraintVar(_p82) ? okConstrain : (_user$project$Types$isConstraintVar(_p83) ? okConstrain : (_elm_lang$core$Native_Utils.eq(_p82, _p83) ? ok : err)));
									default:
										break _v68_15;
								}
							default:
								if (_p73._1.ctor === 'TApp') {
									break _v68_6;
								} else {
									break _v68_15;
								}
						}
					} else {
						break _v68_15;
					}
				} while(false);
				return errAdd('TODO: Implement this part in Types.elm');
			} while(false);
			return A2(
				_user$project$Types$tryCatchAlls,
				err,
				{
					ctor: '::',
					_0: function (_p84) {
						var _p85 = _p84;
						return A3(_user$project$Types$checkSubtypeTVar, tipe1, okConstrain, err);
					},
					_1: {
						ctor: '::',
						_0: function (_p86) {
							var _p87 = _p86;
							return A3(_user$project$Types$checkSubtypeTVar, tipe2, okConstrain, err);
						},
						_1: {
							ctor: '::',
							_0: function (_p88) {
								var _p89 = _p88;
								return A4(_user$project$Types$checkSubtypeUnionRight, typeInfo, typeEnv, tipe1, tipe2);
							},
							_1: {
								ctor: '::',
								_0: function (_p90) {
									var _p91 = _p90;
									return A4(_user$project$Types$checkSubtypeUnionLeft, typeInfo, typeEnv, tipe1, tipe2);
								},
								_1: {
									ctor: '::',
									_0: function (_p92) {
										var _p93 = _p92;
										return A4(_user$project$Types$checkSubtypeFoldLeft, typeInfo, typeEnv, tipe1, tipe2);
									},
									_1: {
										ctor: '::',
										_0: function (_p94) {
											var _p95 = _p94;
											return A4(_user$project$Types$checkSubtypeSingletonUnion, typeInfo, typeEnv, tipe1, tipe2);
										},
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}
				});
		}
	});
var _user$project$Types$checkSubMaybeType = F4(
	function (typeInfo, typeEnv, mt1, mt2) {
		var _p96 = {ctor: '_Tuple2', _0: mt1, _1: mt2};
		_v88_2:
		do {
			if (_p96.ctor === '_Tuple2') {
				if (_p96._0.ctor === 'Just') {
					if (_p96._1.ctor === 'Just') {
						return A4(_user$project$Types$checkSubtype, typeInfo, typeEnv, _p96._0._0, _p96._1._0);
					} else {
						break _v88_2;
					}
				} else {
					if (_p96._1.ctor === 'Nothing') {
						return {
							result: _elm_lang$core$Result$Ok(
								{ctor: '_Tuple0'}),
							typeInfo: typeInfo
						};
					} else {
						break _v88_2;
					}
				}
			} else {
				break _v88_2;
			}
		} while(false);
		return {
			result: _elm_lang$core$Result$Err('checkSubMaybeType failed...'),
			typeInfo: typeInfo
		};
	});
var _user$project$Types$checkSubtypeFoldLeft = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		var _p97 = _user$project$Types$coerceTupleToList(tipe1);
		if ((_p97.ctor === 'Just') && (_p97._0.ctor === 'Ok')) {
			var result = A4(_user$project$Types$checkSubtype, typeInfo, typeEnv, _p97._0._0, tipe2);
			var _p98 = result.result;
			if (_p98.ctor === 'Ok') {
				return _elm_lang$core$Maybe$Just(result.typeInfo);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$coerceTupleToList = function (t) {
	var _p99 = t.val.t__;
	if (_p99.ctor === 'TTuple') {
		if (_p99._1.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p100 = _user$project$Types$joinManyTypes(_p99._1);
			if (_p100.ctor === 'Err') {
				return _elm_lang$core$Maybe$Just(
					_elm_lang$core$Result$Err(_p100._0));
			} else {
				var _p103 = _p100._0;
				var _p101 = _p99._3;
				if (_p101.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Just(
						_elm_lang$core$Result$Ok(
							_user$project$Types$tList(_p103)));
				} else {
					var _p102 = A2(
						_user$project$Types$joinTypes,
						_user$project$Types$tList(_p103),
						_p101._0);
					if (_p102.ctor === 'Err') {
						return _elm_lang$core$Maybe$Just(
							_elm_lang$core$Result$Err(_p102._0));
					} else {
						return _elm_lang$core$Maybe$Just(
							_elm_lang$core$Result$Ok(_p102._0));
					}
				}
			}
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Types$joinManyTypes = function (ts) {
	var _p104 = ts;
	if (_p104.ctor === '[]') {
		return _elm_lang$core$Native_Utils.crashCase(
			'Types',
			{
				start: {line: 1644, column: 3},
				end: {line: 1651, column: 19}
			},
			_p104)('joinManyTypes: empty list');
	} else {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (tNext, acc) {
					var _p106 = acc;
					if (_p106.ctor === 'Err') {
						return _elm_lang$core$Result$Err(_p106._0);
					} else {
						return A2(_user$project$Types$joinTypes, tNext, _p106._0);
					}
				}),
			_elm_lang$core$Result$Ok(_p104._0),
			_p104._1);
	}
};
var _user$project$Types$joinTypes = F2(
	function (t1, t2) {
		var dummyTypeInfo = _user$project$Types$initTypeInfo;
		var dummyTypeEnv = {ctor: '[]'};
		var _p107 = A4(_user$project$Types$checkSubtype, dummyTypeInfo, dummyTypeEnv, t1, t2).result;
		if ((_p107.ctor === 'Ok') && (_p107._0.ctor === '_Tuple0')) {
			return _elm_lang$core$Result$Ok(t2);
		} else {
			var _p108 = A4(_user$project$Types$checkSubtype, dummyTypeInfo, dummyTypeEnv, t2, t1).result;
			if ((_p108.ctor === 'Ok') && (_p108._0.ctor === '_Tuple0')) {
				return _elm_lang$core$Result$Ok(t1);
			} else {
				var _p109 = A2(_user$project$Types$joinTypes_, t1, t2);
				if (_p109.ctor === 'Ok') {
					return _elm_lang$core$Result$Ok(_p109._0);
				} else {
					return A2(_user$project$Types$joinTypes_, t2, t1);
				}
			}
		}
	});
var _user$project$Types$checkSubtypeList = F3(
	function (typeInfo, typeEnv, list) {
		var _p110 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p112, _p111) {
					var _p113 = _p112;
					var _p114 = _p111;
					var _p117 = _p114._1;
					var _p116 = _p114._0;
					var _p115 = _p116;
					if (_p115.ctor === 'Err') {
						return {ctor: '_Tuple2', _0: _p116, _1: _p117};
					} else {
						var nextResult = A4(_user$project$Types$checkSubtype, _p117, typeEnv, _p113._0, _p113._1);
						return {ctor: '_Tuple2', _0: nextResult.result, _1: nextResult.typeInfo};
					}
				}),
			{
				ctor: '_Tuple2',
				_0: _elm_lang$core$Result$Ok(
					{ctor: '_Tuple0'}),
				_1: typeInfo
			},
			list);
		var result = _p110._0;
		var typeInfo_ = _p110._1;
		return {result: result, typeInfo: typeInfo_};
	});
var _user$project$Types$checkSubtypeSingletonUnion = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		var _p118 = tipe1.val.t__;
		if (((_p118.ctor === 'TUnion') && (_p118._1.ctor === '::')) && (_p118._1._1.ctor === '[]')) {
			var result = A4(_user$project$Types$checkSubtype, typeInfo, typeEnv, _p118._1._0, tipe2);
			var _p119 = result.result;
			if (_p119.ctor === 'Ok') {
				return _elm_lang$core$Maybe$Just(result.typeInfo);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$checkSubtypeSomeRight = F4(
	function (typeInfo, typeEnv, t1, ts2) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (t2, acc) {
					var _p120 = acc;
					if (_p120.ctor === 'Just') {
						return acc;
					} else {
						var result = A4(_user$project$Types$checkSubtype, typeInfo, typeEnv, t1, t2);
						var _p121 = result.result;
						if (_p121.ctor === 'Ok') {
							return _elm_lang$core$Maybe$Just(result.typeInfo);
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					}
				}),
			_elm_lang$core$Maybe$Nothing,
			ts2);
	});
var _user$project$Types$checkSubtypeUnionLeft = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		var _p122 = {ctor: '_Tuple2', _0: tipe1.val.t__, _1: tipe2.val.t__};
		if ((_p122.ctor === '_Tuple2') && (_p122._0.ctor === 'TUnion')) {
			var _p124 = _p122._0._1;
			var obligations = A2(
				_user$project$Utils$zip,
				_p124,
				A2(
					_elm_lang$core$List$repeat,
					_elm_lang$core$List$length(_p124),
					tipe2));
			var result = A3(_user$project$Types$checkSubtypeList, typeInfo, typeEnv, obligations);
			var _p123 = result.result;
			if (_p123.ctor === 'Ok') {
				return _elm_lang$core$Maybe$Just(result.typeInfo);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$checkSubtypeUnionRight = F4(
	function (typeInfo, typeEnv, tipe1, tipe2) {
		var _p125 = {ctor: '_Tuple2', _0: tipe1.val.t__, _1: tipe2.val.t__};
		if ((_p125.ctor === '_Tuple2') && (_p125._1.ctor === 'TUnion')) {
			return A2(
				_user$project$Utils$bindMaybe,
				_elm_lang$core$Maybe$Just,
				A4(_user$project$Types$checkSubtypeSomeRight, typeInfo, typeEnv, tipe1, _p125._1._1));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Types$subtractType = F2(
	function (union1, tipe2) {
		var _p126 = tipe2.val.t__;
		if (_p126.ctor === 'TUnion') {
			return A3(
				_elm_lang$core$List$foldl,
				_elm_lang$core$Basics$flip(_user$project$Types$subtractType),
				union1,
				_p126._1);
		} else {
			return A3(
				_elm_lang$core$List$foldl,
				F2(
					function (t1, acc) {
						return A2(_user$project$Types$checkEqualType, t1, tipe2) ? acc : {ctor: '::', _0: t1, _1: acc};
					}),
				{ctor: '[]'},
				union1);
		}
	});
var _user$project$Types$narrowUnionType = F2(
	function (tAfterPreviousCases, tThisCase) {
		var tThisCase_ = function () {
			var _p127 = {ctor: '_Tuple2', _0: tThisCase.val.t__, _1: tAfterPreviousCases};
			if ((_p127.ctor === '_Tuple2') && (_p127._0.ctor === 'TWildcard')) {
				if ((_p127._1.ctor === '::') && (_p127._1._1.ctor === '[]')) {
					return _p127._1._0;
				} else {
					return _user$project$Types$tUnion(tAfterPreviousCases);
				}
			} else {
				return tThisCase;
			}
		}();
		var tAfterThisCase = A2(_user$project$Types$subtractType, tAfterPreviousCases, tThisCase_);
		return tAfterThisCase;
	});
var _user$project$Types$checkSubtypeSimple = F3(
	function (typeEnv, tipe1, tipe2) {
		var result = A4(_user$project$Types$checkSubtype, _user$project$Types$initTypeInfo, typeEnv, tipe1, tipe2);
		var _p128 = result.result;
		if (_p128.ctor === 'Err') {
			return false;
		} else {
			return true;
		}
	});
var _user$project$Types$unify = F5(
	function (typeEnv, vars, accActive, accUnifier, cs) {
		var _p129 = cs;
		if (_p129.ctor === '[]') {
			return _elm_lang$core$Result$Ok(
				{ctor: '_Tuple2', _0: accUnifier, _1: accActive});
		} else {
			var _p142 = _p129._1;
			var _p141 = _p129._0;
			var recurse = A2(_user$project$Types$unify, typeEnv, vars);
			var _p130 = _p141;
			var id = _p130._0;
			var t1 = _p130._1._0;
			var t2 = _p130._1._1;
			var err = _user$project$Utils$spaces(
				{
					ctor: '::',
					_0: 'Unification failure:',
					_1: {
						ctor: '::',
						_0: _elm_lang$core$String$trim(
							_user$project$LangUnparser$unparseType(t1)),
						_1: {
							ctor: '::',
							_0: _elm_lang$core$String$trim(
								_user$project$LangUnparser$unparseType(t2)),
							_1: {ctor: '[]'}
						}
					}
				});
			if (A2(_user$project$Types$checkEqualType, t1, t2)) {
				return A3(recurse, accActive, accUnifier, _p142);
			} else {
				var _p131 = {ctor: '_Tuple2', _0: t1.val.t__, _1: t2.val.t__};
				_v114_10:
				do {
					_v114_9:
					do {
						_v114_2:
						do {
							_v114_1:
							do {
								if (_p131.ctor === '_Tuple2') {
									switch (_p131._0.ctor) {
										case 'TVar':
											switch (_p131._1.ctor) {
												case 'TVar':
													var _p133 = _p131._1._1;
													var _p132 = _p131._0._1;
													return A2(_elm_lang$core$List$member, _p132, vars) ? A3(
														recurse,
														accActive,
														{
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _p132, _1: t2},
															_1: accUnifier
														},
														A2(
															_user$project$Types$applyUnifierToConstraints,
															{
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: _p132, _1: t2},
																_1: {ctor: '[]'}
															},
															_p142)) : (A2(_elm_lang$core$List$member, _p133, vars) ? A3(
														recurse,
														accActive,
														{
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _p133, _1: t1},
															_1: accUnifier
														},
														A2(
															_user$project$Types$applyUnifierToConstraints,
															{
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: _p133, _1: t1},
																_1: {ctor: '[]'}
															},
															_p142)) : A3(
														recurse,
														{ctor: '::', _0: _p141, _1: accActive},
														accUnifier,
														_p142));
												case 'TApp':
													break _v114_1;
												default:
													break _v114_1;
											}
										case 'TArrow':
											switch (_p131._1.ctor) {
												case 'TVar':
													break _v114_2;
												case 'TArrow':
													var _p136 = A2(_user$project$Utils$maybeZip, _p131._0._1, _p131._1._1);
													if (_p136.ctor === 'Nothing') {
														return _elm_lang$core$Result$Err('unify TArrow: different arity');
													} else {
														var induced = A2(
															_elm_lang$core$List$map,
															function (raw) {
																return {ctor: '_Tuple2', _0: -1, _1: raw};
															},
															_p136._0);
														return A3(
															recurse,
															accActive,
															accUnifier,
															A2(_elm_lang$core$Basics_ops['++'], induced, _p142));
													}
												case 'TApp':
													break _v114_9;
												default:
													break _v114_10;
											}
										case 'TTuple':
											switch (_p131._1.ctor) {
												case 'TVar':
													break _v114_2;
												case 'TTuple':
													var _p137 = A2(_user$project$Utils$maybeZip, _p131._0._1, _p131._1._1);
													if (_p137.ctor === 'Nothing') {
														return _elm_lang$core$Result$Err('unify TTuple: different arity');
													} else {
														var induced = A2(
															_elm_lang$core$List$map,
															function (raw) {
																return {ctor: '_Tuple2', _0: -1, _1: raw};
															},
															_p137._0);
														var _p138 = {ctor: '_Tuple2', _0: _p131._0._3, _1: _p131._1._3};
														_v117_2:
														do {
															if (_p138.ctor === '_Tuple2') {
																if (_p138._0.ctor === 'Nothing') {
																	if (_p138._1.ctor === 'Nothing') {
																		return A3(
																			recurse,
																			accActive,
																			accUnifier,
																			A2(_elm_lang$core$Basics_ops['++'], induced, _p142));
																	} else {
																		break _v117_2;
																	}
																} else {
																	if (_p138._1.ctor === 'Just') {
																		var induced_ = {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: -1,
																				_1: {ctor: '_Tuple2', _0: _p138._0._0, _1: _p138._1._0}
																			},
																			_1: induced
																		};
																		return A3(
																			recurse,
																			accActive,
																			accUnifier,
																			A2(_elm_lang$core$Basics_ops['++'], induced_, _p142));
																	} else {
																		break _v117_2;
																	}
																}
															} else {
																break _v117_2;
															}
														} while(false);
														return _elm_lang$core$Result$Err('unify TTuple: rest types don\'t match');
													}
												case 'TApp':
													break _v114_9;
												default:
													break _v114_10;
											}
										case 'TList':
											switch (_p131._1.ctor) {
												case 'TVar':
													break _v114_2;
												case 'TList':
													var induced = {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: -1,
															_1: {ctor: '_Tuple2', _0: _p131._0._1, _1: _p131._1._1}
														},
														_1: {ctor: '[]'}
													};
													return A3(
														recurse,
														accActive,
														accUnifier,
														A2(_elm_lang$core$Basics_ops['++'], induced, _p142));
												case 'TTuple':
													var _p140 = _p131._0._1;
													var induced = A2(
														_elm_lang$core$List$map,
														function (ti) {
															return {
																ctor: '_Tuple2',
																_0: -1,
																_1: {ctor: '_Tuple2', _0: _p140, _1: ti}
															};
														},
														_p131._1._1);
													var induced_ = function () {
														var _p139 = _p131._1._3;
														if (_p139.ctor === 'Nothing') {
															return induced;
														} else {
															return {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: -1,
																	_1: {
																		ctor: '_Tuple2',
																		_0: _user$project$Types$tList(_p140),
																		_1: _p139._0
																	}
																},
																_1: induced
															};
														}
													}();
													return A3(
														recurse,
														accActive,
														accUnifier,
														A2(_elm_lang$core$Basics_ops['++'], induced_, _p142));
												case 'TApp':
													break _v114_9;
												default:
													break _v114_10;
											}
										case 'TApp':
											switch (_p131._1.ctor) {
												case 'TVar':
													break _v114_2;
												case 'TApp':
													return _elm_lang$core$Result$Err('unify TApp: Implement this');
												default:
													return _elm_lang$core$Result$Err('unify TApp: Implement this');
											}
										default:
											switch (_p131._1.ctor) {
												case 'TVar':
													break _v114_2;
												case 'TApp':
													break _v114_9;
												default:
													break _v114_10;
											}
									}
								} else {
									break _v114_10;
								}
							} while(false);
							var _p134 = _p131._0._1;
							return A2(_elm_lang$core$List$member, _p134, vars) ? A3(
								recurse,
								accActive,
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _p134, _1: t2},
									_1: accUnifier
								},
								A2(
									_user$project$Types$applyUnifierToConstraints,
									{
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: _p134, _1: t2},
										_1: {ctor: '[]'}
									},
									_p142)) : A3(
								recurse,
								{ctor: '::', _0: _p141, _1: accActive},
								accUnifier,
								_p142);
						} while(false);
						var _p135 = _p131._1._1;
						return A2(_elm_lang$core$List$member, _p135, vars) ? A3(
							recurse,
							accActive,
							{
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p135, _1: t1},
								_1: accUnifier
							},
							A2(
								_user$project$Types$applyUnifierToConstraints,
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _p135, _1: t1},
									_1: {ctor: '[]'}
								},
								_p142)) : A3(
							recurse,
							{ctor: '::', _0: _p141, _1: accActive},
							accUnifier,
							_p142);
					} while(false);
					return _elm_lang$core$Result$Err('unify TApp: Implement this');
				} while(false);
				return A3(_user$project$Types$checkSubtypeSimple, typeEnv, t1, t2) ? A3(recurse, accActive, accUnifier, _p142) : (A3(_user$project$Types$checkSubtypeSimple, typeEnv, t2, t1) ? A3(recurse, accActive, accUnifier, _p142) : _elm_lang$core$Result$Err(err));
			}
		}
	});
var _user$project$Types$tRecord = function (ts) {
	return _user$project$Lang$withDummyTypeInfo(
		A4(_user$project$Lang$TRecord, _user$project$Lang$space1, _elm_lang$core$Maybe$Nothing, ts, _user$project$Lang$space0));
};
var _user$project$Types$tTupleRest = F2(
	function (ts, tRest) {
		return _user$project$Lang$withDummyTypeInfo(
			A5(_user$project$Lang$TTuple, _user$project$Lang$space1, ts, _user$project$Lang$space0, tRest, _user$project$Lang$space0));
	});
var _user$project$Types$tTuple = function (ts) {
	return A2(_user$project$Types$tTupleRest, ts, _elm_lang$core$Maybe$Nothing);
};
var _user$project$Types$tVar = function (x) {
	return _user$project$Lang$withDummyTypeInfo(
		A2(_user$project$Lang$TVar, _user$project$Lang$space1, x));
};
var _user$project$Types$newArrowTemplate = F2(
	function (typeInfo, n) {
		var _p143 = A2(_user$project$Types$generateConstraintVars, 1 + n, typeInfo);
		var constraintVars = _p143._0;
		var typeInfo_ = _p143._1;
		var arrow = _user$project$Types$splitTypesInArrow(
			A2(_elm_lang$core$List$map, _user$project$Types$tVar, constraintVars));
		return {ctor: '_Tuple2', _0: arrow, _1: typeInfo_};
	});
var _user$project$Types$instantiatePolyArrowWithConstraintVars = F2(
	function (typeInfo, _p144) {
		var _p145 = _p144;
		var _p147 = _p145._0;
		var _p146 = A2(
			_user$project$Types$generateConstraintVars,
			_elm_lang$core$List$length(_p147),
			typeInfo);
		var constraintVars = _p146._0;
		var typeInfo_ = _p146._1;
		var subst = A3(
			_elm_lang$core$List$map2,
			F2(
				function (x, y) {
					return {
						ctor: '_Tuple2',
						_0: x,
						_1: _user$project$Types$tVar(y)
					};
				}),
			_p147,
			constraintVars);
		var argTypes_ = A2(
			_elm_lang$core$List$map,
			_user$project$Types$applyUnifier(subst),
			_p145._1._0);
		var retType_ = A2(_user$project$Types$applyUnifier, subst, _p145._1._1);
		return {
			result: {
				ctor: '_Tuple2',
				_0: constraintVars,
				_1: {ctor: '_Tuple2', _0: argTypes_, _1: retType_}
			},
			typeInfo: typeInfo_
		};
	});
var _user$project$Types$instantiateTypeWithConstraintVars = F2(
	function (typeInfo, t) {
		var _p148 = _user$project$Types$stripPolymorphicArrow(t);
		if (_p148.ctor === 'Nothing') {
			return {
				result: {
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: t
				},
				typeInfo: typeInfo
			};
		} else {
			var result = A2(_user$project$Types$instantiatePolyArrowWithConstraintVars, typeInfo, _p148._0);
			var _p149 = result.result;
			var constraintVars = _p149._0;
			var arrow = _p149._1;
			return {
				result: {
					ctor: '_Tuple2',
					_0: constraintVars,
					_1: _user$project$Types$tArrow(arrow)
				},
				typeInfo: result.typeInfo
			};
		}
	});
var _user$project$Types$instantiateTypesWithConstraintVars = F2(
	function (typeInfo, ts) {
		var _p150 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (t, _p151) {
					var _p152 = _p151;
					var result = A2(_user$project$Types$instantiateTypeWithConstraintVars, _p152._2, t);
					var _p153 = result.result;
					var newVars = _p153._0;
					var t_ = _p153._1;
					return {
						ctor: '_Tuple3',
						_0: A2(_elm_lang$core$Basics_ops['++'], _p152._0, newVars),
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							_p152._1,
							{
								ctor: '::',
								_0: t_,
								_1: {ctor: '[]'}
							}),
						_2: result.typeInfo
					};
				}),
			{
				ctor: '_Tuple3',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'},
				_2: typeInfo
			},
			ts);
		var newVars = _p150._0;
		var newTypes = _p150._1;
		var newTypeInfo = _p150._2;
		return {
			result: {ctor: '_Tuple2', _0: newVars, _1: newTypes},
			typeInfo: newTypeInfo
		};
	});
var _user$project$Types$tNull = _user$project$Lang$withDummyTypeInfo(
	_user$project$Lang$TNull(_user$project$Lang$space1));
var _user$project$Types$tString = _user$project$Lang$withDummyTypeInfo(
	_user$project$Lang$TString(_user$project$Lang$space1));
var _user$project$Types$tNum = _user$project$Lang$withDummyTypeInfo(
	_user$project$Lang$TNum(_user$project$Lang$space1));
var _user$project$Types$parseT = function (s) {
	if (_elm_lang$core$Native_Utils.eq(s, ' Num ')) {
		return _user$project$Types$tNum;
	} else {
		if (_elm_lang$core$Native_Utils.eq(s, ' TODO')) {
			return _user$project$Types$tString;
		} else {
			var _p154 = _user$project$LeoParser$parseT(s);
			if (_p154.ctor === 'Err') {
				return _user$project$Types$tList(
					_user$project$Types$tVar('s'));
			} else {
				return _p154._0;
			}
		}
	}
};
var _user$project$Types$opTypeTable = A2(
	_elm_lang$core$List$map,
	_elm_lang$core$Tuple$mapSecond(_user$project$Types$parseT),
	{
		ctor: '::',
		_0: {ctor: '_Tuple2', _0: _user$project$Lang$Pi, _1: ' Num '},
		_1: {
			ctor: '::',
			_0: {ctor: '_Tuple2', _0: _user$project$Lang$ToStr, _1: ' (forall a (-> a String))'},
			_1: {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: _user$project$Lang$DebugLog, _1: ' (forall a (-> a String))'},
				_1: {
					ctor: '::',
					_0: {ctor: '_Tuple2', _0: _user$project$Lang$Eq, _1: ' (forall a (-> a a Bool))'},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: _user$project$Lang$Cos, _1: ' (-> Num Num)'},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _user$project$Lang$Sin, _1: ' (-> Num Num)'},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _user$project$Lang$ArcCos, _1: ' (-> Num Num)'},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: _user$project$Lang$ArcSin, _1: ' (-> Num Num)'},
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: _user$project$Lang$ArcTan2, _1: ' (-> Num Num Num)'},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: _user$project$Lang$Floor, _1: ' (-> Num Num)'},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: _user$project$Lang$Ceil, _1: ' (-> Num Num)'},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: _user$project$Lang$Round, _1: ' (-> Num Num)'},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: _user$project$Lang$Sqrt, _1: ' (-> Num Num)'},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _user$project$Lang$Plus, _1: ' DUMMY'},
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: _user$project$Lang$Minus, _1: ' (-> Num Num Num)'},
																_1: {
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: _user$project$Lang$Mult, _1: ' (-> Num Num Num)'},
																	_1: {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: _user$project$Lang$Div, _1: ' (-> Num Num Num)'},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: _user$project$Lang$Lt, _1: ' (-> Num Num Bool)'},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: _user$project$Lang$Mod, _1: ' (-> Num Num Num)'},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: _user$project$Lang$Pow, _1: ' (-> Num Num Num)'},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: _user$project$Lang$CurrentEnv, _1: ' TODO'},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple2', _0: _user$project$Lang$DictEmpty, _1: ' TODO'},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: _user$project$Lang$DictFromList, _1: ' TODO'},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: _user$project$Lang$DictGet, _1: ' TODO'},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: _user$project$Lang$DictRemove, _1: ' TODO'},
																										_1: {
																											ctor: '::',
																											_0: {ctor: '_Tuple2', _0: _user$project$Lang$DictInsert, _1: ' TODO'},
																											_1: {ctor: '[]'}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	});
var _user$project$Types$opType = function (op) {
	var _p155 = A2(_user$project$Utils$maybeFind, op.val, _user$project$Types$opTypeTable);
	if (_p155.ctor === 'Just') {
		return _p155._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'Types',
			{
				start: {line: 294, column: 3},
				end: {line: 296, column: 69}
			},
			_p155)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'opType not defined: ',
				_user$project$ValUnparser$strOp(op.val)));
	}
};
var _user$project$Types$tBool = _user$project$Lang$withDummyTypeInfo(
	_user$project$Lang$TBool(_user$project$Lang$space1));
var _user$project$Types$lookupPat = F2(
	function (typeEnv, p) {
		lookupPat:
		while (true) {
			var _p157 = p.val.p__;
			switch (_p157.ctor) {
				case 'PWildcard':
					return _elm_lang$core$Maybe$Nothing;
				case 'PVar':
					return A2(_user$project$Types$lookupVar, typeEnv, _p157._1);
				case 'PAs':
					var _p158 = A2(_user$project$Types$lookupPat, typeEnv, _p157._1);
					if (_p158.ctor === 'Nothing') {
						var _v126 = typeEnv,
							_v127 = _p157._3;
						typeEnv = _v126;
						p = _v127;
						continue lookupPat;
					} else {
						return _p158;
					}
				case 'PParens':
					var _v128 = typeEnv,
						_v129 = _p157._1;
					typeEnv = _v128;
					p = _v129;
					continue lookupPat;
				case 'PConst':
					return _elm_lang$core$Maybe$Just(_user$project$Types$tNum);
				case 'PBase':
					switch (_p157._1.ctor) {
						case 'EBool':
							return _elm_lang$core$Maybe$Just(_user$project$Types$tBool);
						case 'EString':
							return _elm_lang$core$Maybe$Just(_user$project$Types$tString);
						default:
							return _elm_lang$core$Maybe$Just(_user$project$Types$tNull);
					}
				case 'PList':
					return A2(
						_user$project$Utils$bindMaybe,
						function (ts) {
							var _p159 = _p157._3;
							if (_p159.ctor === 'Nothing') {
								return _elm_lang$core$Maybe$Just(
									_user$project$Types$tTuple(ts));
							} else {
								return A2(
									_user$project$Utils$bindMaybe,
									function (tRest) {
										return _elm_lang$core$Maybe$Just(
											A2(
												_user$project$Types$tTupleRest,
												ts,
												_elm_lang$core$Maybe$Just(tRest)));
									},
									A2(_user$project$Types$lookupPat, typeEnv, _p159._0));
							}
						},
						_user$project$Utils$projJusts(
							A2(
								_elm_lang$core$List$map,
								_user$project$Types$lookupPat(typeEnv),
								_p157._1)));
				case 'PRecord':
					var _p161 = _p157._1;
					return A2(
						_user$project$Utils$bindMaybe,
						function (_p160) {
							return _elm_lang$core$Maybe$Just(
								_user$project$Types$tRecord(
									A2(_user$project$Utils$recordValuesMake, _p161, _p160)));
						},
						_user$project$Utils$projJusts(
							A2(
								_elm_lang$core$List$map,
								_user$project$Types$lookupPat(typeEnv),
								_user$project$Utils$recordValues(_p161))));
				default:
					return _elm_lang$core$Native_Utils.crashCase(
						'Types',
						{
							start: {line: 407, column: 3},
							end: {line: 434, column: 52}
						},
						_p157)('TODO: Implement me in types.elm');
			}
		}
	});
var _user$project$Types$sanityChecks = true;
var _user$project$Types$stopAtError = false;
var _user$project$Types$debugLog = _user$project$Config$debugLog(_user$project$Config$debugTypeChecker);
var _user$project$Types$solveConstraintsFor = F3(
	function (typeInfo, typeEnv, vars) {
		var _p163 = A5(
			_user$project$Types$unify,
			typeEnv,
			vars,
			{ctor: '[]'},
			{ctor: '[]'},
			typeInfo.activeConstraints);
		if (_p163.ctor === 'Ok') {
			return {
				result: _elm_lang$core$Result$Ok(
					_elm_lang$core$List$reverse(_p163._0._0)),
				typeInfo: _elm_lang$core$Native_Utils.update(
					typeInfo,
					{
						activeConstraints: _elm_lang$core$List$reverse(_p163._0._1)
					})
			};
		} else {
			var _p164 = A2(
				_user$project$Types$debugLog,
				'TODO display the constraints that failed...',
				{ctor: '_Tuple0'});
			return {
				result: _elm_lang$core$Result$Err(_p163._0),
				typeInfo: typeInfo
			};
		}
	});
var _user$project$Types$solveTemplateArrow = F4(
	function (typeInfo, typeEnv, eFuncInfo, arrow) {
		var vars = _elm_lang$core$Set$toList(
			_user$project$Types$constraintVarsOfArrow(arrow));
		var result = A3(_user$project$Types$solveConstraintsFor, typeInfo, typeEnv, vars);
		var _p165 = result.result;
		if (_p165.ctor === 'Err') {
			return {
				result: _elm_lang$core$Maybe$Nothing,
				typeInfo: A3(_user$project$Types$addTypeErrorAt, eFuncInfo.start, _p165._0, typeInfo)
			};
		} else {
			var arrow_ = A2(_user$project$Types$rewriteArrow, _p165._0, arrow);
			var unconstrainedVars = _elm_lang$core$Set$toList(
				_user$project$Types$constraintVarsOfArrow(arrow_));
			var arrow = function () {
				if (_elm_lang$core$Native_Utils.eq(
					unconstrainedVars,
					{ctor: '[]'})) {
					return _user$project$Types$tArrow(arrow_);
				} else {
					var newTypeVars = A2(
						_elm_lang$core$List$map,
						_elm_lang$core$String$dropLeft(1),
						unconstrainedVars);
					return A2(
						_user$project$Types$tPolyArrow,
						newTypeVars,
						A2(
							_user$project$Types$rewriteArrow,
							A2(
								_elm_lang$core$List$map,
								function (a) {
									return {
										ctor: '_Tuple2',
										_0: a,
										_1: _user$project$Types$tVar(
											A2(_elm_lang$core$String$dropLeft, 1, a))
									};
								},
								unconstrainedVars),
							arrow_));
				}
			}();
			return {
				result: _elm_lang$core$Maybe$Just(arrow),
				typeInfo: A3(
					_user$project$Types$addFinalType,
					eFuncInfo.val,
					_elm_lang$core$Maybe$Just(arrow),
					result.typeInfo)
			};
		}
	});
var _user$project$Types$displayRawTypes = function (typeInfo) {
	return A3(
		_elm_lang$core$Dict$foldl,
		F3(
			function (eid, _p167, _p166) {
				var _p168 = _p167;
				var _p169 = _p166;
				var _p170 = _p168._1;
				if (_p170.ctor === 'Nothing') {
					return {ctor: '_Tuple0'};
				} else {
					var s = _user$project$LangUnparser$unparseType(_p170._0);
					var _p171 = A2(
						_user$project$Types$debugLog,
						'synthesized type: ',
						{ctor: '_Tuple2', _0: eid, _1: s});
					return {ctor: '_Tuple0'};
				}
			}),
		{ctor: '_Tuple0'},
		typeInfo.rawTypes);
};
var _user$project$Types$displayConstraints = function (typeInfo) {
	var display = F2(
		function (cap, constraints) {
			if (_elm_lang$core$Native_Utils.eq(
				constraints,
				{ctor: '[]'})) {
				return {ctor: '_Tuple0'};
			} else {
				var _p172 = A2(
					_user$project$Types$debugLog,
					cap,
					{ctor: '_Tuple0'});
				var _p173 = A3(
					_elm_lang$core$List$foldl,
					function (_p174) {
						return _user$project$Types$debugLog(
							_user$project$Types$strConstraint(_p174));
					},
					{ctor: '_Tuple0'},
					constraints);
				return {ctor: '_Tuple0'};
			}
		});
	var _p175 = A2(display, 'ALL CONSTRAINTS', typeInfo.constraints);
	var _p176 = A2(display, 'ACTIVE CONSTRAINTS', typeInfo.activeConstraints);
	return {ctor: '_Tuple0'};
};
var _user$project$Types$displayNamedExps = function (typeInfo) {
	var _p177 = A2(
		_user$project$Types$debugLog,
		'NAMED EXPS',
		{ctor: '_Tuple0'});
	return A3(
		_elm_lang$core$List$foldr,
		F2(
			function (_p179, _p178) {
				var _p180 = _p179;
				var _p186 = _p180._0;
				var _p185 = _p180._1;
				var _p181 = _p178;
				var s1 = _elm_lang$core$String$trim(
					_user$project$LangUnparser$unparsePat(_p186));
				var _p182 = {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Dict$get, _p185, typeInfo.finalTypes),
					_1: A2(_elm_lang$core$Dict$get, _p185, typeInfo.rawTypes)
				};
				_v138_2:
				do {
					if (_p182.ctor === '_Tuple2') {
						if ((_p182._0.ctor === 'Just') && (_p182._0._0.ctor === 'Just')) {
							var s2 = _elm_lang$core$String$trim(
								_user$project$LangUnparser$unparseType(_p182._0._0._0));
							var _p183 = A2(
								_user$project$Types$debugLog,
								A2(
									_elm_lang$core$Basics_ops['++'],
									s1,
									A2(
										_elm_lang$core$Basics_ops['++'],
										' : ',
										A2(_elm_lang$core$Basics_ops['++'], s2, ' '))),
								_user$project$Lang$strPos(_p186.start));
							return {ctor: '_Tuple0'};
						} else {
							if (((_p182._1.ctor === 'Just') && (_p182._1._0.ctor === '_Tuple2')) && (_p182._1._0._1.ctor === 'Just')) {
								var s2 = _elm_lang$core$String$trim(
									_user$project$LangUnparser$unparseType(_p182._1._0._1._0));
								var _p184 = A2(
									_user$project$Types$debugLog,
									A2(
										_elm_lang$core$Basics_ops['++'],
										s1,
										A2(
											_elm_lang$core$Basics_ops['++'],
											' : ',
											A2(_elm_lang$core$Basics_ops['++'], s2, ' (raw) '))),
									_user$project$Lang$strPos(_p186.start));
								return {ctor: '_Tuple0'};
							} else {
								break _v138_2;
							}
						}
					} else {
						break _v138_2;
					}
				} while(false);
				return {ctor: '_Tuple0'};
			}),
		{ctor: '_Tuple0'},
		typeInfo.namedExps);
};
var _user$project$Types$displayTypeErrors = function (typeInfo) {
	var n = _elm_lang$core$List$length(typeInfo.typeErrors);
	if (_elm_lang$core$Native_Utils.eq(n, 0)) {
		return {ctor: '_Tuple0'};
	} else {
		var _p187 = A2(_user$project$Types$debugLog, '# TYPE ERRORS', n);
		return A3(
			_elm_lang$core$List$foldr,
			F2(
				function (typeError, _p188) {
					var _p189 = _p188;
					var _p190 = A2(
						_user$project$Types$debugLog,
						typeError.val,
						_user$project$Lang$strPos(typeError.pos));
					return {ctor: '_Tuple0'};
				}),
			{ctor: '_Tuple0'},
			typeInfo.typeErrors);
	}
};
var _user$project$Types$displayTypeInfo = function (typeInfo) {
	var _p191 = _user$project$Types$displayTypeErrors(typeInfo);
	return {ctor: '_Tuple0'};
};
var _user$project$Types$valIsType = F2(
	function (val, tipe) {
		var unsupported = function (msg) {
			return _elm_lang$core$Native_Utils.crash(
				'Types',
				{
					start: {line: 116, column: 5},
					end: {line: 116, column: 16}
				})(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'typing values against ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						msg,
						A2(
							_elm_lang$core$Basics_ops['++'],
							' such as ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_user$project$Syntax$typeUnparser, _user$project$Syntax$Leo, tipe),
								' is not supported')))));
		};
		var _p192 = {ctor: '_Tuple2', _0: val.v_, _1: tipe.val.t__};
		_v140_16:
		do {
			_v140_14:
			do {
				if (_p192.ctor === '_Tuple2') {
					switch (_p192._1.ctor) {
						case 'TNum':
							if (_p192._0.ctor === 'VConst') {
								return true;
							} else {
								break _v140_16;
							}
						case 'TBool':
							if ((_p192._0.ctor === 'VBase') && (_p192._0._0.ctor === 'VBool')) {
								return true;
							} else {
								break _v140_16;
							}
						case 'TString':
							if ((_p192._0.ctor === 'VBase') && (_p192._0._0.ctor === 'VString')) {
								return true;
							} else {
								break _v140_16;
							}
						case 'TNull':
							if ((_p192._0.ctor === 'VBase') && (_p192._0._0.ctor === 'VNull')) {
								return true;
							} else {
								break _v140_16;
							}
						case 'TList':
							if (_p192._0.ctor === 'VList') {
								return A2(
									_elm_lang$core$List$all,
									function (v) {
										return A2(_user$project$Types$valIsType, v, _p192._1._1);
									},
									_p192._0._0);
							} else {
								break _v140_16;
							}
						case 'TDict':
							return unsupported('dictionary types');
						case 'TTuple':
							if (_p192._0.ctor === 'VList') {
								var _p197 = _p192._0._0;
								var _p196 = _p192._1._1;
								var typeListsMatch = A3(
									_elm_lang$core$List$foldl,
									F2(
										function (_p193, res) {
											var _p194 = _p193;
											return res && A2(_user$project$Types$valIsType, _p194._0, _p194._1);
										}),
									true,
									A2(_user$project$Utils$zip, _p197, _p196));
								var _p195 = _p192._1._3;
								if (_p195.ctor === 'Nothing') {
									return typeListsMatch && _elm_lang$core$Native_Utils.eq(
										_elm_lang$core$List$length(_p197),
										_elm_lang$core$List$length(_p196));
								} else {
									return typeListsMatch && ((_elm_lang$core$Native_Utils.cmp(
										_elm_lang$core$List$length(_p197),
										_elm_lang$core$List$length(_p196)) > -1) && A2(
										_elm_lang$core$List$all,
										function (v) {
											return A2(_user$project$Types$valIsType, v, _p195._0);
										},
										A2(
											_elm_lang$core$List$drop,
											_elm_lang$core$List$length(_p196),
											_p197)));
								}
							} else {
								break _v140_16;
							}
						case 'TArrow':
							return unsupported('arrow types');
						case 'TUnion':
							return A2(
								_elm_lang$core$List$any,
								_user$project$Types$valIsType(val),
								_p192._1._1);
						case 'TApp':
							if (((_p192._0.ctor === 'VList') && (_p192._1._2.ctor === '::')) && (_p192._1._2._1.ctor === '[]')) {
								var _p198 = _p192._1._1.val.t__;
								if ((_p198.ctor === 'TVar') && (_p198._1 === 'List')) {
									return A2(
										_elm_lang$core$List$all,
										function (v) {
											return A2(_user$project$Types$valIsType, v, _p192._1._2._0);
										},
										_p192._0._0);
								} else {
									return false;
								}
							} else {
								return unsupported('app types');
							}
						case 'TVar':
							switch (_p192._0.ctor) {
								case 'VConst':
									if (_p192._1._1 === 'Num') {
										return true;
									} else {
										break _v140_14;
									}
								case 'VBase':
									switch (_p192._0._0.ctor) {
										case 'VBool':
											if (_p192._1._1 === 'Bool') {
												return true;
											} else {
												break _v140_14;
											}
										case 'VString':
											if (_p192._1._1 === 'String') {
												return true;
											} else {
												break _v140_14;
											}
										default:
											break _v140_14;
									}
								default:
									break _v140_14;
							}
						case 'TWildcard':
							return true;
						default:
							break _v140_16;
					}
				} else {
					break _v140_16;
				}
			} while(false);
			return unsupported('type variables');
		} while(false);
		return false;
	});
var _user$project$Types$identifiersEquivalent = F2(
	function (t1, t2) {
		var flatIdents = function (t) {
			flatIdents:
			while (true) {
				var _p199 = t.val.t__;
				switch (_p199.ctor) {
					case 'TNum':
						return {ctor: '[]'};
					case 'TBool':
						return {ctor: '[]'};
					case 'TString':
						return {ctor: '[]'};
					case 'TNull':
						return {ctor: '[]'};
					case 'TList':
						var _v145 = _p199._1;
						t = _v145;
						continue flatIdents;
					case 'TDict':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							flatIdents(_p199._1),
							flatIdents(_p199._2));
					case 'TTuple':
						var restTypeIdents = function () {
							var _p200 = _p199._3;
							if (_p200.ctor === 'Just') {
								return flatIdents(_p200._0);
							} else {
								return {ctor: '[]'};
							}
						}();
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(_elm_lang$core$List$concatMap, flatIdents, _p199._1),
							restTypeIdents);
					case 'TRecord':
						return A2(
							_elm_lang$core$Basics_ops['++'],
							function () {
								var _p201 = _p199._1;
								if (_p201.ctor === 'Just') {
									return {
										ctor: '::',
										_0: _p201._0._0,
										_1: {ctor: '[]'}
									};
								} else {
									return {ctor: '[]'};
								}
							}(),
							A2(
								_elm_lang$core$List$concatMap,
								flatIdents,
								_user$project$Utils$recordValues(_p199._2)));
					case 'TArrow':
						return A2(_elm_lang$core$List$concatMap, flatIdents, _p199._1);
					case 'TUnion':
						return A2(_elm_lang$core$List$concatMap, flatIdents, _p199._1);
					case 'TApp':
						return A2(_elm_lang$core$List$concatMap, flatIdents, _p199._2);
					case 'TVar':
						return {
							ctor: '::',
							_0: _p199._1,
							_1: {ctor: '[]'}
						};
					case 'TWildcard':
						return {ctor: '[]'};
					case 'TForall':
						return _elm_lang$core$Native_Utils.crashCase(
							'Types',
							{
								start: {line: 85, column: 5},
								end: {line: 109, column: 36}
							},
							_p199)('identifiersEquiv TForall TODO');
					default:
						var _v148 = _p199._1;
						t = _v148;
						continue flatIdents;
				}
			}
		};
		return A2(
			_user$project$Utils$oneToOneMappingExists,
			flatIdents(t1),
			flatIdents(t2));
	});
var _user$project$Types$astsMatch = F2(
	function (t1, t2) {
		astsMatch:
		while (true) {
			var _p203 = {ctor: '_Tuple2', _0: t1.val.t__, _1: t2.val.t__};
			_v149_13:
			do {
				if (_p203.ctor === '_Tuple2') {
					switch (_p203._0.ctor) {
						case 'TNum':
							if (_p203._1.ctor === 'TNum') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TBool':
							if (_p203._1.ctor === 'TBool') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TString':
							if (_p203._1.ctor === 'TString') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TNull':
							if (_p203._1.ctor === 'TNull') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TList':
							if (_p203._1.ctor === 'TList') {
								var _v150 = _p203._0._1,
									_v151 = _p203._1._1;
								t1 = _v150;
								t2 = _v151;
								continue astsMatch;
							} else {
								break _v149_13;
							}
						case 'TDict':
							if (_p203._1.ctor === 'TDict') {
								return A2(_user$project$Types$astsMatch, _p203._0._1, _p203._1._1) && A2(_user$project$Types$astsMatch, _p203._0._2, _p203._1._2);
							} else {
								break _v149_13;
							}
						case 'TTuple':
							if (_p203._1.ctor === 'TTuple') {
								var maybeRestTypesMatch = function () {
									var _p204 = {ctor: '_Tuple2', _0: _p203._0._3, _1: _p203._1._3};
									_v152_2:
									do {
										if (_p204.ctor === '_Tuple2') {
											if (_p204._0.ctor === 'Nothing') {
												if (_p204._1.ctor === 'Nothing') {
													return true;
												} else {
													break _v152_2;
												}
											} else {
												if (_p204._1.ctor === 'Just') {
													return A2(_user$project$Types$astsMatch, _p204._0._0, _p204._1._0);
												} else {
													break _v152_2;
												}
											}
										} else {
											break _v152_2;
										}
									} while(false);
									return false;
								}();
								return maybeRestTypesMatch && A3(_user$project$Utils$listsEqualBy, _user$project$Types$astsMatch, _p203._0._1, _p203._1._1);
							} else {
								break _v149_13;
							}
						case 'TArrow':
							if (_p203._1.ctor === 'TArrow') {
								return A3(_user$project$Utils$listsEqualBy, _user$project$Types$astsMatch, _p203._0._1, _p203._1._1);
							} else {
								break _v149_13;
							}
						case 'TUnion':
							if (_p203._1.ctor === 'TUnion') {
								return A3(_user$project$Utils$listsEqualBy, _user$project$Types$astsMatch, _p203._0._1, _p203._1._1);
							} else {
								break _v149_13;
							}
						case 'TApp':
							if (_p203._1.ctor === 'TApp') {
								return _elm_lang$core$Native_Utils.eq(_p203._0._1, _p203._1._1) && A3(_user$project$Utils$listsEqualBy, _user$project$Types$astsMatch, _p203._0._2, _p203._1._2);
							} else {
								break _v149_13;
							}
						case 'TVar':
							if (_p203._1.ctor === 'TVar') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TWildcard':
							if (_p203._1.ctor === 'TWildcard') {
								return true;
							} else {
								break _v149_13;
							}
						case 'TForall':
							if (_p203._1.ctor === 'TForall') {
								return _elm_lang$core$Native_Utils.eq(
									_elm_lang$core$List$length(_p203._0._1),
									_elm_lang$core$List$length(_p203._1._1)) && A2(_user$project$Types$astsMatch, _p203._0._2, _p203._1._2);
							} else {
								break _v149_13;
							}
						default:
							break _v149_13;
					}
				} else {
					break _v149_13;
				}
			} while(false);
			return false;
		}
	});
var _user$project$Types$equal = F2(
	function (t1, t2) {
		return A2(_user$project$Types$astsMatch, t1, t2) && A2(_user$project$Types$identifiersEquivalent, t1, t2);
	});
var _user$project$Types$typeToMaybeArgTypesAndReturnType = function (tipe) {
	var _p205 = tipe.val.t__;
	if (_p205.ctor === 'TArrow') {
		var _p207 = _p205._1;
		var _p206 = {
			ctor: '_Tuple2',
			_0: A2(_user$project$Utils$dropLast, 1, _p207),
			_1: _user$project$Utils$maybeLast(_p207)
		};
		if ((_p206.ctor === '_Tuple2') && (_p206._1.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				{ctor: '_Tuple2', _0: _p206._0, _1: _p206._1._0});
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Types$typeToMaybeAliasIdent = function (tipe) {
	var _p208 = tipe.val.t__;
	if (_p208.ctor === 'TApp') {
		var _p209 = _p208._1.val.t__;
		if (_p209.ctor === 'TVar') {
			return _elm_lang$core$Maybe$Just(_p209._1);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Types$TypeInfo = F9(
	function (a, b, c, d, e, f, g, h, i) {
		return {constraints: a, activeConstraints: b, typeErrors: c, rawTypes: d, finalTypes: e, namedExps: f, constraintCount: g, constraintVarCount: h, preludeTypeEnv: i};
	});
var _user$project$Types$AceTypeInfo = F3(
	function (a, b, c) {
		return {annotations: a, highlights: b, tooltips: c};
	});
var _user$project$Types$AndTypeInfo = F2(
	function (a, b) {
		return {result: a, typeInfo: b};
	});
var _user$project$Types$TypeAlias = F2(
	function (a, b) {
		return {ctor: 'TypeAlias', _0: a, _1: b};
	});
var _user$project$Types$TypeVar = function (a) {
	return {ctor: 'TypeVar', _0: a};
};
var _user$project$Types$addTypeVarBindings = F2(
	function (typeVars, typeEnv) {
		var newTypeBindings = A2(
			_elm_lang$core$List$map,
			_user$project$Types$TypeVar,
			_elm_lang$core$List$reverse(typeVars));
		return A2(_elm_lang$core$Basics_ops['++'], newTypeBindings, typeEnv);
	});
var _user$project$Types$CheckType = F2(
	function (a, b) {
		return {ctor: 'CheckType', _0: a, _1: b};
	});
var _user$project$Types$addTypBindings = F3(
	function (p, t, typeEnv) {
		var _p210 = p.val.p__;
		if (_p210.ctor === 'PVar') {
			return _elm_lang$core$Result$Ok(
				{
					ctor: '::',
					_0: A2(_user$project$Types$CheckType, _p210._1, t),
					_1: typeEnv
				});
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'Types',
				{
					start: {line: 388, column: 3},
					end: {line: 390, column: 88}
				},
				_p210)('addTypBindings: Currently, only (typ x T) is supported.');
		}
	});
var _user$project$Types$HasType = F2(
	function (a, b) {
		return {ctor: 'HasType', _0: a, _1: b};
	});
var _user$project$Types$addBindingsOne = F2(
	function (_p212, acc) {
		addBindingsOne:
		while (true) {
			var _p213 = _p212;
			var _p223 = _p213._1;
			var _p222 = _p213._0;
			var fail = function (s) {
				return _elm_lang$core$Result$Err(
					_user$project$Utils$spaces(
						{
							ctor: '::',
							_0: 'addBindings',
							_1: {
								ctor: '::',
								_0: _user$project$LangUnparser$unparsePat(_p222),
								_1: {
									ctor: '::',
									_0: _user$project$LangUnparser$unparseType(_p223),
									_1: {
										ctor: '::',
										_0: s,
										_1: {ctor: '[]'}
									}
								}
							}
						}));
			};
			var _p214 = {ctor: '_Tuple2', _0: _p222.val.p__, _1: _p223.val.t__};
			_v159_8:
			do {
				if (_p214.ctor === '_Tuple2') {
					switch (_p214._0.ctor) {
						case 'PConst':
							return _elm_lang$core$Result$Ok(acc);
						case 'PBase':
							return _elm_lang$core$Result$Ok(acc);
						case 'PWildcard':
							return _elm_lang$core$Result$Ok(acc);
						case 'PVar':
							return _elm_lang$core$Result$Ok(
								{
									ctor: '::',
									_0: A2(_user$project$Types$HasType, _p214._0._1, _p223),
									_1: acc
								});
						case 'PAs':
							return A2(
								_elm_lang$core$Result$andThen,
								_user$project$Types$addBindingsOne(
									{ctor: '_Tuple2', _0: _p214._0._3, _1: _p223}),
								A2(
									_user$project$Types$addBindingsOne,
									{ctor: '_Tuple2', _0: _p214._0._1, _1: _p223},
									acc));
						case 'PList':
							switch (_p214._1.ctor) {
								case 'TApp':
									return fail('App type not defined');
								case 'TTuple':
									var maybeRestBinding = function () {
										var _p215 = {ctor: '_Tuple2', _0: _p214._0._3, _1: _p214._1._3};
										_v160_2:
										do {
											if (_p215.ctor === '_Tuple2') {
												if (_p215._0.ctor === 'Nothing') {
													if (_p215._1.ctor === 'Nothing') {
														return _elm_lang$core$Result$Ok(
															{ctor: '[]'});
													} else {
														break _v160_2;
													}
												} else {
													if (_p215._1.ctor === 'Just') {
														var _p216 = {ctor: '_Tuple2', _0: _p215._0._0.val.p__, _1: _p215._1._0.val.t__};
														if (((_p216.ctor === '_Tuple2') && (_p216._0.ctor === 'PVar')) && (_p216._1.ctor === 'TList')) {
															return _elm_lang$core$Result$Ok(
																{
																	ctor: '::',
																	_0: A2(_user$project$Types$HasType, _p216._0._1, _p216._1._1),
																	_1: {ctor: '[]'}
																});
														} else {
															return fail('PList ERROR 1 TODO');
														}
													} else {
														break _v160_2;
													}
												}
											} else {
												break _v160_2;
											}
										} while(false);
										return fail('PList ERROR 2 TODO');
									}();
									var _p217 = {
										ctor: '_Tuple2',
										_0: A3(_user$project$Types$addBindings, _p214._0._1, _p214._1._1, acc),
										_1: maybeRestBinding
									};
									if (((_p217.ctor === '_Tuple2') && (_p217._0.ctor === 'Ok')) && (_p217._1.ctor === 'Ok')) {
										return _elm_lang$core$Result$Ok(
											A2(_elm_lang$core$Basics_ops['++'], _p217._1._0, _p217._0._0));
									} else {
										return fail('');
									}
								case 'TList':
									var _p221 = _p214._0._1;
									var _p218 = A3(
										_user$project$Types$addBindings,
										_p221,
										A2(
											_elm_lang$core$List$repeat,
											_elm_lang$core$List$length(_p221),
											_p214._1._1),
										acc);
									if (_p218.ctor === 'Err') {
										return fail(_p218._0);
									} else {
										var _p220 = _p218._0;
										var _p219 = _p214._0._3;
										if (_p219.ctor === 'Nothing') {
											return _elm_lang$core$Result$Ok(_p220);
										} else {
											var _v165 = {ctor: '_Tuple2', _0: _p219._0, _1: _p223},
												_v166 = _p220;
											_p212 = _v165;
											acc = _v166;
											continue addBindingsOne;
										}
									}
								default:
									break _v159_8;
							}
						default:
							break _v159_8;
					}
				} else {
					break _v159_8;
				}
			} while(false);
			return fail('');
		}
	});
var _user$project$Types$addBindings = F3(
	function (pats, types, typeEnv) {
		var _p224 = A2(_user$project$Utils$maybeZip, pats, types);
		if (_p224.ctor === 'Nothing') {
			return _elm_lang$core$Result$Err('addBindings: can\'t zip');
		} else {
			return A2(_user$project$Types$addBindingsMany, _p224._0, typeEnv);
		}
	});
var _user$project$Types$addBindingsMany = F2(
	function (patsAndTypes, typeEnv) {
		return A3(
			_elm_lang$core$List$foldl,
			F2(
				function (pt, macc) {
					var _p225 = macc;
					if (_p225.ctor === 'Err') {
						return _elm_lang$core$Result$Err(_p225._0);
					} else {
						return A2(_user$project$Types$addBindingsOne, pt, _p225._0);
					}
				}),
			_elm_lang$core$Result$Ok(typeEnv),
			patsAndTypes);
	});
var _user$project$Types$synthesizeType = F3(
	function (typeInfo, typeEnv, _p226) {
		var _p227 = _p226;
		var _p265 = _p227._0;
		var e = _user$project$Lang$Expr(_p265);
		var finish = {
			withType: A2(
				_user$project$Types$finishSynthesizeWithType,
				_user$project$Lang$expEId(e),
				_p265.start),
			withError: _user$project$Types$finishSynthesizeWithError(_p265.start)
		};
		var _p228 = _user$project$Lang$unwrapExp(e);
		switch (_p228.ctor) {
			case 'EColonType':
				var _p229 = _p228._3;
				if (!A2(_user$project$Types$isWellFormed, typeEnv, _p229)) {
					var err = _user$project$Utils$spaces(
						{
							ctor: '::',
							_0: _elm_lang$core$Basics$toString(
								_user$project$Lang$expEId(e)),
							_1: {
								ctor: '::',
								_0: _user$project$Lang$strPos(_p229.start),
								_1: {
									ctor: '::',
									_0: 'Type annotation not well-formed:',
									_1: {
										ctor: '::',
										_0: _elm_lang$core$String$trim(
											_user$project$LangUnparser$unparseType(_p229)),
										_1: {ctor: '[]'}
									}
								}
							}
						});
					return A2(finish.withError, err, typeInfo);
				} else {
					var result1 = A4(_user$project$Types$checkType, typeInfo, typeEnv, _p228._1, _p229);
					return result1.result ? A2(finish.withType, _p229, result1.typeInfo) : {result: _elm_lang$core$Maybe$Nothing, typeInfo: result1.typeInfo};
				}
			case 'EConst':
				return A2(finish.withType, _user$project$Types$tNum, typeInfo);
			case 'EBase':
				var _p230 = _p228._1;
				switch (_p230.ctor) {
					case 'EBool':
						return A2(finish.withType, _user$project$Types$tBool, typeInfo);
					case 'EString':
						return A2(finish.withType, _user$project$Types$tString, typeInfo);
					default:
						return A2(finish.withType, _user$project$Types$tNull, typeInfo);
				}
			case 'EVar':
				var _p232 = _p228._1;
				var _p231 = A2(_user$project$Types$lookupVar, typeEnv, _p232);
				if (_p231.ctor === 'Just') {
					return A2(finish.withType, _p231._0, typeInfo);
				} else {
					var err = _user$project$Utils$spaces(
						{
							ctor: '::',
							_0: _elm_lang$core$Basics$toString(
								_user$project$Lang$expEId(e)),
							_1: {
								ctor: '::',
								_0: 'var not found: ',
								_1: {
									ctor: '::',
									_0: _p232,
									_1: {ctor: '[]'}
								}
							}
						});
					return A2(finish.withError, err, typeInfo);
				}
			case 'EFun':
				var _p234 = _p228._1;
				var _p233 = A2(
					_user$project$Types$newArrowTemplate,
					typeInfo,
					_elm_lang$core$List$length(_p234));
				var arrow = _p233._0;
				var typeInfo_ = _p233._1;
				return A6(_user$project$Types$tsFun, finish, typeInfo_, typeEnv, _p234, _p228._2, arrow);
			case 'EOp':
				if (_p228._3.ctor === '[]') {
					return A2(
						finish.withType,
						_user$project$Types$opType(_p228._2),
						typeInfo);
				} else {
					var _p238 = _p228._2;
					var _p237 = _p228._3;
					var _p235 = {
						ctor: '_Tuple2',
						_0: _p238.val,
						_1: _user$project$Types$stripPolymorphicArrow(
							_user$project$Types$opType(_p238))
					};
					_v173_0:
					do {
						if (_p235._1.ctor === 'Just') {
							if (_p235._0.ctor === 'Plus') {
								break _v173_0;
							} else {
								if ((_p235._1._0.ctor === '_Tuple2') && (_p235._1._0._0.ctor === '[]')) {
									return A5(_user$project$Types$tsAppMono, finish, typeInfo, typeEnv, _p237, _p235._1._0._1);
								} else {
									return A5(_user$project$Types$tsAppPoly, finish, typeInfo, typeEnv, _p237, _p235._1._0);
								}
							}
						} else {
							if (_p235._0.ctor === 'Plus') {
								break _v173_0;
							} else {
								return A2(finish.withError, 'synthesizeType: EOp ...', typeInfo);
							}
						}
					} while(false);
					var result = A5(
						_user$project$Types$tsAppMono,
						finish,
						typeInfo,
						typeEnv,
						_p237,
						{
							ctor: '_Tuple2',
							_0: {
								ctor: '::',
								_0: _user$project$Types$tNum,
								_1: {
									ctor: '::',
									_0: _user$project$Types$tNum,
									_1: {ctor: '[]'}
								}
							},
							_1: _user$project$Types$tNum
						});
					var _p236 = result.result;
					if (_p236.ctor === 'Just') {
						return result;
					} else {
						return A5(
							_user$project$Types$tsAppMono,
							finish,
							typeInfo,
							typeEnv,
							_p237,
							{
								ctor: '_Tuple2',
								_0: {
									ctor: '::',
									_0: _user$project$Types$tString,
									_1: {
										ctor: '::',
										_0: _user$project$Types$tString,
										_1: {ctor: '[]'}
									}
								},
								_1: _user$project$Types$tString
							});
					}
				}
			case 'EApp':
				var _p241 = _p228._2;
				var result1 = A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, _p228._1);
				var _p239 = result1.result;
				if (_p239.ctor === 'Nothing') {
					return A2(finish.withError, 'synthesizeTyp: EApp ...', result1.typeInfo);
				} else {
					var _p240 = _user$project$Types$stripPolymorphicArrow(_p239._0);
					if (_p240.ctor === 'Just') {
						if ((_p240._0.ctor === '_Tuple2') && (_p240._0._0.ctor === '[]')) {
							return A5(_user$project$Types$tsAppMono, finish, result1.typeInfo, typeEnv, _p241, _p240._0._1);
						} else {
							return A5(_user$project$Types$tsAppPoly, finish, result1.typeInfo, typeEnv, _p241, _p240._0);
						}
					} else {
						var err = 'TS-App: t1 not arrow...';
						return A2(finish.withError, err, result1.typeInfo);
					}
				}
			case 'EList':
				var _p242 = A3(
					_elm_lang$core$List$foldl,
					F2(
						function (ei, _p243) {
							var _p244 = _p243;
							var result = A3(_user$project$Types$synthesizeType, _p244._1, typeEnv, ei);
							return {
								ctor: '_Tuple2',
								_0: {ctor: '::', _0: result.result, _1: _p244._0},
								_1: result.typeInfo
							};
						}),
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: typeInfo
					},
					_elm_lang$core$List$reverse(
						_user$project$Utils$listValues(_p228._1)));
				var maybeTypes = _p242._0;
				var typeInfo_ = _p242._1;
				var _p245 = _user$project$Utils$projJusts(maybeTypes);
				if (_p245.ctor === 'Nothing') {
					return A2(finish.withError, 'synthesizeType: EList 1 ...', typeInfo_);
				} else {
					var _p248 = _p245._0;
					var _p246 = _p228._3;
					if (_p246.ctor === 'Nothing') {
						return A2(
							finish.withType,
							_user$project$Types$tTuple(_p248),
							typeInfo_);
					} else {
						var result = A3(_user$project$Types$synthesizeType, typeInfo_, typeEnv, _p246._0);
						var _p247 = result.result;
						if (_p247.ctor === 'Nothing') {
							return A2(finish.withError, 'synthesizeType: EList 2 ...', result.typeInfo);
						} else {
							return A2(
								finish.withType,
								A2(
									_user$project$Types$tTupleRest,
									_p248,
									_elm_lang$core$Maybe$Just(_p247._0)),
								result.typeInfo);
						}
					}
				}
			case 'ERecord':
				return A2(finish.withError, 'synthesizeType: ERecord 1 ...', typeInfo);
			case 'ESelect':
				var _p254 = _p228._4;
				var resultn = A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, _p228._1);
				var _p249 = resultn.result;
				if (_p249.ctor === 'Nothing') {
					return A2(finish.withError, 'synthesizeType: ESelect 1 ... ', resultn.typeInfo);
				} else {
					var _p250 = _p249._0.val.t__;
					if (_p250.ctor === 'TRecord') {
						var _p253 = A2(
							_user$project$Utils$findLast,
							function (_p251) {
								var _p252 = _p251;
								return _elm_lang$core$Native_Utils.eq(_p252._2, _p254);
							},
							_p250._2);
						if (_p253.ctor === 'Just') {
							return A2(finish.withType, _p253._0._4, resultn.typeInfo);
						} else {
							return A2(
								finish.withError,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'No field ',
									A2(_elm_lang$core$Basics_ops['++'], _p254, ' in definition ')),
								resultn.typeInfo);
						}
					} else {
						return A2(finish.withError, 'This does not evaluate to a dict', resultn.typeInfo);
					}
				}
			case 'EIf':
				var result1 = A4(_user$project$Types$checkType, typeInfo, typeEnv, _p228._1, _user$project$Types$tBool);
				if (!result1.result) {
					return A2(finish.withError, 'synthesizeType: EIf 1 ...', result1.typeInfo);
				} else {
					var result2 = A3(_user$project$Types$synthesizeType, result1.typeInfo, typeEnv, _p228._3);
					var result3 = A3(_user$project$Types$synthesizeType, result2.typeInfo, typeEnv, _p228._5);
					var _p255 = {ctor: '_Tuple2', _0: result2.result, _1: result3.result};
					if (((_p255.ctor === '_Tuple2') && (_p255._0.ctor === 'Just')) && (_p255._1.ctor === 'Just')) {
						var _p256 = A2(_user$project$Types$joinTypes, _p255._0._0, _p255._1._0);
						if (_p256.ctor === 'Ok') {
							return A2(finish.withType, _p256._0, result3.typeInfo);
						} else {
							return A2(finish.withError, 'synthesizeType: EIf 2 ...', result3.typeInfo);
						}
					} else {
						return A2(finish.withError, 'synthesizeType: EIf 3 ...', result3.typeInfo);
					}
				}
			case 'ECase':
				var result1 = A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, _p228._1);
				var _p257 = result1.result;
				if (_p257.ctor === 'Nothing') {
					return A2(finish.withError, 'synthesizeType: ECase ...', result1.typeInfo);
				} else {
					var _p264 = _p257._0;
					var _p258 = _elm_lang$core$Set$isEmpty(
						_user$project$Types$constraintVarsOf(
							{
								ctor: '::',
								_0: _p264,
								_1: {ctor: '[]'}
							})) ? {ctor: '_Tuple0'} : A2(
						_user$project$Types$debugLog,
						'ECase: TODO constraints based on patterns',
						{ctor: '_Tuple0'});
					var maybeThings = A3(
						_elm_lang$core$List$foldl,
						F2(
							function (pe, acc) {
								var _p259 = pe.val;
								var pi = _p259._1;
								var ei = _p259._2;
								var _p260 = {
									ctor: '_Tuple2',
									_0: acc,
									_1: A2(
										_user$project$Types$addBindingsOne,
										{ctor: '_Tuple2', _0: pi, _1: _p264},
										typeEnv)
								};
								if (_p260._0.ctor === 'Ok') {
									if (_p260._1.ctor === 'Ok') {
										return _elm_lang$core$Result$Ok(
											{
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: _p260._1._0, _1: ei},
												_1: _p260._0._0
											});
									} else {
										return _elm_lang$core$Result$Err(_p260._1._0);
									}
								} else {
									return _elm_lang$core$Result$Err(_p260._0._0);
								}
							}),
						_elm_lang$core$Result$Ok(
							{ctor: '[]'}),
						_p228._2);
					var _p261 = maybeThings;
					if (_p261.ctor === 'Err') {
						var err_ = _user$project$Utils$spaces(
							{
								ctor: '::',
								_0: 'ECase: could not typecheck all patterns',
								_1: {
									ctor: '::',
									_0: _p261._0,
									_1: {ctor: '[]'}
								}
							});
						return A2(finish.withError, err_, result1.typeInfo);
					} else {
						var result2 = A2(_user$project$Types$synthesizeBranchTypes, result1.typeInfo, _p261._0);
						var _p262 = _user$project$Utils$projJusts(result2.result);
						if (_p262.ctor === 'Nothing') {
							var err = 'ECase: could not typecheck all branches';
							return A2(finish.withError, err, result2.typeInfo);
						} else {
							var _p263 = _user$project$Types$joinManyTypes(_p262._0);
							if (_p263.ctor === 'Err') {
								return A2(finish.withError, _p263._0, result2.typeInfo);
							} else {
								return A2(finish.withType, _p263._0, result2.typeInfo);
							}
						}
					}
				}
			case 'ELet':
				return {
					result: _elm_lang$core$Maybe$Nothing,
					typeInfo: _elm_lang$core$Native_Utils.update(
						typeInfo,
						{
							preludeTypeEnv: _elm_lang$core$Maybe$Just(typeEnv)
						})
				};
			case 'EParens':
				return _user$project$Types$propagateResult(
					A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, _p228._1));
			default:
				return {result: _elm_lang$core$Maybe$Nothing, typeInfo: typeInfo};
		}
	});
var _user$project$Types$checkType = F4(
	function (typeInfo, typeEnv, _p266, goalType) {
		checkType:
		while (true) {
			var _p267 = _p266;
			var _p277 = _p267._0;
			var _p268 = _user$project$Lang$unwrapExp(
				_user$project$Lang$Expr(_p277));
			switch (_p268.ctor) {
				case 'EFun':
					var _p269 = _user$project$Types$stripPolymorphicArrow(goalType);
					if (_p269.ctor === 'Nothing') {
						return {typeInfo: typeInfo, result: false};
					} else {
						var _p270 = A3(
							_user$project$Types$addBindings,
							_p268._1,
							_p269._0._1._0,
							A2(_user$project$Types$addTypeVarBindings, _p269._0._0, typeEnv));
						if (_p270.ctor === 'Err') {
							return {
								result: false,
								typeInfo: A3(_user$project$Types$addTypeErrorAt, _p277.start, _p270._0, typeInfo)
							};
						} else {
							var _v196 = typeInfo,
								_v197 = _p270._0,
								_v198 = _p268._2,
								_v199 = _p269._0._1._1;
							typeInfo = _v196;
							typeEnv = _v197;
							_p266 = _v198;
							goalType = _v199;
							continue checkType;
						}
					}
				case 'EIf':
					var result1 = A4(_user$project$Types$checkType, typeInfo, typeEnv, _p268._1, _user$project$Types$tBool);
					var result2 = A4(_user$project$Types$checkType, result1.typeInfo, typeEnv, _p268._3, goalType);
					var result3 = A4(_user$project$Types$checkType, result2.typeInfo, typeEnv, _p268._5, goalType);
					return {result: result1.result && (result2.result && result3.result), typeInfo: result3.typeInfo};
				case 'ECase':
					var result1 = A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, _p268._1);
					var _p271 = result1.result;
					if (_p271.ctor === 'Nothing') {
						return {result: false, typeInfo: result1.typeInfo};
					} else {
						var result_branches = A3(
							_elm_lang$core$List$foldl,
							F2(
								function (pe, acc) {
									var _p272 = pe.val;
									var pi = _p272._1;
									var ei = _p272._2;
									var _p273 = A2(
										_user$project$Types$addBindingsOne,
										{ctor: '_Tuple2', _0: pi, _1: _p271._0},
										typeEnv);
									if (_p273.ctor === 'Err') {
										return {
											result: false,
											typeInfo: A3(_user$project$Types$addTypeErrorAt, pi.start, _p273._0, acc.typeInfo)
										};
									} else {
										var resulti = A4(_user$project$Types$checkType, acc.typeInfo, _p273._0, ei, goalType);
										return {result: resulti.result && acc.result, typeInfo: resulti.typeInfo};
									}
								}),
							{result: true, typeInfo: result1.typeInfo},
							_p268._2);
						var _p274 = result_branches.result;
						if (_p274 === true) {
							return result_branches;
						} else {
							var err = 'couldn\'t check all branches';
							return {
								result: false,
								typeInfo: A3(_user$project$Types$addTypeErrorAt, _p277.start, err, result_branches.typeInfo)
							};
						}
					}
				default:
					var result1 = A3(
						_user$project$Types$synthesizeType,
						typeInfo,
						typeEnv,
						_user$project$Lang$Expr(_p277));
					var typeInfo1 = result1.typeInfo;
					var _p275 = result1.result;
					if (_p275.ctor === 'Nothing') {
						var err = _user$project$Utils$spaces(
							{
								ctor: '::',
								_0: 'checkType',
								_1: {
									ctor: '::',
									_0: _elm_lang$core$Basics$toString(
										_user$project$Lang$expEId(
											_user$project$Lang$Expr(_p277))),
									_1: {
										ctor: '::',
										_0: _elm_lang$core$String$trim(
											_user$project$LangUnparser$unparseType(goalType)),
										_1: {
											ctor: '::',
											_0: 'failed to synthesize a type',
											_1: {ctor: '[]'}
										}
									}
								}
							});
						return {
							result: false,
							typeInfo: A3(_user$project$Types$addTypeErrorAt, _p277.start, err, typeInfo1)
						};
					} else {
						var result2 = A4(_user$project$Types$checkSubtype, typeInfo1, typeEnv, _p275._0, goalType);
						var _p276 = result2.result;
						if (_p276.ctor === 'Err') {
							var err_ = _user$project$Utils$spaces(
								{
									ctor: '::',
									_0: 'checkType',
									_1: {
										ctor: '::',
										_0: _elm_lang$core$Basics$toString(
											_user$project$Lang$expEId(
												_user$project$Lang$Expr(_p277))),
										_1: {
											ctor: '::',
											_0: _p276._0,
											_1: {ctor: '[]'}
										}
									}
								});
							return {
								result: false,
								typeInfo: A3(_user$project$Types$addTypeErrorAt, _p277.start, err_, result2.typeInfo)
							};
						} else {
							return {result: true, typeInfo: result2.typeInfo};
						}
					}
			}
		}
	});
var _user$project$Types$synthesizeBranchTypes = F2(
	function (typeInfo, list) {
		var _p278 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p280, _p279) {
					var _p281 = _p280;
					var _p282 = _p279;
					var resulti = A3(_user$project$Types$synthesizeType, _p282._1, _p281._0, _p281._1);
					return {
						ctor: '_Tuple2',
						_0: {ctor: '::', _0: resulti.result, _1: _p282._0},
						_1: resulti.typeInfo
					};
				}),
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: typeInfo
			},
			list);
		var maybeTypes = _p278._0;
		var typeInfo_ = _p278._1;
		return {
			result: _elm_lang$core$List$reverse(maybeTypes),
			typeInfo: typeInfo_
		};
	});
var _user$project$Types$tsAppMono = F5(
	function (finish, typeInfo, typeEnv, eArgs, _p283) {
		var _p284 = _p283;
		var _p292 = _p284._1;
		var _p291 = _p284._0;
		var checkArgs = F2(
			function (argsAndTypes, retType) {
				var _p285 = A3(
					_elm_lang$core$List$foldl,
					F2(
						function (_p287, _p286) {
							var _p288 = _p287;
							var _p289 = _p286;
							var res = A4(_user$project$Types$checkType, _p289._1, typeEnv, _p288._0, _p288._1);
							return {ctor: '_Tuple2', _0: _p289._0 && res.result, _1: res.typeInfo};
						}),
					{ctor: '_Tuple2', _0: true, _1: typeInfo},
					argsAndTypes);
				var argsOkay = _p285._0;
				var typeInfo_ = _p285._1;
				return argsOkay ? A2(finish.withType, retType, typeInfo_) : A2(finish.withError, 'Function arguments don\'t match required types.', typeInfo_);
			});
		var _p290 = {
			ctor: '_Tuple2',
			_0: _elm_lang$core$List$length(eArgs),
			_1: _elm_lang$core$List$length(_p291)
		};
		var nArgs = _p290._0;
		var nTypes = _p290._1;
		if (_elm_lang$core$Native_Utils.eq(nArgs, nTypes)) {
			return A2(
				checkArgs,
				A2(_user$project$Utils$zip, eArgs, _p291),
				_p292);
		} else {
			if (_elm_lang$core$Native_Utils.cmp(nArgs, nTypes) < 0) {
				var argTypes_ = A2(_elm_lang$core$List$take, nArgs, _p291);
				var retType_ = _user$project$Types$tArrow(
					{
						ctor: '_Tuple2',
						_0: A2(_elm_lang$core$List$drop, nArgs, _p291),
						_1: _p292
					});
				return A2(
					checkArgs,
					A2(_user$project$Utils$zip, eArgs, argTypes_),
					retType_);
			} else {
				return A2(finish.withError, 'Too many arguments to this function.', typeInfo);
			}
		}
	});
var _user$project$Types$tsAppPoly = F5(
	function (finish, typeInfo, typeEnv, eArgs, polyArrow) {
		var result = A3(_user$project$Types$synthesizeTypeMany, typeInfo, typeEnv, eArgs);
		var _p293 = _user$project$Utils$projJusts(result.result);
		if (_p293.ctor === 'Nothing') {
			var err = 'Could not typecheck all of the arguments.';
			return A2(finish.withError, err, result.typeInfo);
		} else {
			var result1 = A2(_user$project$Types$instantiatePolyArrowWithConstraintVars, result.typeInfo, polyArrow);
			var result2 = A2(_user$project$Types$instantiateTypesWithConstraintVars, result1.typeInfo, _p293._0);
			var _p294 = result1.result;
			var constraintVars1 = _p294._0;
			var argTypes_ = _p294._1._0;
			var retType_ = _p294._1._1;
			var _p295 = result2.result;
			var constraintVars2 = _p295._0;
			var tActuals_ = _p295._1;
			var typeInfo_ = A2(
				_user$project$Types$addRawConstraints,
				A2(_user$project$Utils$zip, argTypes_, tActuals_),
				result2.typeInfo);
			var constraintVars = A2(_elm_lang$core$Basics_ops['++'], constraintVars1, constraintVars2);
			var result3 = A3(_user$project$Types$solveConstraintsFor, typeInfo_, typeEnv, constraintVars);
			var _p296 = result3.result;
			if (_p296.ctor === 'Err') {
				return A2(finish.withError, _p296._0, typeInfo_);
			} else {
				var _p298 = _p296._0;
				var retType__ = A2(_user$project$Types$applyUnifier, _p298, retType_);
				var _p297 = {
					ctor: '_Tuple2',
					_0: _elm_lang$core$List$length(eArgs),
					_1: _elm_lang$core$List$length(argTypes_)
				};
				var nArgs = _p297._0;
				var nTypes = _p297._1;
				if (_elm_lang$core$Native_Utils.eq(nArgs, nTypes)) {
					return A2(finish.withType, retType__, result3.typeInfo);
				} else {
					if (_elm_lang$core$Native_Utils.cmp(nArgs, nTypes) < 0) {
						var remainingArgTypes_ = A2(
							_elm_lang$core$List$map,
							_user$project$Types$applyUnifier(_p298),
							A2(
								_elm_lang$core$List$drop,
								_elm_lang$core$List$length(eArgs),
								argTypes_));
						return A2(
							finish.withType,
							_user$project$Types$tArrow(
								{ctor: '_Tuple2', _0: remainingArgTypes_, _1: retType__}),
							result3.typeInfo);
					} else {
						return A2(finish.withError, 'Too many arguments to this function.', result3.typeInfo);
					}
				}
			}
		}
	});
var _user$project$Types$synthesizeTypeMany = F3(
	function (typeInfo, typeEnv, es) {
		return A2(
			_user$project$Types$synthesizeBranchTypes,
			typeInfo,
			A2(
				_elm_lang$core$List$map,
				function (ei) {
					return {ctor: '_Tuple2', _0: typeEnv, _1: ei};
				},
				es));
	});
var _user$project$Types$tsFun = F6(
	function (finish, typeInfo, typeEnv, ps, eBody, _p299) {
		var _p300 = _p299;
		var _p304 = _p300._1;
		var _p303 = _p300._0;
		var _p301 = A3(_user$project$Types$addBindings, ps, _p303, typeEnv);
		if (_p301.ctor === 'Err') {
			return A2(finish.withError, _p301._0, typeInfo);
		} else {
			var result1 = A3(_user$project$Types$synthesizeType, typeInfo, _p301._0, eBody);
			var _p302 = result1.result;
			if (_p302.ctor === 'Nothing') {
				return A2(finish.withError, 'can\'t synthesize type for function body', result1.typeInfo);
			} else {
				return A2(
					finish.withType,
					_user$project$Types$tArrow(
						{ctor: '_Tuple2', _0: _p303, _1: _p304}),
					A2(
						_user$project$Types$addRawConstraints,
						{
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p304, _1: _p302._0},
							_1: {ctor: '[]'}
						},
						result1.typeInfo));
			}
		}
	});
var _user$project$Types$tsLetFinishE2_ = F7(
	function (finishWithType, typeInfo, typeEnv, p, t1, e1eid, e2) {
		var _p305 = A3(
			_user$project$Types$addBindings,
			{
				ctor: '::',
				_0: p,
				_1: {ctor: '[]'}
			},
			{
				ctor: '::',
				_0: t1,
				_1: {ctor: '[]'}
			},
			typeEnv);
		if (_p305.ctor === 'Err') {
			return {
				result: _elm_lang$core$Maybe$Nothing,
				typeInfo: A3(_user$project$Types$addTypeErrorAt, p.start, _p305._0, typeInfo)
			};
		} else {
			var typeInfo_ = A3(
				_user$project$Types$addNamedExp,
				p,
				e1eid,
				A3(
					_user$project$Types$addFinalType,
					e1eid,
					_elm_lang$core$Maybe$Just(t1),
					typeInfo));
			var result2 = A3(_user$project$Types$synthesizeType, typeInfo_, _p305._0, e2);
			var _p306 = result2.result;
			if (_p306.ctor === 'Nothing') {
				return {result: _elm_lang$core$Maybe$Nothing, typeInfo: result2.typeInfo};
			} else {
				return A2(finishWithType, _p306._0, result2.typeInfo);
			}
		}
	});
var _user$project$Types$tsLetFinishE2 = F7(
	function (finishWithType, typeInfo, typeEnv, p, t1, eInfo1, e2) {
		if (!_user$project$Types$sanityChecks) {
			return A7(_user$project$Types$tsLetFinishE2_, finishWithType, typeInfo, typeEnv, p, t1, eInfo1.val, e2);
		} else {
			if (A2(_user$project$Types$isWellFormed, typeEnv, t1)) {
				return A7(_user$project$Types$tsLetFinishE2_, finishWithType, typeInfo, typeEnv, p, t1, eInfo1.val, e2);
			} else {
				var err = _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: '[TYPE SYSTEM BUG]',
						_1: {
							ctor: '::',
							_0: _elm_lang$core$Basics$toString(eInfo1.val),
							_1: {
								ctor: '::',
								_0: _user$project$Lang$strPos(t1.start),
								_1: {
									ctor: '::',
									_0: 'Synthesized type not well-formed:',
									_1: {
										ctor: '::',
										_0: _elm_lang$core$String$trim(
											_user$project$LangUnparser$unparseType(t1)),
										_1: {ctor: '[]'}
									}
								}
							}
						}
					});
				var typeInfo_ = A3(_user$project$Types$addTypeErrorAt, eInfo1.start, err, typeInfo);
				return _user$project$Types$stopAtError ? {result: _elm_lang$core$Maybe$Nothing, typeInfo: typeInfo_} : A7(_user$project$Types$tsLetFinishE2_, finishWithType, typeInfo_, typeEnv, p, t1, eInfo1.val, e2);
			}
		}
	});
var _user$project$Types$tsLet = F6(
	function (finishWithType, typeInfo, typeEnv, p, e1, e2) {
		var result1 = A3(_user$project$Types$synthesizeType, typeInfo, typeEnv, e1);
		var _p307 = result1.result;
		if (_p307.ctor === 'Nothing') {
			if (_user$project$Types$stopAtError) {
				return result1;
			} else {
				var t1 = _user$project$Types$tVar('__NO_TYPE__');
				return A7(
					_user$project$Types$tsLetFinishE2,
					finishWithType,
					result1.typeInfo,
					typeEnv,
					p,
					t1,
					_user$project$Types$eInfoOf(e1),
					e2);
			}
		} else {
			var _p310 = _p307._0;
			var result1_ = function () {
				var _p308 = _user$project$Types$isArrowTemplate(_p310);
				if (_p308.ctor === 'Just') {
					return A4(
						_user$project$Types$solveTemplateArrow,
						result1.typeInfo,
						typeEnv,
						_user$project$Types$eInfoOf(e1),
						_p308._0);
				} else {
					return {
						result: _elm_lang$core$Maybe$Just(_p310),
						typeInfo: result1.typeInfo
					};
				}
			}();
			var _p309 = result1_.result;
			if (_p309.ctor === 'Just') {
				return A7(
					_user$project$Types$tsLetFinishE2,
					finishWithType,
					result1_.typeInfo,
					typeEnv,
					p,
					_p309._0,
					_user$project$Types$eInfoOf(e1),
					e2);
			} else {
				if (_user$project$Types$stopAtError) {
					return result1_;
				} else {
					var t1_ = _user$project$Types$tVar('__NO_TYPE__');
					return A7(
						_user$project$Types$tsLetFinishE2,
						finishWithType,
						result1_.typeInfo,
						typeEnv,
						p,
						t1_,
						_user$project$Types$eInfoOf(e1),
						e2);
				}
			}
		}
	});
var _user$project$Types$typecheck = function (e) {
	var _p311 = A2(_user$project$Types$debugLog, 'TYPE CHECKING', '...');
	var result = A3(_user$project$Types$synthesizeType, _user$project$Types$initTypeInfo, _user$project$Types$preludeTypeEnv, e);
	var _p312 = _user$project$Types$displayTypeInfo(result.typeInfo);
	return _user$project$Types$aceTypeInfo(result.typeInfo);
};
var _user$project$Types$addRecBinding = F4(
	function (rec, p, t, typeEnv) {
		if (!rec) {
			return typeEnv;
		} else {
			var _p313 = p.val.p__;
			if (_p313.ctor === 'PVar') {
				var tMono = function () {
					var _p314 = _user$project$Types$stripPolymorphicArrow(t);
					if (_p314.ctor === 'Nothing') {
						return t;
					} else {
						return _user$project$Types$tArrow(_p314._0._1);
					}
				}();
				return {
					ctor: '::',
					_0: A2(_user$project$Types$HasType, _p313._1, tMono),
					_1: typeEnv
				};
			} else {
				var _p315 = A2(
					_user$project$Types$debugLog,
					'addRecBinding: multi TODO',
					{
						ctor: '_Tuple2',
						_0: _user$project$LangUnparser$unparsePat(p),
						_1: _user$project$LangUnparser$unparseType(t)
					});
				return typeEnv;
			}
		}
	});

var _user$project$LangUtils$patternExtractsField = F2(
	function (fieldPredicate, pat) {
		patternExtractsField:
		while (true) {
			var _p0 = pat.val.p__;
			switch (_p0.ctor) {
				case 'PParens':
					var _v1 = fieldPredicate,
						_v2 = _p0._1;
					fieldPredicate = _v1;
					pat = _v2;
					continue patternExtractsField;
				case 'PAs':
					return A2(_user$project$LangUtils$patternExtractsField, fieldPredicate, _p0._3) || A2(_user$project$LangUtils$patternExtractsField, fieldPredicate, _p0._1);
				case 'PVar':
					return true;
				case 'PRecord':
					return A2(
						_elm_lang$core$List$any,
						function (_p1) {
							var _p2 = _p1;
							return fieldPredicate(_p2._2);
						},
						_p0._1);
				case 'PColonType':
					var _v4 = fieldPredicate,
						_v5 = _p0._1;
					fieldPredicate = _v4;
					pat = _v5;
					continue patternExtractsField;
				case 'PConst':
					return false;
				case 'PBase':
					return false;
				case 'PWildcard':
					return false;
				default:
					return false;
			}
		}
	});
var _user$project$LangUtils$expEqual = F2(
	function (e1_, e2_) {
		return _elm_lang$core$Native_Utils.eq(
			A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e1_),
			A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e2_));
	});
var _user$project$LangUtils$listForAll2 = F3(
	function (f, l1, l2) {
		listForAll2:
		while (true) {
			var _p3 = l1;
			if (_p3.ctor === '[]') {
				var _p4 = l2;
				if (_p4.ctor === '[]') {
					return true;
				} else {
					return false;
				}
			} else {
				var _p5 = l2;
				if (_p5.ctor === '[]') {
					return false;
				} else {
					if (A2(f, _p3._0, _p5._0)) {
						var _v9 = f,
							_v10 = _p3._1,
							_v11 = _p5._1;
						f = _v9;
						l1 = _v10;
						l2 = _v11;
						continue listForAll2;
					} else {
						return false;
					}
				}
			}
		}
	});
var _user$project$LangUtils$patEqual = F2(
	function (p1_, p2_) {
		return _elm_lang$core$Native_Utils.eq(
			A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, p1_),
			A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, p2_));
	});
var _user$project$LangUtils$wsEqual = F2(
	function (ws1, ws2) {
		return _elm_lang$core$Native_Utils.eq(ws1.val, ws2.val);
	});
var _user$project$LangUtils$branchEqual = F2(
	function (b1, b2) {
		var _p6 = {ctor: '_Tuple2', _0: b1.val, _1: b2.val};
		return A2(_user$project$LangUtils$wsEqual, _p6._0._0, _p6._1._0) && (A2(_user$project$LangUtils$wsEqual, _p6._0._3, _p6._1._3) && (A2(_user$project$LangUtils$expEqual, _p6._0._2, _p6._1._2) && A2(_user$project$LangUtils$patEqual, _p6._0._1, _p6._1._1)));
	});
var _user$project$LangUtils$typeEqual = F2(
	function (ty1, ty2) {
		var _p7 = {ctor: '_Tuple2', _0: ty1.val.t__, _1: ty2.val.t__};
		_v13_13:
		do {
			if (_p7.ctor === '_Tuple2') {
				switch (_p7._0.ctor) {
					case 'TNum':
						if (_p7._1.ctor === 'TNum') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0);
						} else {
							break _v13_13;
						}
					case 'TBool':
						if (_p7._1.ctor === 'TBool') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0);
						} else {
							break _v13_13;
						}
					case 'TString':
						if (_p7._1.ctor === 'TString') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0);
						} else {
							break _v13_13;
						}
					case 'TNull':
						if (_p7._1.ctor === 'TNull') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0);
						} else {
							break _v13_13;
						}
					case 'TList':
						if (_p7._1.ctor === 'TList') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._2, _p7._1._2) && A2(_user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1));
						} else {
							break _v13_13;
						}
					case 'TDict':
						if (_p7._1.ctor === 'TDict') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._3, _p7._1._3) && (A2(_user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1) && A2(_user$project$LangUtils$typeEqual, _p7._0._2, _p7._1._2)));
						} else {
							break _v13_13;
						}
					case 'TTuple':
						if (_p7._1.ctor === 'TTuple') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._2, _p7._1._2) && (A2(_user$project$LangUtils$wsEqual, _p7._0._4, _p7._1._4) && (A3(_user$project$LangUtils$listForAll2, _user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1) && function () {
								var _p8 = {ctor: '_Tuple2', _0: _p7._0._3, _1: _p7._1._3};
								_v14_2:
								do {
									if (_p8.ctor === '_Tuple2') {
										if (_p8._0.ctor === 'Nothing') {
											if (_p8._1.ctor === 'Nothing') {
												return true;
											} else {
												break _v14_2;
											}
										} else {
											if (_p8._1.ctor === 'Just') {
												return A2(_user$project$LangUtils$typeEqual, _p8._0._0, _p8._1._0);
											} else {
												break _v14_2;
											}
										}
									} else {
										break _v14_2;
									}
								} while(false);
								return false;
							}())));
						} else {
							break _v13_13;
						}
					case 'TArrow':
						if (_p7._1.ctor === 'TArrow') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._2, _p7._1._2) && A3(_user$project$LangUtils$listForAll2, _user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1));
						} else {
							break _v13_13;
						}
					case 'TUnion':
						if (_p7._1.ctor === 'TUnion') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._2, _p7._1._2) && A3(_user$project$LangUtils$listForAll2, _user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1));
						} else {
							break _v13_13;
						}
					case 'TApp':
						if (_p7._1.ctor === 'TApp') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$typeEqual, _p7._0._1, _p7._1._1) && A3(_user$project$LangUtils$listForAll2, _user$project$LangUtils$typeEqual, _p7._0._2, _p7._1._2));
						} else {
							break _v13_13;
						}
					case 'TVar':
						if (_p7._1.ctor === 'TVar') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && _elm_lang$core$Native_Utils.eq(_p7._0._1, _p7._1._1);
						} else {
							break _v13_13;
						}
					case 'TForall':
						if (_p7._1.ctor === 'TForall') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0) && (A2(_user$project$LangUtils$wsEqual, _p7._0._3, _p7._1._3) && (A3(
								_user$project$LangUtils$listForAll2,
								F2(
									function (a1, a2) {
										return _elm_lang$core$Native_Utils.eq(a1, a2);
									}),
								_p7._0._1,
								_p7._1._1) && A2(_user$project$LangUtils$typeEqual, _p7._0._2, _p7._1._2)));
						} else {
							break _v13_13;
						}
					case 'TWildcard':
						if (_p7._1.ctor === 'TWildcard') {
							return A2(_user$project$LangUtils$wsEqual, _p7._0._0, _p7._1._0);
						} else {
							break _v13_13;
						}
					default:
						break _v13_13;
				}
			} else {
				break _v13_13;
			}
		} while(false);
		return false;
	});
var _user$project$LangUtils$tbranchEqual = F2(
	function (t1, t2) {
		var _p9 = {ctor: '_Tuple2', _0: t1.val, _1: t2.val};
		return A2(_user$project$LangUtils$wsEqual, _p9._0._0, _p9._1._0) && (A2(_user$project$LangUtils$wsEqual, _p9._0._3, _p9._1._3) && (A2(_user$project$LangUtils$expEqual, _p9._0._2, _p9._1._2) && A2(_user$project$LangUtils$typeEqual, _p9._0._1, _p9._1._1)));
	});
var _user$project$LangUtils$logExp = F2(
	function (msg, v) {
		var _p10 = A2(
			_elm_lang$core$Debug$log,
			A2(
				_elm_lang$core$Basics_ops['++'],
				msg,
				A2(
					_elm_lang$core$Basics_ops['++'],
					':',
					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, v))),
			{ctor: '_Tuple0'});
		return v;
	});
var _user$project$LangUtils$foldIndentStyle = F3(
	function (inlineString, indentStringFun, style) {
		var _p11 = style;
		if (_p11.ctor === 'InlineSpace') {
			return inlineString;
		} else {
			return indentStringFun(_p11._0);
		}
	});
var _user$project$LangUtils$foldIndent = function (inlineString) {
	return A2(
		_user$project$LangUtils$foldIndentStyle,
		inlineString,
		function (x) {
			return A2(_elm_lang$core$Basics_ops['++'], '\n', x);
		});
};
var _user$project$LangUtils$valFromExpVal_ = F2(
	function (e, v_) {
		return {
			v_: v_,
			provenance: A3(
				_user$project$Lang$Provenance,
				{ctor: '[]'},
				e,
				{ctor: '[]'}),
			parents: _user$project$Lang$Parents(
				{ctor: '[]'})
		};
	});
var _user$project$LangUtils$pruneEnv = F2(
	function (exp, env) {
		var freeVars = _user$project$Lang$freeIdentifiers(exp);
		return A2(
			_elm_lang$core$List$filter,
			function (_p12) {
				var _p13 = _p12;
				return A2(_elm_lang$core$Set$member, _p13._0, freeVars);
			},
			env);
	});
var _user$project$LangUtils$removeVarsInEnv = F2(
	function (boundVars, env) {
		return A2(
			_elm_lang$core$List$filter,
			function (_p14) {
				var _p15 = _p14;
				return !A2(_elm_lang$core$Set$member, _p15._0, boundVars);
			},
			env);
	});
var _user$project$LangUtils$pruneEnvPattern = F2(
	function (pats, env) {
		pruneEnvPattern:
		while (true) {
			var _p16 = pats;
			if (_p16.ctor === '[]') {
				return env;
			} else {
				var varspattern = _user$project$Lang$identifiersSetInPat(_p16._0);
				var _v21 = _p16._1,
					_v22 = A2(
					_elm_lang$core$List$filter,
					function (_p17) {
						var _p18 = _p17;
						return !A2(_elm_lang$core$Set$member, _p18._0, varspattern);
					},
					env);
				pats = _v21;
				env = _v22;
				continue pruneEnvPattern;
			}
		}
	});
var _user$project$LangUtils$IndentSpace = function (a) {
	return {ctor: 'IndentSpace', _0: a};
};
var _user$project$LangUtils$InlineSpace = {ctor: 'InlineSpace'};
var _user$project$LangUtils$increaseIndent = function (style) {
	var _p19 = style;
	if (_p19.ctor === 'InlineSpace') {
		return _user$project$LangUtils$InlineSpace;
	} else {
		return _user$project$LangUtils$IndentSpace(
			A2(_elm_lang$core$Basics_ops['++'], _p19._0, '  '));
	}
};
var _user$project$LangUtils$valToExpFull = F4(
	function (copyFrom, sp_, indent, v) {
		var sp = A2(
			_elm_lang$core$Maybe$withDefault,
			sp_,
			A2(
				_elm_lang$core$Maybe$andThen,
				function (e) {
					var _p20 = _user$project$Lang$unwrapExp(e);
					if (_p20.ctor === 'EApp') {
						return _elm_lang$core$Maybe$Just(
							_user$project$Lang$ws(''));
					} else {
						return _elm_lang$core$Maybe$Just(
							_user$project$Lang$ws(
								_user$project$Lang$precedingWhitespace(e)));
					}
				},
				copyFrom));
		return _user$project$Lang$withDummyExpInfo(
			function () {
				var _p21 = v.v_;
				switch (_p21.ctor) {
					case 'VConst':
						return A4(
							_user$project$Lang$EConst,
							sp,
							_elm_lang$core$Tuple$first(_p21._1),
							_user$project$Lang$dummyLoc,
							_user$project$Lang$noWidgetDecl);
					case 'VBase':
						switch (_p21._0.ctor) {
							case 'VBool':
								return A2(
									_user$project$Lang$EBase,
									sp,
									_user$project$Lang$EBool(_p21._0._0));
							case 'VString':
								var _p22 = _p21._0._0;
								var $default = A2(
									_user$project$Lang$EBase,
									sp,
									A2(_user$project$Lang$EString, _user$project$Lang$defaultQuoteChar, _p22));
								return ((_elm_lang$core$Native_Utils.cmp(
									_elm_lang$core$String$length(_p22),
									50) > 0) && A2(_elm_lang$core$String$contains, '\n', _p22)) ? A4(
									_user$project$Lang$EParens,
									_user$project$Lang$space0,
									_user$project$Lang$withDummyExpInfo($default),
									_user$project$Lang$LongStringSyntax,
									_user$project$Lang$space0) : $default;
							default:
								return A2(_user$project$Lang$EBase, sp, _user$project$Lang$ENull);
						}
					case 'VList':
						var _p47 = _p21._0;
						var _p23 = _user$project$Lang$vHtmlNodeUnapply(v);
						if (_p23.ctor === 'Just') {
							var _p40 = _p23._0._0;
							var _p39 = _p23._0._2;
							var _p38 = _p23._0._1;
							var defaultAttrs = function (_p24) {
								var _p25 = _p24;
								var _p26 = _user$project$Utils$projJusts(
									A2(_elm_lang$core$List$map, _user$project$Lang$vTupleViewUnapply, _p38));
								if (_p26.ctor === 'Nothing') {
									return A2(
										_user$project$Lang$eList0,
										A2(
											_elm_lang$core$List$map,
											A3(_user$project$LangUtils$valToExpFull, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0, indent),
											_p38),
										_elm_lang$core$Maybe$Nothing);
								} else {
									var elems = A2(
										_elm_lang$core$List$map,
										function (_p27) {
											var _p28 = _p27;
											return {
												ctor: '_Tuple2',
												_0: _user$project$Lang$space1,
												_1: A2(
													_user$project$Lang$eListWs,
													{
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: _user$project$Lang$space0,
															_1: A3(_user$project$LangUtils$valToExp, _user$project$Lang$space0, indent, _p28._0)
														},
														_1: {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: _user$project$Lang$space0,
																_1: A3(_user$project$LangUtils$valToExp, _user$project$Lang$space0, indent, _p28._1)
															},
															_1: {ctor: '[]'}
														}
													},
													_elm_lang$core$Maybe$Nothing)
											};
										},
										_p26._0);
									return _user$project$Lang$withDummyExpInfo(
										A5(_user$project$Lang$EList, _user$project$Lang$space0, elems, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0));
								}
							};
							var defaultChildren = function (_p29) {
								var _p30 = _p29;
								return A2(
									_user$project$Lang$eList0,
									A2(
										_elm_lang$core$List$map,
										A3(_user$project$LangUtils$valToExpFull, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0, indent),
										_p39),
									_elm_lang$core$Maybe$Nothing);
							};
							var newClosingType = _user$project$Lang$ws(
								_user$project$HTMLParser$isVoidElement(_p40) ? _user$project$Lang$encoding_voidclosing : '');
							var _p31 = A2(_elm_lang$core$Maybe$map, _user$project$Lang$unwrapExp, copyFrom);
							if ((((((((((_p31.ctor === 'Just') && (_p31._0.ctor === 'EList')) && (_p31._0._1.ctor === '::')) && (_p31._0._1._0.ctor === '_Tuple2')) && (_p31._0._1._1.ctor === '::')) && (_p31._0._1._1._0.ctor === '_Tuple2')) && (_p31._0._1._1._1.ctor === '::')) && (_p31._0._1._1._1._0.ctor === '_Tuple2')) && (_p31._0._1._1._1._1.ctor === '[]')) && (_p31._0._3.ctor === 'Nothing')) {
								var _p37 = _p31._0._1._1._0._1;
								var mbNewAttrExp = function () {
									var _p32 = _user$project$Lang$unwrapExp(_p37);
									if ((_p32.ctor === 'EList') && (_p32._3.ctor === 'Nothing')) {
										return (_elm_lang$core$Native_Utils.cmp(
											_elm_lang$core$List$length(_p32._1),
											2) > -1) ? _elm_lang$core$Maybe$Just(
											A4(
												_user$project$LangUtils$valToExpFull,
												_elm_lang$core$Maybe$Just(_p37),
												_user$project$Lang$space0,
												indent,
												A2(
													_user$project$Lang$replaceV_,
													v,
													_user$project$Lang$VList(_p38)))) : _elm_lang$core$Maybe$Nothing;
									} else {
										return _elm_lang$core$Maybe$Nothing;
									}
								}();
								var newAttrExp = A2(_user$project$Utils$maybeWithDefaultLazy, defaultAttrs, mbNewAttrExp);
								var newChildExp = function () {
									var _p33 = _user$project$Lang$unwrapExp(_p31._0._1._1._1._0._1);
									if ((_p33.ctor === 'EList') && (_p33._3.ctor === 'Nothing')) {
										var _p36 = _p33._1;
										return (_elm_lang$core$Native_Utils.cmp(
											_elm_lang$core$List$length(_p36),
											_elm_lang$core$List$length(_p39)) > -1) ? A2(
											_user$project$Lang$eListWs,
											A3(
												_elm_lang$core$List$map2,
												F2(
													function (_p34, n) {
														var _p35 = _p34;
														return {
															ctor: '_Tuple2',
															_0: _p35._0,
															_1: A4(
																_user$project$LangUtils$valToExpFull,
																_elm_lang$core$Maybe$Just(_p35._1),
																_user$project$Lang$space0,
																indent,
																n)
														};
													}),
												_p36,
												_p39),
											_elm_lang$core$Maybe$Nothing) : defaultChildren(
											{ctor: '_Tuple0'});
									} else {
										return defaultChildren(
											{ctor: '_Tuple0'});
									}
								}();
								return A5(
									_user$project$Lang$EList,
									_p31._0._0,
									{
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: _p31._0._1._0._0,
											_1: _user$project$Lang$eStr0(_p40)
										},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: _p31._0._1._1._0._0, _1: newAttrExp},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: _p31._0._1._1._1._0._0, _1: newChildExp},
												_1: {ctor: '[]'}
											}
										}
									},
									newClosingType,
									_elm_lang$core$Maybe$Nothing,
									_p31._0._4);
							} else {
								return A5(
									_user$project$Lang$EList,
									_user$project$Lang$space0,
									{
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: _user$project$Lang$space0,
											_1: _user$project$Lang$eStr(_p40)
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: _user$project$Lang$space0,
												_1: defaultAttrs(
													{ctor: '_Tuple0'})
											},
											_1: {
												ctor: '::',
												_0: {
													ctor: '_Tuple2',
													_0: _user$project$Lang$space0,
													_1: defaultChildren(
														{ctor: '_Tuple0'})
												},
												_1: {ctor: '[]'}
											}
										}
									},
									newClosingType,
									_elm_lang$core$Maybe$Nothing,
									_user$project$Lang$space0);
							}
						} else {
							var defaultSpCommaHd = _user$project$Lang$ws('');
							var defaultSpCommaTail = _user$project$Lang$space0;
							var _p41 = A2(
								_elm_lang$core$Maybe$withDefault,
								{
									ctor: '_Tuple3',
									_0: sp,
									_1: {
										ctor: '_Tuple2',
										_0: {ctor: '_Tuple2', _0: defaultSpCommaHd, _1: _user$project$LangUtils$valToExp},
										_1: {ctor: '_Tuple2', _0: defaultSpCommaTail, _1: _user$project$LangUtils$valToExp}
									},
									_2: _elm_lang$core$List$isEmpty(_p47) ? _user$project$Lang$space0 : _user$project$Lang$ws(
										A2(_user$project$LangUtils$foldIndent, '', indent))
								},
								A2(
									_elm_lang$core$Maybe$andThen,
									function (e) {
										var _p42 = _user$project$Lang$unwrapExp(e);
										if (_p42.ctor === 'EList') {
											var valToExps = function () {
												var _p43 = _p42._1;
												if (_p43.ctor === '::') {
													if (_p43._1.ctor === '::') {
														return {
															ctor: '_Tuple2',
															_0: {
																ctor: '_Tuple2',
																_0: _p43._0._0,
																_1: _user$project$LangUtils$valToExpFull(
																	_elm_lang$core$Maybe$Just(_p43._0._1))
															},
															_1: {
																ctor: '_Tuple2',
																_0: _p43._1._0._0,
																_1: _user$project$LangUtils$valToExpFull(
																	_elm_lang$core$Maybe$Just(_p43._1._0._1))
															}
														};
													} else {
														var _p44 = _p43._0._1;
														return {
															ctor: '_Tuple2',
															_0: {
																ctor: '_Tuple2',
																_0: _p43._0._0,
																_1: _user$project$LangUtils$valToExpFull(
																	_elm_lang$core$Maybe$Just(_p44))
															},
															_1: {
																ctor: '_Tuple2',
																_0: defaultSpCommaTail,
																_1: _user$project$LangUtils$valToExpFull(
																	_elm_lang$core$Maybe$Just(_p44))
															}
														};
													}
												} else {
													return {
														ctor: '_Tuple2',
														_0: {ctor: '_Tuple2', _0: defaultSpCommaHd, _1: _user$project$LangUtils$valToExp},
														_1: {ctor: '_Tuple2', _0: defaultSpCommaTail, _1: _user$project$LangUtils$valToExp}
													};
												}
											}();
											return _elm_lang$core$Maybe$Just(
												{ctor: '_Tuple3', _0: _p42._0, _1: valToExps, _2: _p42._4});
										} else {
											return _elm_lang$core$Maybe$Nothing;
										}
									},
									copyFrom));
							var precedingWS = _p41._0;
							var spaceCommaHead = _p41._1._0._0;
							var v2expHead = _p41._1._0._1;
							var spaceCommaTail = _p41._1._1._0;
							var v2expTail = _p41._1._1._1;
							var spBeforeEnd = _p41._2;
							var _p45 = _p47;
							if (_p45.ctor === '[]') {
								return A5(
									_user$project$Lang$EList,
									precedingWS,
									{ctor: '[]'},
									_user$project$Lang$space0,
									_elm_lang$core$Maybe$Nothing,
									spBeforeEnd);
							} else {
								var headExp = {
									ctor: '_Tuple2',
									_0: spaceCommaHead,
									_1: A3(
										v2expHead,
										_user$project$Lang$ws(
											A3(
												_user$project$LangUtils$foldIndentStyle,
												'',
												function (_p46) {
													return ' ';
												},
												indent)),
										_user$project$LangUtils$increaseIndent(indent),
										_p45._0)
								};
								var tailExps = A2(
									_elm_lang$core$List$map,
									function (y) {
										return {
											ctor: '_Tuple2',
											_0: spaceCommaTail,
											_1: A3(
												v2expTail,
												_user$project$Lang$ws(
													A2(
														_user$project$LangUtils$foldIndent,
														' ',
														_user$project$LangUtils$increaseIndent(indent))),
												_user$project$LangUtils$increaseIndent(indent),
												y)
										};
									},
									_p45._1);
								return A5(
									_user$project$Lang$EList,
									precedingWS,
									{ctor: '::', _0: headExp, _1: tailExps},
									_user$project$Lang$space0,
									_elm_lang$core$Maybe$Nothing,
									spBeforeEnd);
							}
						}
					case 'VClosure':
						var _p58 = _p21._0;
						var _p57 = _p21._1;
						var _p56 = _p21._3;
						var _p55 = _p21._2;
						var _p48 = A2(
							_user$project$Utils$split,
							_elm_lang$core$List$length(_p58),
							_p56);
						var recEnv = _p48._0;
						var remEnv = _p48._1;
						var prunedEnv = A2(
							_user$project$LangUtils$removeVarsInEnv,
							_elm_lang$core$Set$fromList(
								A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$first, recEnv)),
							A2(
								_user$project$LangUtils$pruneEnvPattern,
								_p57,
								A2(_user$project$LangUtils$pruneEnv, _p55, _p56)));
						var _p49 = prunedEnv;
						if (_p49.ctor === '[]') {
							return A4(_user$project$Lang$EFun, sp, _p57, _p55, _user$project$Lang$space0);
						} else {
							var baseCase = _user$project$Lang$withDummyExpInfo(
								A4(
									_user$project$Lang$EFun,
									_user$project$Lang$ws(
										A2(_user$project$LangUtils$foldIndent, '', indent)),
									_p57,
									_p55,
									_user$project$Lang$space0));
							var startCase = function () {
								var _p50 = _p58;
								if (_p50.ctor === '[]') {
									return baseCase;
								} else {
									if (_p50._1.ctor === '[]') {
										var _p51 = _p50._0;
										return _user$project$Lang$withDummyExpInfo(
											A5(
												_user$project$Lang$ELet,
												sp,
												_user$project$Lang$Let,
												A4(
													_user$project$Lang$Declarations,
													{
														ctor: '::',
														_0: 0,
														_1: {ctor: '[]'}
													},
													{ctor: '[]'},
													{ctor: '[]'},
													{
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: true,
															_1: {
																ctor: '::',
																_0: A6(
																	_user$project$Lang$LetExp,
																	_elm_lang$core$Maybe$Nothing,
																	_user$project$Lang$space1,
																	_user$project$Lang$withDummyPatInfo(
																		A3(_user$project$Lang$PVar, _user$project$Lang$space0, _p51, _user$project$Lang$noWidgetDecl)),
																	_user$project$Lang$FunArgAsPats,
																	_user$project$Lang$space1,
																	baseCase),
																_1: {ctor: '[]'}
															}
														},
														_1: {ctor: '[]'}
													}),
												_user$project$Lang$space1,
												_user$project$Lang$withDummyExpInfo(
													A2(
														_user$project$Lang$EVar,
														_user$project$Lang$ws(
															A2(_user$project$LangUtils$foldIndent, ' ', indent)),
														_p51))));
									} else {
										return _elm_lang$core$Native_Utils.crashCase(
											'LangUtils',
											{
												start: {line: 195, column: 17},
												end: {line: 201, column: 129}
											},
											_p50)('cannot convert back a VCLosure with multiple defs to an ELet. Need syntax support for that.');
									}
								}
							}();
							var bigbody = A3(
								_elm_lang$core$List$foldl,
								F2(
									function (_p53, body) {
										var _p54 = _p53;
										return _user$project$Lang$withDummyExpInfo(
											A9(
												_user$project$Lang$eLet__,
												_user$project$Lang$ws(
													A2(_user$project$LangUtils$foldIndent, '', indent)),
												_user$project$Lang$Let,
												false,
												_user$project$Lang$withDummyPatInfo(
													A3(
														_user$project$Lang$PVar,
														_user$project$Lang$ws(' '),
														_p54._0,
														_user$project$Lang$noWidgetDecl)),
												_user$project$Lang$space1,
												A3(
													_user$project$LangUtils$valToExp,
													_user$project$Lang$space1,
													_user$project$LangUtils$increaseIndent(indent),
													_p54._1),
												_user$project$Lang$space1,
												body,
												_user$project$Lang$space0));
									}),
								startCase,
								_p49._1);
							return A9(
								_user$project$Lang$eLet__,
								sp,
								_user$project$Lang$Let,
								false,
								_user$project$Lang$withDummyPatInfo(
									A3(
										_user$project$Lang$PVar,
										_user$project$Lang$ws(' '),
										_p49._0._0,
										_user$project$Lang$noWidgetDecl)),
								_user$project$Lang$space1,
								A3(
									_user$project$LangUtils$valToExp,
									_user$project$Lang$space1,
									_user$project$LangUtils$increaseIndent(indent),
									_p49._0._1),
								_user$project$Lang$space1,
								bigbody,
								_user$project$Lang$space0);
						}
					case 'VRecord':
						var _p76 = _p21._0;
						var copiedResult = function () {
							var _p59 = copyFrom;
							if (_p59.ctor === 'Just') {
								var _p60 = _user$project$Lang$unwrapExp(_p59._0);
								if ((_p60.ctor === 'ERecord') && (_p60._1.ctor === 'Nothing')) {
									var _p67 = _p60._2._3;
									var _p63 = _user$project$Utils$projJusts(
										A2(
											_elm_lang$core$List$map,
											function (_p61) {
												var _p62 = _p61;
												return _user$project$Lang$pVarUnapply(_p62._2);
											},
											_user$project$Lang$elemsOf(_p67)));
									if (_p63.ctor === 'Just') {
										return _elm_lang$core$Native_Utils.eq(
											_elm_lang$core$Set$fromList(_p63._0),
											_elm_lang$core$Set$fromList(
												_elm_lang$core$Dict$keys(_p76))) ? A2(
											_elm_lang$core$Maybe$map,
											function (newLxs) {
												return A4(
													_user$project$Lang$ERecord,
													_p60._0,
													_elm_lang$core$Maybe$Nothing,
													A4(
														_user$project$Lang$Declarations,
														_p60._2._0,
														_p60._2._1,
														_p60._2._2,
														A2(_user$project$Lang$regroup, _p67, newLxs)),
													_p60._3);
											},
											_user$project$Utils$projJusts(
												A2(
													_elm_lang$core$List$map,
													function (_p64) {
														var _p65 = _p64;
														var _p66 = _p65._2;
														return A2(
															_elm_lang$core$Maybe$map,
															function (v) {
																return A6(
																	_user$project$Lang$LetExp,
																	_p65._0,
																	_p65._1,
																	_p66,
																	_p65._3,
																	_p65._4,
																	A4(
																		_user$project$LangUtils$valToExpFull,
																		_elm_lang$core$Maybe$Just(_p65._5),
																		_user$project$Lang$space1,
																		_user$project$LangUtils$increaseIndent(indent),
																		v));
															},
															A2(
																_elm_lang$core$Maybe$andThen,
																function (key) {
																	return A2(_elm_lang$core$Dict$get, key, _p76);
																},
																_user$project$Lang$pVarUnapply(_p66)));
													},
													_user$project$Lang$elemsOf(_p67)))) : _elm_lang$core$Maybe$Nothing;
									} else {
										return _elm_lang$core$Maybe$Nothing;
									}
								} else {
									return _elm_lang$core$Maybe$Nothing;
								}
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						}();
						var _p68 = copiedResult;
						if (_p68.ctor === 'Just') {
							return _p68._0;
						} else {
							var _p69 = function () {
								var _p70 = _user$project$Lang$vRecordTupleUnapply(v);
								if (_p70.ctor === 'Just') {
									return {
										ctor: '_Tuple2',
										_0: true,
										_1: {ctor: '::', _0: _p70._0._0, _1: _p70._0._1}
									};
								} else {
									return {
										ctor: '_Tuple2',
										_0: false,
										_1: _elm_lang$core$Dict$toList(_p76)
									};
								}
							}();
							var isTuple = _p69._0;
							var keyValues = _p69._1;
							var _p71 = {
								ctor: '_Tuple4',
								_0: sp,
								_1: _elm_lang$core$Dict$keys(_p76),
								_2: {
									ctor: '_Tuple2',
									_0: {ctor: '_Tuple4', _0: _elm_lang$core$Maybe$Nothing, _1: _user$project$Lang$space1, _2: _user$project$Lang$space1, _3: _user$project$LangUtils$valToExp},
									_1: {
										ctor: '_Tuple4',
										_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
										_1: _user$project$Lang$ws(
											A2(
												_user$project$LangUtils$foldIndent,
												' ',
												_user$project$LangUtils$increaseIndent(indent))),
										_2: _user$project$Lang$space1,
										_3: _user$project$LangUtils$valToExp
									}
								},
								_3: isTuple ? _user$project$Lang$ws('') : (_elm_lang$core$Dict$isEmpty(_p76) ? _user$project$Lang$space1 : _user$project$Lang$ws(
									A2(_user$project$LangUtils$foldIndent, '', indent)))
							};
							var precedingWS = _p71._0;
							var keys = _p71._1;
							var spaceComma = _p71._2._0._0;
							var spaceKey = _p71._2._0._1;
							var spaceEqual = _p71._2._0._2;
							var v2expHead = _p71._2._0._3;
							var spaceCommaTail = _p71._2._1._0;
							var spaceKeyTail = _p71._2._1._1;
							var spaceEqualTail = _p71._2._1._2;
							var v2expTail = _p71._2._1._3;
							var spBeforeEnd = _p71._3;
							return A4(
								_user$project$Lang$eRecord__,
								precedingWS,
								_elm_lang$core$Maybe$Nothing,
								A2(
									_elm_lang$core$List$indexedMap,
									F2(
										function (i, _p72) {
											var _p73 = _p72;
											var _p75 = _p73._1;
											var _p74 = _p73._0;
											return _elm_lang$core$Native_Utils.eq(i, 0) ? {
												ctor: '_Tuple5',
												_0: spaceComma,
												_1: spaceKey,
												_2: _p74,
												_3: spaceEqual,
												_4: A3(
													v2expHead,
													isTuple ? _user$project$Lang$ws('') : _user$project$Lang$ws(' '),
													_user$project$LangUtils$increaseIndent(
														_user$project$LangUtils$increaseIndent(indent)),
													_p75)
											} : {
												ctor: '_Tuple5',
												_0: spaceCommaTail,
												_1: spaceKeyTail,
												_2: _p74,
												_3: spaceEqualTail,
												_4: A3(
													v2expTail,
													(isTuple && (_elm_lang$core$Native_Utils.cmp(i, 1) < 1)) ? _user$project$Lang$ws('') : _user$project$Lang$ws(' '),
													_user$project$LangUtils$increaseIndent(
														_user$project$LangUtils$increaseIndent(indent)),
													_p75)
											};
										}),
									keyValues),
								spBeforeEnd);
						}
					case 'VDict':
						return A5(
							_user$project$Lang$EOp,
							sp,
							_user$project$Lang$space0,
							_user$project$Info$withDummyInfo(_user$project$Lang$DictFromList),
							{
								ctor: '::',
								_0: _user$project$Lang$withDummyExpInfo(
									A5(
										_user$project$Lang$EList,
										_user$project$Lang$space1,
										A2(
											_elm_lang$core$List$indexedMap,
											F2(
												function (i, _p77) {
													var _p78 = _p77;
													var spaceComma = _elm_lang$core$Native_Utils.eq(i, 0) ? _user$project$Lang$ws('') : _user$project$Lang$ws(
														A2(_user$project$LangUtils$foldIndent, '', indent));
													var spaceElem = _user$project$Lang$ws(' ');
													return {
														ctor: '_Tuple2',
														_0: spaceComma,
														_1: A3(
															_user$project$LangUtils$valToExp,
															spaceElem,
															_user$project$LangUtils$increaseIndent(indent),
															A2(
																_user$project$Lang$replaceV_,
																v,
																_user$project$Lang$vTuple(
																	{
																		ctor: '::',
																		_0: A2(
																			_user$project$Utils$fromOk,
																			'valToExp',
																			A2(_user$project$LangUtils$dictKeyToVal, _user$project$Syntax$Leo, _p78._0)),
																		_1: {
																			ctor: '::',
																			_0: _p78._1,
																			_1: {ctor: '[]'}
																		}
																	})))
													};
												}),
											_elm_lang$core$Dict$toList(_p21._0)),
										_user$project$Lang$space0,
										_elm_lang$core$Maybe$Nothing,
										_user$project$Lang$space0)),
								_1: {ctor: '[]'}
							},
							_user$project$Lang$space0);
					default:
						return A2(_user$project$Lang$EVar, sp, _p21._0);
				}
			}());
	});
var _user$project$LangUtils$dictKeyToVal = F2(
	function (syntax, _p79) {
		var _p80 = _p79;
		return A2(
			_elm_lang$core$Result$andThen,
			function (e) {
				return A2(_user$project$LangUtils$simpleExpToVal, syntax, e);
			},
			A2(
				_elm_lang$core$Result$mapError,
				_user$project$ParserUtils$showError,
				A2(_user$project$Syntax$parser, syntax, _p80._0)));
	});
var _user$project$LangUtils$simpleExpToVal = F2(
	function (syntax, e) {
		var _p81 = _user$project$Lang$unwrapExp(e);
		_v51_7:
		do {
			switch (_p81.ctor) {
				case 'EConst':
					return _elm_lang$core$Result$Ok(
						A2(
							_user$project$LangUtils$valFromExpVal_,
							e,
							A2(
								_user$project$Lang$VConst,
								_elm_lang$core$Maybe$Nothing,
								{ctor: '_Tuple2', _0: _p81._1, _1: _user$project$Lang$dummyTrace})));
				case 'EBase':
					switch (_p81._1.ctor) {
						case 'EBool':
							return _elm_lang$core$Result$Ok(
								A2(
									_user$project$LangUtils$valFromExpVal_,
									e,
									_user$project$Lang$VBase(
										_user$project$Lang$VBool(_p81._1._0))));
						case 'EString':
							return _elm_lang$core$Result$Ok(
								A2(
									_user$project$LangUtils$valFromExpVal_,
									e,
									_user$project$Lang$VBase(
										_user$project$Lang$VString(_p81._1._1))));
						default:
							return _elm_lang$core$Result$Ok(
								A2(
									_user$project$LangUtils$valFromExpVal_,
									e,
									_user$project$Lang$VBase(_user$project$Lang$VNull)));
					}
				case 'EList':
					if (_p81._3.ctor === 'Nothing') {
						return A2(
							_elm_lang$core$Result$map,
							function (_p82) {
								return A2(
									_user$project$LangUtils$valFromExpVal_,
									e,
									_user$project$Lang$VList(_p82));
							},
							_user$project$Utils$projOk(
								A2(
									_elm_lang$core$List$map,
									_user$project$LangUtils$simpleExpToVal(syntax),
									_user$project$Utils$listValues(_p81._1))));
					} else {
						break _v51_7;
					}
				case 'ERecord':
					if (_p81._1.ctor === 'Nothing') {
						return A2(
							_elm_lang$core$Result$andThen,
							function (l) {
								return A2(
									_elm_lang$core$Result$map,
									function (_p83) {
										return A2(
											_user$project$LangUtils$valFromExpVal_,
											e,
											_user$project$Lang$VRecord(
												_elm_lang$core$Dict$fromList(_p83)));
									},
									_user$project$Utils$projOk(
										A2(
											_elm_lang$core$List$map,
											function (_p84) {
												var _p85 = _p84;
												return A2(
													_elm_lang$core$Result$map,
													function (v) {
														return {ctor: '_Tuple2', _0: _p85._2, _1: v};
													},
													A2(_user$project$LangUtils$simpleExpToVal, syntax, _p85._4));
											},
											l)));
							},
							A2(
								_elm_lang$core$Result$fromMaybe,
								'Record is not simple enough not to be computed',
								_user$project$Lang$recordEntriesFromDeclarations(_p81._2)));
					} else {
						break _v51_7;
					}
				case 'EOp':
					if ((_p81._3.ctor === '::') && (_p81._3._1.ctor === '[]')) {
						var _p86 = _p81._2.val;
						if (_p86.ctor === 'DictFromList') {
							return A2(
								_elm_lang$core$Result$andThen,
								function (d) {
									var _p87 = d.v_;
									if (_p87.ctor === 'VList') {
										return A2(
											_elm_lang$core$Result$map,
											function (_p88) {
												return A2(
													_user$project$LangUtils$valFromExpVal_,
													e,
													_user$project$Lang$VDict(
														_elm_lang$core$Dict$fromList(_p88)));
											},
											_user$project$Utils$projOk(
												A2(
													_elm_lang$core$List$map,
													function (pair) {
														var _p89 = pair.v_;
														if ((((_p89.ctor === 'VList') && (_p89._0.ctor === '::')) && (_p89._0._1.ctor === '::')) && (_p89._0._1._1.ctor === '[]')) {
															return A2(
																_elm_lang$core$Result$map,
																function (k) {
																	return {ctor: '_Tuple2', _0: k, _1: _p89._0._1._0};
																},
																A2(_user$project$LangUtils$valToDictKey, syntax, _p89._0._0));
														} else {
															return _elm_lang$core$Result$Err(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Expected a tuple, got ',
																	_user$project$LangUtils$valToString(d)));
														}
													},
													_p87._0)));
									} else {
										return _elm_lang$core$Result$Err('Cannot create a dictionary from something else than a list of tuples');
									}
								},
								A2(_user$project$LangUtils$simpleExpToVal, syntax, _p81._3._0));
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Could not consider as a simple expression ',
									_elm_lang$core$Basics$toString(e)));
						}
					} else {
						break _v51_7;
					}
				default:
					break _v51_7;
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Could not consider as a simple expression ',
				_elm_lang$core$Basics$toString(e)));
	});
var _user$project$LangUtils$valToDictKey = F2(
	function (syntax, val) {
		return _elm_lang$core$Result$Ok(
			{
				ctor: '_Tuple2',
				_0: _user$project$LangUtils$valToString(val),
				_1: 'val'
			});
	});
var _user$project$LangUtils$valToString = function (_p90) {
	return A2(
		_user$project$Syntax$unparser,
		_user$project$Syntax$Leo,
		A3(
			_user$project$LangUtils$valToExp,
			_user$project$Lang$ws(''),
			_user$project$LangUtils$IndentSpace(''),
			_p90));
};
var _user$project$LangUtils$valToExp = _user$project$LangUtils$valToExpFull(_elm_lang$core$Maybe$Nothing);
var _user$project$LangUtils$logVal = F2(
	function (msg, v) {
		var _p91 = A2(
			_elm_lang$core$Debug$log,
			A2(
				_elm_lang$core$Basics_ops['++'],
				msg,
				A2(
					_elm_lang$core$Basics_ops['++'],
					':',
					_user$project$LangUtils$valToString(v))),
			{ctor: '_Tuple0'});
		return v;
	});
var _user$project$LangUtils$envToString = function (env) {
	var _p92 = env;
	if (_p92.ctor === '[]') {
		return '';
	} else {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			_p92._0._0,
			A2(
				_elm_lang$core$Basics_ops['++'],
				'->',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUtils$valToString(_p92._0._1),
					A2(
						_elm_lang$core$Basics_ops['++'],
						' ',
						_user$project$LangUtils$envToString(_p92._1)))));
	}
};
var _user$project$LangUtils$logEnv = F3(
	function (msg, exp, env) {
		var _p93 = A2(
			_elm_lang$core$Debug$log,
			A2(
				_elm_lang$core$Basics_ops['++'],
				msg,
				A2(
					_elm_lang$core$Basics_ops['++'],
					':',
					_user$project$LangUtils$envToString(
						A2(_user$project$LangUtils$pruneEnv, exp, env)))),
			{ctor: '_Tuple0'});
		return env;
	});
var _user$project$LangUtils$valEqual = F2(
	function (v1, v2) {
		return _elm_lang$core$Native_Utils.eq(
			_user$project$LangUtils$valToString(v1),
			_user$project$LangUtils$valToString(v2));
	});
var _user$project$LangUtils$envEqual = F2(
	function (env1, env2) {
		return A3(
			_user$project$LangUtils$listForAll2,
			F2(
				function (_p95, _p94) {
					var _p96 = _p95;
					var _p97 = _p94;
					return _elm_lang$core$Native_Utils.eq(_p96._0, _p97._0) && A2(_user$project$LangUtils$valEqual, _p96._1, _p97._1);
				}),
			env1,
			env2);
	});

var _user$project$ValUnbuilder$dup = F3(
	function (sub1, sub2, v) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (a) {
				return A2(
					_elm_lang$core$Result$map,
					function (b) {
						return {ctor: '_Tuple2', _0: a, _1: b};
					},
					sub2(v));
			},
			sub1(v));
	});
var _user$project$ValUnbuilder$identity = function (v) {
	return _elm_lang$core$Result$Ok(v);
};
var _user$project$ValUnbuilder$record = F2(
	function (sub, v) {
		var _p0 = v.v_;
		if (_p0.ctor === 'VRecord') {
			return A3(
				_elm_lang$core$Dict$foldl,
				F3(
					function (k, v, acc) {
						return A3(
							_elm_lang$core$Result$map2,
							F2(
								function (acc, v) {
									return A3(_elm_lang$core$Dict$insert, k, v, acc);
								}),
							acc,
							sub(v));
					}),
				_elm_lang$core$Result$Ok(_elm_lang$core$Dict$empty),
				_p0._0);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a record, got ',
					_user$project$LangUtils$valToString(v)));
		}
	});
var _user$project$ValUnbuilder$dict = F2(
	function (sub, v) {
		var _p1 = v.v_;
		if (_p1.ctor === 'VDict') {
			return A3(
				_elm_lang$core$Dict$foldl,
				F3(
					function (k, v, acc) {
						return A3(
							_elm_lang$core$Result$map2,
							F2(
								function (acc, v) {
									return A3(_elm_lang$core$Dict$insert, k, v, acc);
								}),
							acc,
							sub(v));
					}),
				_elm_lang$core$Result$Ok(_elm_lang$core$Dict$empty),
				_p1._0);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a dict, got ',
					_user$project$LangUtils$valToString(v)));
		}
	});
var _user$project$ValUnbuilder$bool = function (v) {
	var _p2 = v.v_;
	if ((_p2.ctor === 'VBase') && (_p2._0.ctor === 'VBool')) {
		return _elm_lang$core$Result$Ok(_p2._0._0);
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a bool, got ',
				_user$project$LangUtils$valToString(v)));
	}
};
var _user$project$ValUnbuilder$num = function (v) {
	var _p3 = v.v_;
	if ((_p3.ctor === 'VConst') && (_p3._1.ctor === '_Tuple2')) {
		return _elm_lang$core$Result$Ok(_p3._1._0);
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a constant, got ',
				_user$project$LangUtils$valToString(v)));
	}
};
var _user$project$ValUnbuilder$int = function (v) {
	var _p4 = v.v_;
	if ((_p4.ctor === 'VConst') && (_p4._1.ctor === '_Tuple2')) {
		return _elm_lang$core$Result$Ok(
			_elm_lang$core$Basics$floor(_p4._1._0));
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a constant, got ',
				_user$project$LangUtils$valToString(v)));
	}
};
var _user$project$ValUnbuilder$string = function (v) {
	var _p5 = v.v_;
	if ((_p5.ctor === 'VBase') && (_p5._0.ctor === 'VString')) {
		return _elm_lang$core$Result$Ok(_p5._0._0);
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a string, got ',
				_user$project$LangUtils$valToString(v)));
	}
};
var _user$project$ValUnbuilder$innerTuple = F2(
	function (n, dv) {
		var _p6 = A2(
			_elm_lang$core$Dict$get,
			A2(
				_elm_lang$core$Basics_ops['++'],
				'_',
				_elm_lang$core$Basics$toString(n)),
			dv);
		if (_p6.ctor === 'Nothing') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: _p6._0,
				_1: A2(_user$project$ValUnbuilder$innerTuple, n + 1, dv)
			};
		}
	});
var _user$project$ValUnbuilder$constructor = F2(
	function (argwhat, v) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (d) {
				return A2(
					_elm_lang$core$Result$andThen,
					function (tagNameVal) {
						return A2(
							_elm_lang$core$Result$andThen,
							function (tagName) {
								return A2(
									_elm_lang$core$Result$andThen,
									function (dargs) {
										return A2(
											_elm_lang$core$Result$andThen,
											function (argDict) {
												return A2(
													_elm_lang$core$Result$map,
													function (args) {
														return {ctor: '_Tuple2', _0: tagName, _1: args};
													},
													argwhat(
														A2(_user$project$ValUnbuilder$innerTuple, 1, argDict)));
											},
											A2(_user$project$ValUnbuilder$record, _elm_lang$core$Result$Ok, dargs));
									},
									A2(
										_elm_lang$core$Result$fromMaybe,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Datatype: ',
											A2(_elm_lang$core$Basics_ops['++'], _user$project$Lang$ctorArgs, ' not found in record')),
										A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorArgs, d)));
							},
							_user$project$ValUnbuilder$string(tagNameVal));
					},
					A2(
						_elm_lang$core$Result$fromMaybe,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Datatype: ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$stringifyCtorKind(_user$project$Lang$DataTypeCtor),
								' not found in record')),
						A2(
							_elm_lang$core$Dict$get,
							_user$project$Lang$stringifyCtorKind(_user$project$Lang$DataTypeCtor),
							d)));
			},
			A2(_user$project$ValUnbuilder$record, _elm_lang$core$Result$Ok, v));
	});
var _user$project$ValUnbuilder$maybe = F2(
	function (subroutine, v) {
		var _p7 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
		_v7_2:
		do {
			if (_p7.ctor === 'Ok') {
				if (_p7._0.ctor === '_Tuple2') {
					if (_p7._0._1.ctor === '::') {
						if ((_p7._0._0 === 'Just') && (_p7._0._1._1.ctor === '[]')) {
							return A2(
								_elm_lang$core$Result$map,
								_elm_lang$core$Maybe$Just,
								subroutine(_p7._0._1._0));
						} else {
							break _v7_2;
						}
					} else {
						if (_p7._0._0 === 'Nothing') {
							return _elm_lang$core$Result$Ok(_elm_lang$core$Maybe$Nothing);
						} else {
							break _v7_2;
						}
					}
				} else {
					break _v7_2;
				}
			} else {
				return _elm_lang$core$Result$Err(_p7._0);
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected Just or Nothing, got ',
				_user$project$LangUtils$valToString(v)));
	});
var _user$project$ValUnbuilder$result = F2(
	function (subroutine, v) {
		var _p8 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
		_v8_2:
		do {
			if (_p8.ctor === 'Ok') {
				if (((_p8._0.ctor === '_Tuple2') && (_p8._0._1.ctor === '::')) && (_p8._0._1._1.ctor === '[]')) {
					switch (_p8._0._0) {
						case 'Ok':
							return A2(
								_elm_lang$core$Result$map,
								_elm_lang$core$Result$Ok,
								subroutine(_p8._0._1._0));
						case 'Err':
							return A2(
								_elm_lang$core$Result$map,
								_elm_lang$core$Result$Err,
								_user$project$ValUnbuilder$string(_p8._0._1._0));
						default:
							break _v8_2;
					}
				} else {
					break _v8_2;
				}
			} else {
				return _elm_lang$core$Result$Err(_p8._0);
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected Ok or Err, got ',
				_user$project$LangUtils$valToString(v)));
	});
var _user$project$ValUnbuilder$tuple2 = F3(
	function (sub1, sub2, v) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (d) {
				var _p9 = A2(_elm_lang$core$Dict$get, '_1', d);
				if (_p9.ctor === 'Nothing') {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Expected tuple, got ',
							_user$project$LangUtils$valToString(v)));
				} else {
					var _p10 = A2(_elm_lang$core$Dict$get, '_2', d);
					if (_p10.ctor === 'Nothing') {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected tuple, got ',
								_user$project$LangUtils$valToString(v)));
					} else {
						return A3(
							_elm_lang$core$Result$map2,
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								}),
							sub1(_p9._0),
							sub2(_p10._0));
					}
				}
			},
			A2(_user$project$ValUnbuilder$record, _elm_lang$core$Result$Ok, v));
	});
var _user$project$ValUnbuilder$viewtuple2 = F3(
	function (sub1, sub2, v) {
		var _p11 = v.v_;
		if ((((_p11.ctor === 'VList') && (_p11._0.ctor === '::')) && (_p11._0._1.ctor === '::')) && (_p11._0._1._1.ctor === '[]')) {
			return A3(
				_elm_lang$core$Result$map2,
				F2(
					function (a, b) {
						return {ctor: '_Tuple2', _0: a, _1: b};
					}),
				sub1(_p11._0._0),
				sub2(_p11._0._1._0));
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a 2-element list, got ',
					_user$project$LangUtils$valToString(v)));
		}
	});
var _user$project$ValUnbuilder$list = F2(
	function (sub, v) {
		var _p12 = v.v_;
		if (_p12.ctor === 'VList') {
			return _user$project$Utils$projOk(
				A2(_elm_lang$core$List$map, sub, _p12._0));
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a list, got ',
					_user$project$LangUtils$valToString(v)));
		}
	});

var _user$project$ValBuilder$identity = F2(
	function (vb, theVal) {
		return theVal;
	});
var _user$project$ValBuilder$record = F2(
	function (sub, vb) {
		return function (_p0) {
			return vb(
				_user$project$Lang$VRecord(
					A2(
						_elm_lang$core$Dict$map,
						F2(
							function (k, a) {
								return A2(sub, vb, a);
							}),
						_p0)));
		};
	});
var _user$project$ValBuilder$dict = F2(
	function (sub, vb) {
		return function (_p1) {
			return vb(
				_user$project$Lang$VDict(
					A2(
						_elm_lang$core$Dict$map,
						F2(
							function (k, a) {
								return A2(sub, vb, a);
							}),
						_p1)));
		};
	});
var _user$project$ValBuilder$const = function (vb) {
	return function (_p2) {
		return vb(
			A2(
				_user$project$Lang$VConst,
				_elm_lang$core$Maybe$Nothing,
				function (i) {
					return {ctor: '_Tuple2', _0: i, _1: _user$project$Lang$dummyTrace};
				}(_p2)));
	};
};
var _user$project$ValBuilder$bool = function (vb) {
	return function (_p3) {
		return vb(
			_user$project$Lang$VBase(
				_user$project$Lang$VBool(_p3)));
	};
};
var _user$project$ValBuilder$num = function (vb) {
	return function (_p4) {
		return vb(
			A2(
				_user$project$Lang$VConst,
				_elm_lang$core$Maybe$Nothing,
				function (i) {
					return {ctor: '_Tuple2', _0: i, _1: _user$project$Lang$dummyTrace};
				}(_p4)));
	};
};
var _user$project$ValBuilder$int = function (vb) {
	return function (_p5) {
		return vb(
			A2(
				_user$project$Lang$VConst,
				_elm_lang$core$Maybe$Nothing,
				function (i) {
					return {
						ctor: '_Tuple2',
						_0: _elm_lang$core$Basics$toFloat(i),
						_1: _user$project$Lang$dummyTrace
					};
				}(_p5)));
	};
};
var _user$project$ValBuilder$string = function (vb) {
	return function (_p6) {
		return vb(
			_user$project$Lang$VBase(
				_user$project$Lang$VString(_p6)));
	};
};
var _user$project$ValBuilder$constructor = F3(
	function (vb, tagname, vals) {
		return vb(
			_user$project$Lang$VRecord(
				_elm_lang$core$Dict$fromList(
					{
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _user$project$Lang$stringifyCtorKind(_user$project$Lang$DataTypeCtor),
							_1: A2(_user$project$ValBuilder$string, vb, tagname)
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: _user$project$Lang$ctorArgs,
								_1: vb(
									_user$project$Lang$VRecord(
										_elm_lang$core$Dict$fromList(
											A3(_user$project$Utils$indexedMapFrom, 1, _user$project$Lang$numericalValEntry, vals))))
							},
							_1: {ctor: '[]'}
						}
					})));
	});
var _user$project$ValBuilder$maybe = F3(
	function (subroutine, vb, mba) {
		var _p7 = mba;
		if (_p7.ctor === 'Just') {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Just',
				{
					ctor: '::',
					_0: A2(subroutine, vb, _p7._0),
					_1: {ctor: '[]'}
				});
		} else {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Nothing',
				{ctor: '[]'});
		}
	});
var _user$project$ValBuilder$result = F3(
	function (subroutine, vb, mba) {
		var _p8 = mba;
		if (_p8.ctor === 'Ok') {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Ok',
				{
					ctor: '::',
					_0: A2(subroutine, vb, _p8._0),
					_1: {ctor: '[]'}
				});
		} else {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Err',
				{
					ctor: '::',
					_0: A2(_user$project$ValBuilder$string, vb, _p8._0),
					_1: {ctor: '[]'}
				});
		}
	});
var _user$project$ValBuilder$tuple3 = F5(
	function (sub1, sub2, sub3, vb, _p9) {
		var _p10 = _p9;
		return vb(
			_user$project$Lang$VRecord(
				_elm_lang$core$Dict$fromList(
					{
						ctor: '::',
						_0: A3(
							_user$project$Lang$ctorVal,
							function (_p11) {
								return vb(
									_user$project$Lang$VBase(
										_user$project$Lang$VString(_p11)));
							},
							_user$project$Lang$TupleCtor,
							_user$project$Lang$ctorTupleName(3)),
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: '_1',
								_1: A2(sub1, vb, _p10._0)
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: '_2',
									_1: A2(sub2, vb, _p10._1)
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: '_3',
										_1: A2(sub3, vb, _p10._2)
									},
									_1: {ctor: '[]'}
								}
							}
						}
					})));
	});
var _user$project$ValBuilder$viewtuple3 = F5(
	function (sub1, sub2, sub3, vb, _p12) {
		var _p13 = _p12;
		return vb(
			_user$project$Lang$VList(
				{
					ctor: '::',
					_0: A2(sub1, vb, _p13._0),
					_1: {
						ctor: '::',
						_0: A2(sub2, vb, _p13._1),
						_1: {
							ctor: '::',
							_0: A2(sub3, vb, _p13._2),
							_1: {ctor: '[]'}
						}
					}
				}));
	});
var _user$project$ValBuilder$tuple2 = F4(
	function (sub1, sub2, vb, _p14) {
		var _p15 = _p14;
		return vb(
			_user$project$Lang$VRecord(
				_elm_lang$core$Dict$fromList(
					{
						ctor: '::',
						_0: A3(
							_user$project$Lang$ctorVal,
							function (_p16) {
								return vb(
									_user$project$Lang$VBase(
										_user$project$Lang$VString(_p16)));
							},
							_user$project$Lang$TupleCtor,
							_user$project$Lang$ctorTupleName(2)),
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: '_1',
								_1: A2(sub1, vb, _p15._0)
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: '_2',
									_1: A2(sub2, vb, _p15._1)
								},
								_1: {ctor: '[]'}
							}
						}
					})));
	});
var _user$project$ValBuilder$viewtuple2 = F4(
	function (sub1, sub2, vb, _p17) {
		var _p18 = _p17;
		return vb(
			_user$project$Lang$VList(
				{
					ctor: '::',
					_0: A2(sub1, vb, _p18._0),
					_1: {
						ctor: '::',
						_0: A2(sub2, vb, _p18._1),
						_1: {ctor: '[]'}
					}
				}));
	});
var _user$project$ValBuilder$htmlText = F2(
	function (vb, text) {
		return A4(
			_user$project$ValBuilder$viewtuple2,
			_user$project$ValBuilder$string,
			_user$project$ValBuilder$string,
			vb,
			{ctor: '_Tuple2', _0: 'TEXT', _1: text});
	});
var _user$project$ValBuilder$list = F2(
	function (sub, vb) {
		return function (_p19) {
			return vb(
				_user$project$Lang$VList(
					A2(
						_elm_lang$core$List$map,
						sub(vb),
						_p19)));
		};
	});
var _user$project$ValBuilder$fromVal = function (v) {
	return _user$project$Lang$replaceV_(v);
};

var _user$project$HTMLValParser$styleAttrToElmViewInLeo = F2(
	function (vb, _p0) {
		var _p1 = _p0;
		var _p5 = _p1._0;
		var _p4 = _p1._1;
		return (!_elm_lang$core$Native_Utils.eq(_p5, 'style')) ? A4(
			_user$project$ValBuilder$viewtuple2,
			_user$project$ValBuilder$string,
			_user$project$ValBuilder$string,
			vb,
			{ctor: '_Tuple2', _0: _p5, _1: _p4}) : A4(
			_user$project$ValBuilder$viewtuple2,
			_user$project$ValBuilder$string,
			_user$project$ValBuilder$list(
				A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$string)),
			vb,
			{
				ctor: '_Tuple2',
				_0: _p5,
				_1: A2(
					_elm_lang$core$List$map,
					function (_p2) {
						var _p3 = _p2;
						return {ctor: '_Tuple2', _0: _p3._1, _1: _p3._3};
					},
					_user$project$LangParserUtils$explodeStyleValue(_p4))
			});
	});
var _user$project$HTMLValParser$htmlNodeToElmViewInLeo = F2(
	function (vb, tree) {
		htmlNodeToElmViewInLeo:
		while (true) {
			var _p6 = tree.val;
			switch (_p6.ctor) {
				case 'HTMLInner':
					return A4(
						_user$project$ValBuilder$viewtuple2,
						_user$project$ValBuilder$string,
						_user$project$ValBuilder$string,
						vb,
						{
							ctor: '_Tuple2',
							_0: 'TEXT',
							_1: A4(
								_elm_lang$core$Regex$replace,
								_elm_lang$core$Regex$All,
								_elm_lang$core$Regex$regex('</[^>]*>'),
								function (_p7) {
									var _p8 = _p7;
									return '';
								},
								_p6._0)
						});
				case 'HTMLElement':
					return A5(
						_user$project$ValBuilder$viewtuple3,
						_user$project$ValBuilder$string,
						_user$project$ValBuilder$list(_user$project$HTMLValParser$styleAttrToElmViewInLeo),
						_user$project$ValBuilder$list(_user$project$HTMLValParser$htmlNodeToElmViewInLeo),
						vb,
						{
							ctor: '_Tuple3',
							_0: _user$project$HTMLParser$unparseTagName(_p6._0),
							_1: A2(
								_elm_lang$core$List$map,
								function (attr) {
									var _p9 = attr.val;
									if (_p9.ctor === 'HTMLAttributeListExp') {
										return {ctor: '_Tuple2', _0: 'internal-error', _1: 'unable-to-render-HTMLAttributeListExp'};
									} else {
										var _p11 = _p9._1;
										var _p10 = _p9._2.val;
										switch (_p10.ctor) {
											case 'HTMLAttributeUnquoted':
												return {
													ctor: '_Tuple2',
													_0: _p11.val,
													_1: _user$project$HTMLParser$interpretAttrValueContent(_p10._2)
												};
											case 'HTMLAttributeString':
												return {
													ctor: '_Tuple2',
													_0: _p11.val,
													_1: _user$project$HTMLParser$interpretAttrValueContent(_p10._3)
												};
											case 'HTMLAttributeNoValue':
												return {ctor: '_Tuple2', _0: _p11.val, _1: ''};
											default:
												return {ctor: '_Tuple2', _0: 'internal-error', _1: 'unable-to-render-HTMLAttributeExp'};
										}
									}
								},
								_p6._1),
							_2: _p6._4
						});
				case 'HTMLComment':
					var contentToVal = function (content) {
						return A4(
							_user$project$ValBuilder$viewtuple2,
							_user$project$ValBuilder$string,
							_user$project$ValBuilder$string,
							vb,
							{ctor: '_Tuple2', _0: 'COMMENT', _1: content});
					};
					var _p12 = _p6._0;
					switch (_p12.ctor) {
						case 'Less_Greater':
							return contentToVal(_p12._0);
						case 'LessSlash_Greater':
							return contentToVal(_p12._0);
						case 'LessBang_Greater':
							return contentToVal(_p12._0);
						default:
							return contentToVal(_p12._0);
					}
				case 'HTMLListNodeExp':
					return A4(
						_user$project$ValBuilder$viewtuple2,
						_user$project$ValBuilder$string,
						_user$project$ValBuilder$string,
						vb,
						{ctor: '_Tuple2', _0: 'TEXT', _1: '[internal error, cannot render HTMLListNodeExp]'});
				default:
					var _v7 = vb,
						_v8 = _elm_lang$core$Native_Utils.update(
						tree,
						{
							val: _user$project$HTMLParser$HTMLInner(_p6._0)
						});
					vb = _v7;
					tree = _v8;
					continue htmlNodeToElmViewInLeo;
			}
		}
	});
var _user$project$HTMLValParser$valToHtmlNode = function (v) {
	var toHTMLAttributeContent = function (contentv) {
		return A2(
			_user$project$ValUnbuilder$list,
			function (elemV) {
				var _p13 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, elemV);
				_v9_2:
				do {
					if (((_p13.ctor === 'Ok') && (_p13._0.ctor === '_Tuple2')) && (_p13._0._1.ctor === '::')) {
						if (_p13._0._1._1.ctor === '[]') {
							if (_p13._0._0 === 'HTMLAttributeStringRaw') {
								return A2(
									_elm_lang$core$Result$map,
									function (_p14) {
										return _user$project$Info$withDummyInfo(
											_user$project$HTMLParser$HTMLAttributeStringRaw(_p14));
									},
									_user$project$ValUnbuilder$string(_p13._0._1._0));
							} else {
								break _v9_2;
							}
						} else {
							if ((_p13._0._0 === 'HTMLAttributeEntity') && (_p13._0._1._1._1.ctor === '[]')) {
								return A3(
									_elm_lang$core$Result$map2,
									F2(
										function (rendered, content) {
											return _user$project$Info$withDummyInfo(
												A2(_user$project$HTMLParser$HTMLAttributeEntity, rendered, content));
										}),
									_user$project$ValUnbuilder$string(_p13._0._1._0),
									_user$project$ValUnbuilder$string(_p13._0._1._1._0));
							} else {
								break _v9_2;
							}
						}
					} else {
						break _v9_2;
					}
				} while(false);
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected HTMLAttributeStringRaw(1) or HTMLAttributeEntity(2), got ',
						_user$project$LangUtils$valToString(elemV)));
			},
			contentv);
	};
	return A2(
		_elm_lang$core$Result$map,
		_user$project$Info$withDummyInfo,
		function () {
			var _p15 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
			_v10_4:
			do {
				if (((_p15.ctor === 'Ok') && (_p15._0.ctor === '_Tuple2')) && (_p15._0._1.ctor === '::')) {
					if (_p15._0._1._1.ctor === '::') {
						if (_p15._0._1._1._1.ctor === '[]') {
							if (_p15._0._0 === 'HTMLEntity') {
								return A2(
									_elm_lang$core$Result$andThen,
									function (entityRendered) {
										return A2(
											_elm_lang$core$Result$map,
											function (entity) {
												return A2(_user$project$HTMLParser$HTMLEntity, entityRendered, entity);
											},
											_user$project$ValUnbuilder$string(_p15._0._1._1._0));
									},
									_user$project$ValUnbuilder$string(_p15._0._1._0));
							} else {
								break _v10_4;
							}
						} else {
							if (((((_p15._0._0 === 'HTMLElement') && (_p15._0._1._1._1._1.ctor === '::')) && (_p15._0._1._1._1._1._1.ctor === '::')) && (_p15._0._1._1._1._1._1._1.ctor === '::')) && (_p15._0._1._1._1._1._1._1._1.ctor === '[]')) {
								var _p25 = _p15._0._1._1._1._1._0;
								var _p24 = _p15._0._1._1._1._1._1._1._0;
								return A2(
									_elm_lang$core$Result$andThen,
									function (_p16) {
										var _p17 = _p16;
										return A4(
											_elm_lang$core$Result$map3,
											F3(
												function (endOp, children, closing) {
													return A6(
														_user$project$HTMLParser$HTMLElement,
														_user$project$HTMLParser$HTMLTagString(
															_user$project$Info$withDummyInfo(_p17._0)),
														_p17._1,
														_user$project$Lang$ws(_p17._2),
														endOp,
														children,
														closing);
												}),
											function () {
												var _p18 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, _p25);
												_v12_2:
												do {
													if (((_p18.ctor === 'Ok') && (_p18._0.ctor === '_Tuple2')) && (_p18._0._1.ctor === '[]')) {
														switch (_p18._0._0) {
															case 'RegularEndOpening':
																return _elm_lang$core$Result$Ok(_user$project$HTMLParser$RegularEndOpening);
															case 'SlashEndOpening':
																return _elm_lang$core$Result$Ok(_user$project$HTMLParser$SlashEndOpening);
															default:
																break _v12_2;
														}
													} else {
														break _v12_2;
													}
												} while(false);
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Expected RegularEndOpening or SlashEndOpening, got ',
														_user$project$LangUtils$valToString(_p25)));
											}(),
											A2(_user$project$ValUnbuilder$list, _user$project$HTMLValParser$valToHtmlNode, _p15._0._1._1._1._1._1._0),
											function () {
												var _p19 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, _p24);
												_v13_5:
												do {
													if ((_p19.ctor === 'Ok') && (_p19._0.ctor === '_Tuple2')) {
														if (_p19._0._1.ctor === '::') {
															if ((_p19._0._0 === 'RegularClosing') && (_p19._0._1._1.ctor === '[]')) {
																return A2(
																	_elm_lang$core$Result$map,
																	function (_p20) {
																		return _user$project$HTMLParser$RegularClosing(
																			_user$project$Lang$ws(_p20));
																	},
																	_user$project$ValUnbuilder$string(_p19._0._1._0));
															} else {
																break _v13_5;
															}
														} else {
															switch (_p19._0._0) {
																case 'VoidClosing':
																	return _elm_lang$core$Result$Ok(_user$project$HTMLParser$VoidClosing);
																case 'AutoClosing':
																	return _elm_lang$core$Result$Ok(_user$project$HTMLParser$AutoClosing);
																case 'ForgotClosing':
																	return _elm_lang$core$Result$Ok(_user$project$HTMLParser$ForgotClosing);
																case 'ImplicitElem':
																	return _elm_lang$core$Result$Ok(_user$project$HTMLParser$ImplicitElem);
																default:
																	break _v13_5;
															}
														}
													} else {
														break _v13_5;
													}
												} while(false);
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Expected RegularClosing space, VoidClosing, AutoClosing, ForgotClosing or ImplicitElem, got ',
														_user$project$LangUtils$valToString(_p24)));
											}());
									},
									A4(
										_elm_lang$core$Result$map3,
										F3(
											function (tagName, attrs, ws1) {
												return {ctor: '_Tuple3', _0: tagName, _1: attrs, _2: ws1};
											}),
										_user$project$ValUnbuilder$string(_p15._0._1._0),
										A2(
											_user$project$ValUnbuilder$list,
											function (attrV) {
												var _p21 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, attrV);
												if (((((((_p21.ctor === 'Ok') && (_p21._0.ctor === '_Tuple2')) && (_p21._0._0 === 'HTMLAttribute')) && (_p21._0._1.ctor === '::')) && (_p21._0._1._1.ctor === '::')) && (_p21._0._1._1._1.ctor === '::')) && (_p21._0._1._1._1._1.ctor === '[]')) {
													var _p23 = _p21._0._1._1._1._0;
													return A4(
														_elm_lang$core$Result$map3,
														F3(
															function (sp0, name, value) {
																return _user$project$Info$withDummyInfo(
																	A3(
																		_user$project$HTMLParser$HTMLAttribute,
																		_user$project$Lang$ws(sp0),
																		_user$project$Info$withDummyInfo(name),
																		value));
															}),
														_user$project$ValUnbuilder$string(_p21._0._1._0),
														_user$project$ValUnbuilder$string(_p21._0._1._1._0),
														function () {
															var _p22 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, _p23);
															_v15_3:
															do {
																if ((_p22.ctor === 'Ok') && (_p22._0.ctor === '_Tuple2')) {
																	if (_p22._0._1.ctor === '::') {
																		if ((_p22._0._1._1.ctor === '::') && (_p22._0._1._1._1.ctor === '::')) {
																			if (_p22._0._1._1._1._1.ctor === '[]') {
																				if (_p22._0._0 === 'HTMLAttributeUnquoted') {
																					return A4(
																						_elm_lang$core$Result$map3,
																						F3(
																							function (ws1, ws2, content) {
																								return _user$project$Info$withDummyInfo(
																									A3(
																										_user$project$HTMLParser$HTMLAttributeUnquoted,
																										_user$project$Lang$ws(ws1),
																										_user$project$Lang$ws(ws2),
																										content));
																							}),
																						_user$project$ValUnbuilder$string(_p22._0._1._0),
																						_user$project$ValUnbuilder$string(_p22._0._1._1._0),
																						toHTMLAttributeContent(_p22._0._1._1._1._0));
																				} else {
																					break _v15_3;
																				}
																			} else {
																				if ((_p22._0._0 === 'HTMLAttributeString') && (_p22._0._1._1._1._1._1.ctor === '[]')) {
																					return A5(
																						_elm_lang$core$Result$map4,
																						F4(
																							function (ws1, ws2, delimiter, content) {
																								return _user$project$Info$withDummyInfo(
																									A4(
																										_user$project$HTMLParser$HTMLAttributeString,
																										_user$project$Lang$ws(ws1),
																										_user$project$Lang$ws(ws2),
																										delimiter,
																										content));
																							}),
																						_user$project$ValUnbuilder$string(_p22._0._1._0),
																						_user$project$ValUnbuilder$string(_p22._0._1._1._0),
																						_user$project$ValUnbuilder$string(_p22._0._1._1._1._0),
																						toHTMLAttributeContent(_p22._0._1._1._1._1._0));
																				} else {
																					break _v15_3;
																				}
																			}
																		} else {
																			break _v15_3;
																		}
																	} else {
																		if (_p22._0._0 === 'HTMLAttributeNoValue') {
																			return _elm_lang$core$Result$Ok(
																				_user$project$Info$withDummyInfo(_user$project$HTMLParser$HTMLAttributeNoValue));
																		} else {
																			break _v15_3;
																		}
																	}
																} else {
																	break _v15_3;
																}
															} while(false);
															return _elm_lang$core$Result$Err(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Expected HTMLAttributeUnquoted(3), HTMLAttributeString(4), HTMLAttributeNoValue(0), got ',
																	_user$project$LangUtils$valToString(_p23)));
														}());
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'Expected HTMLAttribute, got ',
															_user$project$LangUtils$valToString(attrV)));
												}
											},
											_p15._0._1._1._0),
										_user$project$ValUnbuilder$string(_p15._0._1._1._1._0)));
							} else {
								break _v10_4;
							}
						}
					} else {
						switch (_p15._0._0) {
							case 'HTMLInner':
								return A2(
									_elm_lang$core$Result$map,
									_user$project$HTMLParser$HTMLInner,
									_user$project$ValUnbuilder$string(_p15._0._1._0));
							case 'HTMLComment':
								var _p27 = _p15._0._1._0;
								return A2(
									_elm_lang$core$Result$map,
									function (style) {
										return _user$project$HTMLParser$HTMLComment(style);
									},
									function () {
										var _p26 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, _p27);
										_v16_4:
										do {
											if ((((_p26.ctor === 'Ok') && (_p26._0.ctor === '_Tuple2')) && (_p26._0._1.ctor === '::')) && (_p26._0._1._1.ctor === '[]')) {
												switch (_p26._0._0) {
													case 'Less_Greater':
														return A2(
															_elm_lang$core$Result$map,
															_user$project$HTMLParser$Less_Greater,
															_user$project$ValUnbuilder$string(_p26._0._1._0));
													case 'LessSlash_Greater':
														return A2(
															_elm_lang$core$Result$map,
															_user$project$HTMLParser$LessSlash_Greater,
															_user$project$ValUnbuilder$string(_p26._0._1._0));
													case 'LessBang_Greater':
														return A2(
															_elm_lang$core$Result$map,
															_user$project$HTMLParser$LessBang_Greater,
															_user$project$ValUnbuilder$string(_p26._0._1._0));
													case 'LessBangDashDash_DashDashGreater':
														return A2(
															_elm_lang$core$Result$map,
															_user$project$HTMLParser$LessBangDashDash_DashDashGreater,
															_user$project$ValUnbuilder$string(_p26._0._1._0));
													default:
														break _v16_4;
												}
											} else {
												break _v16_4;
											}
										} while(false);
										return _elm_lang$core$Result$Err(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Expected Less_Greater, LessSlash_Greater, LessBang_Greater or LessBangDashDash_DashDashGreater but got ',
												_user$project$LangUtils$valToString(_p27)));
									}());
							default:
								break _v10_4;
						}
					}
				} else {
					break _v10_4;
				}
			} while(false);
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected HTMLInner, HTMLElement or HTMLComment, got ',
					_user$project$LangUtils$valToString(v)));
		}());
};
var _user$project$HTMLValParser$htmlNodeToVal = F2(
	function (vb, n) {
		var fromHTMLAttributeContent = F2(
			function (vb, content) {
				return A3(
					_user$project$ValBuilder$list,
					F2(
						function (vb, elem) {
							var _p28 = elem.val;
							if (_p28.ctor === 'HTMLAttributeStringRaw') {
								return A3(
									_user$project$ValBuilder$constructor,
									vb,
									'HTMLAttributeStringRaw',
									{
										ctor: '::',
										_0: A2(_user$project$ValBuilder$string, vb, _p28._0),
										_1: {ctor: '[]'}
									});
							} else {
								return A3(
									_user$project$ValBuilder$constructor,
									vb,
									'HTMLAttributeEntity',
									{
										ctor: '::',
										_0: A2(_user$project$ValBuilder$string, vb, _p28._0),
										_1: {
											ctor: '::',
											_0: A2(_user$project$ValBuilder$string, vb, _p28._1),
											_1: {ctor: '[]'}
										}
									});
							}
						}),
					vb,
					content);
			});
		var _p29 = n.val;
		switch (_p29.ctor) {
			case 'HTMLInner':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'HTMLInner',
					{
						ctor: '::',
						_0: A2(_user$project$ValBuilder$string, vb, _p29._0),
						_1: {ctor: '[]'}
					});
			case 'HTMLElement':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'HTMLElement',
					{
						ctor: '::',
						_0: A2(
							_user$project$ValBuilder$string,
							vb,
							_user$project$HTMLParser$unparseTagName(_p29._0)),
						_1: {
							ctor: '::',
							_0: A3(
								_user$project$ValBuilder$list,
								F2(
									function (vb, a) {
										var _p30 = a.val;
										if (_p30.ctor === 'HTMLAttributeListExp') {
											return A3(
												_user$project$ValBuilder$constructor,
												vb,
												'HTMLAttributeListExpNotSupportedHere',
												{ctor: '[]'});
										} else {
											return A3(
												_user$project$ValBuilder$constructor,
												vb,
												'HTMLAttribute',
												{
													ctor: '::',
													_0: A2(_user$project$ValBuilder$string, vb, _p30._0.val),
													_1: {
														ctor: '::',
														_0: A2(_user$project$ValBuilder$string, vb, _p30._1.val),
														_1: {
															ctor: '::',
															_0: function () {
																var _p31 = _p30._2.val;
																switch (_p31.ctor) {
																	case 'HTMLAttributeUnquoted':
																		return A3(
																			_user$project$ValBuilder$constructor,
																			vb,
																			'HTMLAttributeUnquoted',
																			{
																				ctor: '::',
																				_0: A2(_user$project$ValBuilder$string, vb, _p31._0.val),
																				_1: {
																					ctor: '::',
																					_0: A2(_user$project$ValBuilder$string, vb, _p31._1.val),
																					_1: {
																						ctor: '::',
																						_0: A2(fromHTMLAttributeContent, vb, _p31._2),
																						_1: {ctor: '[]'}
																					}
																				}
																			});
																	case 'HTMLAttributeString':
																		return A3(
																			_user$project$ValBuilder$constructor,
																			vb,
																			'HTMLAttributeString',
																			{
																				ctor: '::',
																				_0: A2(_user$project$ValBuilder$string, vb, _p31._0.val),
																				_1: {
																					ctor: '::',
																					_0: A2(_user$project$ValBuilder$string, vb, _p31._1.val),
																					_1: {
																						ctor: '::',
																						_0: A2(_user$project$ValBuilder$string, vb, _p31._2),
																						_1: {
																							ctor: '::',
																							_0: A2(fromHTMLAttributeContent, vb, _p31._3),
																							_1: {ctor: '[]'}
																						}
																					}
																				}
																			});
																	case 'HTMLAttributeNoValue':
																		return A3(
																			_user$project$ValBuilder$constructor,
																			vb,
																			'HTMLAttributeNoValue',
																			{ctor: '[]'});
																	default:
																		return A3(
																			_user$project$ValBuilder$constructor,
																			vb,
																			'HTMLAttributeExpNotSupportedHere',
																			{ctor: '[]'});
																}
															}(),
															_1: {ctor: '[]'}
														}
													}
												});
										}
									}),
								vb,
								_p29._1),
							_1: {
								ctor: '::',
								_0: A2(_user$project$ValBuilder$string, vb, _p29._2.val),
								_1: {
									ctor: '::',
									_0: function () {
										var _p32 = _p29._3;
										if (_p32.ctor === 'RegularEndOpening') {
											return A3(
												_user$project$ValBuilder$constructor,
												vb,
												'RegularEndOpening',
												{ctor: '[]'});
										} else {
											return A3(
												_user$project$ValBuilder$constructor,
												vb,
												'SlashEndOpening',
												{ctor: '[]'});
										}
									}(),
									_1: {
										ctor: '::',
										_0: A3(_user$project$ValBuilder$list, _user$project$HTMLValParser$htmlNodeToVal, vb, _p29._4),
										_1: {
											ctor: '::',
											_0: function () {
												var _p33 = _p29._5;
												switch (_p33.ctor) {
													case 'RegularClosing':
														return A3(
															_user$project$ValBuilder$constructor,
															vb,
															'RegularClosing',
															{
																ctor: '::',
																_0: A2(_user$project$ValBuilder$string, vb, _p33._0.val),
																_1: {ctor: '[]'}
															});
													case 'VoidClosing':
														return A3(
															_user$project$ValBuilder$constructor,
															vb,
															'VoidClosing',
															{ctor: '[]'});
													case 'AutoClosing':
														return A3(
															_user$project$ValBuilder$constructor,
															vb,
															'AutoClosing',
															{ctor: '[]'});
													case 'ForgotClosing':
														return A3(
															_user$project$ValBuilder$constructor,
															vb,
															'ForgotClosing',
															{ctor: '[]'});
													default:
														return A3(
															_user$project$ValBuilder$constructor,
															vb,
															'ImplicitElem',
															{ctor: '[]'});
												}
											}(),
											_1: {ctor: '[]'}
										}
									}
								}
							}
						}
					});
			case 'HTMLComment':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'HTMLComment',
					{
						ctor: '::',
						_0: function () {
							var _p34 = _p29._0;
							switch (_p34.ctor) {
								case 'Less_Greater':
									return A3(
										_user$project$ValBuilder$constructor,
										vb,
										'Less_Greater',
										{
											ctor: '::',
											_0: A2(_user$project$ValBuilder$string, vb, _p34._0),
											_1: {ctor: '[]'}
										});
								case 'LessSlash_Greater':
									return A3(
										_user$project$ValBuilder$constructor,
										vb,
										'LessSlash_Greater',
										{
											ctor: '::',
											_0: A2(_user$project$ValBuilder$string, vb, _p34._0),
											_1: {ctor: '[]'}
										});
								case 'LessBang_Greater':
									return A3(
										_user$project$ValBuilder$constructor,
										vb,
										'LessBang_Greater',
										{
											ctor: '::',
											_0: A2(_user$project$ValBuilder$string, vb, _p34._0),
											_1: {ctor: '[]'}
										});
								default:
									return A3(
										_user$project$ValBuilder$constructor,
										vb,
										'LessBangDashDash_DashDashGreater',
										{
											ctor: '::',
											_0: A2(_user$project$ValBuilder$string, vb, _p34._0),
											_1: {ctor: '[]'}
										});
							}
						}(),
						_1: {ctor: '[]'}
					});
			case 'HTMLListNodeExp':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'HTMLListNodeExpNotSupportedHere',
					{ctor: '[]'});
			default:
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'HTMLEntity',
					{
						ctor: '::',
						_0: A2(_user$project$ValBuilder$string, vb, _p29._0),
						_1: {
							ctor: '::',
							_0: A2(_user$project$ValBuilder$string, vb, _p29._1),
							_1: {ctor: '[]'}
						}
					});
		}
	});
var _user$project$HTMLValParser$htmlValParser = A2(
	_user$project$Lang$builtinVal,
	'(Native)HTMLValParser.htmlValParser',
	A4(
		_user$project$Lang$VFun,
		'parseHTML',
		{
			ctor: '::',
			_0: 'html',
			_1: {ctor: '[]'}
		},
		function (args) {
			var _p35 = args;
			if ((_p35.ctor === '::') && (_p35._1.ctor === '[]')) {
				var _p38 = _p35._0;
				var _p36 = _p38.v_;
				if ((_p36.ctor === 'VBase') && (_p36._0.ctor === 'VString')) {
					var _p37 = _user$project$HTMLParser$parseHTMLString(_p36._0._0);
					if (_p37.ctor === 'Err') {
						return _elm_lang$core$Result$Err(
							_user$project$ParserUtils$showError(_p37._0));
					} else {
						return _elm_lang$core$Result$Ok(
							{
								ctor: '_Tuple2',
								_0: A3(
									_user$project$ValBuilder$list,
									_user$project$HTMLValParser$htmlNodeToVal,
									_user$project$ValBuilder$fromVal(_p38),
									_p37._0),
								_1: {ctor: '[]'}
							});
					}
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'parseHTML expects a string, got ',
							_user$project$LangUtils$valToString(_p38)));
				}
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'parseHTML expects exactly one argument, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args))));
			}
		},
		_elm_lang$core$Maybe$Just(
			F4(
				function (oldArgs, oldOut, newOut, vdiffs) {
					var newOutHtml = A2(_user$project$ValUnbuilder$list, _user$project$HTMLValParser$valToHtmlNode, newOut);
					var oldOutHtml = A2(_user$project$ValUnbuilder$list, _user$project$HTMLValParser$valToHtmlNode, oldOut);
					return _user$project$Results$fromResult(
						A2(
							_elm_lang$core$Result$map,
							function (_p39) {
								var _p40 = _p39;
								var _p42 = _p40._1;
								var finalSDiffs = function () {
									var _p41 = _p42;
									if (_p41.ctor === '[]') {
										return {ctor: '[]'};
									} else {
										return {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 0,
												_1: _user$project$Lang$VStringDiffs(_p42)
											},
											_1: {ctor: '[]'}
										};
									}
								}();
								return {
									ctor: '_Tuple2',
									_0: {
										ctor: '::',
										_0: A2(
											_user$project$Lang$replaceV_,
											newOut,
											_user$project$Lang$VBase(
												_user$project$Lang$VString(_p40._0))),
										_1: {ctor: '[]'}
									},
									_1: finalSDiffs
								};
							},
							A2(
								_elm_lang$core$Result$andThen,
								_elm_lang$core$Basics$identity,
								A3(
									_elm_lang$core$Result$map2,
									_user$project$HTMLParser$unparseHtmlNodesDiffs(
										_elm_lang$core$Maybe$Just(vdiffs)),
									oldOutHtml,
									newOutHtml))));
				}))));

var _user$project$UpdateUtils$classOf = function (c) {
	return _elm_lang$core$Char$isDigit(c) ? 0 : (_elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('.')) ? 1 : ((_elm_lang$core$Char$isLower(c) || (_elm_lang$core$Char$isUpper(c) || _elm_lang$core$Native_Utils.eq(
		c,
		_elm_lang$core$Native_Utils.chr('_')))) ? 2 : ((!_user$project$LangParserUtils$isSpace(c)) ? 3 : 4)));
};
var _user$project$UpdateUtils$affinityArray = _elm_lang$core$Array$fromList(
	{
		ctor: '::',
		_0: _elm_lang$core$Array$fromList(
			{
				ctor: '::',
				_0: 19,
				_1: {
					ctor: '::',
					_0: 9,
					_1: {
						ctor: '::',
						_0: 6,
						_1: {
							ctor: '::',
							_0: 11,
							_1: {
								ctor: '::',
								_0: 14,
								_1: {ctor: '[]'}
							}
						}
					}
				}
			}),
		_1: {
			ctor: '::',
			_0: _elm_lang$core$Array$fromList(
				{
					ctor: '::',
					_0: 5,
					_1: {
						ctor: '::',
						_0: 0,
						_1: {
							ctor: '::',
							_0: 3,
							_1: {
								ctor: '::',
								_0: 12,
								_1: {
									ctor: '::',
									_0: 16,
									_1: {ctor: '[]'}
								}
							}
						}
					}
				}),
			_1: {
				ctor: '::',
				_0: _elm_lang$core$Array$fromList(
					{
						ctor: '::',
						_0: 1,
						_1: {
							ctor: '::',
							_0: 18,
							_1: {
								ctor: '::',
								_0: 24,
								_1: {
									ctor: '::',
									_0: 21,
									_1: {
										ctor: '::',
										_0: 22,
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}),
				_1: {
					ctor: '::',
					_0: _elm_lang$core$Array$fromList(
						{
							ctor: '::',
							_0: 8,
							_1: {
								ctor: '::',
								_0: 2,
								_1: {
									ctor: '::',
									_0: 17,
									_1: {
										ctor: '::',
										_0: 7,
										_1: {
											ctor: '::',
											_0: 20,
											_1: {ctor: '[]'}
										}
									}
								}
							}
						}),
					_1: {
						ctor: '::',
						_0: _elm_lang$core$Array$fromList(
							{
								ctor: '::',
								_0: 15,
								_1: {
									ctor: '::',
									_0: 4,
									_1: {
										ctor: '::',
										_0: 23,
										_1: {
											ctor: '::',
											_0: 10,
											_1: {
												ctor: '::',
												_0: 13,
												_1: {ctor: '[]'}
											}
										}
									}
								}
							}),
						_1: {ctor: '[]'}
					}
				}
			}
		}
	});
var _user$project$UpdateUtils$affinityChar = F2(
	function (c1, c2) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			0,
			A2(
				_elm_lang$core$Maybe$andThen,
				function (row) {
					return A2(
						_elm_lang$core$Array$get,
						_user$project$UpdateUtils$classOf(c2),
						row);
				},
				A2(
					_elm_lang$core$Array$get,
					_user$project$UpdateUtils$classOf(c1),
					_user$project$UpdateUtils$affinityArray)));
	});
var _user$project$UpdateUtils$affinity = F2(
	function (s1, s2) {
		var _p0 = _elm_lang$core$String$uncons(
			A3(
				_elm_lang$core$String$slice,
				-1,
				_elm_lang$core$String$length(s1),
				s1));
		if (_p0.ctor === 'Just') {
			var _p1 = _elm_lang$core$String$uncons(s2);
			if (_p1.ctor === 'Just') {
				return A2(_user$project$UpdateUtils$affinityChar, _p0._0._0, _p1._0._0);
			} else {
				return 25;
			}
		} else {
			return 25;
		}
	});
var _user$project$UpdateUtils$reverseStringConcatenation = F4(
	function (sa, sb, newOut, strDiffs) {
		var saLength = _elm_lang$core$String$length(sa);
		var aux = F3(
			function (offset, revForSa, diffs) {
				aux:
				while (true) {
					var _p2 = diffs;
					if (_p2.ctor === '[]') {
						var indexCut = offset + saLength;
						var newSa = A2(_elm_lang$core$String$left, indexCut, newOut);
						var newSb = A2(_elm_lang$core$String$dropLeft, indexCut, newOut);
						return _user$project$Results$ok1(
							{
								ctor: '_Tuple4',
								_0: newSa,
								_1: _elm_lang$core$List$reverse(revForSa),
								_2: newSb,
								_3: {ctor: '[]'}
							});
					} else {
						var _p11 = _p2._0;
						var _p10 = _p2._0._0;
						var _p9 = _p2._0._2;
						var _p8 = _p2._0._1;
						var _p7 = _p2._1;
						if ((_elm_lang$core$Native_Utils.cmp(_p10, saLength) < 0) && (_elm_lang$core$Native_Utils.cmp(_p8, saLength) > 0)) {
							return A2(
								_user$project$Results$andThen,
								function (_p3) {
									return _elm_lang$core$Result$Ok(
										_user$project$LazyList$fromList(_p3));
								},
								_user$project$Results$projOk(
									{
										ctor: '::',
										_0: A3(
											aux,
											offset,
											revForSa,
											{
												ctor: '::',
												_0: A3(_user$project$Lang$StringUpdate, _p10, saLength, 0),
												_1: {
													ctor: '::',
													_0: A3(_user$project$Lang$StringUpdate, saLength, _p8, _p9),
													_1: _p7
												}
											}),
										_1: {
											ctor: '::',
											_0: A3(
												aux,
												offset,
												revForSa,
												{
													ctor: '::',
													_0: A3(_user$project$Lang$StringUpdate, _p10, saLength, _p9),
													_1: {
														ctor: '::',
														_0: A3(_user$project$Lang$StringUpdate, saLength, _p8, 0),
														_1: _p7
													}
												}),
											_1: {ctor: '[]'}
										}
									}));
						} else {
							if ((_elm_lang$core$Native_Utils.cmp(_p10, saLength) > 0) || (_elm_lang$core$Native_Utils.eq(_p10, saLength) && (_elm_lang$core$Native_Utils.cmp(_p8, _p10) > 0))) {
								var indexCutNew = saLength + offset;
								var newSa = A2(_elm_lang$core$String$left, indexCutNew, newOut);
								var newSb = A2(_elm_lang$core$String$dropLeft, indexCutNew, newOut);
								return _user$project$Results$ok1(
									{
										ctor: '_Tuple4',
										_0: newSa,
										_1: _elm_lang$core$List$reverse(revForSa),
										_2: newSb,
										_3: A2(_user$project$Lang$offsetStr, 0 - saLength, diffs)
									});
							} else {
								if (_elm_lang$core$Native_Utils.eq(_p10, saLength) && _elm_lang$core$Native_Utils.eq(_p8, saLength)) {
									var aLeft = A3(
										_elm_lang$core$String$slice,
										A2(_elm_lang$core$Basics$max, _p10 - 1, 0),
										_p10,
										sa);
									var bRight = A3(_elm_lang$core$String$slice, _p8 - saLength, (_p8 - saLength) + 1, sb);
									var inserted = A3(_elm_lang$core$String$slice, _p10 + offset, (_p10 + offset) + _p9, newOut);
									var replacements = {
										ctor: '::',
										_0: {
											ctor: '_Tuple3',
											_0: (offset + _p10) + _p9,
											_1: _elm_lang$core$List$reverse(
												{ctor: '::', _0: _p11, _1: revForSa}),
											_2: A2(_user$project$Lang$offsetStr, 0 - saLength, _p7)
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple3',
												_0: offset + _p10,
												_1: _elm_lang$core$List$reverse(revForSa),
												_2: A2(
													_user$project$Lang$offsetStr,
													0 - saLength,
													{ctor: '::', _0: _p11, _1: _p7})
											},
											_1: {ctor: '[]'}
										}
									};
									var orderedReplacementst = ((_elm_lang$core$Native_Utils.cmp(
										A2(_user$project$UpdateUtils$affinity, aLeft, inserted),
										A2(_user$project$UpdateUtils$affinity, inserted, bRight)) > -1) || ((_elm_lang$core$Native_Utils.cmp(_p8 - _p10, 1) > -1) && (_elm_lang$core$Native_Utils.cmp(_p8, saLength) < 1))) ? _user$project$Results$oks(replacements) : _user$project$Results$oks(
										_elm_lang$core$List$reverse(replacements));
									return A2(
										_user$project$Results$andThen,
										function (_p4) {
											var _p5 = _p4;
											var _p6 = _p5._0;
											var newSa = A2(_elm_lang$core$String$left, _p6, newOut);
											var newSb = A2(_elm_lang$core$String$dropLeft, _p6, newOut);
											return _user$project$Results$ok1(
												{ctor: '_Tuple4', _0: newSa, _1: _p5._1, _2: newSb, _3: _p5._2});
										},
										orderedReplacementst);
								} else {
									var _v4 = (offset - (_p8 - _p10)) + _p9,
										_v5 = {ctor: '::', _0: _p11, _1: revForSa},
										_v6 = _p7;
									offset = _v4;
									revForSa = _v5;
									diffs = _v6;
									continue aux;
								}
							}
						}
					}
				}
			});
		return A3(
			aux,
			0,
			{ctor: '[]'},
			strDiffs);
	});
var _user$project$UpdateUtils$reverseStringConcatenationMultiple = F3(
	function (strings, newOut, strDiffs) {
		var _p12 = strings;
		if (_p12.ctor === '[]') {
			return _user$project$Results$ok1(
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: {ctor: '[]'}
				});
		} else {
			if (_p12._1.ctor === '[]') {
				return _user$project$Results$ok1(
					{
						ctor: '_Tuple2',
						_0: {
							ctor: '::',
							_0: newOut,
							_1: {ctor: '[]'}
						},
						_1: {
							ctor: '::',
							_0: strDiffs,
							_1: {ctor: '[]'}
						}
					});
			} else {
				var _p17 = _p12._1;
				return A2(
					_user$project$Results$andThen,
					F2(
						function (tail, _p13) {
							var _p14 = _p13;
							return A2(
								_user$project$Results$map,
								A2(
									F3(
										function (newHead, headDiffs, _p15) {
											var _p16 = _p15;
											return {
												ctor: '_Tuple2',
												_0: {ctor: '::', _0: newHead, _1: _p16._0},
												_1: {ctor: '::', _0: headDiffs, _1: _p16._1}
											};
										}),
									_p14._0,
									_p14._1),
								A3(_user$project$UpdateUtils$reverseStringConcatenationMultiple, tail, _p14._2, _p14._3));
						})(_p17),
					A4(
						_user$project$UpdateUtils$reverseStringConcatenation,
						_p12._0,
						A2(_elm_lang$core$String$join, '', _p17),
						newOut,
						strDiffs));
			}
		}
	});
var _user$project$UpdateUtils$mergeRecord = F6(
	function (submerger, originalDict, modified1Dict, modifs1, modified2Dict, modifs2) {
		var get0 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict0',
				A2(_elm_lang$core$Dict$get, name, originalDict));
		};
		var get1 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict1',
				A2(_elm_lang$core$Dict$get, name, modified1Dict));
		};
		var get2 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict2',
				A2(_elm_lang$core$Dict$get, name, modified2Dict));
		};
		return A6(
			_elm_lang$core$Dict$merge,
			F3(
				function (kIn1, vIn1, _p18) {
					var _p19 = _p18;
					return {
						ctor: '_Tuple2',
						_0: A3(
							_elm_lang$core$Dict$insert,
							kIn1,
							get1(kIn1),
							_p19._0),
						_1: A3(_elm_lang$core$Dict$insert, kIn1, vIn1, _p19._1)
					};
				}),
			F4(
				function (kIn, vIn1, vIn2, _p20) {
					var _p21 = _p20;
					var _p22 = A5(
						submerger,
						get0(kIn),
						get1(kIn),
						vIn1,
						get2(kIn),
						vIn2);
					var newV = _p22._0;
					var mergedModif = _p22._1;
					return {
						ctor: '_Tuple2',
						_0: A3(_elm_lang$core$Dict$insert, kIn, newV, _p21._0),
						_1: A3(_elm_lang$core$Dict$insert, kIn, mergedModif, _p21._1)
					};
				}),
			F3(
				function (kIn2, vIn2, _p23) {
					var _p24 = _p23;
					return {
						ctor: '_Tuple2',
						_0: A3(
							_elm_lang$core$Dict$insert,
							kIn2,
							get2(kIn2),
							_p24._0),
						_1: A3(_elm_lang$core$Dict$insert, kIn2, vIn2, _p24._1)
					};
				}),
			modifs1,
			modifs2,
			{ctor: '_Tuple2', _0: originalDict, _1: _elm_lang$core$Dict$empty});
	});
var _user$project$UpdateUtils$mergeDict = F6(
	function (submerger, originalDict, modified1Dict, modifs1, modified2Dict, modifs2) {
		var get0 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict0',
				A2(_elm_lang$core$Dict$get, name, originalDict));
		};
		var get1 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict1',
				A2(_elm_lang$core$Dict$get, name, modified1Dict));
		};
		var get2 = function (name) {
			return A2(
				_user$project$Utils$fromJust_,
				'mergeDict2',
				A2(_elm_lang$core$Dict$get, name, modified2Dict));
		};
		return A6(
			_elm_lang$core$Dict$merge,
			F3(
				function (kIn1, vIn1, _p25) {
					var _p26 = _p25;
					var _p29 = _p26._1;
					var _p28 = _p26._0;
					var _p27 = vIn1;
					switch (_p27.ctor) {
						case 'VDictElemDelete':
							return {
								ctor: '_Tuple2',
								_0: A2(_elm_lang$core$Dict$remove, kIn1, _p28),
								_1: A3(_elm_lang$core$Dict$insert, kIn1, vIn1, _p29)
							};
						case 'VDictElemInsert':
							return {
								ctor: '_Tuple2',
								_0: A3(
									_elm_lang$core$Dict$insert,
									kIn1,
									get1(kIn1),
									_p28),
								_1: A3(_elm_lang$core$Dict$insert, kIn1, vIn1, _p29)
							};
						default:
							return {
								ctor: '_Tuple2',
								_0: A3(
									_elm_lang$core$Dict$insert,
									kIn1,
									get1(kIn1),
									_p28),
								_1: A3(_elm_lang$core$Dict$insert, kIn1, vIn1, _p29)
							};
					}
				}),
			F4(
				function (kIn, vIn1, vIn2, _p30) {
					var _p31 = _p30;
					var _p37 = _p31._1;
					var _p36 = _p31._0;
					var _p32 = {ctor: '_Tuple2', _0: vIn1, _1: vIn2};
					_v16_1:
					do {
						switch (_p32._1.ctor) {
							case 'VDictElemDelete':
								return {
									ctor: '_Tuple2',
									_0: A2(_elm_lang$core$Dict$remove, kIn, _p36),
									_1: A3(_elm_lang$core$Dict$insert, kIn, vIn2, _p37)
								};
							case 'VDictElemUpdate':
								switch (_p32._0.ctor) {
									case 'VDictElemDelete':
										break _v16_1;
									case 'VDictElemUpdate':
										var _p33 = A5(
											submerger,
											get0(kIn),
											get1(kIn),
											_p32._0._0,
											get2(kIn),
											_p32._1._0);
										var newV = _p33._0;
										var mergedModif = _p33._1;
										return {
											ctor: '_Tuple2',
											_0: A3(_elm_lang$core$Dict$insert, kIn, newV, _p36),
											_1: A3(
												_elm_lang$core$Dict$insert,
												kIn,
												_user$project$Lang$VDictElemUpdate(mergedModif),
												_p37)
										};
									default:
										return _elm_lang$core$Native_Utils.crashCase(
											'UpdateUtils',
											{
												start: {line: 2113, column: 11},
												end: {line: 2124, column: 169}
											},
											_p32)(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Something pretended that it inserted a key, and the other pretended that it updated the key. This is not possible. Key = ',
												_elm_lang$core$Basics$toString(kIn)));
								}
							default:
								switch (_p32._0.ctor) {
									case 'VDictElemDelete':
										break _v16_1;
									case 'VDictElemInsert':
										return {
											ctor: '_Tuple2',
											_0: A3(
												_elm_lang$core$Dict$insert,
												kIn,
												get1(kIn),
												_p36),
											_1: A3(_elm_lang$core$Dict$insert, kIn, vIn1, _p37)
										};
									default:
										return _elm_lang$core$Native_Utils.crashCase(
											'UpdateUtils',
											{
												start: {line: 2113, column: 11},
												end: {line: 2124, column: 169}
											},
											_p32)(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Something pretended that it inserted a key, and the other pretended that it updated the key. This is not possible. Key = ',
												_elm_lang$core$Basics$toString(kIn)));
								}
						}
					} while(false);
					return {
						ctor: '_Tuple2',
						_0: A2(_elm_lang$core$Dict$remove, kIn, _p36),
						_1: A3(_elm_lang$core$Dict$insert, kIn, vIn2, _p37)
					};
				}),
			F3(
				function (kIn2, vIn2, _p38) {
					var _p39 = _p38;
					var _p42 = _p39._1;
					var _p41 = _p39._0;
					var _p40 = vIn2;
					switch (_p40.ctor) {
						case 'VDictElemDelete':
							return {
								ctor: '_Tuple2',
								_0: A2(_elm_lang$core$Dict$remove, kIn2, _p41),
								_1: A3(_elm_lang$core$Dict$insert, kIn2, vIn2, _p42)
							};
						case 'VDictElemInsert':
							return {
								ctor: '_Tuple2',
								_0: A3(
									_elm_lang$core$Dict$insert,
									kIn2,
									get2(kIn2),
									_p41),
								_1: A3(_elm_lang$core$Dict$insert, kIn2, vIn2, _p42)
							};
						default:
							return {
								ctor: '_Tuple2',
								_0: A3(
									_elm_lang$core$Dict$insert,
									kIn2,
									get2(kIn2),
									_p41),
								_1: A3(_elm_lang$core$Dict$insert, kIn2, vIn2, _p42)
							};
					}
				}),
			modifs1,
			modifs2,
			{ctor: '_Tuple2', _0: originalDict, _1: _elm_lang$core$Dict$empty});
	});
var _user$project$UpdateUtils$mergeList = function (submerger) {
	var aux = F7(
		function (i, _p43, originals, modified1, modifs1, modified2, modifs2) {
			aux:
			while (true) {
				var _p44 = _p43;
				var _p89 = _p44._0;
				var _p88 = _p44._1;
				var _p45 = {ctor: '_Tuple3', _0: originals, _1: modifs1, _2: modifs2};
				if (_p45._1.ctor === '[]') {
					if (_p45._2.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$List$reverse(_p89),
							_1: _elm_lang$core$List$reverse(_p88)
						};
					} else {
						return {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(_p89),
								modified2),
							_1: A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(_p88),
								modifs2)
						};
					}
				} else {
					if (_p45._2.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(_p89),
								modified1),
							_1: A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(_p88),
								modifs1)
						};
					} else {
						if (_p45._0.ctor === '[]') {
							var _p55 = _p45._2._0._1;
							var _p54 = _p45._1._0._1;
							var _p53 = _p45._2._0._0;
							var _p52 = _p45._1._0._0;
							if ((!_elm_lang$core$Native_Utils.eq(_p52, i)) || (!_elm_lang$core$Native_Utils.eq(_p53, i))) {
								return _elm_lang$core$Native_Utils.crash(
									'UpdateUtils',
									{
										start: {line: 2009, column: 14},
										end: {line: 2009, column: 25}
									})(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Expected terminal modifications to only occur at the end of the list, got ',
										_elm_lang$core$Basics$toString(
											{ctor: '_Tuple3', _0: i, _1: _p52, _2: _p53})));
							} else {
								var _p46 = {ctor: '_Tuple2', _0: _p54, _1: _p55};
								if (((_p46.ctor === '_Tuple2') && (_p46._0.ctor === 'ListElemInsert')) && (_p46._1.ctor === 'ListElemInsert')) {
									var _p50 = _p46._1._0;
									var _p49 = _p46._0._0;
									var _p47 = A2(_user$project$Utils$split, _p49, modified1);
									var hdModified1 = _p47._0;
									var tlModified1 = _p47._1;
									var _p48 = A2(_user$project$Utils$split, _p50, modified2);
									var hdModified2 = _p48._0;
									var tlModified2 = _p48._1;
									var _v22 = i,
										_v23 = {
										ctor: '_Tuple2',
										_0: A2(
											_user$project$Utils$reverseInsert,
											hdModified2,
											A2(_user$project$Utils$reverseInsert, hdModified1, _p89)),
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: i,
												_1: _user$project$Lang$ListElemInsert(_p49 + _p50)
											},
											_1: _p88
										}
									},
										_v24 = originals,
										_v25 = tlModified1,
										_v26 = _p45._1._1,
										_v27 = tlModified2,
										_v28 = _p45._2._1;
									i = _v22;
									_p43 = _v23;
									originals = _v24;
									modified1 = _v25;
									modifs1 = _v26;
									modified2 = _v27;
									modifs2 = _v28;
									continue aux;
								} else {
									return _elm_lang$core$Native_Utils.crashCase(
										'UpdateUtils',
										{
											start: {line: 2011, column: 14},
											end: {line: 2016, column: 111}
										},
										_p46)(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected two insertions at the end of the list, got ',
											_elm_lang$core$Basics$toString(
												{ctor: '_Tuple2', _0: _p54, _1: _p55})));
								}
							}
						} else {
							var _p87 = _p45._2._1;
							var _p86 = _p45._1._1;
							var _p85 = _p45._0._1;
							var _p84 = _p45._2._0._1;
							var _p83 = _p45._1._0._1;
							var _p82 = _p45._2._0._0;
							var _p81 = _p45._1._0._0;
							if (_elm_lang$core$Native_Utils.eq(_p81, i) && _elm_lang$core$Native_Utils.eq(_p82, i)) {
								var _p56 = {ctor: '_Tuple2', _0: _p83, _1: _p84};
								_v29_3:
								do {
									switch (_p56._0.ctor) {
										case 'ListElemInsert':
											if (_p56._1.ctor === 'ListElemInsert') {
												var _p63 = _p56._1._0;
												var _p62 = _p56._0._0;
												var _p60 = A2(_user$project$Utils$split, _p62, modified1);
												var hdModified1 = _p60._0;
												var tlModified1 = _p60._1;
												var _p61 = A2(_user$project$Utils$split, _p63, modified2);
												var hdModified2 = _p61._0;
												var tlModified2 = _p61._1;
												var _v30 = i,
													_v31 = {
													ctor: '_Tuple2',
													_0: A2(
														_user$project$Utils$reverseInsert,
														hdModified2,
														A2(_user$project$Utils$reverseInsert, hdModified1, _p89)),
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: i,
															_1: _user$project$Lang$ListElemInsert(_p62 + _p63)
														},
														_1: _p88
													}
												},
													_v32 = originals,
													_v33 = tlModified1,
													_v34 = _p86,
													_v35 = tlModified2,
													_v36 = _p87;
												i = _v30;
												_p43 = _v31;
												originals = _v32;
												modified1 = _v33;
												modifs1 = _v34;
												modified2 = _v35;
												modifs2 = _v36;
												continue aux;
											} else {
												var _p67 = A2(_user$project$Utils$split, _p56._0._0, modified1);
												var inserted = _p67._0;
												var modified1Tail = _p67._1;
												var _v37 = i,
													_v38 = {
													ctor: '_Tuple2',
													_0: A2(_user$project$Utils$reverseInsert, inserted, _p89),
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: i, _1: _p83},
														_1: _p88
													}
												},
													_v39 = originals,
													_v40 = modified1Tail,
													_v41 = _p86,
													_v42 = modified2,
													_v43 = modifs2;
												i = _v37;
												_p43 = _v38;
												originals = _v39;
												modified1 = _v40;
												modifs1 = _v41;
												modified2 = _v42;
												modifs2 = _v43;
												continue aux;
											}
										case 'ListElemUpdate':
											switch (_p56._1.ctor) {
												case 'ListElemUpdate':
													var _p57 = {ctor: '_Tuple2', _0: modified1, _1: modified2};
													if (((_p57.ctor === '_Tuple2') && (_p57._0.ctor === '::')) && (_p57._1.ctor === '::')) {
														var _p58 = A5(submerger, _p45._0._0, _p57._0._0, _p56._0._0, _p57._1._0, _p56._1._0);
														var newHd = _p58._0;
														var newDiffs = _p58._1;
														var _v45 = i + 1,
															_v46 = {
															ctor: '_Tuple2',
															_0: {ctor: '::', _0: newHd, _1: _p89},
															_1: {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemUpdate(newDiffs)
																},
																_1: _p88
															}
														},
															_v47 = _p85,
															_v48 = _p57._0._1,
															_v49 = _p86,
															_v50 = _p57._1._1,
															_v51 = _p87;
														i = _v45;
														_p43 = _v46;
														originals = _v47;
														modified1 = _v48;
														modifs1 = _v49;
														modified2 = _v50;
														modifs2 = _v51;
														continue aux;
													} else {
														return _elm_lang$core$Native_Utils.crashCase(
															'UpdateUtils',
															{
																start: {line: 2021, column: 19},
																end: {line: 2025, column: 96}
															},
															_p57)('Expected non-empty modifications since they were updates');
													}
												case 'ListElemInsert':
													break _v29_3;
												default:
													var _p68 = _p56._1._0;
													if (_elm_lang$core$Native_Utils.eq(_p68, 1)) {
														var originalsTail = A2(_elm_lang$core$List$drop, 1, originals);
														var _v52 = i + 1,
															_v53 = {
															ctor: '_Tuple2',
															_0: _p89,
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: i, _1: _p84},
																_1: _p88
															}
														},
															_v54 = originalsTail,
															_v55 = A2(_elm_lang$core$List$drop, 1, modified1),
															_v56 = _p86,
															_v57 = modified2,
															_v58 = _p87;
														i = _v52;
														_p43 = _v53;
														originals = _v54;
														modified1 = _v55;
														modifs1 = _v56;
														modified2 = _v57;
														modifs2 = _v58;
														continue aux;
													} else {
														if (_elm_lang$core$Native_Utils.eq(_p68, 0)) {
															return _elm_lang$core$Native_Utils.crash(
																'UpdateUtils',
																{
																	start: {line: 2049, column: 44},
																	end: {line: 2049, column: 55}
																})('Unexpected 0 here');
														} else {
															var _v59 = i,
																_v60 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
																_v61 = originals,
																_v62 = modified1,
																_v63 = modifs1,
																_v64 = modified2,
																_v65 = {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemDelete(1)
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(1)
																	},
																	_1: _p87
																}
															};
															i = _v59;
															_p43 = _v60;
															originals = _v61;
															modified1 = _v62;
															modifs1 = _v63;
															modified2 = _v64;
															modifs2 = _v65;
															continue aux;
														}
													}
											}
										default:
											switch (_p56._1.ctor) {
												case 'ListElemDelete':
													var _p65 = _p56._1._0;
													var _p64 = _p56._0._0;
													if (_elm_lang$core$Native_Utils.eq(_p64, _p65)) {
														var _v66 = i,
															_v67 = {
															ctor: '_Tuple2',
															_0: _p89,
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: i, _1: _p83},
																_1: _p88
															}
														},
															_v68 = originals,
															_v69 = modified1,
															_v70 = _p86,
															_v71 = modified2,
															_v72 = _p87;
														i = _v66;
														_p43 = _v67;
														originals = _v68;
														modified1 = _v69;
														modifs1 = _v70;
														modified2 = _v71;
														modifs2 = _v72;
														continue aux;
													} else {
														if (_elm_lang$core$Native_Utils.cmp(_p64, _p65) < 0) {
															var _v73 = i,
																_v74 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
																_v75 = originals,
																_v76 = modified1,
																_v77 = modifs1,
																_v78 = modified2,
																_v79 = {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemDelete(_p64)
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i + _p64,
																		_1: _user$project$Lang$ListElemDelete(_p65 - _p64)
																	},
																	_1: _p87
																}
															};
															i = _v73;
															_p43 = _v74;
															originals = _v75;
															modified1 = _v76;
															modifs1 = _v77;
															modified2 = _v78;
															modifs2 = _v79;
															continue aux;
														} else {
															var _v80 = i,
																_v81 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
																_v82 = originals,
																_v83 = modified1,
																_v84 = {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemDelete(_p65)
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i + _p65,
																		_1: _user$project$Lang$ListElemDelete(_p64 - _p65)
																	},
																	_1: _p86
																}
															},
																_v85 = modified2,
																_v86 = modifs2;
															i = _v80;
															_p43 = _v81;
															originals = _v82;
															modified1 = _v83;
															modifs1 = _v84;
															modified2 = _v85;
															modifs2 = _v86;
															continue aux;
														}
													}
												case 'ListElemInsert':
													break _v29_3;
												default:
													var _p69 = _p56._0._0;
													if (_elm_lang$core$Native_Utils.eq(_p69, 1)) {
														var originalsTail = A2(_elm_lang$core$List$drop, 1, originals);
														var _v87 = i + 1,
															_v88 = {
															ctor: '_Tuple2',
															_0: _p89,
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: i, _1: _p83},
																_1: _p88
															}
														},
															_v89 = originalsTail,
															_v90 = modified1,
															_v91 = _p86,
															_v92 = A2(_elm_lang$core$List$drop, 1, modified2),
															_v93 = _p87;
														i = _v87;
														_p43 = _v88;
														originals = _v89;
														modified1 = _v90;
														modifs1 = _v91;
														modified2 = _v92;
														modifs2 = _v93;
														continue aux;
													} else {
														if (_elm_lang$core$Native_Utils.eq(_p69, 0)) {
															return _elm_lang$core$Native_Utils.crash(
																'UpdateUtils',
																{
																	start: {line: 2056, column: 44},
																	end: {line: 2056, column: 55}
																})('Unexpected 0 here');
														} else {
															var _v94 = i,
																_v95 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
																_v96 = originals,
																_v97 = modified1,
																_v98 = {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemDelete(1)
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(1)
																	},
																	_1: _p86
																}
															},
																_v99 = modified2,
																_v100 = modifs2;
															i = _v94;
															_p43 = _v95;
															originals = _v96;
															modified1 = _v97;
															modifs1 = _v98;
															modified2 = _v99;
															modifs2 = _v100;
															continue aux;
														}
													}
											}
									}
								} while(false);
								var _p66 = A2(_user$project$Utils$split, _p56._1._0, modified2);
								var inserted = _p66._0;
								var modified2Tail = _p66._1;
								var _v101 = i,
									_v102 = {
									ctor: '_Tuple2',
									_0: A2(_user$project$Utils$reverseInsert, inserted, _p89),
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: i, _1: _p84},
										_1: _p88
									}
								},
									_v103 = originals,
									_v104 = modified1,
									_v105 = modifs2,
									_v106 = modified2Tail,
									_v107 = _p87;
								i = _v101;
								_p43 = _v102;
								originals = _v103;
								modified1 = _v104;
								modifs1 = _v105;
								modified2 = _v106;
								modifs2 = _v107;
								continue aux;
							} else {
								if (_elm_lang$core$Native_Utils.eq(_p82, i)) {
									var _p70 = _p84;
									switch (_p70.ctor) {
										case 'ListElemInsert':
											var _p71 = A2(_user$project$Utils$split, _p70._0, modified2);
											var inserted = _p71._0;
											var modified2Tail = _p71._1;
											var _v109 = i,
												_v110 = {
												ctor: '_Tuple2',
												_0: A2(_user$project$Utils$reverseInsert, inserted, _p89),
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: i, _1: _p84},
													_1: _p88
												}
											},
												_v111 = originals,
												_v112 = modified1,
												_v113 = modifs2,
												_v114 = modified2Tail,
												_v115 = _p87;
											i = _v109;
											_p43 = _v110;
											originals = _v111;
											modified1 = _v112;
											modifs1 = _v113;
											modified2 = _v114;
											modifs2 = _v115;
											continue aux;
										case 'ListElemDelete':
											var _p72 = _p70._0;
											var maxCount = _p81 - _p82;
											if (_elm_lang$core$Native_Utils.cmp(_p72, maxCount) < 1) {
												var originalsTail = A2(_elm_lang$core$List$drop, _p72, originals);
												var _v116 = i + _p72,
													_v117 = {
													ctor: '_Tuple2',
													_0: _p89,
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: i, _1: _p84},
														_1: _p88
													}
												},
													_v118 = originalsTail,
													_v119 = modified1,
													_v120 = modifs1,
													_v121 = modified2,
													_v122 = _p87;
												i = _v116;
												_p43 = _v117;
												originals = _v118;
												modified1 = _v119;
												modifs1 = _v120;
												modified2 = _v121;
												modifs2 = _v122;
												continue aux;
											} else {
												var _v123 = i,
													_v124 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
													_v125 = originals,
													_v126 = modified1,
													_v127 = modifs1,
													_v128 = modified2,
													_v129 = {
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: i,
														_1: _user$project$Lang$ListElemDelete(maxCount)
													},
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: i + maxCount,
															_1: _user$project$Lang$ListElemDelete(_p72 - maxCount)
														},
														_1: _p87
													}
												};
												i = _v123;
												_p43 = _v124;
												originals = _v125;
												modified1 = _v126;
												modifs1 = _v127;
												modified2 = _v128;
												modifs2 = _v129;
												continue aux;
											}
										default:
											var _p73 = modified2;
											if (_p73.ctor === '::') {
												var _v131 = i + 1,
													_v132 = {
													ctor: '_Tuple2',
													_0: {ctor: '::', _0: _p73._0, _1: _p89},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: i, _1: _p84},
														_1: _p88
													}
												},
													_v133 = _p85,
													_v134 = A2(_elm_lang$core$List$drop, 1, modified1),
													_v135 = modifs1,
													_v136 = _p73._1,
													_v137 = _p87;
												i = _v131;
												_p43 = _v132;
												originals = _v133;
												modified1 = _v134;
												modifs1 = _v135;
												modified2 = _v136;
												modifs2 = _v137;
												continue aux;
											} else {
												return _elm_lang$core$Native_Utils.crashCase(
													'UpdateUtils',
													{
														start: {line: 2073, column: 19},
														end: {line: 2076, column: 86}
													},
													_p73)('empty modified although it said it was updated');
											}
									}
								} else {
									if (_elm_lang$core$Native_Utils.eq(_p81, i)) {
										var _p75 = _p83;
										switch (_p75.ctor) {
											case 'ListElemInsert':
												var _p76 = A2(_user$project$Utils$split, _p75._0, modified1);
												var inserted = _p76._0;
												var modified1Tail = _p76._1;
												var _v139 = i,
													_v140 = {
													ctor: '_Tuple2',
													_0: A2(_user$project$Utils$reverseInsert, inserted, _p89),
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: i, _1: _p83},
														_1: _p88
													}
												},
													_v141 = originals,
													_v142 = modified1Tail,
													_v143 = _p86,
													_v144 = modified2,
													_v145 = modifs2;
												i = _v139;
												_p43 = _v140;
												originals = _v141;
												modified1 = _v142;
												modifs1 = _v143;
												modified2 = _v144;
												modifs2 = _v145;
												continue aux;
											case 'ListElemDelete':
												var _p77 = _p75._0;
												var maxCount = _p82 - _p81;
												if (_elm_lang$core$Native_Utils.cmp(_p77, maxCount) < 1) {
													var originalsTail = A2(_elm_lang$core$List$drop, _p77, originals);
													var _v146 = i + _p77,
														_v147 = {
														ctor: '_Tuple2',
														_0: _p89,
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: i, _1: _p83},
															_1: _p88
														}
													},
														_v148 = originalsTail,
														_v149 = modified1,
														_v150 = _p86,
														_v151 = modified2,
														_v152 = modifs2;
													i = _v146;
													_p43 = _v147;
													originals = _v148;
													modified1 = _v149;
													modifs1 = _v150;
													modified2 = _v151;
													modifs2 = _v152;
													continue aux;
												} else {
													var _v153 = i,
														_v154 = {ctor: '_Tuple2', _0: _p89, _1: _p88},
														_v155 = originals,
														_v156 = modified1,
														_v157 = {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: i,
															_1: _user$project$Lang$ListElemDelete(maxCount)
														},
														_1: {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: i + maxCount,
																_1: _user$project$Lang$ListElemDelete(_p77 - maxCount)
															},
															_1: _p86
														}
													},
														_v158 = modified2,
														_v159 = modifs2;
													i = _v153;
													_p43 = _v154;
													originals = _v155;
													modified1 = _v156;
													modifs1 = _v157;
													modified2 = _v158;
													modifs2 = _v159;
													continue aux;
												}
											default:
												var _p78 = modified1;
												if (_p78.ctor === '::') {
													var _v161 = i + 1,
														_v162 = {
														ctor: '_Tuple2',
														_0: {ctor: '::', _0: _p78._0, _1: _p89},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: i, _1: _p83},
															_1: _p88
														}
													},
														_v163 = _p85,
														_v164 = _p78._1,
														_v165 = _p86,
														_v166 = A2(_elm_lang$core$List$drop, 1, modified2),
														_v167 = modifs2;
													i = _v161;
													_p43 = _v162;
													originals = _v163;
													modified1 = _v164;
													modifs1 = _v165;
													modified2 = _v166;
													modifs2 = _v167;
													continue aux;
												} else {
													return _elm_lang$core$Native_Utils.crashCase(
														'UpdateUtils',
														{
															start: {line: 2090, column: 18},
															end: {line: 2093, column: 85}
														},
														_p78)('empty modified although it said it was updated');
												}
										}
									} else {
										var untouched = A2(_elm_lang$core$Basics$min, _p82 - i, _p81 - i);
										var _p80 = A2(_user$project$Utils$split, untouched, originals);
										var originalUntouched = _p80._0;
										var originalRemaining = _p80._1;
										var _v168 = i + untouched,
											_v169 = {
											ctor: '_Tuple2',
											_0: A2(_user$project$Utils$reverseInsert, originalUntouched, _p89),
											_1: _p88
										},
											_v170 = originalRemaining,
											_v171 = A2(_elm_lang$core$List$drop, untouched, modified1),
											_v172 = modifs1,
											_v173 = A2(_elm_lang$core$List$drop, untouched, modified2),
											_v174 = modifs2;
										i = _v168;
										_p43 = _v169;
										originals = _v170;
										modified1 = _v171;
										modifs1 = _v172;
										modified2 = _v173;
										modifs2 = _v174;
										continue aux;
									}
								}
							}
						}
					}
				}
			}
		});
	return A2(
		aux,
		0,
		{
			ctor: '_Tuple2',
			_0: {ctor: '[]'},
			_1: {ctor: '[]'}
		});
};
var _user$project$UpdateUtils$mergeListDiffs = F3(
	function (submerger, l1_, l2_) {
		var aux = F4(
			function (i, revAcc, l1, l2) {
				aux:
				while (true) {
					var _p90 = {ctor: '_Tuple2', _0: l1, _1: l2};
					if (_p90._0.ctor === '[]') {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$List$reverse(revAcc),
							l2);
					} else {
						if (_p90._1.ctor === '[]') {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(revAcc),
								l1);
						} else {
							var _p100 = _p90._1._1;
							var _p99 = _p90._0._1;
							var _p98 = _p90._1._0._1;
							var _p97 = _p90._0._0._1;
							var _p96 = _p90._1._0._0;
							var _p95 = _p90._0._0._0;
							if ((_elm_lang$core$Native_Utils.cmp(_p95, i) > 0) && (_elm_lang$core$Native_Utils.cmp(_p96, i) > 0)) {
								var _v176 = A2(_elm_lang$core$Basics$min, _p95, _p96),
									_v177 = revAcc,
									_v178 = l1,
									_v179 = l2;
								i = _v176;
								revAcc = _v177;
								l1 = _v178;
								l2 = _v179;
								continue aux;
							} else {
								if (_elm_lang$core$Native_Utils.eq(_p95, i) && _elm_lang$core$Native_Utils.eq(_p96, i)) {
									var _p91 = {ctor: '_Tuple2', _0: _p97, _1: _p98};
									_v180_2:
									do {
										if (_p91.ctor === '_Tuple2') {
											switch (_p91._0.ctor) {
												case 'ListElemUpdate':
													if (_p91._1.ctor === 'ListElemUpdate') {
														var _v181 = _p95 + 1,
															_v182 = {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: i,
																_1: _user$project$Lang$ListElemUpdate(
																	A2(submerger, _p91._0._0, _p91._1._0))
															},
															_1: revAcc
														},
															_v183 = _p99,
															_v184 = _p100;
														i = _v181;
														revAcc = _v182;
														l1 = _v183;
														l2 = _v184;
														continue aux;
													} else {
														break _v180_2;
													}
												case 'ListElemDelete':
													if (_p91._1.ctor === 'ListElemDelete') {
														var _p93 = _p91._1._0;
														var _p92 = _p91._0._0;
														if (_elm_lang$core$Native_Utils.eq(_p92, _p93)) {
															var _v185 = i + _p92,
																_v186 = {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: _user$project$Lang$ListElemDelete(
																		A2(_elm_lang$core$Basics$min, _p92, _p93))
																},
																_1: revAcc
															},
																_v187 = _p99,
																_v188 = _p100;
															i = _v185;
															revAcc = _v186;
															l1 = _v187;
															l2 = _v188;
															continue aux;
														} else {
															if (_elm_lang$core$Native_Utils.cmp(_p92, _p93) < 0) {
																var _v189 = i + _p92,
																	_v190 = {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(
																			A2(_elm_lang$core$Basics$min, _p92, _p93))
																	},
																	_1: revAcc
																},
																	_v191 = _p99,
																	_v192 = {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(_p93 - _p92)
																	},
																	_1: _p100
																};
																i = _v189;
																revAcc = _v190;
																l1 = _v191;
																l2 = _v192;
																continue aux;
															} else {
																var _v193 = i + _p92,
																	_v194 = {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(
																			A2(_elm_lang$core$Basics$min, _p92, _p93))
																	},
																	_1: revAcc
																},
																	_v195 = {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i,
																		_1: _user$project$Lang$ListElemDelete(_p92 - _p93)
																	},
																	_1: _p99
																},
																	_v196 = _p100;
																i = _v193;
																revAcc = _v194;
																l1 = _v195;
																l2 = _v196;
																continue aux;
															}
														}
													} else {
														break _v180_2;
													}
												default:
													break _v180_2;
											}
										} else {
											break _v180_2;
										}
									} while(false);
									return _elm_lang$core$Native_Utils.crashCase(
										'UpdateUtils',
										{
											start: {line: 1871, column: 13},
											end: {line: 1881, column: 112}
										},
										_p91)(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Inconsistent modifications to merge: ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(_p97),
												A2(
													_elm_lang$core$Basics_ops['++'],
													', ',
													_elm_lang$core$Basics$toString(_p98)))));
								} else {
									if (_elm_lang$core$Native_Utils.eq(_p95, i)) {
										var _v197 = _p95 + 1,
											_v198 = {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: _p95, _1: _p97},
											_1: revAcc
										},
											_v199 = _p99,
											_v200 = l2;
										i = _v197;
										revAcc = _v198;
										l1 = _v199;
										l2 = _v200;
										continue aux;
									} else {
										if (_elm_lang$core$Native_Utils.eq(_p96, i)) {
											var _v201 = _p96 + 1,
												_v202 = {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: _p96, _1: _p98},
												_1: revAcc
											},
												_v203 = l1,
												_v204 = _p100;
											i = _v201;
											revAcc = _v202;
											l1 = _v203;
											l2 = _v204;
											continue aux;
										} else {
											return _elm_lang$core$Native_Utils.crash(
												'UpdateUtils',
												{
													start: {line: 1887, column: 13},
													end: {line: 1887, column: 24}
												})(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Malformed list diffs:',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Basics$toString(l1_),
														A2(
															_elm_lang$core$Basics_ops['++'],
															', ',
															_elm_lang$core$Basics$toString(l2_)))));
										}
									}
								}
							}
						}
					}
				}
			});
		return A4(
			aux,
			0,
			{ctor: '[]'},
			l1_,
			l2_);
	});
var _user$project$UpdateUtils$mergeTupleDiffs = F3(
	function (submerger, l1_, l2_) {
		var aux = F4(
			function (i, revAcc, l1, l2) {
				aux:
				while (true) {
					var _p101 = {ctor: '_Tuple2', _0: l1, _1: l2};
					if (_p101._0.ctor === '[]') {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$List$reverse(revAcc),
							l2);
					} else {
						if (_p101._1.ctor === '[]') {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$List$reverse(revAcc),
								l1);
						} else {
							var _p107 = _p101._1._1;
							var _p106 = _p101._0._1;
							var _p105 = _p101._1._0._1;
							var _p104 = _p101._0._0._1;
							var _p103 = _p101._1._0._0;
							var _p102 = _p101._0._0._0;
							if ((_elm_lang$core$Native_Utils.cmp(_p102, i) > 0) && (_elm_lang$core$Native_Utils.cmp(_p103, i) > 0)) {
								var _v206 = A2(_elm_lang$core$Basics$min, _p102, _p103),
									_v207 = revAcc,
									_v208 = l1,
									_v209 = l2;
								i = _v206;
								revAcc = _v207;
								l1 = _v208;
								l2 = _v209;
								continue aux;
							} else {
								if (_elm_lang$core$Native_Utils.eq(_p102, i) && _elm_lang$core$Native_Utils.eq(_p103, i)) {
									var _v210 = _p102 + 1,
										_v211 = {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: i,
											_1: A2(submerger, _p104, _p105)
										},
										_1: revAcc
									},
										_v212 = _p106,
										_v213 = _p107;
									i = _v210;
									revAcc = _v211;
									l1 = _v212;
									l2 = _v213;
									continue aux;
								} else {
									if (_elm_lang$core$Native_Utils.eq(_p102, i)) {
										var _v214 = _p102 + 1,
											_v215 = {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: _p102, _1: _p104},
											_1: revAcc
										},
											_v216 = _p106,
											_v217 = l2;
										i = _v214;
										revAcc = _v215;
										l1 = _v216;
										l2 = _v217;
										continue aux;
									} else {
										if (_elm_lang$core$Native_Utils.eq(_p103, i)) {
											var _v218 = _p103 + 1,
												_v219 = {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: _p103, _1: _p105},
												_1: revAcc
											},
												_v220 = l1,
												_v221 = _p107;
											i = _v218;
											revAcc = _v219;
											l1 = _v220;
											l2 = _v221;
											continue aux;
										} else {
											return _elm_lang$core$Native_Utils.crash(
												'UpdateUtils',
												{
													start: {line: 1858, column: 11},
													end: {line: 1858, column: 22}
												})(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Malformed tuple diffs:',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Basics$toString(l1_),
														A2(
															_elm_lang$core$Basics_ops['++'],
															', ',
															_elm_lang$core$Basics$toString(l2_)))));
										}
									}
								}
							}
						}
					}
				}
			});
		return A4(
			aux,
			0,
			{ctor: '[]'},
			l1_,
			l2_);
	});
var _user$project$UpdateUtils$mergeInfo = F4(
	function (merger, w1, w2, w3) {
		return A2(
			_user$project$Info$replaceInfo,
			w1,
			A3(merger, w1.val, w2.val, w3.val));
	});
var _user$project$UpdateUtils$mergeWS = F3(
	function (o, e1, e2) {
		return _elm_lang$core$Native_Utils.eq(o.val, e1.val) ? e2 : e1;
	});
var _user$project$UpdateUtils$patsEqual = F3(
	function (pats1, pats2, pats3) {
		return A2(
			_elm_lang$core$List$all,
			_elm_lang$core$Basics$identity,
			A4(
				_elm_lang$core$List$map3,
				F3(
					function (p0, p1, p2) {
						return A2(_user$project$LangUtils$patEqual, p0, p1) && A2(_user$project$LangUtils$patEqual, p1, p2);
					}),
				pats1,
				pats2,
				pats3));
	});
var _user$project$UpdateUtils$defaultMerge = F5(
	function (original, modified1, modifs1, modified2, modifs2) {
		return A2(_user$project$LangUtils$valEqual, original, modified2) ? {ctor: '_Tuple2', _0: modified1, _1: modifs1} : {ctor: '_Tuple2', _0: modified2, _1: modifs2};
	});
var _user$project$UpdateUtils$mergeInt = F3(
	function (original, modified1, modified2) {
		return _elm_lang$core$Native_Utils.eq(original, modified1) ? modified2 : modified1;
	});
var _user$project$UpdateUtils$mergeTuple = function (submerger) {
	var aux = F8(
		function (i, accTuple, accDiffs, origTuple, newTup2, modifs2, newTup3, modifs3) {
			aux:
			while (true) {
				var _p108 = {ctor: '_Tuple5', _0: origTuple, _1: modifs2, _2: newTup2, _3: modifs3, _4: newTup3};
				_v222_4:
				do {
					if (_p108.ctor === '_Tuple5') {
						if (_p108._1.ctor === '[]') {
							if ((((_p108._3.ctor === '[]') && (_p108._0.ctor === '[]')) && (_p108._2.ctor === '[]')) && (_p108._4.ctor === '[]')) {
								return {
									ctor: '_Tuple2',
									_0: _elm_lang$core$List$reverse(accTuple),
									_1: _elm_lang$core$List$reverse(accDiffs)
								};
							} else {
								return {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$List$reverse(accTuple),
										newTup3),
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$List$reverse(accDiffs),
										modifs3)
								};
							}
						} else {
							if (_p108._3.ctor === '[]') {
								return {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$List$reverse(accTuple),
										newTup2),
									_1: A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$List$reverse(accDiffs),
										modifs2)
								};
							} else {
								if (((((_p108._0.ctor === '::') && (_p108._1._0.ctor === '_Tuple2')) && (_p108._2.ctor === '::')) && (_p108._3._0.ctor === '_Tuple2')) && (_p108._4.ctor === '::')) {
									var _p121 = _p108._4._0;
									var _p120 = _p108._2._0;
									var _p119 = _p108._0._1;
									var _p118 = _p108._4._1;
									var _p117 = _p108._2._1;
									var _p116 = _p108._3._0._1;
									var _p115 = _p108._1._0._1;
									var _p114 = _p108._3._1;
									var _p113 = _p108._3._0._0;
									var _p112 = _p108._1._1;
									var _p111 = _p108._1._0._0;
									if (_elm_lang$core$Native_Utils.eq(_p111, i) && _elm_lang$core$Native_Utils.eq(_p113, i)) {
										var _p109 = A5(submerger, _p108._0._0, _p120, _p115, _p121, _p116);
										var newVal = _p109._0;
										var newDiffs = _p109._1;
										var _v223 = i + 1,
											_v224 = {ctor: '::', _0: newVal, _1: accTuple},
											_v225 = {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: i, _1: newDiffs},
											_1: accDiffs
										},
											_v226 = _p119,
											_v227 = _p117,
											_v228 = _p112,
											_v229 = _p118,
											_v230 = _p114;
										i = _v223;
										accTuple = _v224;
										accDiffs = _v225;
										origTuple = _v226;
										newTup2 = _v227;
										modifs2 = _v228;
										newTup3 = _v229;
										modifs3 = _v230;
										continue aux;
									} else {
										if (_elm_lang$core$Native_Utils.eq(_p111, i)) {
											var _v231 = i + 1,
												_v232 = {ctor: '::', _0: _p120, _1: accTuple},
												_v233 = {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: i, _1: _p115},
												_1: accDiffs
											},
												_v234 = _p119,
												_v235 = _p117,
												_v236 = _p112,
												_v237 = _p118,
												_v238 = modifs3;
											i = _v231;
											accTuple = _v232;
											accDiffs = _v233;
											origTuple = _v234;
											newTup2 = _v235;
											modifs2 = _v236;
											newTup3 = _v237;
											modifs3 = _v238;
											continue aux;
										} else {
											if (_elm_lang$core$Native_Utils.eq(_p113, i)) {
												var _v239 = i + 1,
													_v240 = {ctor: '::', _0: _p121, _1: accTuple},
													_v241 = {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: i, _1: _p116},
													_1: accDiffs
												},
													_v242 = _p119,
													_v243 = _p117,
													_v244 = modifs2,
													_v245 = _p118,
													_v246 = _p114;
												i = _v239;
												accTuple = _v240;
												accDiffs = _v241;
												origTuple = _v242;
												newTup2 = _v243;
												modifs2 = _v244;
												newTup3 = _v245;
												modifs3 = _v246;
												continue aux;
											} else {
												var countToIgnore = A2(_elm_lang$core$Basics$min, _p113 - i, _p111 - i);
												var _p110 = A2(_user$project$Utils$split, countToIgnore, origTuple);
												var toInsert = _p110._0;
												var toRemain = _p110._1;
												var _v247 = i + countToIgnore,
													_v248 = A2(_user$project$Utils$reverseInsert, toInsert, accTuple),
													_v249 = accDiffs,
													_v250 = A2(_elm_lang$core$List$drop, countToIgnore, origTuple),
													_v251 = A2(_elm_lang$core$List$drop, countToIgnore, newTup2),
													_v252 = modifs2,
													_v253 = A2(_elm_lang$core$List$drop, countToIgnore, newTup3),
													_v254 = modifs3;
												i = _v247;
												accTuple = _v248;
												accDiffs = _v249;
												origTuple = _v250;
												newTup2 = _v251;
												modifs2 = _v252;
												newTup3 = _v253;
												modifs3 = _v254;
												continue aux;
											}
										}
									}
								} else {
									break _v222_4;
								}
							}
						}
					} else {
						break _v222_4;
					}
				} while(false);
				return _elm_lang$core$Native_Utils.crashCase(
					'UpdateUtils',
					{
						start: {line: 1698, column: 8},
						end: {line: 1716, column: 98}
					},
					_p108)(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected tuples to have the same size, got\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(origTuple),
							A2(
								_elm_lang$core$Basics_ops['++'],
								', ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(newTup2),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_elm_lang$core$Basics$toString(newTup3)))))));
			}
		});
	return A3(
		aux,
		0,
		{ctor: '[]'},
		{ctor: '[]'});
};
var _user$project$UpdateUtils$autoMergeTuple = F4(
	function (submerger, original, modified1, modified2) {
		return A4(_elm_lang$core$List$map3, submerger, original, modified1, modified2);
	});
var _user$project$UpdateUtils$defaultRecordDiffs = F4(
	function (keyOf, defaultElemModif, elems1, elems2) {
		return A2(
			_user$project$Results$map,
			function (d) {
				return _elm_lang$core$Dict$isEmpty(d) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
					_user$project$Lang$VRecordDiffs(d));
			},
			A6(
				_elm_lang$core$Dict$merge,
				F3(
					function (k1, v1, acc) {
						return _elm_lang$core$Result$Err(
							A2(_elm_lang$core$Basics_ops['++'], 'Not allowed to remove a key from record:', k1));
					}),
				F4(
					function (k, v1, v2, acc) {
						return _elm_lang$core$Native_Utils.eq(
							keyOf(v1),
							keyOf(v2)) ? acc : A2(
							_user$project$Results$andThen,
							function (acc) {
								return A2(
									_user$project$Results$map,
									function (mbv) {
										return A2(
											_elm_lang$core$Maybe$withDefault,
											acc,
											A2(
												_elm_lang$core$Maybe$map,
												function (v) {
													return A3(_elm_lang$core$Dict$insert, k, v, acc);
												},
												mbv));
									},
									A2(defaultElemModif, v1, v2));
							},
							acc);
					}),
				F3(
					function (k2, v2, acc) {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Not allowed to insert a key to record:',
								A2(
									_elm_lang$core$Basics_ops['++'],
									k2,
									A2(
										_elm_lang$core$Basics_ops['++'],
										' ',
										_user$project$LangUtils$valToString(v2)))));
					}),
				elems1,
				elems2,
				_user$project$Results$ok1(_elm_lang$core$Dict$empty)));
	});
var _user$project$UpdateUtils$defaultDictDiffs = F4(
	function (keyOf, defaultElemModif, elems1, elems2) {
		return A2(
			_user$project$Results$map,
			function (d) {
				return _elm_lang$core$Dict$isEmpty(d) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
					_user$project$Lang$VDictDiffs(d));
			},
			A6(
				_elm_lang$core$Dict$merge,
				F3(
					function (k1, v1, acc) {
						return A2(
							_user$project$Results$map,
							A2(_elm_lang$core$Dict$insert, k1, _user$project$Lang$VDictElemDelete),
							acc);
					}),
				F4(
					function (k, v1, v2, acc) {
						return _elm_lang$core$Native_Utils.eq(
							keyOf(v1),
							keyOf(v2)) ? acc : A2(
							_user$project$Results$andThen,
							function (acc) {
								return A2(
									_user$project$Results$map,
									function (mbv) {
										return A2(
											_elm_lang$core$Maybe$withDefault,
											acc,
											A2(
												_elm_lang$core$Maybe$map,
												function (v) {
													return A3(
														_elm_lang$core$Dict$insert,
														k,
														_user$project$Lang$VDictElemUpdate(v),
														acc);
												},
												mbv));
									},
									A2(defaultElemModif, v1, v2));
							},
							acc);
					}),
				F3(
					function (k2, v2, acc) {
						return A2(
							_user$project$Results$map,
							A2(_elm_lang$core$Dict$insert, k2, _user$project$Lang$VDictElemInsert),
							acc);
					}),
				elems1,
				elems2,
				_user$project$Results$ok1(_elm_lang$core$Dict$empty)));
	});
var _user$project$UpdateUtils$defaultTupleDiffs = F4(
	function (keyOf, defaultElemModif, elems1, elems2) {
		var aux = F4(
			function (i, revEnvDiffs, l1, l2) {
				aux:
				while (true) {
					var _p123 = {ctor: '_Tuple2', _0: l1, _1: l2};
					_v255_2:
					do {
						if (_p123.ctor === '_Tuple2') {
							if (_p123._0.ctor === '[]') {
								if (_p123._1.ctor === '[]') {
									var _p124 = _elm_lang$core$List$reverse(revEnvDiffs);
									if (_p124.ctor === '[]') {
										return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
									} else {
										return _user$project$Results$ok1(
											_elm_lang$core$Maybe$Just(_p124));
									}
								} else {
									break _v255_2;
								}
							} else {
								if (_p123._1.ctor === '::') {
									var _p129 = _p123._1._0;
									var _p128 = _p123._0._0;
									var _p127 = _p123._1._1;
									var _p126 = _p123._0._1;
									if (_elm_lang$core$Native_Utils.eq(
										keyOf(_p128),
										keyOf(_p129))) {
										var _v257 = i + 1,
											_v258 = revEnvDiffs,
											_v259 = _p126,
											_v260 = _p127;
										i = _v257;
										revEnvDiffs = _v258;
										l1 = _v259;
										l2 = _v260;
										continue aux;
									} else {
										return A2(
											_user$project$Results$andThen,
											A4(
												F5(
													function (i, etl1, etl2, revEnvDiffs, mbv) {
														var newRevEnvDiffs = function () {
															var _p125 = mbv;
															if (_p125.ctor === 'Nothing') {
																return revEnvDiffs;
															} else {
																return {
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: i, _1: _p125._0},
																	_1: revEnvDiffs
																};
															}
														}();
														return A4(aux, i + 1, newRevEnvDiffs, etl1, etl2);
													}),
												i,
												_p126,
												_p127,
												revEnvDiffs),
											A2(defaultElemModif, _p128, _p129));
									}
								} else {
									break _v255_2;
								}
							}
						} else {
							break _v255_2;
						}
					} while(false);
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Tuples do not have the same size: ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(l1),
								A2(
									_elm_lang$core$Basics_ops['++'],
									', ',
									_elm_lang$core$Basics$toString(l2)))));
				}
			});
		return A4(
			aux,
			0,
			{ctor: '[]'},
			elems1,
			elems2);
	});
var _user$project$UpdateUtils$tupleDiffsToDiffs = function (t) {
	var _p130 = t;
	if (_p130.ctor === '[]') {
		return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
	} else {
		return _user$project$Results$ok1(
			_elm_lang$core$Maybe$Just(_p130));
	}
};
var _user$project$UpdateUtils$combineTupleDiffs = function (l) {
	var aux = F2(
		function (revAcc, l) {
			aux:
			while (true) {
				var _p131 = l;
				if (_p131.ctor === '[]') {
					var _p132 = _elm_lang$core$List$reverse(revAcc);
					if (_p132.ctor === '[]') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Just(_p132);
					}
				} else {
					if (_p131._0._1.ctor === 'Nothing') {
						var _v265 = revAcc,
							_v266 = _p131._1;
						revAcc = _v265;
						l = _v266;
						continue aux;
					} else {
						var _v267 = {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p131._0._0, _1: _p131._0._1._0},
							_1: revAcc
						},
							_v268 = _p131._1;
						revAcc = _v267;
						l = _v268;
						continue aux;
					}
				}
			}
		});
	return A2(
		aux,
		{ctor: '[]'},
		l);
};
var _user$project$UpdateUtils$combineEChildDiffs = function (l) {
	return A2(
		_elm_lang$core$Maybe$map,
		_user$project$Lang$EChildDiffs,
		_user$project$UpdateUtils$combineTupleDiffs(l));
};
var _user$project$UpdateUtils$modifiedIndices = _elm_lang$core$List$map(_elm_lang$core$Tuple$first);
var _user$project$UpdateUtils$eDiffModifiedIndex = F2(
	function (i, ediffs) {
		eDiffModifiedIndex:
		while (true) {
			var _p133 = ediffs;
			if (((_p133.ctor === 'EChildDiffs') && (_p133._0.ctor === '::')) && (_p133._0._0.ctor === '_Tuple2')) {
				var _p134 = _p133._0._0._0;
				if (_elm_lang$core$Native_Utils.cmp(_p134, i) < 0) {
					var _v270 = i,
						_v271 = _user$project$Lang$EChildDiffs(_p133._0._1);
					i = _v270;
					ediffs = _v271;
					continue eDiffModifiedIndex;
				} else {
					return _elm_lang$core$Native_Utils.eq(i, _p134);
				}
			} else {
				return false;
			}
		}
	});
var _user$project$UpdateUtils$toTupleDiffs = function (l) {
	var _p135 = l;
	if (_p135.ctor === '[]') {
		return _elm_lang$core$Maybe$Just(
			{ctor: '[]'});
	} else {
		if ((_p135._0.ctor === '_Tuple2') && (_p135._0._1.ctor === 'ListElemUpdate')) {
			return A2(
				_elm_lang$core$Maybe$map,
				function (td) {
					return {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: _p135._0._0, _1: _p135._0._1._0},
						_1: td
					};
				},
				_user$project$UpdateUtils$toTupleDiffs(_p135._1));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	}
};
var _user$project$UpdateUtils$zipDiffs = F2(
	function (l, diffs) {
		var aux = F4(
			function (i, l, diffs, revAcc) {
				aux:
				while (true) {
					var _p136 = l;
					if (_p136.ctor === '[]') {
						return _elm_lang$core$List$reverse(revAcc);
					} else {
						var _p137 = function () {
							var _p138 = diffs;
							if (_p138.ctor === '[]') {
								return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: diffs};
							} else {
								var _p139 = _p138._0._0;
								return (_elm_lang$core$Native_Utils.cmp(i, _p139) < 0) ? {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: diffs} : (_elm_lang$core$Native_Utils.eq(i, _p139) ? {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Maybe$Just(_p138._0._1),
									_1: _p138._1
								} : A2(
									_elm_lang$core$Native_Utils.crash(
										'UpdateUtils',
										{
											start: {line: 1347, column: 21},
											end: {line: 1347, column: 32}
										}),
									'Malformed diffs',
									{ctor: '_Tuple2', _0: diffs, _1: i}));
							}
						}();
						var thisDiff = _p137._0;
						var tailDiffs = _p137._1;
						var _v275 = i + 1,
							_v276 = _p136._1,
							_v277 = tailDiffs,
							_v278 = {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p136._0, _1: thisDiff},
							_1: revAcc
						};
						i = _v275;
						l = _v276;
						diffs = _v277;
						revAcc = _v278;
						continue aux;
					}
				}
			});
		return A4(
			aux,
			0,
			l,
			diffs,
			{ctor: '[]'});
	});
var _user$project$UpdateUtils$mapDiffs = F2(
	function (f, _p140) {
		var _p141 = _p140;
		var aux = F4(
			function (i, l, diffs, _p142) {
				aux:
				while (true) {
					var _p143 = _p142;
					var _p151 = _p143._0;
					var _p150 = _p143._1;
					var _p144 = l;
					if (_p144.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: _elm_lang$core$List$reverse(_p151),
							_1: _elm_lang$core$List$reverse(_p150)
						};
					} else {
						var _p145 = function () {
							var _p146 = diffs;
							if (_p146.ctor === '[]') {
								return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: diffs};
							} else {
								var _p147 = _p146._0._0;
								return (_elm_lang$core$Native_Utils.cmp(i, _p147) < 0) ? {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: diffs} : (_elm_lang$core$Native_Utils.eq(i, _p147) ? {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Maybe$Just(_p146._0._1),
									_1: _p146._1
								} : A2(
									_elm_lang$core$Native_Utils.crash(
										'UpdateUtils',
										{
											start: {line: 1329, column: 21},
											end: {line: 1329, column: 32}
										}),
									'Malformed diffs',
									{ctor: '_Tuple2', _0: diffs, _1: i}));
							}
						}();
						var thisDiff = _p145._0;
						var tailDiffs = _p145._1;
						var _p148 = A2(f, _p144._0, thisDiff);
						var newA = _p148._0;
						var newDiff = _p148._1;
						var _v283 = i + 1,
							_v284 = _p144._1,
							_v285 = tailDiffs,
							_v286 = {
							ctor: '_Tuple2',
							_0: {ctor: '::', _0: newA, _1: _p151},
							_1: A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$Maybe$withDefault,
									{ctor: '[]'},
									A2(
										_elm_lang$core$Maybe$map,
										function (_p149) {
											return _elm_lang$core$List$singleton(
												A2(
													F2(
														function (v0, v1) {
															return {ctor: '_Tuple2', _0: v0, _1: v1};
														}),
													i,
													_p149));
										},
										newDiff)),
								_p150)
						};
						i = _v283;
						l = _v284;
						diffs = _v285;
						_p142 = _v286;
						continue aux;
					}
				}
			});
		return A4(
			aux,
			0,
			_p141._0,
			_p141._1,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateUtils$diffsAt = F2(
	function (n, td) {
		diffsAt:
		while (true) {
			var _p152 = td;
			if (_p152.ctor === '[]') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				var _p153 = _p152._0._0;
				if (_elm_lang$core$Native_Utils.eq(_p153, n)) {
					return _elm_lang$core$Maybe$Just(_p152._0._1);
				} else {
					if (_elm_lang$core$Native_Utils.cmp(_p153, n) > 0) {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						var _v288 = n,
							_v289 = _p152._1;
						n = _v288;
						td = _v289;
						continue diffsAt;
					}
				}
			}
		}
	});
var _user$project$UpdateUtils$changeAt = F2(
	function (path, mbd) {
		changeAt:
		while (true) {
			var _p154 = path;
			if (_p154.ctor === '[]') {
				return mbd;
			} else {
				var _p155 = mbd;
				if (_p155.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					if (_p155._0.ctor === 'EChildDiffs') {
						var _v292 = _p154._1,
							_v293 = A2(_user$project$UpdateUtils$diffsAt, _p154._0, _p155._0._0);
						path = _v292;
						mbd = _v293;
						continue changeAt;
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				}
			}
		}
	});
var _user$project$UpdateUtils$replace = F3(
	function (n, a, td) {
		var _p156 = td;
		if (_p156.ctor === '[]') {
			return td;
		} else {
			var _p158 = _p156._1;
			var _p157 = _p156._0._0;
			return _elm_lang$core$Native_Utils.eq(_p157, n) ? {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: _p157, _1: a},
				_1: _p158
			} : ((_elm_lang$core$Native_Utils.cmp(_p157, n) > 0) ? {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: n, _1: a},
				_1: td
			} : {
				ctor: '::',
				_0: _p156._0,
				_1: A3(_user$project$UpdateUtils$replace, n, a, _p158)
			});
		}
	});
var _user$project$UpdateUtils$wrap = F2(
	function (i, mbd) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (d) {
				return _user$project$Lang$EChildDiffs(
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: i, _1: d},
						_1: {ctor: '[]'}
					});
			},
			mbd);
	});
var _user$project$UpdateUtils$offset = F2(
	function (n, diffs) {
		return A2(
			_elm_lang$core$List$map,
			function (_p159) {
				var _p160 = _p159;
				return {ctor: '_Tuple2', _0: _p160._0 + n, _1: _p160._1};
			},
			diffs);
	});
var _user$project$UpdateUtils$shift = F2(
	function (i, mbd) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (d) {
				var _p161 = d;
				if (_p161.ctor === 'EChildDiffs') {
					return _user$project$Lang$EChildDiffs(
						A2(_user$project$UpdateUtils$offset, i, _p161._0));
				} else {
					return _p161;
				}
			},
			mbd);
	});
var _user$project$UpdateUtils$dropDiffs = F2(
	function (n, td) {
		dropDiffs:
		while (true) {
			var _p162 = td;
			if (_p162.ctor === '[]') {
				return {ctor: '[]'};
			} else {
				if (_elm_lang$core$Native_Utils.cmp(_p162._0._0, n) < 0) {
					var _v298 = n,
						_v299 = _p162._1;
					n = _v298;
					td = _v299;
					continue dropDiffs;
				} else {
					return A2(_user$project$UpdateUtils$offset, 0 - n, td);
				}
			}
		}
	});
var _user$project$UpdateUtils$combineAppChanges = F2(
	function (newE1Changes, newE2Changes) {
		var e1Changes = A2(
			_elm_lang$core$Maybe$withDefault,
			{ctor: '[]'},
			A2(
				_elm_lang$core$Maybe$map,
				function (x) {
					return {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 0, _1: x},
						_1: {ctor: '[]'}
					};
				},
				newE1Changes));
		var e2Changes = A2(
			_elm_lang$core$Maybe$withDefault,
			{ctor: '[]'},
			A2(
				_elm_lang$core$Maybe$map,
				_user$project$UpdateUtils$offset(1),
				newE2Changes));
		var _p163 = A2(_elm_lang$core$Basics_ops['++'], e1Changes, e2Changes);
		if (_p163.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Just(
				_user$project$Lang$EChildDiffs(_p163));
		}
	});
var _user$project$UpdateUtils$composeStringDiffs = F2(
	function (oldStringDiffs, newStringDiffs) {
		var aux = F6(
			function (offsetStart, offsetEnd, offsetReplaced, oldStringDiffs, newStringDiffs, revStrDiffs) {
				aux:
				while (true) {
					var makeOldReplacement = function (newStrDiff) {
						var _p164 = newStrDiff;
						return A3(_user$project$Lang$StringUpdate, _p164._0 - offsetStart, _p164._1 - offsetEnd, _p164._2);
					};
					var _p165 = {ctor: '_Tuple2', _0: oldStringDiffs, _1: newStringDiffs};
					if (_p165._0.ctor === '[]') {
						if (_p165._1.ctor === '[]') {
							return _elm_lang$core$List$reverse(revStrDiffs);
						} else {
							var _v303 = offsetEnd,
								_v304 = offsetEnd,
								_v305 = 0,
								_v306 = {ctor: '[]'},
								_v307 = _p165._1._1,
								_v308 = {
								ctor: '::',
								_0: makeOldReplacement(_p165._1._0),
								_1: revStrDiffs
							};
							offsetStart = _v303;
							offsetEnd = _v304;
							offsetReplaced = _v305;
							oldStringDiffs = _v306;
							newStringDiffs = _v307;
							revStrDiffs = _v308;
							continue aux;
						}
					} else {
						if (_p165._1.ctor === '[]') {
							var _v309 = offsetEnd,
								_v310 = offsetEnd,
								_v311 = 0,
								_v312 = _p165._0._1,
								_v313 = {ctor: '[]'},
								_v314 = {
								ctor: '::',
								_0: A3(_user$project$Lang$StringUpdate, _p165._0._0._0, _p165._0._0._1, _p165._0._0._2 + offsetReplaced),
								_1: revStrDiffs
							};
							offsetStart = _v309;
							offsetEnd = _v310;
							offsetReplaced = _v311;
							oldStringDiffs = _v312;
							newStringDiffs = _v313;
							revStrDiffs = _v314;
							continue aux;
						} else {
							var _p173 = _p165._0._0._0;
							var _p172 = _p165._0._0._2;
							var _p171 = _p165._1._0._0;
							var _p170 = _p165._1._0._1;
							var _p169 = _p165._1._0._2;
							var _p168 = _p165._0._1;
							var _p167 = _p165._1._1;
							var _p166 = _p165._0._0._1;
							var newEnd = (offsetEnd + _p173) + _p172;
							var newStart = offsetEnd + _p173;
							if (_elm_lang$core$Native_Utils.cmp(newStart, _p170) > -1) {
								var _v315 = offsetEnd,
									_v316 = offsetEnd,
									_v317 = 0,
									_v318 = oldStringDiffs,
									_v319 = _p167,
									_v320 = {
									ctor: '::',
									_0: makeOldReplacement(_p165._1._0),
									_1: revStrDiffs
								};
								offsetStart = _v315;
								offsetEnd = _v316;
								offsetReplaced = _v317;
								oldStringDiffs = _v318;
								newStringDiffs = _v319;
								revStrDiffs = _v320;
								continue aux;
							} else {
								if (_elm_lang$core$Native_Utils.cmp(newEnd, _p171) < 1) {
									var newOffsetEnd = (offsetEnd + _p172) - (_p166 - _p173);
									var _v321 = newOffsetEnd,
										_v322 = newOffsetEnd,
										_v323 = 0,
										_v324 = _p168,
										_v325 = newStringDiffs,
										_v326 = {
										ctor: '::',
										_0: A3(_user$project$Lang$StringUpdate, _p173, _p166, _p172 + offsetReplaced),
										_1: revStrDiffs
									};
									offsetStart = _v321;
									offsetEnd = _v322;
									offsetReplaced = _v323;
									oldStringDiffs = _v324;
									newStringDiffs = _v325;
									revStrDiffs = _v326;
									continue aux;
								} else {
									if ((_elm_lang$core$Native_Utils.cmp(newStart, _p171) < 1) && (_elm_lang$core$Native_Utils.cmp(_p170, newEnd) < 1)) {
										var _v327 = offsetStart,
											_v328 = offsetEnd,
											_v329 = (offsetReplaced + _p169) - (_p170 - _p171),
											_v330 = {
											ctor: '::',
											_0: A3(_user$project$Lang$StringUpdate, _p173, _p166, _p172),
											_1: _p168
										},
											_v331 = _p167,
											_v332 = revStrDiffs;
										offsetStart = _v327;
										offsetEnd = _v328;
										offsetReplaced = _v329;
										oldStringDiffs = _v330;
										newStringDiffs = _v331;
										revStrDiffs = _v332;
										continue aux;
									} else {
										if (_elm_lang$core$Native_Utils.cmp(newStart, _p171) > 0) {
											if (_elm_lang$core$Native_Utils.cmp(newEnd, _p170) < 0) {
												var offsetIncrease = _p172 - (_p166 - _p173);
												var newOffsetEnd = offsetEnd + offsetIncrease;
												var _v333 = offsetStart,
													_v334 = newOffsetEnd,
													_v335 = 0,
													_v336 = _p168,
													_v337 = newStringDiffs,
													_v338 = revStrDiffs;
												offsetStart = _v333;
												offsetEnd = _v334;
												offsetReplaced = _v335;
												oldStringDiffs = _v336;
												newStringDiffs = _v337;
												revStrDiffs = _v338;
												continue aux;
											} else {
												var deltaReplaced = _p169 - (_p170 - _p171);
												var _v339 = offsetStart,
													_v340 = offsetEnd,
													_v341 = deltaReplaced,
													_v342 = {
													ctor: '::',
													_0: A3(_user$project$Lang$StringUpdate, _p171 - offsetStart, _p166, (_p172 + newStart) - _p171),
													_1: _p168
												},
													_v343 = _p167,
													_v344 = revStrDiffs;
												offsetStart = _v339;
												offsetEnd = _v340;
												offsetReplaced = _v341;
												oldStringDiffs = _v342;
												newStringDiffs = _v343;
												revStrDiffs = _v344;
												continue aux;
											}
										} else {
											var offsetIncrease = _p172 - (_p166 - _p173);
											var newOffsetEnd = offsetEnd + offsetIncrease;
											var _v345 = offsetStart,
												_v346 = newOffsetEnd,
												_v347 = 0,
												_v348 = _p168,
												_v349 = {
												ctor: '::',
												_0: A3(_user$project$Lang$StringUpdate, newStart, _p170, (_p169 + _p171) - newStart),
												_1: _p167
											},
												_v350 = revStrDiffs;
											offsetStart = _v345;
											offsetEnd = _v346;
											offsetReplaced = _v347;
											oldStringDiffs = _v348;
											newStringDiffs = _v349;
											revStrDiffs = _v350;
											continue aux;
										}
									}
								}
							}
						}
					}
				}
			});
		return A6(
			aux,
			0,
			0,
			0,
			oldStringDiffs,
			newStringDiffs,
			{ctor: '[]'});
	});
var _user$project$UpdateUtils$applyConcreteDiffs = F2(
	function (string, diffs) {
		var aux = F2(
			function (l, _p174) {
				aux:
				while (true) {
					var _p175 = _p174;
					var _p181 = _p175._0;
					var _p180 = _p175._1;
					var _p176 = l;
					if (_p176.ctor === '[]') {
						return {ctor: '_Tuple2', _0: _p181, _1: _p180};
					} else {
						var _p179 = _p176._0._2;
						var _p178 = _p176._0._0;
						var _p177 = _p176._0._1;
						var _v353 = _p176._1,
							_v354 = {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_elm_lang$core$String$left, _p178, _p181),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p179,
									A2(_elm_lang$core$String$dropLeft, _p177, _p181))),
							_1: {
								ctor: '::',
								_0: A3(
									_user$project$Lang$StringUpdate,
									_p178,
									_p177,
									_elm_lang$core$String$length(_p179)),
								_1: _p180
							}
						};
						l = _v353;
						_p174 = _v354;
						continue aux;
					}
				}
			});
		return A2(
			aux,
			_elm_lang$core$List$reverse(diffs),
			{
				ctor: '_Tuple2',
				_0: string,
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateUtils$pruneConcreteDiffs = function (l) {
	var aux = function (l) {
		aux:
		while (true) {
			var _p182 = l;
			if ((((_p182.ctor === '::') && (_p182._0.ctor === '_Tuple3')) && (_p182._1.ctor === '::')) && (_p182._1._0.ctor === '_Tuple3')) {
				var _p183 = _p182._0._1;
				if (_elm_lang$core$Native_Utils.cmp(_p183, _p182._1._0._0) < 1) {
					return {
						ctor: '::',
						_0: {ctor: '_Tuple3', _0: _p182._0._0, _1: _p183, _2: _p182._0._2},
						_1: aux(_p182._1)
					};
				} else {
					var _v356 = {ctor: '::', _0: _p182._0, _1: _p182._1._1};
					l = _v356;
					continue aux;
				}
			} else {
				return l;
			}
		}
	};
	return aux(
		A2(
			_elm_lang$core$List$sortBy,
			function (_p184) {
				var _p185 = _p184;
				return _p185._0;
			},
			l));
};
var _user$project$UpdateUtils$strDiffToConcreteDiff = F2(
	function (newString, d) {
		var aux = F3(
			function (offset, d, revAcc) {
				aux:
				while (true) {
					var _p186 = d;
					if (_p186.ctor === '[]') {
						return _elm_lang$core$List$reverse(revAcc);
					} else {
						var _p189 = _p186._0._0;
						var _p188 = _p186._0._2;
						var _p187 = _p186._0._1;
						var _v359 = (offset + _p188) - (_p187 - _p189),
							_v360 = _p186._1,
							_v361 = {
							ctor: '::',
							_0: {
								ctor: '_Tuple3',
								_0: _p189,
								_1: _p187,
								_2: A3(_elm_lang$core$String$slice, _p189 + offset, (_p189 + _p188) + offset, newString)
							},
							_1: revAcc
						};
						offset = _v359;
						d = _v360;
						revAcc = _v361;
						continue aux;
					}
				}
			});
		return A3(
			aux,
			0,
			d,
			{ctor: '[]'});
	});
var _user$project$UpdateUtils$flattenFirstEChildDiffs = F2(
	function (realElementNumber, ediffs) {
		var _p190 = ediffs;
		if (_p190.ctor === 'EChildDiffs') {
			if ((((_p190._0.ctor === '::') && (_p190._0._0.ctor === '_Tuple2')) && (_p190._0._0._0 === 0)) && (_p190._0._0._1.ctor === 'EChildDiffs')) {
				return _user$project$Lang$EChildDiffs(
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p190._0._0._1._0,
						A2(_user$project$UpdateUtils$offset, realElementNumber, _p190._0._1)));
			} else {
				return _user$project$Lang$EChildDiffs(
					A2(_user$project$UpdateUtils$offset, realElementNumber, _p190._0));
			}
		} else {
			return ediffs;
		}
	});
var _user$project$UpdateUtils$offsetConcStr = F2(
	function (n, diffs) {
		return A2(
			_elm_lang$core$List$map,
			function (_p191) {
				var _p192 = _p191;
				return {ctor: '_Tuple3', _0: _p192._0 + n, _1: _p192._1 + n, _2: _p192._2};
			},
			diffs);
	});
var _user$project$UpdateUtils$displayPos = function (p) {
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'L',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$Basics$toString(p.line),
			' '));
};
var _user$project$UpdateUtils$offsetPosition = F2(
	function (_p193, p) {
		var _p194 = _p193;
		var _p197 = _p194._0;
		var _p196 = _p194._1._0;
		var _p195 = _p194._1._1;
		return ((_elm_lang$core$Native_Utils.cmp(p.line, _p197.line) < 0) || (_elm_lang$core$Native_Utils.eq(p.line, _p197.line) && (_elm_lang$core$Native_Utils.cmp(p.col, _p197.col) < 0))) ? p : ((_elm_lang$core$Native_Utils.eq(p.line, _p197.line) && (_elm_lang$core$Native_Utils.cmp(p.col, _p197.col) > -1)) ? A2(
			_user$project$Pos$Pos,
			p.line + _p196,
			_elm_lang$core$Native_Utils.eq(_p196, 0) ? (p.col + _p195) : ((p.col - _p197.col) + _p195)) : _elm_lang$core$Native_Utils.update(
			p,
			{line: p.line + _p196}));
	});
var _user$project$UpdateUtils$collapseLastEdit = function (_p198) {
	var _p199 = _p198;
	var _p202 = _p199._1._0;
	var _p201 = _p199._0;
	var _p200 = _p199._1._1;
	return (!_elm_lang$core$Native_Utils.eq(_p202, 0)) ? A2(_user$project$Pos$Pos, _p201.line + _p202, _p200) : A2(_user$project$Pos$Pos, _p201.line, _p201.col + _p200);
};
var _user$project$UpdateUtils$dictDiffsToString = F5(
	function (indent, subroutine, originals, modified, diffs) {
		return A3(
			_elm_lang$core$Dict$foldl,
			F3(
				function (k, diffb, accStr) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						accStr,
						A5(
							subroutine,
							indent,
							k,
							A2(_elm_lang$core$Dict$get, k, originals),
							A2(_elm_lang$core$Dict$get, k, modified),
							diffb));
				}),
			'',
			diffs);
	});
var _user$project$UpdateUtils$listDiffsToString = F8(
	function (structName, subroutine, displayElemModif, elementDisplay, indent, originals, modifieds, diffs) {
		if (_elm_lang$core$List$isEmpty(diffs)) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'[Internal error: Empty ',
				A2(_elm_lang$core$Basics_ops['++'], structName, ' diff]'));
		} else {
			var aux = F5(
				function (i, original, modifieds, diffs, acc) {
					aux:
					while (true) {
						var _p203 = diffs;
						if (_p203.ctor === '[]') {
							return acc;
						} else {
							var _p210 = _p203._0._0;
							var _p209 = _p203._1;
							if (_elm_lang$core$Native_Utils.cmp(_p210, i) > 0) {
								var _v367 = _p210,
									_v368 = A2(_elm_lang$core$List$drop, _p210 - i, original),
									_v369 = A2(_elm_lang$core$List$drop, _p210 - i, modifieds),
									_v370 = diffs,
									_v371 = acc;
								i = _v367;
								original = _v368;
								modifieds = _v369;
								diffs = _v370;
								acc = _v371;
								continue aux;
							} else {
								var _p204 = _p203._0._1;
								switch (_p204.ctor) {
									case 'ListElemDelete':
										var _p205 = A2(_user$project$Utils$split, _p204._0, original);
										var originalRemoved = _p205._0;
										var originalKept = _p205._1;
										var _v373 = i + 1,
											_v374 = originalKept,
											_v375 = modifieds,
											_v376 = _p209,
											_v377 = A2(
											_elm_lang$core$Basics_ops['++'],
											acc,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'\n',
												A2(
													_elm_lang$core$Basics_ops['++'],
													indent,
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Removed ',
														A2(
															_elm_lang$core$String$join,
															',',
															A2(_elm_lang$core$List$map, elementDisplay, originalRemoved))))));
										i = _v373;
										original = _v374;
										modifieds = _v375;
										diffs = _v376;
										acc = _v377;
										continue aux;
									case 'ListElemInsert':
										var _p206 = A2(_user$project$Utils$split, _p204._0, modifieds);
										var modifiedInserted = _p206._0;
										var modifiedTail = _p206._1;
										var _v378 = i,
											_v379 = original,
											_v380 = modifiedTail,
											_v381 = _p209,
											_v382 = A2(
											_elm_lang$core$Basics_ops['++'],
											acc,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'\n',
												A2(
													_elm_lang$core$Basics_ops['++'],
													indent,
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Inserted ',
														A2(
															_elm_lang$core$String$join,
															',',
															A2(_elm_lang$core$List$map, elementDisplay, modifiedInserted))))));
										i = _v378;
										original = _v379;
										modifieds = _v380;
										diffs = _v381;
										acc = _v382;
										continue aux;
									default:
										var _p207 = {ctor: '_Tuple2', _0: original, _1: modifieds};
										if (((_p207.ctor === '_Tuple2') && (_p207._0.ctor === '::')) && (_p207._1.ctor === '::')) {
											var _p208 = A2(
												_elm_lang$core$Maybe$withDefault,
												{ctor: '_Tuple2', _0: '', _1: indent},
												A2(displayElemModif, indent, i));
											var incAcc = _p208._0;
											var newIndent = _p208._1;
											var _v384 = i + 1,
												_v385 = _p207._0._1,
												_v386 = _p207._1._1,
												_v387 = _p209,
												_v388 = A2(
												_elm_lang$core$Basics_ops['++'],
												acc,
												A2(
													_elm_lang$core$Basics_ops['++'],
													incAcc,
													A4(subroutine, newIndent, _p207._0._0, _p207._1._0, _p204._0)));
											i = _v384;
											original = _v385;
											modifieds = _v386;
											diffs = _v387;
											acc = _v388;
											continue aux;
										} else {
											return A2(
												_elm_lang$core$Basics_ops['++'],
												'[Internal error] For diff ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Basics$toString(diffs),
													A2(
														_elm_lang$core$Basics_ops['++'],
														', expected non-empty lists, got [',
														A2(
															_elm_lang$core$Basics_ops['++'],
															A2(
																_elm_lang$core$String$join,
																',',
																A2(_elm_lang$core$List$map, elementDisplay, originals)),
															A2(
																_elm_lang$core$Basics_ops['++'],
																'] and [',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	A2(
																		_elm_lang$core$String$join,
																		',',
																		A2(_elm_lang$core$List$map, elementDisplay, modifieds)),
																	']'))))));
										}
								}
							}
						}
					}
				});
			return A5(aux, 0, originals, modifieds, diffs, '');
		}
	});
var _user$project$UpdateUtils$stringDiffsToString = F4(
	function (indent, original, modified, diffs) {
		var aux = F3(
			function (acc, offset, diffs) {
				aux:
				while (true) {
					var _p211 = diffs;
					if (_p211.ctor === '[]') {
						return A2(
							_elm_lang$core$String$join,
							', ',
							_elm_lang$core$List$reverse(acc));
					} else {
						var _p214 = _p211._0._0;
						var _p213 = _p211._0._2;
						var _p212 = _p211._0._1;
						var accInc = _elm_lang$core$Native_Utils.eq(_p214, _p212) ? A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								indent,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Inserted: \'',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A3(_elm_lang$core$String$slice, _p214 + offset, (_p214 + offset) + _p213, modified),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'\'',
											A2(
												_elm_lang$core$Basics_ops['++'],
												' at pos ',
												_elm_lang$core$Basics$toString(_p214))))))) : (_elm_lang$core$Native_Utils.eq(_p213, 0) ? A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								indent,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Removed: \'',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A3(_elm_lang$core$String$slice, _p214, _p212, original),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'\'',
											A2(
												_elm_lang$core$Basics_ops['++'],
												' at pos ',
												_elm_lang$core$Basics$toString(_p214))))))) : A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								indent,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Replaced \'',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A3(_elm_lang$core$String$slice, _p214, _p212, original),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'\' by \'',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A3(_elm_lang$core$String$slice, _p214 + offset, (_p214 + offset) + _p213, modified),
												'\'')))))));
						var newOffset = (offset - (_p212 - _p214)) + _p213;
						var newAcc = {ctor: '::', _0: accInc, _1: acc};
						var _v390 = newAcc,
							_v391 = newOffset,
							_v392 = _p211._1;
						acc = _v390;
						offset = _v391;
						diffs = _v392;
						continue aux;
					}
				}
			});
		return A3(
			aux,
			{ctor: '[]'},
			0,
			diffs);
	});
var _user$project$UpdateUtils$tupleDiffsToString = F6(
	function (mbStructName, subroutine, indent, originalEnv, modifiedEnv, envDiffs) {
		var aux = F5(
			function (i, original, modified, diffs, acc) {
				aux:
				while (true) {
					var _p215 = diffs;
					if (_p215.ctor === '[]') {
						return acc;
					} else {
						var _p218 = _p215._0._0;
						if (_elm_lang$core$Native_Utils.cmp(_p218, i) > 0) {
							var _v394 = _p218,
								_v395 = A2(_elm_lang$core$List$drop, _p218 - i, original),
								_v396 = A2(_elm_lang$core$List$drop, _p218 - i, modified),
								_v397 = diffs,
								_v398 = acc;
							i = _v394;
							original = _v395;
							modified = _v396;
							diffs = _v397;
							acc = _v398;
							continue aux;
						} else {
							if (_elm_lang$core$Native_Utils.eq(_p218, i)) {
								var _p216 = {ctor: '_Tuple2', _0: original, _1: modified};
								if (((_p216.ctor === '_Tuple2') && (_p216._0.ctor === '::')) && (_p216._1.ctor === '::')) {
									var _v400 = i + 1,
										_v401 = _p216._0._1,
										_v402 = _p216._1._1,
										_v403 = _p215._1,
										_v404 = A2(
										_elm_lang$core$Basics_ops['++'],
										acc,
										A4(subroutine, indent, _p216._0._0, _p216._1._0, _p215._0._1));
									i = _v400;
									original = _v401;
									modified = _v402;
									diffs = _v403;
									acc = _v404;
									continue aux;
								} else {
									return _elm_lang$core$Native_Utils.crashCase(
										'UpdateUtils',
										{
											start: {line: 758, column: 11},
											end: {line: 762, column: 104}
										},
										_p216)(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expcted non-empty ',
											A2(_elm_lang$core$Maybe$withDefault, 'structuro', mbStructName)));
								}
							} else {
								return _elm_lang$core$Native_Utils.crash(
									'UpdateUtils',
									{
										start: {line: 764, column: 11},
										end: {line: 764, column: 22}
									})(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Changes does not match the ',
										A2(_elm_lang$core$Maybe$withDefault, 'structuro', mbStructName)));
							}
						}
					}
				}
			});
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(
				_elm_lang$core$Maybe$withDefault,
				'',
				A2(
					_elm_lang$core$Maybe$map,
					function (structName) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								indent,
								A2(_elm_lang$core$Basics_ops['++'], structName, ' = ...')));
					},
					mbStructName)),
			A5(aux, 0, originalEnv, modifiedEnv, envDiffs, ''));
	});
var _user$project$UpdateUtils$valToListElemDiff = F2(
	function (subroutine, v) {
		var _p219 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
		_v405_3:
		do {
			if (_p219.ctor === 'Ok') {
				if (((_p219._0.ctor === '_Tuple2') && (_p219._0._1.ctor === '::')) && (_p219._0._1._1.ctor === '[]')) {
					switch (_p219._0._0) {
						case 'ListElemUpdate':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$ListElemUpdate,
								subroutine(_p219._0._1._0));
						case 'ListElemInsert':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$ListElemInsert,
								_user$project$ValUnbuilder$int(_p219._0._1._0));
						case 'ListElemDelete':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$ListElemDelete,
								_user$project$ValUnbuilder$int(_p219._0._1._0));
						default:
							break _v405_3;
					}
				} else {
					break _v405_3;
				}
			} else {
				return _elm_lang$core$Result$Err(_p219._0);
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected ListElemUpdate[_], ListElemInsert[_], ListElemDelete[_], got ',
				_user$project$LangUtils$valToString(v)));
	});
var _user$project$UpdateUtils$valToStringDiffs = function (v) {
	var _p220 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
	if (((((((_p220.ctor === 'Ok') && (_p220._0.ctor === '_Tuple2')) && (_p220._0._0 === 'StringUpdate')) && (_p220._0._1.ctor === '::')) && (_p220._0._1._1.ctor === '::')) && (_p220._0._1._1._1.ctor === '::')) && (_p220._0._1._1._1._1.ctor === '[]')) {
		return A4(
			_elm_lang$core$Result$map3,
			_user$project$Lang$StringUpdate,
			_user$project$ValUnbuilder$int(_p220._0._1._0),
			_user$project$ValUnbuilder$int(_p220._0._1._1._0),
			_user$project$ValUnbuilder$int(_p220._0._1._1._1._0));
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected StringUpdate, got ',
				_user$project$LangUtils$valToString(v)));
	}
};
var _user$project$UpdateUtils$stringDiffsToVal = F2(
	function (vb, sd) {
		var _p221 = sd;
		return A3(
			_user$project$ValBuilder$constructor,
			vb,
			'StringUpdate',
			{
				ctor: '::',
				_0: A2(_user$project$ValBuilder$int, vb, _p221._0),
				_1: {
					ctor: '::',
					_0: A2(_user$project$ValBuilder$int, vb, _p221._1),
					_1: {
						ctor: '::',
						_0: A2(_user$project$ValBuilder$int, vb, _p221._2),
						_1: {ctor: '[]'}
					}
				}
			});
	});
var _user$project$UpdateUtils$listElemDiffToVal = F3(
	function (subroutine, vb, velem) {
		var _p222 = velem;
		switch (_p222.ctor) {
			case 'ListElemUpdate':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'ListElemUpdate',
					{
						ctor: '::',
						_0: A2(subroutine, vb, _p222._0),
						_1: {ctor: '[]'}
					});
			case 'ListElemInsert':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'ListElemInsert',
					{
						ctor: '::',
						_0: A2(_user$project$ValBuilder$int, vb, _p222._0),
						_1: {ctor: '[]'}
					});
			default:
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'ListElemDelete',
					{
						ctor: '::',
						_0: A2(_user$project$ValBuilder$int, vb, _p222._0),
						_1: {ctor: '[]'}
					});
		}
	});
var _user$project$UpdateUtils$valToListDiffs = F2(
	function (subroutine, l) {
		return A2(
			_user$project$ValUnbuilder$list,
			A2(
				_user$project$ValUnbuilder$tuple2,
				_user$project$ValUnbuilder$int,
				_user$project$UpdateUtils$valToListElemDiff(subroutine)),
			l);
	});
var _user$project$UpdateUtils$listDiffsToVal = function (subroutine) {
	return _user$project$ValBuilder$list(
		A2(
			_user$project$ValBuilder$tuple2,
			_user$project$ValBuilder$int,
			_user$project$UpdateUtils$listElemDiffToVal(subroutine)));
};
var _user$project$UpdateUtils$valToTupleDiffs = function (subroutine) {
	return _user$project$ValUnbuilder$list(
		A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$int, subroutine));
};
var _user$project$UpdateUtils$valToEDiffs = function (v) {
	var _p223 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
	_v409_4:
	do {
		if (_p223.ctor === 'Ok') {
			if (((_p223._0.ctor === '_Tuple2') && (_p223._0._1.ctor === '::')) && (_p223._0._1._1.ctor === '[]')) {
				switch (_p223._0._0) {
					case 'EConstDiffs':
						return A2(
							_elm_lang$core$Result$map,
							function (i) {
								return _user$project$Lang$EConstDiffs(
									_elm_lang$core$Native_Utils.eq(i, 0) ? _user$project$Lang$EOnlyWhitespaceDiffs : _user$project$Lang$EAnyDiffs);
							},
							_user$project$ValUnbuilder$int(_p223._0._1._0));
					case 'EListDiffs':
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$EListDiffs,
							A2(_user$project$UpdateUtils$valToListDiffs, _user$project$UpdateUtils$valToEDiffs, _p223._0._1._0));
					case 'EStringDiffs':
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$EStringDiffs,
							A2(_user$project$ValUnbuilder$list, _user$project$UpdateUtils$valToStringDiffs, _p223._0._1._0));
					case 'EChildDiffs':
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$EChildDiffs,
							A2(_user$project$UpdateUtils$valToTupleDiffs, _user$project$UpdateUtils$valToEDiffs, _p223._0._1._0));
					default:
						break _v409_4;
				}
			} else {
				break _v409_4;
			}
		} else {
			return _elm_lang$core$Result$Err(_p223._0);
		}
	} while(false);
	return _elm_lang$core$Result$Err(
		A2(
			_elm_lang$core$Basics_ops['++'],
			'Expected EConstDiffs, EListDiffs, EStringDiffs, EChildDiffs, got ',
			_user$project$LangUtils$valToString(v)));
};
var _user$project$UpdateUtils$valToVDiffs = function (v) {
	var _p224 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
	_v410_6:
	do {
		if (_p224.ctor === 'Ok') {
			if (_p224._0._1.ctor === '[]') {
				if (_p224._0._0 === 'VConstDiffs') {
					return _elm_lang$core$Result$Ok(_user$project$Lang$VConstDiffs);
				} else {
					break _v410_6;
				}
			} else {
				if (_p224._0._1._1.ctor === '::') {
					if ((_p224._0._0 === 'VClosureDiffs') && (_p224._0._1._1._1.ctor === '[]')) {
						return A3(
							_elm_lang$core$Result$map2,
							_user$project$Lang$VClosureDiffs,
							_user$project$UpdateUtils$valToEnvDiffs(_p224._0._1._0),
							A2(_user$project$ValUnbuilder$maybe, _user$project$UpdateUtils$valToEDiffs, _p224._0._1._1._0));
					} else {
						break _v410_6;
					}
				} else {
					switch (_p224._0._0) {
						case 'VListDiffs':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$VListDiffs,
								A2(_user$project$UpdateUtils$valToListDiffs, _user$project$UpdateUtils$valToVDiffs, _p224._0._1._0));
						case 'VStringDiffs':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$VStringDiffs,
								A2(_user$project$ValUnbuilder$list, _user$project$UpdateUtils$valToStringDiffs, _p224._0._1._0));
						case 'VDictDiffs':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$VDictDiffs,
								A2(_user$project$ValUnbuilder$dict, _user$project$UpdateUtils$valToVDictElemDiff, _p224._0._1._0));
						case 'VRecordDiffs':
							return A2(
								_elm_lang$core$Result$map,
								_user$project$Lang$VRecordDiffs,
								A2(_user$project$ValUnbuilder$record, _user$project$UpdateUtils$valToVDiffs, _p224._0._1._0));
						default:
							break _v410_6;
					}
				}
			}
		} else {
			return _elm_lang$core$Result$Err(_p224._0);
		}
	} while(false);
	return _elm_lang$core$Result$Err(
		A2(
			_elm_lang$core$Basics_ops['++'],
			'Expected VClosureDiffs _ _, VListDiffs _, VStringDiffs, VConstDiffs, VDictDiffs _, VRecordDiffs _, got ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_user$project$LangUtils$valToString(v),
				A2(
					_elm_lang$core$Basics_ops['++'],
					' (constructor = ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_p224._0._0,
						A2(
							_elm_lang$core$Basics_ops['++'],
							' with ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(
									_elm_lang$core$List$length(_p224._0._1)),
								'arguments)')))))));
};
var _user$project$UpdateUtils$valToEnvDiffs = _user$project$UpdateUtils$valToTupleDiffs(_user$project$UpdateUtils$valToVDiffs);
var _user$project$UpdateUtils$valToVDictElemDiff = function (v) {
	var _p225 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
	_v411_3:
	do {
		if (_p225.ctor === 'Ok') {
			if (_p225._0.ctor === '_Tuple2') {
				if (_p225._0._1.ctor === '[]') {
					switch (_p225._0._0) {
						case 'VDictElemDelete':
							return _elm_lang$core$Result$Ok(_user$project$Lang$VDictElemDelete);
						case 'VDictElemInsert':
							return _elm_lang$core$Result$Ok(_user$project$Lang$VDictElemInsert);
						default:
							break _v411_3;
					}
				} else {
					if ((_p225._0._0 === 'VDictElemUpdate') && (_p225._0._1._1.ctor === '[]')) {
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$VDictElemUpdate,
							_user$project$UpdateUtils$valToVDiffs(_p225._0._1._0));
					} else {
						break _v411_3;
					}
				}
			} else {
				break _v411_3;
			}
		} else {
			return _elm_lang$core$Result$Err(_p225._0);
		}
	} while(false);
	return _elm_lang$core$Result$Err(
		A2(
			_elm_lang$core$Basics_ops['++'],
			'Expected VDictElemDelete[], VDictElemInsert[], VDictElemUpdate[_], got ',
			_user$project$LangUtils$valToString(v)));
};
var _user$project$UpdateUtils$valToUpdateReturn = function (v) {
	var _p226 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
	_v412_2:
	do {
		if (_p226.ctor === 'Ok') {
			if ((_p226._0._1.ctor === '::') && (_p226._0._1._1.ctor === '[]')) {
				switch (_p226._0._0) {
					case 'Inputs':
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$Inputs,
							A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$identity, _p226._0._1._0));
					case 'InputsWithDiffs':
						return A2(
							_elm_lang$core$Result$map,
							_user$project$Lang$InputsWithDiffs,
							A2(
								_user$project$ValUnbuilder$list,
								A2(
									_user$project$ValUnbuilder$tuple2,
									_user$project$ValUnbuilder$identity,
									_user$project$ValUnbuilder$maybe(_user$project$UpdateUtils$valToVDiffs)),
								_p226._0._1._0));
					default:
						break _v412_2;
				}
			} else {
				break _v412_2;
			}
		} else {
			return _elm_lang$core$Result$Err(_p226._0);
		}
	} while(false);
	return _elm_lang$core$Result$Err(
		A2(
			_elm_lang$core$Basics_ops['++'],
			'Expected Inputs (List Val) or InputsWithDiffs (List (Val, Maybe VDiffs)), got ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_p226._0._0,
				A2(
					_elm_lang$core$Basics_ops['++'],
					' with ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(_p226._0._1)),
						' arguments')))));
};
var _user$project$UpdateUtils$tupleDiffsToVal = function (subroutine) {
	return _user$project$ValBuilder$list(
		A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$int, subroutine));
};
var _user$project$UpdateUtils$eDiffsToVal = F2(
	function (vb, ediffs) {
		var _p227 = ediffs;
		switch (_p227.ctor) {
			case 'EConstDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'EConstDiffs',
					{
						ctor: '::',
						_0: A2(
							_user$project$ValBuilder$int,
							vb,
							_elm_lang$core$Native_Utils.eq(_p227._0, _user$project$Lang$EOnlyWhitespaceDiffs) ? 0 : 1),
						_1: {ctor: '[]'}
					});
			case 'EListDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'EListDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$UpdateUtils$listDiffsToVal, _user$project$UpdateUtils$eDiffsToVal, vb, _p227._0),
						_1: {ctor: '[]'}
					});
			case 'EStringDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'EStringDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$ValBuilder$list, _user$project$UpdateUtils$stringDiffsToVal, vb, _p227._0),
						_1: {ctor: '[]'}
					});
			default:
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'EChildDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$UpdateUtils$tupleDiffsToVal, _user$project$UpdateUtils$eDiffsToVal, vb, _p227._0),
						_1: {ctor: '[]'}
					});
		}
	});
var _user$project$UpdateUtils$vDiffsToVal = F2(
	function (vb, vdiffs) {
		var _p228 = vdiffs;
		switch (_p228.ctor) {
			case 'VClosureDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VClosureDiffs',
					{
						ctor: '::',
						_0: A2(_user$project$UpdateUtils$envDiffsToVal, vb, _p228._0),
						_1: {
							ctor: '::',
							_0: A3(_user$project$ValBuilder$maybe, _user$project$UpdateUtils$eDiffsToVal, vb, _p228._1),
							_1: {ctor: '[]'}
						}
					});
			case 'VListDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VListDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$UpdateUtils$listDiffsToVal, _user$project$UpdateUtils$vDiffsToVal, vb, _p228._0),
						_1: {ctor: '[]'}
					});
			case 'VStringDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VStringDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$ValBuilder$list, _user$project$UpdateUtils$stringDiffsToVal, vb, _p228._0),
						_1: {ctor: '[]'}
					});
			case 'VConstDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VConstDiffs',
					{ctor: '[]'});
			case 'VDictDiffs':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VDictDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$ValBuilder$dict, _user$project$UpdateUtils$vDictElemDiffToVal, vb, _p228._0),
						_1: {ctor: '[]'}
					});
			default:
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VRecordDiffs',
					{
						ctor: '::',
						_0: A3(_user$project$ValBuilder$record, _user$project$UpdateUtils$vDiffsToVal, vb, _p228._0),
						_1: {ctor: '[]'}
					});
		}
	});
var _user$project$UpdateUtils$envDiffsToVal = _user$project$UpdateUtils$tupleDiffsToVal(_user$project$UpdateUtils$vDiffsToVal);
var _user$project$UpdateUtils$vDictElemDiffToVal = F2(
	function (vb, velem) {
		var _p229 = velem;
		switch (_p229.ctor) {
			case 'VDictElemDelete':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VDictElemDelete',
					{ctor: '[]'});
			case 'VDictElemInsert':
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VDictElemInsert',
					{ctor: '[]'});
			default:
				return A3(
					_user$project$ValBuilder$constructor,
					vb,
					'VDictElemUpdate',
					{
						ctor: '::',
						_0: A2(_user$project$UpdateUtils$vDiffsToVal, vb, _p229._0),
						_1: {ctor: '[]'}
					});
		}
	});
var _user$project$UpdateUtils$updateReturnToVal = F2(
	function (vb, updateReturn) {
		var _p230 = updateReturn;
		if (_p230.ctor === 'Inputs') {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Inputs',
				{
					ctor: '::',
					_0: A3(_user$project$ValBuilder$list, _user$project$ValBuilder$identity, vb, _p230._0),
					_1: {ctor: '[]'}
				});
		} else {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'InputsWithDiffs',
				{
					ctor: '::',
					_0: A3(
						_user$project$ValBuilder$list,
						A2(
							_user$project$ValBuilder$tuple2,
							_user$project$ValBuilder$identity,
							_user$project$ValBuilder$maybe(_user$project$UpdateUtils$vDiffsToVal)),
						vb,
						_p230._0),
					_1: {ctor: '[]'}
				});
		}
	});
var _user$project$UpdateUtils$extractors = {
	unapply: F4(
		function (msg, unapply, e, c) {
			return A2(
				_elm_lang$core$Result$andThen,
				c,
				A2(
					_elm_lang$core$Result$fromMaybe,
					msg,
					unapply(e)));
		}),
	unapplySeq: F4(
		function (msg, transformer, input, c) {
			return A2(
				_elm_lang$core$Result$andThen,
				c,
				A2(
					_elm_lang$core$Result$fromMaybe,
					msg,
					_user$project$Utils$projJusts(
						A2(_elm_lang$core$List$map, transformer, input))));
		})
};
var _user$project$UpdateUtils$recursiveMerge = F3(
	function (merge, original, modifications) {
		recursiveMerge:
		while (true) {
			var _p231 = modifications;
			if (_p231.ctor === '[]') {
				return {ctor: '_Tuple2', _0: original, _1: _elm_lang$core$Maybe$Nothing};
			} else {
				if (_p231._1.ctor === '[]') {
					return {
						ctor: '_Tuple2',
						_0: _p231._0._0,
						_1: _elm_lang$core$Maybe$Just(_p231._0._1)
					};
				} else {
					var _v418 = merge,
						_v419 = original,
						_v420 = {
						ctor: '::',
						_0: A5(merge, original, _p231._0._0, _p231._0._1, _p231._1._0._0, _p231._1._0._1),
						_1: _p231._1._1
					};
					merge = _v418;
					original = _v419;
					modifications = _v420;
					continue recursiveMerge;
				}
			}
		}
	});
var _user$project$UpdateUtils$defaultConflictPolicy = F2(
	function (a, b) {
		return a;
	});
var _user$project$UpdateUtils$heuristicHtmlRegex = _elm_lang$core$Regex$regex('^<(\\w+)');
var _user$project$UpdateUtils$heuristicOf = function (centralElement) {
	var lastChar = A2(_elm_lang$core$String$right, 1, centralElement);
	var firstChar = A2(_elm_lang$core$String$left, 1, centralElement);
	return A2(_elm_lang$core$Regex$contains, _user$project$UpdateUtils$heuristicHtmlRegex, centralElement) ? 15 : ((_elm_lang$core$Native_Utils.eq(lastChar, '>') || (_elm_lang$core$Native_Utils.eq(lastChar, ')') || (_elm_lang$core$Native_Utils.eq(lastChar, ']') || _elm_lang$core$Native_Utils.eq(lastChar, '}')))) ? 10 : ((_elm_lang$core$Native_Utils.eq(firstChar, '<') || (_elm_lang$core$Native_Utils.eq(firstChar, '(') || (_elm_lang$core$Native_Utils.eq(firstChar, '[') || _elm_lang$core$Native_Utils.eq(firstChar, '{')))) ? 9 : (_elm_lang$core$Native_Utils.eq(lastChar, ' ') ? 8 : (_elm_lang$core$Native_Utils.eq(firstChar, ' ') ? 7 : 0))));
};
var _user$project$UpdateUtils$priorityListToList = function (l) {
	return A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$first, l);
};
var _user$project$UpdateUtils$priorityListMapDelta = F2(
	function (d, f) {
		return _elm_lang$core$List$map(
			function (_p232) {
				var _p233 = _p232;
				return {
					ctor: '_Tuple2',
					_0: f(_p233._0),
					_1: _p233._1 + d
				};
			});
	});
var _user$project$UpdateUtils$priorityListMap = function (f) {
	return _elm_lang$core$List$map(
		function (_p234) {
			var _p235 = _p234;
			return {
				ctor: '_Tuple2',
				_0: f(_p235._0),
				_1: _p235._1
			};
		});
};
var _user$project$UpdateUtils$priorityListMerge = F2(
	function (priorityList1, priorityList2) {
		var _p236 = priorityList1;
		if (_p236.ctor === '[]') {
			return priorityList2;
		} else {
			var _p237 = priorityList2;
			if (_p237.ctor === '[]') {
				return priorityList1;
			} else {
				return (_elm_lang$core$Native_Utils.cmp(_p236._0._1, _p237._0._1) > -1) ? {
					ctor: '::',
					_0: _p236._0,
					_1: A2(_user$project$UpdateUtils$priorityListMerge, _p236._1, priorityList2)
				} : {
					ctor: '::',
					_0: _p237._0,
					_1: A2(_user$project$UpdateUtils$priorityListMerge, priorityList1, _p237._1)
				};
			}
		}
	});
var _user$project$UpdateUtils$priorityListInsert = F3(
	function (element, priority, priorityList) {
		var _p238 = priorityList;
		if (_p238.ctor === '[]') {
			return {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: element, _1: priority},
				_1: {ctor: '[]'}
			};
		} else {
			return (_elm_lang$core$Native_Utils.cmp(priority, _p238._0._1) > 0) ? {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: element, _1: priority},
				_1: priorityList
			} : {
				ctor: '::',
				_0: _p238._0,
				_1: A3(_user$project$UpdateUtils$priorityListInsert, element, priority, _p238._1)
			};
		}
	});
var _user$project$UpdateUtils$longestSufixSizeBetweenGuard = F3(
	function (maxIndex, before, after) {
		var lengthBefore = _elm_lang$core$String$length(before);
		var lengthAfter = _elm_lang$core$String$length(after);
		var aux = function (i) {
			aux:
			while (true) {
				if ((_elm_lang$core$Native_Utils.cmp(i, maxIndex) < 1) && ((_elm_lang$core$Native_Utils.cmp(i, lengthBefore) < 0) && _elm_lang$core$Native_Utils.eq(
					A3(_elm_lang$core$String$slice, (lengthBefore - 1) - i, lengthBefore - i, before),
					A3(_elm_lang$core$String$slice, (lengthAfter - 1) - i, lengthAfter - i, after)))) {
					var _v426 = i + 1;
					i = _v426;
					continue aux;
				} else {
					return i;
				}
			}
		};
		return aux(0);
	});
var _user$project$UpdateUtils$longestSufixSizeBetween = F2(
	function (before, after) {
		var lengthBefore = _elm_lang$core$String$length(before);
		var lengthAfter = _elm_lang$core$String$length(after);
		var aux = function (i) {
			aux:
			while (true) {
				if ((_elm_lang$core$Native_Utils.cmp(i, lengthBefore) < 0) && _elm_lang$core$Native_Utils.eq(
					A3(_elm_lang$core$String$slice, (lengthBefore - 1) - i, lengthBefore - i, before),
					A3(_elm_lang$core$String$slice, (lengthAfter - 1) - i, lengthAfter - i, after))) {
					var _v427 = i + 1;
					i = _v427;
					continue aux;
				} else {
					return i;
				}
			}
		};
		return aux(0);
	});
var _user$project$UpdateUtils$longestPrefixSizeBetween = F2(
	function (before, after) {
		var lengthBefore = _elm_lang$core$String$length(before);
		var aux = function (i) {
			aux:
			while (true) {
				if ((_elm_lang$core$Native_Utils.cmp(i, lengthBefore) < 0) && _elm_lang$core$Native_Utils.eq(
					A3(_elm_lang$core$String$slice, i, i + 1, before),
					A3(_elm_lang$core$String$slice, i, i + 1, after))) {
					var _v428 = i + 1;
					i = _v428;
					continue aux;
				} else {
					return i;
				}
			}
		};
		return aux(0);
	});
var _user$project$UpdateUtils$combineLengthWeight = F2(
	function (length, weight) {
		return (2 * length) + weight;
	});
var _user$project$UpdateUtils$dummyExp1 = F5(
	function (msg, row, col, row2, col2) {
		return _user$project$Lang$Expr(
			A3(
				_user$project$Info$WithInfo,
				A2(
					_user$project$Lang$makeExp_,
					A2(
						_user$project$Lang$EBase,
						_user$project$Lang$space0,
						A2(_user$project$Lang$EString, '\"', msg)),
					0),
				A2(_user$project$Pos$Pos, row - 1, col - 1),
				A2(_user$project$Pos$Pos, row2 - 1, col2 - 1)));
	});
var _user$project$UpdateUtils$dummyExp = F5(
	function (msg, row, col, row2, col2) {
		return _user$project$Lang$Expr(
			A3(
				_user$project$Info$WithInfo,
				A2(
					_user$project$Lang$makeExp_,
					A2(
						_user$project$Lang$EBase,
						_user$project$Lang$space0,
						A2(_user$project$Lang$EString, '\"', msg)),
					0),
				A2(_user$project$Pos$Pos, row, col),
				A2(_user$project$Pos$Pos, row2, col2)));
	});
var _user$project$UpdateUtils$deltaLineRow = function (kept) {
	var rowAdded = _elm_lang$core$List$length(
		A2(_elm_lang$core$String$indexes, '\n', kept));
	var colAdded = _elm_lang$core$String$length(
		A4(
			_elm_lang$core$Regex$replace,
			_elm_lang$core$Regex$All,
			_elm_lang$core$Regex$regex('(.*\r?\n)*'),
			function (_p239) {
				return '';
			},
			kept));
	return {ctor: '_Tuple2', _0: rowAdded, _1: colAdded};
};
var _user$project$UpdateUtils$displayDiffPositions = F3(
	function (tos, initialPosition, difference) {
		var lToString = function (l) {
			return A2(
				_elm_lang$core$String$join,
				'',
				A2(_elm_lang$core$List$map, tos, l));
		};
		var newStringRowCol = F3(
			function (prevRow, prevCol, l) {
				var kept = lToString(l);
				var _p240 = _user$project$UpdateUtils$deltaLineRow(kept);
				var rowAdded = _p240._0;
				var colAdded = _p240._1;
				return _elm_lang$core$Native_Utils.eq(rowAdded, 0) ? {ctor: '_Tuple3', _0: kept, _1: prevRow, _2: prevCol + colAdded} : {ctor: '_Tuple3', _0: kept, _1: prevRow + rowAdded, _2: colAdded};
			});
		var maybeComma = function (s) {
			return _elm_lang$core$Native_Utils.eq(s, '') ? s : A2(_elm_lang$core$Basics_ops['++'], s, ', \n');
		};
		var aux = F3(
			function (_p242, _p241, difference) {
				aux:
				while (true) {
					var _p243 = _p242;
					var _p253 = _p243._0;
					var _p252 = _p243._1;
					var _p244 = _p241;
					var _p251 = _p244._0;
					var _p250 = _p244._1;
					var _p245 = difference;
					if (_p245.ctor === '[]') {
						return {ctor: '_Tuple2', _0: _p251, _1: _p250};
					} else {
						switch (_p245._0.ctor) {
							case 'DiffEqual':
								var _p246 = A3(newStringRowCol, _p253, _p252, _p245._0._0);
								var sameString = _p246._0;
								var newRow = _p246._1;
								var newCol = _p246._2;
								var _v432 = {ctor: '_Tuple2', _0: newRow, _1: newCol},
									_v433 = {ctor: '_Tuple2', _0: _p251, _1: _p250},
									_v434 = _p245._1;
								_p242 = _v432;
								_p241 = _v433;
								difference = _v434;
								continue aux;
							case 'DiffRemoved':
								if ((_p245._1.ctor === '::') && (_p245._1._0.ctor === 'DiffAdded')) {
									var removed = lToString(_p245._0._0);
									var _p247 = A3(newStringRowCol, _p253, _p252, _p245._1._0._0);
									var added = _p247._0;
									var newRow = _p247._1;
									var newCol = _p247._2;
									var e = A5(_user$project$UpdateUtils$dummyExp, added, _p253, _p252, newRow, newCol);
									var _v435 = {ctor: '_Tuple2', _0: newRow, _1: newCol},
										_v436 = {
										ctor: '_Tuple2',
										_0: A2(
											_elm_lang$core$Basics_ops['++'],
											maybeComma(_p251),
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Replaced ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													removed,
													A2(_elm_lang$core$Basics_ops['++'], ' by ', added)))),
										_1: {ctor: '::', _0: e, _1: _p250}
									},
										_v437 = _p245._1._1;
									_p242 = _v435;
									_p241 = _v436;
									difference = _v437;
									continue aux;
								} else {
									var _p248 = _p245._0._0;
									var removed = lToString(_p248);
									var e = A5(
										_user$project$UpdateUtils$dummyExp,
										A2(_elm_lang$core$Basics_ops['++'], '- ', removed),
										_p253,
										_p252,
										_p253,
										_p252 + _elm_lang$core$List$length(_p248));
									var _v438 = {ctor: '_Tuple2', _0: _p253, _1: _p252},
										_v439 = {
										ctor: '_Tuple2',
										_0: A2(
											_elm_lang$core$Basics_ops['++'],
											maybeComma(_p251),
											A2(_elm_lang$core$Basics_ops['++'], 'Removed ', removed)),
										_1: {ctor: '::', _0: e, _1: _p250}
									},
										_v440 = _p245._1;
									_p242 = _v438;
									_p241 = _v439;
									difference = _v440;
									continue aux;
								}
							default:
								var _p249 = A3(newStringRowCol, _p253, _p252, _p245._0._0);
								var added = _p249._0;
								var newRow = _p249._1;
								var newCol = _p249._2;
								var e = A5(_user$project$UpdateUtils$dummyExp, added, _p253, _p252, newRow, newCol);
								var _v441 = {ctor: '_Tuple2', _0: newRow, _1: newCol},
									_v442 = {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										maybeComma(_p251),
										A2(_elm_lang$core$Basics_ops['++'], 'Inserted ', added)),
									_1: {ctor: '::', _0: e, _1: _p250}
								},
									_v443 = _p245._1;
								_p242 = _v441;
								_p241 = _v442;
								difference = _v443;
								continue aux;
						}
					}
				}
			});
		return A3(
			aux,
			{ctor: '_Tuple2', _0: initialPosition.line - 1, _1: initialPosition.col - 1},
			{
				ctor: '_Tuple2',
				_0: '',
				_1: {ctor: '[]'}
			},
			difference);
	});
var _user$project$UpdateUtils$addOffsetFromString = F2(
	function (p, s1) {
		var _p254 = _user$project$UpdateUtils$deltaLineRow(s1);
		var r1 = _p254._0;
		var c1 = _p254._1;
		return _user$project$UpdateUtils$collapseLastEdit(
			{
				ctor: '_Tuple2',
				_0: p,
				_1: {ctor: '_Tuple2', _0: r1, _1: c1}
			});
	});
var _user$project$UpdateUtils$offsetFromStrings = F4(
	function (lm, startOldReferential, s1, s2) {
		var _p255 = lm;
		var lmpos = _p255._0;
		var lmline = _p255._1._0;
		var lmcol = _p255._1._1;
		var startNewReferential = A2(_user$project$UpdateUtils$offsetPosition, lm, startOldReferential);
		var _p256 = _user$project$UpdateUtils$deltaLineRow(s1);
		var r1 = _p256._0;
		var c1 = _p256._1;
		var _p257 = _user$project$UpdateUtils$deltaLineRow(s2);
		var r2 = _p257._0;
		var c2 = _p257._1;
		var prevEndOldReferential = _user$project$UpdateUtils$collapseLastEdit(
			{
				ctor: '_Tuple2',
				_0: startOldReferential,
				_1: {ctor: '_Tuple2', _0: r1, _1: c1}
			});
		var prevEndNewReferential = _user$project$UpdateUtils$collapseLastEdit(
			{
				ctor: '_Tuple2',
				_0: startNewReferential,
				_1: {ctor: '_Tuple2', _0: r1, _1: c1}
			});
		var newEndNewReferential = _user$project$UpdateUtils$collapseLastEdit(
			{
				ctor: '_Tuple2',
				_0: startNewReferential,
				_1: {ctor: '_Tuple2', _0: r2, _1: c2}
			});
		var deltaLine = newEndNewReferential.line - prevEndOldReferential.line;
		var deltaCol = _elm_lang$core$Native_Utils.eq(deltaLine, 0) ? (newEndNewReferential.col - prevEndOldReferential.col) : newEndNewReferential.col;
		return {
			ctor: '_Tuple2',
			_0: {
				ctor: '_Tuple2',
				_0: prevEndOldReferential,
				_1: {ctor: '_Tuple2', _0: deltaLine, _1: deltaCol}
			},
			_1: newEndNewReferential
		};
	});
var _user$project$UpdateUtils$stringDiffsToString2 = F8(
	function (renderingStyle, indent, lastEdit, lastPos, quoteChar, original, modified, diffs) {
		var renderChars = function () {
			var _p258 = renderingStyle;
			switch (_p258.ctor) {
				case 'LongStringSyntax':
					return _user$project$LeoUnparser$unparseLongStringContent;
				case 'HtmlSyntax':
					return _user$project$LeoUnparser$unparseHtmlTextContent(_user$project$LeoUnparser$Interpolated);
				default:
					return _user$project$ParserUtils$unparseStringContent(quoteChar);
			}
		}();
		var initialLine = lastPos.line;
		var aux = F6(
			function (lastEdit, lastPos, lastEnd, offset, diffs, _p259) {
				aux:
				while (true) {
					var _p260 = _p259;
					var _p268 = _p260._1;
					var _p267 = _p260._0;
					var _p261 = diffs;
					if (_p261.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$String$join,
								', ',
								_elm_lang$core$List$reverse(_p267)),
							_1: {
								ctor: '_Tuple2',
								_0: {ctor: '_Tuple2', _0: lastEdit, _1: lastPos},
								_1: _elm_lang$core$List$reverse(_p268)
							}
						};
					} else {
						var _p266 = _p261._0._0;
						var _p265 = _p261._0._2;
						var _p264 = _p261._0._1;
						var betweenNormalized = renderChars(
							A3(_elm_lang$core$String$slice, lastEnd, _p266, original));
						var lastPos1 = A2(_user$project$UpdateUtils$addOffsetFromString, lastPos, betweenNormalized);
						var beforeS = renderChars(
							A3(_elm_lang$core$String$slice, _p266, _p264, original));
						var afterS = renderChars(
							A3(_elm_lang$core$String$slice, _p266 + offset, (_p266 + offset) + _p265, modified));
						var _p262 = A4(_user$project$UpdateUtils$offsetFromStrings, lastEdit, lastPos1, beforeS, afterS);
						var newLastEdit = _p262._0;
						var newEndPos = _p262._1;
						var newStartPos = A2(_user$project$UpdateUtils$offsetPosition, lastEdit, lastPos1);
						var _p263 = _elm_lang$core$Native_Utils.eq(_p266, _p264) ? {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								'\n',
								A2(
									_elm_lang$core$Basics_ops['++'],
									indent,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$UpdateUtils$displayPos(newEndPos),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Inserted [',
											A2(_elm_lang$core$Basics_ops['++'], afterS, ']'))))),
							_1: '+'
						} : (_elm_lang$core$Native_Utils.eq(_p265, 0) ? {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								'\n',
								A2(
									_elm_lang$core$Basics_ops['++'],
									indent,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$UpdateUtils$displayPos(newEndPos),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Removed [',
											A2(_elm_lang$core$Basics_ops['++'], beforeS, ']'))))),
							_1: '-'
						} : {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								'\n',
								A2(
									_elm_lang$core$Basics_ops['++'],
									indent,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$UpdateUtils$displayPos(newEndPos),
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Replaced [',
											A2(
												_elm_lang$core$Basics_ops['++'],
												beforeS,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'] by [',
													A2(_elm_lang$core$Basics_ops['++'], afterS, ']'))))))),
							_1: '~'
						});
						var accInc = _p263._0;
						var title = _p263._1;
						var newOffset = (offset - (_p264 - _p266)) + _p265;
						var newRevAcc = {ctor: '::', _0: accInc, _1: _p267};
						var endCol = (_elm_lang$core$Native_Utils.eq(newStartPos.line, newEndPos.line) && _elm_lang$core$Native_Utils.eq(newStartPos.col, newEndPos.col)) ? newEndPos.col : newEndPos.col;
						var duckTapeOffset = (_elm_lang$core$Native_Utils.eq(renderingStyle, _user$project$Lang$LongStringSyntax) && (_elm_lang$core$Native_Utils.cmp(initialLine, newStartPos.line) < 0)) ? 1 : 0;
						var insertedExp = A5(_user$project$UpdateUtils$dummyExp1, title, newStartPos.line, newStartPos.col + duckTapeOffset, newEndPos.line, endCol + duckTapeOffset);
						var _v447 = newLastEdit,
							_v448 = _elm_lang$core$Tuple$first(newLastEdit),
							_v449 = _p264,
							_v450 = newOffset,
							_v451 = _p261._1,
							_v452 = {
							ctor: '_Tuple2',
							_0: newRevAcc,
							_1: {ctor: '::', _0: insertedExp, _1: _p268}
						};
						lastEdit = _v447;
						lastPos = _v448;
						lastEnd = _v449;
						offset = _v450;
						diffs = _v451;
						_p259 = _v452;
						continue aux;
					}
				}
			});
		return A6(
			aux,
			lastEdit,
			lastPos,
			0,
			0,
			diffs,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateUtils$eDiffsToStringPositions = F6(
	function (renderingStyle, indent, lastEdit, _p270, _p269, ediff) {
		var _p271 = _p270;
		var _p283 = _p271._0;
		var _p272 = _p269;
		var _p282 = _p272._0;
		var renderExp = function () {
			var _p273 = renderingStyle;
			if (_p273.ctor === 'HtmlSyntax') {
				return _user$project$LeoUnparser$unparseAnyHtml;
			} else {
				return _user$project$Syntax$unparser(_user$project$Syntax$Leo);
			}
		}();
		var _p274 = ediff;
		switch (_p274.ctor) {
			case 'EConstDiffs':
				if (_elm_lang$core$Native_Utils.eq(_p274._0, _user$project$Lang$EOnlyWhitespaceDiffs)) {
					var newLastEdit_newEnd = A4(
						_user$project$UpdateUtils$offsetFromStrings,
						lastEdit,
						_p283.start,
						renderExp(
							_user$project$Lang$Expr(_p283)),
						renderExp(
							_user$project$Lang$Expr(_p282)));
					return {
						ctor: '_Tuple2',
						_0: '',
						_1: {
							ctor: '_Tuple2',
							_0: newLastEdit_newEnd,
							_1: {ctor: '[]'}
						}
					};
				} else {
					var prefix = A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$UpdateUtils$displayPos(_p283.start),
								': ')));
					var beforeS = renderExp(
						_user$project$Lang$Expr(_p283));
					var afterS = renderExp(
						_user$project$Lang$Expr(_p282));
					var msg = A2(
						_elm_lang$core$Basics_ops['++'],
						'Was ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							beforeS,
							A2(_elm_lang$core$Basics_ops['++'], ', now ', afterS)));
					var newStart = A2(_user$project$UpdateUtils$offsetPosition, lastEdit, _p283.start);
					var _p275 = A4(_user$project$UpdateUtils$offsetFromStrings, lastEdit, _p283.start, beforeS, afterS);
					var newLastEdit = _p275._0;
					var newEnd = _p275._1;
					var diffExp = A5(_user$project$UpdateUtils$dummyExp1, '~', newStart.line, newStart.col, newEnd.line, newEnd.col);
					return {
						ctor: '_Tuple2',
						_0: A2(_elm_lang$core$Basics_ops['++'], prefix, msg),
						_1: {
							ctor: '_Tuple2',
							_0: {ctor: '_Tuple2', _0: newLastEdit, _1: newEnd},
							_1: {
								ctor: '::',
								_0: diffExp,
								_1: {ctor: '[]'}
							}
						}
					};
				}
			case 'EListDiffs':
				var _p276 = {
					ctor: '_Tuple2',
					_0: _user$project$Lang$unwrapExp(
						_user$project$Lang$Expr(_p283)),
					_1: _user$project$Lang$unwrapExp(
						_user$project$Lang$Expr(_p282))
				};
				if (((_p276.ctor === '_Tuple2') && (_p276._0.ctor === 'EList')) && (_p276._1.ctor === 'EList')) {
					var theStart = _p283.start;
					var lastPos = function () {
						var _p277 = renderingStyle;
						if (_p277.ctor === 'HtmlSyntax') {
							return theStart;
						} else {
							return _elm_lang$core$Native_Utils.update(
								theStart,
								{col: theStart.col + 1});
						}
					}();
					return A9(_user$project$UpdateUtils$listDiffsToString2, renderingStyle, 'list', renderExp, indent, lastEdit, lastPos, _p276._0._1, _p276._1._1, _p274._0);
				} else {
					return {
						ctor: '_Tuple2',
						_0: A2(
							_elm_lang$core$Basics_ops['++'],
							'[Internal error] eDiffsToString ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(ediff),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' expects lists here, got ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										renderExp(
											_user$project$Lang$Expr(_p283)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											', ',
											renderExp(
												_user$project$Lang$Expr(_p282))))))),
						_1: {
							ctor: '_Tuple2',
							_0: {
								ctor: '_Tuple2',
								_0: lastEdit,
								_1: A2(_user$project$UpdateUtils$offsetPosition, lastEdit, _p283.end)
							},
							_1: {ctor: '[]'}
						}
					};
				}
			case 'EStringDiffs':
				var _p278 = {
					ctor: '_Tuple2',
					_0: _user$project$Lang$unwrapExp(
						_user$project$Lang$Expr(_p283)),
					_1: _user$project$Lang$unwrapExp(
						_user$project$Lang$Expr(_p282))
				};
				if (((((_p278.ctor === '_Tuple2') && (_p278._0.ctor === 'EBase')) && (_p278._0._1.ctor === 'EString')) && (_p278._1.ctor === 'EBase')) && (_p278._1._1.ctor === 'EString')) {
					var theStart = _p283.start;
					var lastPos = function () {
						var _p279 = renderingStyle;
						switch (_p279.ctor) {
							case 'LongStringSyntax':
								return theStart;
							case 'HtmlSyntax':
								return theStart;
							default:
								return _elm_lang$core$Native_Utils.update(
									theStart,
									{col: theStart.col + 1});
						}
					}();
					return A8(_user$project$UpdateUtils$stringDiffsToString2, renderingStyle, indent, lastEdit, lastPos, _p278._0._1._0, _p278._0._1._1, _p278._1._1._1, _p274._0);
				} else {
					return {
						ctor: '_Tuple2',
						_0: A2(
							_elm_lang$core$Basics_ops['++'],
							'[Internal error] eDiffsToString ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(ediff),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' expects strings here, got ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										renderExp(
											_user$project$Lang$Expr(_p283)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											', ',
											renderExp(
												_user$project$Lang$Expr(_p282))))))),
						_1: {
							ctor: '_Tuple2',
							_0: {
								ctor: '_Tuple2',
								_0: lastEdit,
								_1: A2(_user$project$UpdateUtils$offsetPosition, lastEdit, _p283.end)
							},
							_1: {ctor: '[]'}
						}
					};
				}
			default:
				var childIndent = '';
				var newRenderingStyle = function () {
					var _p280 = _user$project$Lang$unwrapExp(
						_user$project$Lang$Expr(_p283));
					if (_p280.ctor === 'EParens') {
						return _p280._2;
					} else {
						return renderingStyle;
					}
				}();
				var _p281 = A6(
					_user$project$UpdateUtils$tupleDiffsToString2,
					newRenderingStyle,
					childIndent,
					lastEdit,
					_user$project$Lang$childExps(
						_user$project$Lang$Expr(_p283)),
					_user$project$Lang$childExps(
						_user$project$Lang$Expr(_p282)),
					_p274._0);
				var msg = _p281._0;
				var newLastEdit = _p281._1._0;
				var newExps = _p281._1._1;
				var newLastPos = A2(_user$project$UpdateUtils$offsetPosition, newLastEdit, _p283.end);
				return {
					ctor: '_Tuple2',
					_0: msg,
					_1: {
						ctor: '_Tuple2',
						_0: {ctor: '_Tuple2', _0: newLastEdit, _1: newLastPos},
						_1: newExps
					}
				};
		}
	});
var _user$project$UpdateUtils$listDiffsToString2 = F9(
	function (renderingStyle, structName, elementDisplay, indent, lastEdit, lastPos, originals_, modifieds_, diffs_) {
		if (_elm_lang$core$List$isEmpty(diffs_)) {
			return {
				ctor: '_Tuple2',
				_0: A2(
					_elm_lang$core$Basics_ops['++'],
					'[Internal error]: Empty ',
					A2(_elm_lang$core$Basics_ops['++'], structName, ' diff]')),
				_1: {
					ctor: '_Tuple2',
					_0: {ctor: '_Tuple2', _0: lastEdit, _1: lastPos},
					_1: {ctor: '[]'}
				}
			};
		} else {
			var displaySpaceComma = function () {
				var _p284 = renderingStyle;
				if (_p284.ctor === 'HtmlSyntax') {
					return false;
				} else {
					return true;
				}
			}();
			var aux = F7(
				function (i, lastEdit, lastPos, original, modifieds, diffs, _p285) {
					aux:
					while (true) {
						var _p286 = _p285;
						var _p313 = _p286._0;
						var _p312 = _p286._1;
						var _p287 = diffs;
						if (_p287.ctor === '[]') {
							return {
								ctor: '_Tuple2',
								_0: _p313,
								_1: {
									ctor: '_Tuple2',
									_0: {ctor: '_Tuple2', _0: lastEdit, _1: lastPos},
									_1: _p312
								}
							};
						} else {
							var _p311 = _p287._0._0;
							var _p310 = _p287._1;
							if (_elm_lang$core$Native_Utils.cmp(_p311, i) > 0) {
								var count = _p311 - i;
								var _p288 = A2(_user$project$Utils$split, count, original);
								var originalDropped = _p288._0;
								var originalTaken = _p288._1;
								var newLastPos = function (_p289) {
									var _p290 = _p289;
									return _p290._0.end;
								}(
									_elm_lang$core$Tuple$second(
										A3(
											_elm_lang$core$Basics$flip,
											_user$project$Utils$maybeWithLazyDefault,
											function (_p291) {
												return _elm_lang$core$Native_Utils.crash(
													'UpdateUtils',
													{
														start: {line: 986, column: 16},
														end: {line: 986, column: 27}
													})(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Inconsistent diffs at index ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															_elm_lang$core$Basics$toString(i),
															A2(
																_elm_lang$core$Basics_ops['++'],
																' in listDiffsToStrings2 ',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_elm_lang$core$Basics$toString(renderingStyle),
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		' ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_elm_lang$core$Basics$toString(structName),
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				' _ ',
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					_elm_lang$core$Basics$toString(indent),
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						' ',
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							_elm_lang$core$Basics$toString(lastEdit),
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								' ',
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									_elm_lang$core$Basics$toString(lastPos),
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										' ',
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											A2(
																												_user$project$Syntax$unparser,
																												_user$project$Syntax$Leo,
																												A2(_user$project$Lang$eListWs, originals_, _elm_lang$core$Maybe$Nothing)),
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												' ',
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													A2(
																														_user$project$Syntax$unparser,
																														_user$project$Syntax$Leo,
																														A2(_user$project$Lang$eListWs, modifieds_, _elm_lang$core$Maybe$Nothing)),
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														' ',
																														_elm_lang$core$Basics$toString(diffs_)))))))))))))))))));
											},
											_user$project$Utils$maybeLast(originalDropped))));
								var _v466 = _p311,
									_v467 = lastEdit,
									_v468 = newLastPos,
									_v469 = A2(_elm_lang$core$List$drop, count, original),
									_v470 = A2(_elm_lang$core$List$drop, count, modifieds),
									_v471 = diffs,
									_v472 = {ctor: '_Tuple2', _0: _p313, _1: _p312};
								i = _v466;
								lastEdit = _v467;
								lastPos = _v468;
								original = _v469;
								modifieds = _v470;
								diffs = _v471;
								_p285 = _v472;
								continue aux;
							} else {
								var _p292 = _p287._0._1;
								switch (_p292.ctor) {
									case 'ListElemDelete':
										var _p298 = _p292._0;
										var _p293 = A2(_user$project$Utils$split, _p298, original);
										var originalRemoved = _p293._0;
										var originalKept = _p293._1;
										var secondCommaSpace = A2(
											_elm_lang$core$Maybe$withDefault,
											'',
											A2(
												_elm_lang$core$Maybe$map,
												function (x) {
													return A2(_elm_lang$core$Basics_ops['++'], x, ',');
												},
												A2(
													_elm_lang$core$Maybe$map,
													function (_p294) {
														return function (_) {
															return _.val;
														}(
															_elm_lang$core$Tuple$first(_p294));
													},
													A2(
														_elm_lang$core$Maybe$andThen,
														_elm_lang$core$List$head,
														_elm_lang$core$List$tail(originalKept)))));
										var beforeS = A2(
											_elm_lang$core$String$join,
											'',
											A2(
												_elm_lang$core$List$indexedMap,
												F2(
													function (k, _p295) {
														var _p296 = _p295;
														return A2(
															_elm_lang$core$Basics_ops['++'],
															((_elm_lang$core$Native_Utils.cmp(i + k, 0) > 0) && displaySpaceComma) ? A2(_elm_lang$core$Basics_ops['++'], _p296._0.val, ',') : '',
															A2(
																_elm_lang$core$Basics_ops['++'],
																elementDisplay(_p296._1),
																(_elm_lang$core$Native_Utils.eq(i + k, 0) && displaySpaceComma) ? secondCommaSpace : ''));
													}),
												originalRemoved));
										var afterS = '';
										var _p297 = A4(_user$project$UpdateUtils$offsetFromStrings, lastEdit, lastPos, beforeS, afterS);
										var newLastEdit = _p297._0;
										var newEnd = _p297._1;
										var newStartPos = A2(_user$project$UpdateUtils$offsetPosition, lastEdit, lastPos);
										var removedExp = A5(_user$project$UpdateUtils$dummyExp1, '-', newStartPos.line, newStartPos.col, newStartPos.line, newStartPos.col);
										var _v475 = i + _p298,
											_v476 = newLastEdit,
											_v477 = newEnd,
											_v478 = originalKept,
											_v479 = modifieds,
											_v480 = _p310,
											_v481 = {
											ctor: '_Tuple2',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												_p313,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'\n',
													A2(
														_elm_lang$core$Basics_ops['++'],
														indent,
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$UpdateUtils$displayPos(newEnd),
															A2(
																_elm_lang$core$Basics_ops['++'],
																'Removed \'',
																A2(_elm_lang$core$Basics_ops['++'], beforeS, '\'')))))),
											_1: {ctor: '::', _0: removedExp, _1: _p312}
										};
										i = _v475;
										lastEdit = _v476;
										lastPos = _v477;
										original = _v478;
										modifieds = _v479;
										diffs = _v480;
										_p285 = _v481;
										continue aux;
									case 'ListElemInsert':
										var _p299 = A2(_user$project$Utils$split, _p292._0, modifieds);
										var modifiedInserted = _p299._0;
										var modifiedTail = _p299._1;
										var secondCommaSpace = A2(
											_elm_lang$core$Maybe$withDefault,
											'',
											A2(
												_elm_lang$core$Maybe$map,
												function (x) {
													return A2(_elm_lang$core$Basics_ops['++'], x, ',');
												},
												A2(
													_elm_lang$core$Maybe$map,
													function (_p300) {
														return function (_) {
															return _.val;
														}(
															_elm_lang$core$Tuple$first(_p300));
													},
													A2(
														_elm_lang$core$Maybe$andThen,
														_elm_lang$core$List$head,
														_elm_lang$core$List$tail(modifiedInserted)))));
										var beforeS = '';
										var afterS = A2(
											_elm_lang$core$String$join,
											'',
											A2(
												_elm_lang$core$List$indexedMap,
												F2(
													function (k, _p301) {
														var _p302 = _p301;
														return A2(
															_elm_lang$core$Basics_ops['++'],
															((_elm_lang$core$Native_Utils.cmp(i + k, 0) > 0) && displaySpaceComma) ? A2(_elm_lang$core$Basics_ops['++'], _p302._0.val, ',') : '',
															A2(
																_elm_lang$core$Basics_ops['++'],
																elementDisplay(_p302._1),
																(_elm_lang$core$Native_Utils.eq(i + k, 0) && displaySpaceComma) ? secondCommaSpace : ''));
													}),
												modifiedInserted));
										var _p303 = A4(_user$project$UpdateUtils$offsetFromStrings, lastEdit, lastPos, beforeS, afterS);
										var newLastEdit = _p303._0;
										var newEnd = _p303._1;
										var newStartPos = A2(_user$project$UpdateUtils$offsetPosition, lastEdit, lastPos);
										var insertedExp = A5(_user$project$UpdateUtils$dummyExp1, '+', newStartPos.line, newStartPos.col, newEnd.line, newEnd.col);
										var _v483 = i,
											_v484 = newLastEdit,
											_v485 = lastPos,
											_v486 = original,
											_v487 = modifiedTail,
											_v488 = _p310,
											_v489 = {
											ctor: '_Tuple2',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												_p313,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'\n',
													A2(
														_elm_lang$core$Basics_ops['++'],
														indent,
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$UpdateUtils$displayPos(newEnd),
															A2(
																_elm_lang$core$Basics_ops['++'],
																'Inserted \'',
																A2(_elm_lang$core$Basics_ops['++'], afterS, '\'')))))),
											_1: {ctor: '::', _0: insertedExp, _1: _p312}
										};
										i = _v483;
										lastEdit = _v484;
										lastPos = _v485;
										original = _v486;
										modifieds = _v487;
										diffs = _v488;
										_p285 = _v489;
										continue aux;
									default:
										var _p309 = _p292._0;
										var _p304 = {ctor: '_Tuple2', _0: original, _1: modifieds};
										if (((((_p304.ctor === '_Tuple2') && (_p304._0.ctor === '::')) && (_p304._0._0.ctor === '_Tuple2')) && (_p304._1.ctor === '::')) && (_p304._1._0.ctor === '_Tuple2')) {
											var _p308 = _p304._0._0._1._0;
											var _p305 = function () {
												var _p306 = _p309;
												if ((_p306.ctor === 'EConstDiffs') && (_p306._0.ctor === 'EOnlyWhitespaceDiffs')) {
													var _p307 = A4(_user$project$UpdateUtils$offsetFromStrings, lastEdit, lastPos, _p304._0._0._0.val, _p304._1._0._0.val);
													var newLastEdit = _p307._0;
													var newEndSpace = _p307._1;
													var newElemEnd = A2(_user$project$UpdateUtils$offsetPosition, newLastEdit, _p308.end);
													return {
														ctor: '_Tuple2',
														_0: '',
														_1: {
															ctor: '_Tuple2',
															_0: {ctor: '_Tuple2', _0: newLastEdit, _1: _p308.end},
															_1: {ctor: '[]'}
														}
													};
												} else {
													return A6(
														_user$project$UpdateUtils$eDiffsToStringPositions,
														renderingStyle,
														indent,
														lastEdit,
														_user$project$Lang$Expr(_p308),
														_p304._1._0._1,
														_p309);
												}
											}();
											var incAcc = _p305._0;
											var newLastEdit = _p305._1._0._0;
											var lastPos2 = _p305._1._0._1;
											var newHighlights = _p305._1._1;
											var _v492 = i + 1,
												_v493 = newLastEdit,
												_v494 = lastPos2,
												_v495 = _p304._0._1,
												_v496 = _p304._1._1,
												_v497 = _p310,
												_v498 = {
												ctor: '_Tuple2',
												_0: A2(_elm_lang$core$Basics_ops['++'], _p313, incAcc),
												_1: A2(_elm_lang$core$Basics_ops['++'], newHighlights, _p312)
											};
											i = _v492;
											lastEdit = _v493;
											lastPos = _v494;
											original = _v495;
											modifieds = _v496;
											diffs = _v497;
											_p285 = _v498;
											continue aux;
										} else {
											return {
												ctor: '_Tuple2',
												_0: A2(
													_elm_lang$core$Basics_ops['++'],
													_p313,
													A2(
														_elm_lang$core$Basics_ops['++'],
														'[Internal error]2 For diff ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															_elm_lang$core$Basics$toString(_p309),
															A2(
																_elm_lang$core$Basics_ops['++'],
																', expected non-empty lists, got [',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	A2(
																		_elm_lang$core$String$join,
																		',',
																		A2(
																			_elm_lang$core$List$map,
																			elementDisplay,
																			_user$project$Utils$listValues(originals_))),
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'] and [',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			A2(
																				_elm_lang$core$String$join,
																				',',
																				A2(
																					_elm_lang$core$List$map,
																					elementDisplay,
																					_user$project$Utils$listValues(modifieds_))),
																			']'))))))),
												_1: {
													ctor: '_Tuple2',
													_0: {ctor: '_Tuple2', _0: lastEdit, _1: lastPos},
													_1: _p312
												}
											};
										}
								}
							}
						}
					}
				});
			return A7(
				aux,
				0,
				lastEdit,
				lastPos,
				originals_,
				modifieds_,
				diffs_,
				{
					ctor: '_Tuple2',
					_0: '',
					_1: {ctor: '[]'}
				});
		}
	});
var _user$project$UpdateUtils$tupleDiffsToString2 = F6(
	function (renderingStyle, indent, lastEdit, originalChildren, modifiedChildren, childDiffs) {
		var aux = F6(
			function (i, lastEdit, original, modified, diffs, _p314) {
				aux:
				while (true) {
					var _p315 = _p314;
					var _p321 = _p315._0;
					var _p320 = _p315._1;
					var _p316 = diffs;
					if (_p316.ctor === '[]') {
						return {
							ctor: '_Tuple2',
							_0: _p321,
							_1: {ctor: '_Tuple2', _0: lastEdit, _1: _p320}
						};
					} else {
						var _p319 = _p316._0._0;
						if (_elm_lang$core$Native_Utils.cmp(_p319, i) > 0) {
							var count = _p319 - i;
							var _v501 = _p319,
								_v502 = lastEdit,
								_v503 = A2(_elm_lang$core$List$drop, count, original),
								_v504 = A2(_elm_lang$core$List$drop, count, modified),
								_v505 = diffs,
								_v506 = {ctor: '_Tuple2', _0: _p321, _1: _p320};
							i = _v501;
							lastEdit = _v502;
							original = _v503;
							modified = _v504;
							diffs = _v505;
							_p314 = _v506;
							continue aux;
						} else {
							if (_elm_lang$core$Native_Utils.eq(_p319, i)) {
								var _p317 = {ctor: '_Tuple2', _0: original, _1: modified};
								if (((_p317.ctor === '_Tuple2') && (_p317._0.ctor === '::')) && (_p317._1.ctor === '::')) {
									var _p318 = A6(_user$project$UpdateUtils$eDiffsToStringPositions, renderingStyle, indent, lastEdit, _p317._0._0, _p317._1._0, _p316._0._1);
									var incAcc = _p318._0;
									var newLastEdit = _p318._1._0._0;
									var newExps = _p318._1._1;
									var _v508 = i + 1,
										_v509 = newLastEdit,
										_v510 = _p317._0._1,
										_v511 = _p317._1._1,
										_v512 = _p316._1,
										_v513 = {
										ctor: '_Tuple2',
										_0: A2(_elm_lang$core$Basics_ops['++'], _p321, incAcc),
										_1: A2(_elm_lang$core$Basics_ops['++'], _p320, newExps)
									};
									i = _v508;
									lastEdit = _v509;
									original = _v510;
									modified = _v511;
									diffs = _v512;
									_p314 = _v513;
									continue aux;
								} else {
									return {
										ctor: '_Tuple2',
										_0: A2(
											_elm_lang$core$Basics_ops['++'],
											'[Internal error] Expcted non-empty ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												'expression',
												A2(
													_elm_lang$core$Basics_ops['++'],
													', diffs = ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Basics$toString(childDiffs),
														A2(
															_elm_lang$core$Basics_ops['++'],
															', original children = ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																A2(
																	_elm_lang$core$String$join,
																	',',
																	A2(
																		_elm_lang$core$List$map,
																		_user$project$Syntax$unparser(_user$project$Syntax$Leo),
																		originalChildren)),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	', modified children: ',
																	A2(
																		_elm_lang$core$String$join,
																		'',
																		A2(
																			_elm_lang$core$List$map,
																			_user$project$Syntax$unparser(_user$project$Syntax$Leo),
																			modifiedChildren))))))))),
										_1: {
											ctor: '_Tuple2',
											_0: lastEdit,
											_1: {ctor: '[]'}
										}
									};
								}
							} else {
								return _elm_lang$core$Native_Utils.crash(
									'UpdateUtils',
									{
										start: {line: 1126, column: 11},
										end: {line: 1126, column: 22}
									})('Changes does not match the expression');
							}
						}
					}
				}
			});
		var _p322 = A6(
			aux,
			0,
			lastEdit,
			originalChildren,
			modifiedChildren,
			childDiffs,
			{
				ctor: '_Tuple2',
				_0: '',
				_1: {ctor: '[]'}
			});
		var msg = _p322._0;
		var newLastEdit = _p322._1._0;
		var newExps = _p322._1._1;
		return {
			ctor: '_Tuple2',
			_0: msg,
			_1: {ctor: '_Tuple2', _0: newLastEdit, _1: newExps}
		};
	});
var _user$project$UpdateUtils$eDiffsToString = F4(
	function (indent, origExp, modifExp, ediff) {
		return _elm_lang$core$Tuple$first(
			A6(
				_user$project$UpdateUtils$eDiffsToStringPositions,
				_user$project$Lang$LeoSyntax,
				indent,
				{
					ctor: '_Tuple2',
					_0: A2(_user$project$Pos$Pos, 1, 1),
					_1: {ctor: '_Tuple2', _0: 0, _1: 0}
				},
				origExp,
				modifExp,
				ediff));
	});
var _user$project$UpdateUtils$vClosureDiffsToString = F7(
	function (indent, origEnv, origBody, modifEnv, modifBody, diffEnv, maybeDiffBody) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A4(_user$project$UpdateUtils$envDiffsToString_, indent, origEnv, modifEnv, diffEnv),
			A2(
				_elm_lang$core$Maybe$withDefault,
				'',
				A2(
					_elm_lang$core$Maybe$map,
					function (ediff) {
						return A4(_user$project$UpdateUtils$eDiffsToString, indent, origBody, modifBody, ediff);
					},
					maybeDiffBody)));
	});
var _user$project$UpdateUtils$envDiffsToString_ = A2(
	_user$project$UpdateUtils$tupleDiffsToString,
	_elm_lang$core$Maybe$Just('environment'),
	F4(
		function (indent, _p324, _p323, change) {
			var _p325 = _p324;
			var _p328 = _p325._0;
			var _p326 = _p323;
			var _p327 = _p326._0;
			return A2(
				_elm_lang$core$Basics_ops['++'],
				(!_elm_lang$core$Native_Utils.eq(_p328, _p327)) ? A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Weird: a name changed from ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p328,
								A2(_elm_lang$core$Basics_ops['++'], ' to ', _p327))))) : '',
				A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Variable ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_p328,
								A2(
									_elm_lang$core$Basics_ops['++'],
									' changes to value:',
									A4(
										_user$project$UpdateUtils$vDiffsToString_,
										A2(_elm_lang$core$Basics_ops['++'], indent, '  '),
										_p325._1,
										_p326._1,
										change)))))));
		}));
var _user$project$UpdateUtils$vDiffsToString_ = F4(
	function (indent, vOriginal, vModified, vDiffs) {
		var _p329 = vDiffs;
		switch (_p329.ctor) {
			case 'VListDiffs':
				var _p330 = {ctor: '_Tuple2', _0: vOriginal.v_, _1: vModified.v_};
				if (((_p330.ctor === '_Tuple2') && (_p330._0.ctor === 'VList')) && (_p330._1.ctor === 'VList')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'A list was modified:',
								A4(_user$project$UpdateUtils$vListDiffsToString, indent, _p330._0._0, _p330._1._0, _p329._0))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] vDiffsToString ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(vDiffs),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' expects lists here, got ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(vOriginal),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(vModified))))));
				}
			case 'VStringDiffs':
				var _p331 = {ctor: '_Tuple2', _0: vOriginal.v_, _1: vModified.v_};
				if (((((_p331.ctor === '_Tuple2') && (_p331._0.ctor === 'VBase')) && (_p331._0._0.ctor === 'VString')) && (_p331._1.ctor === 'VBase')) && (_p331._1._0.ctor === 'VString')) {
					return A4(_user$project$UpdateUtils$stringDiffsToString, indent, _p331._0._0._0, _p331._1._0._0, _p329._0);
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] vDiffsToString_ ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(vDiffs),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' expects strings here, got ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(vOriginal),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(vModified))))));
				}
			case 'VDictDiffs':
				var _p332 = {ctor: '_Tuple2', _0: vOriginal.v_, _1: vModified.v_};
				if (((_p332.ctor === '_Tuple2') && (_p332._0.ctor === 'VDict')) && (_p332._1.ctor === 'VDict')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'A dict was modified:',
								A4(_user$project$UpdateUtils$vDictDiffsToString, indent, _p332._0._0, _p332._1._0, _p329._0))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] vDiffsToString_ ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(vDiffs),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' expects dicts here, got ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(vOriginal),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(vModified))))));
				}
			case 'VRecordDiffs':
				var _p333 = {ctor: '_Tuple2', _0: vOriginal.v_, _1: vModified.v_};
				if (((_p333.ctor === '_Tuple2') && (_p333._0.ctor === 'VRecord')) && (_p333._1.ctor === 'VRecord')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'A record was modified:',
								A4(_user$project$UpdateUtils$vRecordDiffsToString, indent, _p333._0._0, _p333._1._0, _p329._0))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] vDiffsToString_ ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(vDiffs),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' expects records here, got ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(vOriginal),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(vModified))))));
				}
			case 'VClosureDiffs':
				var _p334 = {ctor: '_Tuple2', _0: vOriginal.v_, _1: vModified.v_};
				if (((_p334.ctor === '_Tuple2') && (_p334._0.ctor === 'VClosure')) && (_p334._1.ctor === 'VClosure')) {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'A closure was modified:',
								A7(_user$project$UpdateUtils$vClosureDiffsToString, indent, _p334._0._3, _p334._0._2, _p334._1._3, _p334._1._2, _p329._0, _p329._1))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] vDiffsToString_ ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(vDiffs),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' expects closures here, got ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(vOriginal),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(vModified))))));
				}
			default:
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Was ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUtils$valToString(vOriginal),
								A2(
									_elm_lang$core$Basics_ops['++'],
									', now ',
									_user$project$LangUtils$valToString(vModified))))));
		}
	});
var _user$project$UpdateUtils$vDictDiffsToString = F4(
	function (indent, originals, modified, diffs) {
		return A5(
			_user$project$UpdateUtils$dictDiffsToString,
			indent,
			F5(
				function (indent, key, maybeOriginal, maybeModified, diff) {
					var _p335 = {ctor: '_Tuple3', _0: diff, _1: maybeOriginal, _2: maybeModified};
					_v522_3:
					do {
						if (_p335.ctor === '_Tuple3') {
							if (_p335._1.ctor === 'Nothing') {
								if ((_p335._0.ctor === 'VDictElemInsert') && (_p335._2.ctor === 'Just')) {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										'\n',
										A2(
											_elm_lang$core$Basics_ops['++'],
											indent,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'element for \'',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Tuple$first(key),
													A2(
														_elm_lang$core$Basics_ops['++'],
														'\' was inserted: ',
														_user$project$LangUtils$valToString(_p335._2._0))))));
								} else {
									break _v522_3;
								}
							} else {
								if (_p335._2.ctor === 'Nothing') {
									if (_p335._0.ctor === 'VDictElemDelete') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											'\n',
											A2(
												_elm_lang$core$Basics_ops['++'],
												indent,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'element for \'',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Tuple$first(key),
														A2(
															_elm_lang$core$Basics_ops['++'],
															'\' was removed: ',
															_user$project$LangUtils$valToString(_p335._1._0))))));
									} else {
										break _v522_3;
									}
								} else {
									if (_p335._0.ctor === 'VDictElemUpdate') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											'\n',
											A2(
												_elm_lang$core$Basics_ops['++'],
												indent,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'element for \'',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_elm_lang$core$Tuple$first(key),
														A2(
															_elm_lang$core$Basics_ops['++'],
															'\' was updated: ',
															A4(
																_user$project$UpdateUtils$vDiffsToString_,
																A2(_elm_lang$core$Basics_ops['++'], indent, '  '),
																_p335._1._0,
																_p335._2._0,
																_p335._0._0))))));
									} else {
										break _v522_3;
									}
								}
							}
						} else {
							break _v522_3;
						}
					} while(false);
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'[Internal error] Inconsistency between diff and values ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(diff),
							A2(
								_elm_lang$core$Basics_ops['++'],
								',',
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(
										_elm_lang$core$Maybe$withDefault,
										'',
										A2(_elm_lang$core$Maybe$map, _user$project$LangUtils$valToString, maybeOriginal)),
									A2(
										_elm_lang$core$Basics_ops['++'],
										',',
										A2(
											_elm_lang$core$Maybe$withDefault,
											'',
											A2(_elm_lang$core$Maybe$map, _user$project$LangUtils$valToString, maybeModified)))))));
				}),
			originals,
			modified,
			diffs);
	});
var _user$project$UpdateUtils$vListDiffsToString = A4(
	_user$project$UpdateUtils$listDiffsToString,
	'list',
	_user$project$UpdateUtils$vDiffsToString_,
	F2(
		function (indent, index) {
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'At index ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(index),
									', element modified:')))),
					_1: A2(_elm_lang$core$Basics_ops['++'], indent, '  ')
				});
		}),
	_user$project$LangUtils$valToString);
var _user$project$UpdateUtils$vRecordDiffsToString = F4(
	function (indent, originals, modified, diffs) {
		return A5(
			_user$project$UpdateUtils$dictDiffsToString,
			indent,
			F5(
				function (indent, key, maybeOriginal, maybeModified, diff) {
					var _p336 = {ctor: '_Tuple2', _0: maybeOriginal, _1: maybeModified};
					if (((_p336.ctor === '_Tuple2') && (_p336._0.ctor === 'Just')) && (_p336._1.ctor === 'Just')) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							'\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								indent,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'value for \'',
									A2(
										_elm_lang$core$Basics_ops['++'],
										key,
										A2(
											_elm_lang$core$Basics_ops['++'],
											'\' was updated: ',
											A4(
												_user$project$UpdateUtils$vDiffsToString_,
												A2(_elm_lang$core$Basics_ops['++'], indent, '  '),
												_p336._0._0,
												_p336._1._0,
												diff))))));
					} else {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							'[Internal error] Inconsistency between diff and values ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(diff),
								A2(
									_elm_lang$core$Basics_ops['++'],
									',',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$Maybe$withDefault,
											'',
											A2(_elm_lang$core$Maybe$map, _user$project$LangUtils$valToString, maybeOriginal)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											',',
											A2(
												_elm_lang$core$Maybe$withDefault,
												'',
												A2(_elm_lang$core$Maybe$map, _user$project$LangUtils$valToString, maybeModified)))))));
					}
				}),
			originals,
			modified,
			diffs);
	});
var _user$project$UpdateUtils$envDiffsToString = _user$project$UpdateUtils$envDiffsToString_('');
var _user$project$UpdateUtils$vDiffsToString = _user$project$UpdateUtils$vDiffsToString_('');
var _user$project$UpdateUtils$displayDiff = F2(
	function (tos, difference) {
		return A2(
			_elm_lang$core$String$join,
			',',
			A2(
				_elm_lang$core$List$concatMap,
				function (d) {
					var _p337 = d;
					switch (_p337.ctor) {
						case 'DiffEqual':
							return {ctor: '[]'};
						case 'DiffRemoved':
							return {
								ctor: '::',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									' -',
									A2(
										_elm_lang$core$String$join,
										'',
										A2(_elm_lang$core$List$map, tos, _p337._0))),
								_1: {ctor: '[]'}
							};
						default:
							return {
								ctor: '::',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									' +',
									A2(
										_elm_lang$core$String$join,
										'',
										A2(_elm_lang$core$List$map, tos, _p337._0))),
								_1: {ctor: '[]'}
							};
					}
				},
				difference));
	});
var _user$project$UpdateUtils$splitRegex = _elm_lang$core$Regex$regex('\\b|(?=[-\\]\"\'\\[\\)\\(,><\\\\])');
var _user$project$UpdateUtils$bvToString = function (b) {
	return A2(
		_user$project$Syntax$unparser,
		_user$project$Syntax$Leo,
		_user$project$Lang$withDummyExpInfo(
			A2(_user$project$Lang$EBase, _user$project$Lang$space0, b)));
};
var _user$project$UpdateUtils$DiffAdded = function (a) {
	return {ctor: 'DiffAdded', _0: a};
};
var _user$project$UpdateUtils$DiffRemoved = function (a) {
	return {ctor: 'DiffRemoved', _0: a};
};
var _user$project$UpdateUtils$DiffEqual = function (a) {
	return {ctor: 'DiffEqual', _0: a};
};
var _user$project$UpdateUtils$diffChunkMap = F2(
	function (f, d) {
		var _p338 = d;
		switch (_p338.ctor) {
			case 'DiffEqual':
				return _user$project$UpdateUtils$DiffEqual(
					f(_p338._0));
			case 'DiffRemoved':
				return _user$project$UpdateUtils$DiffRemoved(
					f(_p338._0));
			default:
				return _user$project$UpdateUtils$DiffAdded(
					f(_p338._0));
		}
	});
var _user$project$UpdateUtils$diff = F3(
	function (keyOf, before, after) {
		var oldIndexMapRev = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p339, d) {
					var _p340 = _p339;
					var _p342 = _p340._1;
					return A3(
						_elm_lang$core$Dict$update,
						keyOf(_p340._0),
						function (mbv) {
							var _p341 = mbv;
							if (_p341.ctor === 'Just') {
								return _elm_lang$core$Maybe$Just(
									{ctor: '::', _0: _p342, _1: _p341._0});
							} else {
								return _elm_lang$core$Maybe$Just(
									{
										ctor: '::',
										_0: _p342,
										_1: {ctor: '[]'}
									});
							}
						},
						d);
				}),
			_elm_lang$core$Dict$empty,
			_user$project$Utils$zipWithIndex(before));
		var oldIndexMap = A2(
			_elm_lang$core$Dict$map,
			function (k) {
				return _elm_lang$core$List$reverse;
			},
			oldIndexMapRev);
		var _p343 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p345, _p344) {
					var _p346 = _p345;
					var _p347 = _p344;
					var oldIndexMapAfterInew = A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						A2(
							_elm_lang$core$Dict$get,
							keyOf(_p346._0),
							oldIndexMap));
					return A3(
						_elm_lang$core$List$foldl,
						F2(
							function (iold, _p348) {
								var _p349 = _p348;
								var _p350 = _p349._3;
								var newIoldValue = ((!_elm_lang$core$Native_Utils.eq(iold, 0)) ? A2(
									_elm_lang$core$Maybe$withDefault,
									0,
									A2(_elm_lang$core$Dict$get, iold - 1, _p347._0)) : 0) + 1;
								var newOverlap_ = A3(_elm_lang$core$Dict$insert, iold, newIoldValue, _p349._0);
								return (_elm_lang$core$Native_Utils.cmp(newIoldValue, _p350) > 0) ? {ctor: '_Tuple4', _0: newOverlap_, _1: (iold - newIoldValue) + 1, _2: (_p346._1 - newIoldValue) + 1, _3: newIoldValue} : {ctor: '_Tuple4', _0: newOverlap_, _1: _p349._1, _2: _p349._2, _3: _p350};
							}),
						{ctor: '_Tuple4', _0: _elm_lang$core$Dict$empty, _1: _p347._1, _2: _p347._2, _3: _p347._3},
						oldIndexMapAfterInew);
				}),
			{ctor: '_Tuple4', _0: _elm_lang$core$Dict$empty, _1: 0, _2: 0, _3: 0},
			_user$project$Utils$zipWithIndex(after));
		var overlap = _p343._0;
		var startOld = _p343._1;
		var startNew = _p343._2;
		var subLength = _p343._3;
		return _elm_lang$core$Native_Utils.eq(subLength, 0) ? A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$List$isEmpty(before) ? {ctor: '[]'} : {
				ctor: '::',
				_0: _user$project$UpdateUtils$DiffRemoved(before),
				_1: {ctor: '[]'}
			},
			_elm_lang$core$List$isEmpty(after) ? {ctor: '[]'} : {
				ctor: '::',
				_0: _user$project$UpdateUtils$DiffAdded(after),
				_1: {ctor: '[]'}
			}) : A2(
			_elm_lang$core$Basics_ops['++'],
			A3(
				_user$project$UpdateUtils$diff,
				keyOf,
				A2(_elm_lang$core$List$take, startOld, before),
				A2(_elm_lang$core$List$take, startNew, after)),
			{
				ctor: '::',
				_0: _user$project$UpdateUtils$DiffEqual(
					A2(
						_elm_lang$core$List$take,
						subLength,
						A2(_elm_lang$core$List$drop, startNew, after))),
				_1: A3(
					_user$project$UpdateUtils$diff,
					keyOf,
					A2(_elm_lang$core$List$drop, startOld + subLength, before),
					A2(_elm_lang$core$List$drop, startNew + subLength, after))
			});
	});
var _user$project$UpdateUtils$diffString = F2(
	function (s1, s2) {
		var before = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s1);
		var after = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s2);
		var difference = A3(_user$project$UpdateUtils$diff, _elm_lang$core$Basics$identity, before, after);
		return A2(_user$project$UpdateUtils$displayDiff, _elm_lang$core$Basics$identity, difference);
	});
var _user$project$UpdateUtils$diffExp = F2(
	function (e1, e2) {
		var s1 = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e1);
		var s2 = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e2);
		return A2(_user$project$UpdateUtils$diffString, s1, s2);
	});
var _user$project$UpdateUtils$diffStringPositions = F3(
	function (initialPosition, s1, s2) {
		var before = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s1);
		var after = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s2);
		var difference = A3(_user$project$UpdateUtils$diff, _elm_lang$core$Basics$identity, before, after);
		return A3(_user$project$UpdateUtils$displayDiffPositions, _elm_lang$core$Basics$identity, initialPosition, difference);
	});
var _user$project$UpdateUtils$diffExpWithPositions = F2(
	function (e1, e2) {
		var s1 = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e1);
		var s2 = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e2);
		return A3(
			_user$project$UpdateUtils$diffStringPositions,
			A2(_user$project$Pos$Pos, 1, 1),
			s1,
			s2);
	});
var _user$project$UpdateUtils$diffVals = F2(
	function (before, after) {
		var vToString = function (_p351) {
			return A2(
				_user$project$Syntax$unparser,
				_user$project$Syntax$Leo,
				A3(
					_user$project$LangUtils$valToExp,
					_user$project$Lang$ws(''),
					_user$project$LangUtils$InlineSpace,
					_p351));
		};
		var beforeStrings = A2(
			_elm_lang$core$List$map,
			function (v) {
				return {
					ctor: '_Tuple2',
					_0: v,
					_1: vToString(v)
				};
			},
			before);
		var afterStrings = A2(
			_elm_lang$core$List$map,
			function (v) {
				return {
					ctor: '_Tuple2',
					_0: v,
					_1: vToString(v)
				};
			},
			after);
		var diffRaw = A3(_user$project$UpdateUtils$diff, _elm_lang$core$Tuple$second, beforeStrings, afterStrings);
		return A2(
			_elm_lang$core$List$map,
			_user$project$UpdateUtils$diffChunkMap(
				_elm_lang$core$List$map(_elm_lang$core$Tuple$first)),
			diffRaw);
	});
var _user$project$UpdateUtils$alldiffs = F3(
	function (keyOf, before, after) {
		var oldIndexMapRev = A3(
			_user$project$Utils$foldLeftWithIndex,
			_elm_lang$core$Dict$empty,
			before,
			F3(
				function (d, indexBeforeValue, beforeValue) {
					return A3(
						_elm_lang$core$Dict$update,
						keyOf(beforeValue),
						function (_p352) {
							return _elm_lang$core$Maybe$Just(
								function (v) {
									return {ctor: '::', _0: indexBeforeValue, _1: v};
								}(
									A2(
										_elm_lang$core$Maybe$withDefault,
										{ctor: '[]'},
										_p352)));
						},
						d);
				}));
		var valueToIndexBefore = A2(
			_elm_lang$core$Dict$map,
			F2(
				function (k, v) {
					return _elm_lang$core$List$reverse(v);
				}),
			oldIndexMapRev);
		var afterLength = _elm_lang$core$List$length(after);
		var beforeLength = _elm_lang$core$List$length(before);
		var _p353 = A3(
			_user$project$Utils$foldLeftWithIndex,
			{
				ctor: '_Tuple4',
				_0: _elm_lang$core$Dict$empty,
				_1: {ctor: '[]'},
				_2: 0,
				_3: 0 - (_elm_lang$core$List$length(before) + _elm_lang$core$List$length(after))
			},
			after,
			F3(
				function (_p354, afterIndex, afterValue) {
					var _p355 = _p354;
					var _p362 = _p355._3;
					var _p361 = _p355._2;
					var oldIndicesWhereAfterAppeared = A2(
						_elm_lang$core$Maybe$withDefault,
						{ctor: '[]'},
						A2(
							_elm_lang$core$Dict$get,
							keyOf(afterValue),
							valueToIndexBefore));
					return A3(
						_user$project$Utils$foldLeft,
						{ctor: '_Tuple4', _0: _elm_lang$core$Dict$empty, _1: _p355._1, _2: _p361, _3: _p362},
						oldIndicesWhereAfterAppeared,
						F2(
							function (_p356, oldIdxAfterValue) {
								var _p357 = _p356;
								var _p360 = _p357._3;
								var _p359 = _p357._2;
								var _p358 = _p357._1;
								var newSubLength = (_elm_lang$core$Native_Utils.eq(oldIdxAfterValue, 0) ? 0 : A2(
									_elm_lang$core$Maybe$withDefault,
									0,
									A2(
										_elm_lang$core$Maybe$map,
										_elm_lang$core$Tuple$first,
										A2(_elm_lang$core$Dict$get, oldIdxAfterValue - 1, _p355._0)))) + 1;
								var newWeight = (0 - _elm_lang$core$Basics$abs((afterLength - afterIndex) - (beforeLength - oldIdxAfterValue))) - _elm_lang$core$Basics$abs(afterIndex - oldIdxAfterValue);
								var newOverlap_ = A3(
									_elm_lang$core$Dict$insert,
									oldIdxAfterValue,
									{ctor: '_Tuple2', _0: newSubLength, _1: newWeight},
									_p357._0);
								return (_elm_lang$core$Native_Utils.cmp(
									A2(_user$project$UpdateUtils$combineLengthWeight, newSubLength, newWeight),
									A2(_user$project$UpdateUtils$combineLengthWeight, _p359, _p360)) > 0) ? {
									ctor: '_Tuple4',
									_0: newOverlap_,
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: (oldIdxAfterValue - newSubLength) + 1, _1: (afterIndex - newSubLength) + 1},
										_1: {ctor: '[]'}
									},
									_2: newSubLength,
									_3: newWeight
								} : ((_elm_lang$core$Native_Utils.eq(
									A2(_user$project$UpdateUtils$combineLengthWeight, newSubLength, newWeight),
									A2(_user$project$UpdateUtils$combineLengthWeight, _p359, _p360)) && (_elm_lang$core$Native_Utils.cmp(
									A2(_user$project$UpdateUtils$combineLengthWeight, _p359, _p360),
									A2(_user$project$UpdateUtils$combineLengthWeight, _p361, _p362)) > 0)) ? {
									ctor: '_Tuple4',
									_0: newOverlap_,
									_1: {
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: (oldIdxAfterValue - newSubLength) + 1, _1: (afterIndex - newSubLength) + 1},
										_1: _p358
									},
									_2: newSubLength,
									_3: newWeight
								} : {ctor: '_Tuple4', _0: newOverlap_, _1: _p358, _2: _p359, _3: _p360});
							}));
				}));
		var overlap = _p353._0;
		var startOldNew = _p353._1;
		var subLength = _p353._2;
		var weight = _p353._3;
		return _elm_lang$core$Native_Utils.eq(subLength, 0) ? _user$project$Results$ok1(
			A2(
				_elm_lang$core$Basics_ops['++'],
				_elm_lang$core$List$isEmpty(before) ? {ctor: '[]'} : {
					ctor: '::',
					_0: _user$project$UpdateUtils$DiffRemoved(before),
					_1: {ctor: '[]'}
				},
				_elm_lang$core$List$isEmpty(after) ? {ctor: '[]'} : {
					ctor: '::',
					_0: _user$project$UpdateUtils$DiffAdded(after),
					_1: {ctor: '[]'}
				})) : A3(
			_elm_lang$core$Basics$flip,
			_user$project$Results$andThen,
			_user$project$Results$oks(
				_elm_lang$core$List$reverse(startOldNew)),
			function (_p363) {
				var _p364 = _p363;
				var _p366 = _p364._0;
				var _p365 = _p364._1;
				var left = A3(
					_user$project$UpdateUtils$alldiffs,
					keyOf,
					A2(_elm_lang$core$List$take, _p366, before),
					A2(_elm_lang$core$List$take, _p365, after));
				var right = A3(
					_user$project$UpdateUtils$alldiffs,
					keyOf,
					A2(_elm_lang$core$List$drop, _p366 + subLength, before),
					A2(_elm_lang$core$List$drop, _p365 + subLength, after));
				return A3(
					_elm_lang$core$Basics$flip,
					_user$project$Results$andThen,
					left,
					function (leftDiffs) {
						return A3(
							_elm_lang$core$Basics$flip,
							_user$project$Results$map,
							right,
							function (rightDiffs) {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									leftDiffs,
									{
										ctor: '::',
										_0: _user$project$UpdateUtils$DiffEqual(
											A2(
												_elm_lang$core$List$take,
												subLength,
												A2(_elm_lang$core$List$drop, _p365, after))),
										_1: rightDiffs
									});
							});
					});
			});
	});
var _user$project$UpdateUtils$fixStringDiffs = function (diffChunks) {
	var _p367 = diffChunks;
	_v534_6:
	do {
		if (_p367.ctor === '::') {
			if (_p367._1.ctor === '::') {
				switch (_p367._0.ctor) {
					case 'DiffAdded':
						if (_p367._1._0.ctor === 'DiffEqual') {
							var _p370 = _p367._1._0._0;
							var _p369 = _p367._0._0;
							var _p368 = _p367._1._1;
							return A5(
								_user$project$UpdateUtils$shiftAddedRight,
								'',
								_p369,
								_p370,
								_p368,
								A3(
									_user$project$UpdateUtils$priorityListMapDelta,
									_user$project$UpdateUtils$heuristicOf(_p369),
									function (res) {
										return {
											ctor: '::',
											_0: _user$project$UpdateUtils$DiffAdded(_p369),
											_1: res
										};
									},
									_user$project$UpdateUtils$fixStringDiffs(
										{
											ctor: '::',
											_0: _user$project$UpdateUtils$DiffEqual(_p370),
											_1: _p368
										})));
						} else {
							break _v534_6;
						}
					case 'DiffRemoved':
						if (_p367._1._0.ctor === 'DiffEqual') {
							var _p380 = _p367._1._0._0;
							var _p379 = _p367._0._0;
							var _p378 = _p367._1._1;
							return A5(
								_user$project$UpdateUtils$shiftRemovedRight,
								'',
								_p379,
								_p380,
								_p378,
								A3(
									_user$project$UpdateUtils$priorityListMapDelta,
									_user$project$UpdateUtils$heuristicOf(_p379),
									function (res) {
										return {
											ctor: '::',
											_0: _user$project$UpdateUtils$DiffRemoved(_p379),
											_1: res
										};
									},
									_user$project$UpdateUtils$fixStringDiffs(
										{
											ctor: '::',
											_0: _user$project$UpdateUtils$DiffEqual(_p380),
											_1: _p378
										})));
						} else {
							break _v534_6;
						}
					default:
						switch (_p367._1._0.ctor) {
							case 'DiffAdded':
								if ((_p367._1._1.ctor === '::') && (_p367._1._1._0.ctor === 'DiffEqual')) {
									var _p374 = _p367._1._1._0._0;
									var _p373 = _p367._1._0._0;
									var _p372 = _p367._0._0;
									var _p371 = _p367._1._1._1;
									return A5(
										_user$project$UpdateUtils$shiftAddedRight,
										_p372,
										_p373,
										_p374,
										_p371,
										A5(
											_user$project$UpdateUtils$shiftAddedLeft,
											_p372,
											_p373,
											_p374,
											_p371,
											A3(
												_user$project$UpdateUtils$priorityListMapDelta,
												_user$project$UpdateUtils$heuristicOf(_p373),
												function (res) {
													return {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffEqual(_p372),
														_1: {
															ctor: '::',
															_0: _user$project$UpdateUtils$DiffAdded(_p373),
															_1: res
														}
													};
												},
												_user$project$UpdateUtils$fixStringDiffs(
													{
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffEqual(_p374),
														_1: _p371
													}))));
								} else {
									var _p377 = _p367._1._0._0;
									var _p376 = _p367._0._0;
									var _p375 = _p367._1._1;
									return A5(
										_user$project$UpdateUtils$shiftAddedLeft,
										_p376,
										_p377,
										'',
										_p375,
										A3(
											_user$project$UpdateUtils$priorityListMapDelta,
											_user$project$UpdateUtils$heuristicOf(_p377),
											function (res) {
												return {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(_p376),
													_1: {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffAdded(_p377),
														_1: res
													}
												};
											},
											_user$project$UpdateUtils$fixStringDiffs(_p375)));
								}
							case 'DiffRemoved':
								if ((_p367._1._1.ctor === '::') && (_p367._1._1._0.ctor === 'DiffEqual')) {
									var _p384 = _p367._1._1._0._0;
									var _p383 = _p367._1._0._0;
									var _p382 = _p367._0._0;
									var _p381 = _p367._1._1._1;
									return A5(
										_user$project$UpdateUtils$shiftRemovedRight,
										_p382,
										_p383,
										_p384,
										_p381,
										A5(
											_user$project$UpdateUtils$shiftRemovedLeft,
											_p382,
											_p383,
											_p384,
											_p381,
											A3(
												_user$project$UpdateUtils$priorityListMapDelta,
												_user$project$UpdateUtils$heuristicOf(_p383),
												function (res) {
													return {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffEqual(_p382),
														_1: {
															ctor: '::',
															_0: _user$project$UpdateUtils$DiffRemoved(_p383),
															_1: res
														}
													};
												},
												_user$project$UpdateUtils$fixStringDiffs(
													{
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffEqual(_p384),
														_1: _p381
													}))));
								} else {
									var _p387 = _p367._1._0._0;
									var _p386 = _p367._0._0;
									var _p385 = _p367._1._1;
									return A5(
										_user$project$UpdateUtils$shiftRemovedLeft,
										_p386,
										_p387,
										'',
										_p385,
										A3(
											_user$project$UpdateUtils$priorityListMapDelta,
											_user$project$UpdateUtils$heuristicOf(_p387),
											function (res) {
												return {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(_p386),
													_1: {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffRemoved(_p387),
														_1: res
													}
												};
											},
											_user$project$UpdateUtils$fixStringDiffs(_p385)));
								}
							default:
								break _v534_6;
						}
				}
			} else {
				break _v534_6;
			}
		} else {
			return {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: 0
				},
				_1: {ctor: '[]'}
			};
		}
	} while(false);
	return A2(
		_user$project$UpdateUtils$priorityListMap,
		F2(
			function (x, y) {
				return {ctor: '::', _0: x, _1: y};
			})(_p367._0),
		_user$project$UpdateUtils$fixStringDiffs(_p367._1));
};
var _user$project$UpdateUtils$shiftAddedLeft = function (x) {
	return A2(_user$project$UpdateUtils$shiftLeft, _user$project$UpdateUtils$DiffAdded, x);
};
var _user$project$UpdateUtils$shiftLeft = F6(
	function (diffType, x, y, z, tail, acc) {
		var aux = F2(
			function (i, acc) {
				aux:
				while (true) {
					if ((_elm_lang$core$Native_Utils.cmp(
						i,
						_elm_lang$core$String$length(y)) > 0) || (_elm_lang$core$Native_Utils.cmp(
						i,
						_elm_lang$core$String$length(x)) > 0)) {
						return acc;
					} else {
						var rx = A2(_elm_lang$core$String$right, i, x);
						var ry = A2(_elm_lang$core$String$right, i, y);
						if (_elm_lang$core$Native_Utils.eq(rx, ry)) {
							var newX = A2(
								_elm_lang$core$String$left,
								_elm_lang$core$String$length(x) - i,
								x);
							var addNewX = _elm_lang$core$Native_Utils.eq(
								_elm_lang$core$String$length(newX),
								0) ? _elm_lang$core$Basics$identity : F2(
								function (x, y) {
									return {ctor: '::', _0: x, _1: y};
								})(
								_user$project$UpdateUtils$DiffEqual(newX));
							var newY = A2(
								_elm_lang$core$Basics_ops['++'],
								rx,
								A2(
									_elm_lang$core$String$left,
									_elm_lang$core$String$length(y) - i,
									y));
							var newZ = A2(_elm_lang$core$Basics_ops['++'], rx, z);
							var delta = _user$project$UpdateUtils$heuristicOf(newY);
							var newSolutions = A3(
								_user$project$UpdateUtils$priorityListMapDelta,
								delta,
								function (res) {
									return addNewX(
										{
											ctor: '::',
											_0: diffType(newY),
											_1: res
										});
								},
								_user$project$UpdateUtils$fixStringDiffs(
									{
										ctor: '::',
										_0: _user$project$UpdateUtils$DiffEqual(newZ),
										_1: tail
									}));
							var _v535 = i + 1,
								_v536 = A2(_user$project$UpdateUtils$priorityListMerge, newSolutions, acc);
							i = _v535;
							acc = _v536;
							continue aux;
						} else {
							return acc;
						}
					}
				}
			});
		return A2(aux, 1, acc);
	});
var _user$project$UpdateUtils$shiftAddedRight = function (x) {
	return A2(_user$project$UpdateUtils$shiftRight, _user$project$UpdateUtils$DiffAdded, x);
};
var _user$project$UpdateUtils$shiftRight = F6(
	function (diffType, x, y, z, tail, acc) {
		var aux = F2(
			function (i, acc) {
				aux:
				while (true) {
					if ((_elm_lang$core$Native_Utils.cmp(
						i,
						_elm_lang$core$String$length(y)) > 0) || (_elm_lang$core$Native_Utils.cmp(
						i,
						_elm_lang$core$String$length(z)) > 0)) {
						return acc;
					} else {
						var ry = A2(_elm_lang$core$String$left, i, y);
						var rz = A2(_elm_lang$core$String$left, i, z);
						if (_elm_lang$core$Native_Utils.eq(ry, rz)) {
							var newX = A2(_elm_lang$core$Basics_ops['++'], x, ry);
							var newY = A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_elm_lang$core$String$dropLeft, i, y),
								ry);
							var newZ = A2(_elm_lang$core$String$dropLeft, i, z);
							var addNewZ = _elm_lang$core$Native_Utils.eq(
								_elm_lang$core$String$length(newZ),
								0) ? _elm_lang$core$Basics$identity : F2(
								function (x, y) {
									return {ctor: '::', _0: x, _1: y};
								})(
								_user$project$UpdateUtils$DiffEqual(newZ));
							var delta = _user$project$UpdateUtils$heuristicOf(newY);
							var newSolutions = A3(
								_user$project$UpdateUtils$priorityListMapDelta,
								delta,
								function (res) {
									return {
										ctor: '::',
										_0: _user$project$UpdateUtils$DiffEqual(newX),
										_1: {
											ctor: '::',
											_0: diffType(newY),
											_1: res
										}
									};
								},
								_user$project$UpdateUtils$fixStringDiffs(
									addNewZ(tail)));
							var _v537 = i + 1,
								_v538 = A2(_user$project$UpdateUtils$priorityListMerge, newSolutions, acc);
							i = _v537;
							acc = _v538;
							continue aux;
						} else {
							return acc;
						}
					}
				}
			});
		return A2(aux, 1, acc);
	});
var _user$project$UpdateUtils$shiftRemovedLeft = function (x) {
	return A2(_user$project$UpdateUtils$shiftLeft, _user$project$UpdateUtils$DiffRemoved, x);
};
var _user$project$UpdateUtils$shiftRemovedRight = function (x) {
	return A2(_user$project$UpdateUtils$shiftRight, _user$project$UpdateUtils$DiffRemoved, x);
};
var _user$project$UpdateUtils$allStringDiffs = F2(
	function (a, b) {
		return _user$project$Results$oks(
			_user$project$UpdateUtils$priorityListToList(
				_user$project$UpdateUtils$fixStringDiffs(
					A2(_user$project$ImpureGoodies$diffString, a, b))));
	});
var _user$project$UpdateUtils$defaultStringDiffs = F2(
	function (before, after) {
		return _elm_lang$core$Native_Utils.eq(before, after) ? _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing) : A2(
			_user$project$Results$andThen,
			function (difference) {
				var aux = F3(
					function (i, diffs, revAccDiffs) {
						aux:
						while (true) {
							var _p388 = diffs;
							if (_p388.ctor === '[]') {
								var _p389 = _elm_lang$core$List$reverse(revAccDiffs);
								if (_p389.ctor === '[]') {
									return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
								} else {
									return _user$project$Results$ok1(
										_elm_lang$core$Maybe$Just(_p389));
								}
							} else {
								switch (_p388._0.ctor) {
									case 'DiffEqual':
										var _v541 = i + _elm_lang$core$String$length(_p388._0._0),
											_v542 = _p388._1,
											_v543 = revAccDiffs;
										i = _v541;
										diffs = _v542;
										revAccDiffs = _v543;
										continue aux;
									case 'DiffRemoved':
										if ((_p388._1.ctor === '::') && (_p388._1._0.ctor === 'DiffAdded')) {
											var lengthRemoved = _elm_lang$core$String$length(_p388._0._0);
											var lengthAdded = _elm_lang$core$String$length(_p388._1._0._0);
											var _v544 = i + lengthRemoved,
												_v545 = _p388._1._1,
												_v546 = {
												ctor: '::',
												_0: A3(_user$project$Lang$StringUpdate, i, i + lengthRemoved, lengthAdded),
												_1: revAccDiffs
											};
											i = _v544;
											diffs = _v545;
											revAccDiffs = _v546;
											continue aux;
										} else {
											var lengthRemoved = _elm_lang$core$String$length(_p388._0._0);
											var _v547 = i + lengthRemoved,
												_v548 = _p388._1,
												_v549 = {
												ctor: '::',
												_0: A3(_user$project$Lang$StringUpdate, i, i + lengthRemoved, 0),
												_1: revAccDiffs
											};
											i = _v547;
											diffs = _v548;
											revAccDiffs = _v549;
											continue aux;
										}
									default:
										var lengthAdded = _elm_lang$core$String$length(_p388._0._0);
										var _v550 = i,
											_v551 = _p388._1,
											_v552 = {
											ctor: '::',
											_0: A3(_user$project$Lang$StringUpdate, i, i, lengthAdded),
											_1: revAccDiffs
										};
										i = _v550;
										diffs = _v551;
										revAccDiffs = _v552;
										continue aux;
								}
							}
						}
					});
				return A3(
					aux,
					0,
					difference,
					{ctor: '[]'});
			},
			A2(_user$project$UpdateUtils$allStringDiffs, before, after));
	});
var _user$project$UpdateUtils$regroupDiffs = function (diffs2) {
	var assembleDiffs = F3(
		function (acc, currentModif, thediffs) {
			assembleDiffs:
			while (true) {
				var _p390 = {ctor: '_Tuple2', _0: currentModif, _1: thediffs};
				_v553_3:
				do {
					if (_p390._0.ctor === 'Just') {
						if (_p390._1.ctor === '::') {
							switch (_p390._0._0.ctor) {
								case 'DiffEqual':
									if (_p390._1._0.ctor === 'DiffEqual') {
										var _v554 = acc,
											_v555 = _elm_lang$core$Maybe$Just(
											_user$project$UpdateUtils$DiffEqual(
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p390._0._0._0,
													{
														ctor: '::',
														_0: _p390._1._0._0,
														_1: {ctor: '[]'}
													}))),
											_v556 = _p390._1._1;
										acc = _v554;
										currentModif = _v555;
										thediffs = _v556;
										continue assembleDiffs;
									} else {
										break _v553_3;
									}
								case 'DiffRemoved':
									if (_p390._1._0.ctor === 'DiffRemoved') {
										var _v557 = acc,
											_v558 = _elm_lang$core$Maybe$Just(
											_user$project$UpdateUtils$DiffRemoved(
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p390._0._0._0,
													{
														ctor: '::',
														_0: _p390._1._0._0,
														_1: {ctor: '[]'}
													}))),
											_v559 = _p390._1._1;
										acc = _v557;
										currentModif = _v558;
										thediffs = _v559;
										continue assembleDiffs;
									} else {
										break _v553_3;
									}
								default:
									if (_p390._1._0.ctor === 'DiffAdded') {
										var _v560 = acc,
											_v561 = _elm_lang$core$Maybe$Just(
											_user$project$UpdateUtils$DiffAdded(
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p390._0._0._0,
													{
														ctor: '::',
														_0: _p390._1._0._0,
														_1: {ctor: '[]'}
													}))),
											_v562 = _p390._1._1;
										acc = _v560;
										currentModif = _v561;
										thediffs = _v562;
										continue assembleDiffs;
									} else {
										break _v553_3;
									}
							}
						} else {
							break _v553_3;
						}
					} else {
						if (_p390._1.ctor === '[]') {
							return acc;
						} else {
							switch (_p390._1._0.ctor) {
								case 'DiffEqual':
									var _v563 = acc,
										_v564 = _elm_lang$core$Maybe$Just(
										_user$project$UpdateUtils$DiffEqual(
											{
												ctor: '::',
												_0: _p390._1._0._0,
												_1: {ctor: '[]'}
											})),
										_v565 = _p390._1._1;
									acc = _v563;
									currentModif = _v564;
									thediffs = _v565;
									continue assembleDiffs;
								case 'DiffRemoved':
									var _v566 = acc,
										_v567 = _elm_lang$core$Maybe$Just(
										_user$project$UpdateUtils$DiffRemoved(
											{
												ctor: '::',
												_0: _p390._1._0._0,
												_1: {ctor: '[]'}
											})),
										_v568 = _p390._1._1;
									acc = _v566;
									currentModif = _v567;
									thediffs = _v568;
									continue assembleDiffs;
								default:
									var _v569 = acc,
										_v570 = _elm_lang$core$Maybe$Just(
										_user$project$UpdateUtils$DiffAdded(
											{
												ctor: '::',
												_0: _p390._1._0._0,
												_1: {ctor: '[]'}
											})),
										_v571 = _p390._1._1;
									acc = _v569;
									currentModif = _v570;
									thediffs = _v571;
									continue assembleDiffs;
							}
						}
					}
				} while(false);
				var _v572 = A2(
					_elm_lang$core$Basics_ops['++'],
					acc,
					{
						ctor: '::',
						_0: _p390._0._0,
						_1: {ctor: '[]'}
					}),
					_v573 = _elm_lang$core$Maybe$Nothing,
					_v574 = _p390._1;
				acc = _v572;
				currentModif = _v573;
				thediffs = _v574;
				continue assembleDiffs;
			}
		});
	return A3(
		assembleDiffs,
		{ctor: '[]'},
		_elm_lang$core$Maybe$Nothing,
		diffs2);
};
var _user$project$UpdateUtils$alignRecordDatatypes = F4(
	function (datatypeNameOf, removed, added, difftailglobal) {
		var withDatatypes = function (l) {
			return A2(
				_elm_lang$core$List$map,
				function (elem) {
					return {
						ctor: '_Tuple2',
						_0: elem,
						_1: datatypeNameOf(elem)
					};
				},
				l);
		};
		var resDataTypeDifferences = A3(
			_user$project$UpdateUtils$alldiffs,
			function (_p391) {
				var _p392 = _p391;
				return A2(_elm_lang$core$Maybe$withDefault, '', _p392._1);
			},
			withDatatypes(removed),
			withDatatypes(added));
		var _p393 = resDataTypeDifferences;
		if (((((_p393.ctor === 'Ok') && (_p393._0.ctor === 'Cons')) && (_p393._0._0.ctor === '::')) && (_p393._0._0._0.ctor === 'DiffEqual')) && (_p393._0._0._1.ctor === '[]')) {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Just(
				A2(
					_user$project$Results$map,
					function (datatypedifferences) {
						var aux = F4(
							function (diffs, removed, added, revAccDiffs) {
								aux:
								while (true) {
									var _p394 = diffs;
									if (_p394.ctor === '[]') {
										return A2(_user$project$Utils$reverseInsert, revAccDiffs, difftailglobal);
									} else {
										switch (_p394._0.ctor) {
											case 'DiffEqual':
												var count = _elm_lang$core$List$length(_p394._0._0);
												var _p395 = A2(_user$project$Utils$split, count, removed);
												var removedTaken = _p395._0;
												var removedRemaining = _p395._1;
												var _p396 = A2(_user$project$Utils$split, count, added);
												var addedTaken = _p396._0;
												var addedRemaining = _p396._1;
												var _v578 = _p394._1,
													_v579 = removedRemaining,
													_v580 = addedRemaining,
													_v581 = {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(
														{ctor: '[]'}),
													_1: {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffAdded(addedTaken),
														_1: {
															ctor: '::',
															_0: _user$project$UpdateUtils$DiffRemoved(removedTaken),
															_1: revAccDiffs
														}
													}
												};
												diffs = _v578;
												removed = _v579;
												added = _v580;
												revAccDiffs = _v581;
												continue aux;
											case 'DiffRemoved':
												var count = _elm_lang$core$List$length(_p394._0._0);
												var _p397 = A2(_user$project$Utils$split, count, removed);
												var removedTaken = _p397._0;
												var removedRemaining = _p397._1;
												var _v582 = _p394._1,
													_v583 = removedRemaining,
													_v584 = added,
													_v585 = {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(
														{ctor: '[]'}),
													_1: {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffRemoved(removedTaken),
														_1: revAccDiffs
													}
												};
												diffs = _v582;
												removed = _v583;
												added = _v584;
												revAccDiffs = _v585;
												continue aux;
											default:
												var count = _elm_lang$core$List$length(_p394._0._0);
												var _p398 = A2(_user$project$Utils$split, count, added);
												var addedTaken = _p398._0;
												var addedRemaining = _p398._1;
												var _v586 = _p394._1,
													_v587 = removed,
													_v588 = addedRemaining,
													_v589 = {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(
														{ctor: '[]'}),
													_1: {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffAdded(addedTaken),
														_1: revAccDiffs
													}
												};
												diffs = _v586;
												removed = _v587;
												added = _v588;
												revAccDiffs = _v589;
												continue aux;
										}
									}
								}
							});
						return A4(
							aux,
							datatypedifferences,
							removed,
							added,
							{ctor: '[]'});
					},
					resDataTypeDifferences));
		}
	});
var _user$project$UpdateUtils$defaultListDiffs = F5(
	function (keyOf, datatypeNameOf, defaultElemModif, elems1, elems2) {
		return A2(
			_user$project$Results$andThen,
			function (difference) {
				var aux = F3(
					function (i, accDiffs, diffs) {
						aux:
						while (true) {
							var _p399 = diffs;
							if (_p399.ctor === '[]') {
								var _p400 = _elm_lang$core$List$reverse(accDiffs);
								if (_p400.ctor === '[]') {
									return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
								} else {
									return _user$project$Results$ok1(
										_elm_lang$core$Maybe$Just(_p400));
								}
							} else {
								switch (_p399._0.ctor) {
									case 'DiffEqual':
										var _v592 = i + _elm_lang$core$List$length(_p399._0._0),
											_v593 = accDiffs,
											_v594 = _p399._1;
										i = _v592;
										accDiffs = _v593;
										diffs = _v594;
										continue aux;
									case 'DiffRemoved':
										if ((_p399._1.ctor === '::') && (_p399._1._0.ctor === 'DiffAdded')) {
											var _p404 = _p399._0._0;
											var _p403 = _p399._1._1;
											var _p402 = _p399._1._0._0;
											var _p401 = A4(_user$project$UpdateUtils$alignRecordDatatypes, datatypeNameOf, _p404, _p402, _p403);
											if (_p401.ctor === 'Just') {
												return A2(
													_user$project$Results$andThen,
													A2(aux, i, accDiffs),
													_p401._0);
											} else {
												var lengthRemoved = _elm_lang$core$List$length(_p404);
												var lengthAdded = _elm_lang$core$List$length(_p402);
												var toInsertRes = A4(
													_elm_lang$core$List$map3,
													F3(
														function (i, r, a) {
															return A2(
																_user$project$Results$map,
																_elm_lang$core$Maybe$map(
																	function (v) {
																		return {
																			ctor: '_Tuple2',
																			_0: i,
																			_1: _user$project$Lang$ListElemUpdate(v)
																		};
																	}),
																A2(defaultElemModif, r, a));
														}),
													A2(_elm_lang$core$List$range, i, (i + lengthAdded) - 1),
													_p404,
													_p402);
												return A2(
													_user$project$Results$andThen,
													A3(
														F4(
															function (i, lengthRemoved, difftail, toInsert) {
																var accDiffs1 = A2(_user$project$Utils$maybeReverseInsert, toInsert, accDiffs);
																var accDiffs2 = (_elm_lang$core$Native_Utils.cmp(lengthRemoved, lengthAdded) > 0) ? {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i + lengthAdded,
																		_1: _user$project$Lang$ListElemDelete(lengthRemoved - lengthAdded)
																	},
																	_1: accDiffs1
																} : accDiffs1;
																var accDiffs3 = (_elm_lang$core$Native_Utils.cmp(lengthAdded, lengthRemoved) > 0) ? {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: i + lengthRemoved,
																		_1: _user$project$Lang$ListElemInsert(lengthAdded - lengthRemoved)
																	},
																	_1: accDiffs2
																} : accDiffs2;
																return A3(aux, i + lengthRemoved, accDiffs3, difftail);
															}),
														i,
														lengthRemoved,
														_p403),
													_user$project$Results$projOk(toInsertRes));
											}
										} else {
											var removedLength = _elm_lang$core$List$length(_p399._0._0);
											var _v596 = i + removedLength,
												_v597 = {
												ctor: '::',
												_0: {
													ctor: '_Tuple2',
													_0: i,
													_1: _user$project$Lang$ListElemDelete(removedLength)
												},
												_1: accDiffs
											},
												_v598 = _p399._1;
											i = _v596;
											accDiffs = _v597;
											diffs = _v598;
											continue aux;
										}
									default:
										var addedLength = _elm_lang$core$List$length(_p399._0._0);
										var _v599 = i,
											_v600 = {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: i,
												_1: _user$project$Lang$ListElemInsert(addedLength)
											},
											_1: accDiffs
										},
											_v601 = _p399._1;
										i = _v599;
										accDiffs = _v600;
										diffs = _v601;
										continue aux;
								}
							}
						}
					});
				return A3(
					aux,
					0,
					{ctor: '[]'},
					difference);
			},
			A3(_user$project$UpdateUtils$alldiffs, keyOf, elems1, elems2));
	});
var _user$project$UpdateUtils$defaultEDiffs = F2(
	function (e1, e2) {
		var _p405 = {
			ctor: '_Tuple2',
			_0: _user$project$Lang$unwrapExp(e1),
			_1: _user$project$Lang$unwrapExp(e2)
		};
		_v602_4:
		do {
			switch (_p405._0.ctor) {
				case 'EConst':
					if (_p405._1.ctor === 'EConst') {
						return _elm_lang$core$Native_Utils.eq(_p405._0._1, _p405._1._1) ? _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing) : _user$project$Results$ok1(
							_elm_lang$core$Maybe$Just(
								_user$project$Lang$EConstDiffs(_user$project$Lang$EAnyDiffs)));
					} else {
						break _v602_4;
					}
				case 'EBase':
					if (_p405._1.ctor === 'EBase') {
						if ((_p405._0._1.ctor === 'EString') && (_p405._1._1.ctor === 'EString')) {
							return A2(
								_user$project$Results$map,
								_elm_lang$core$Maybe$map(_user$project$Lang$EStringDiffs),
								A2(_user$project$UpdateUtils$defaultStringDiffs, _p405._0._1._1, _p405._1._1._1));
						} else {
							return _elm_lang$core$Native_Utils.eq(_p405._0._1, _p405._1._1) ? _user$project$Results$ok1(
								_elm_lang$core$Maybe$Just(
									_user$project$Lang$EConstDiffs(_user$project$Lang$EAnyDiffs))) : _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
						}
					} else {
						break _v602_4;
					}
				case 'EList':
					if (((_p405._0._3.ctor === 'Nothing') && (_p405._1.ctor === 'EList')) && (_p405._1._3.ctor === 'Nothing')) {
						return A2(
							_user$project$Results$map,
							_elm_lang$core$Maybe$map(_user$project$Lang$EListDiffs),
							A5(
								_user$project$UpdateUtils$defaultListDiffs,
								_user$project$Syntax$unparser(_user$project$Syntax$Leo),
								function (_p406) {
									return _elm_lang$core$Maybe$Nothing;
								},
								_user$project$UpdateUtils$defaultEDiffs,
								_user$project$Utils$listValues(_p405._0._1),
								_user$project$Utils$listValues(_p405._1._1)));
					} else {
						break _v602_4;
					}
				default:
					break _v602_4;
			}
		} while(false);
		return A2(
			_user$project$Results$map,
			_elm_lang$core$Maybe$map(_user$project$Lang$EChildDiffs),
			A4(
				_user$project$UpdateUtils$defaultTupleDiffs,
				_user$project$Syntax$unparser(_user$project$Syntax$Leo),
				_user$project$UpdateUtils$defaultEDiffs,
				_user$project$Lang$childExps(e1),
				_user$project$Lang$childExps(e2)));
	});
var _user$project$UpdateUtils$defaultVDiffsRec = F4(
	function (testEquality, recurse, original, modified) {
		var _p407 = {ctor: '_Tuple2', _0: original.v_, _1: modified.v_};
		_v603_5:
		do {
			switch (_p407._0.ctor) {
				case 'VList':
					if (_p407._1.ctor === 'VList') {
						return A2(
							_user$project$Results$map,
							_elm_lang$core$Maybe$map(_user$project$Lang$VListDiffs),
							A5(
								_user$project$UpdateUtils$defaultListDiffs,
								_user$project$LangUtils$valToString,
								function (v) {
									return A2(
										_user$project$Utils$maybeOrElseLazy,
										function (_p408) {
											var _p409 = _p408;
											return _user$project$Lang$getViewDatatypeName(v);
										},
										_user$project$Lang$getDatatypeName(v));
								},
								recurse,
								_p407._0._0,
								_p407._1._0));
					} else {
						break _v603_5;
					}
				case 'VBase':
					if (((_p407._0._0.ctor === 'VString') && (_p407._1.ctor === 'VBase')) && (_p407._1._0.ctor === 'VString')) {
						return A2(
							_user$project$Results$map,
							_elm_lang$core$Maybe$map(_user$project$Lang$VStringDiffs),
							A2(_user$project$UpdateUtils$defaultStringDiffs, _p407._0._0._0, _p407._1._0._0));
					} else {
						break _v603_5;
					}
				case 'VClosure':
					if (_p407._1.ctor === 'VClosure') {
						var _p413 = _p407._1._2;
						var _p412 = _p407._0._2;
						var ids = A2(
							_elm_lang$core$Set$union,
							A2(
								_elm_lang$core$Set$diff,
								_user$project$Lang$identifiersSet(_p412),
								_user$project$Lang$identifiersSetInPats(_p407._0._1)),
							A2(
								_elm_lang$core$Set$diff,
								_user$project$Lang$identifiersSet(_p413),
								_user$project$Lang$identifiersSetInPats(_p407._1._1)));
						return A2(
							_user$project$Results$andThen,
							function (mbEnvDiff) {
								return A2(
									_user$project$Results$map,
									function (mbEDiff) {
										var _p410 = mbEnvDiff;
										if (_p410.ctor === 'Nothing') {
											var _p411 = mbEDiff;
											if (_p411.ctor === 'Nothing') {
												return _elm_lang$core$Maybe$Nothing;
											} else {
												return _elm_lang$core$Maybe$Just(
													A2(
														_user$project$Lang$VClosureDiffs,
														{ctor: '[]'},
														mbEDiff));
											}
										} else {
											return _elm_lang$core$Maybe$Just(
												A2(_user$project$Lang$VClosureDiffs, _p410._0, mbEDiff));
										}
									},
									A2(_user$project$UpdateUtils$defaultEDiffs, _p412, _p413));
							},
							A5(_user$project$UpdateUtils$defaultEnvDiffsRec, testEquality, recurse, ids, _p407._0._3, _p407._1._3));
					} else {
						break _v603_5;
					}
				case 'VDict':
					if (_p407._1.ctor === 'VDict') {
						return A4(_user$project$UpdateUtils$defaultDictDiffs, _user$project$LangUtils$valToString, recurse, _p407._0._0, _p407._1._0);
					} else {
						break _v603_5;
					}
				case 'VRecord':
					if (_p407._1.ctor === 'VRecord') {
						var _p417 = _p407._0._0;
						var _p416 = _p407._1._0;
						var _p414 = {
							ctor: '_Tuple2',
							_0: A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorDataType, _p417),
							_1: A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorDataType, _p416)
						};
						if (_p414._0.ctor === 'Just') {
							if (_p414._1.ctor === 'Just') {
								var _p415 = {ctor: '_Tuple2', _0: _p414._0._0.v_, _1: _p414._1._0.v_};
								if (((((_p415.ctor === '_Tuple2') && (_p415._0.ctor === 'VBase')) && (_p415._0._0.ctor === 'VString')) && (_p415._1.ctor === 'VBase')) && (_p415._1._0.ctor === 'VString')) {
									return _elm_lang$core$Native_Utils.eq(_p415._0._0._0, _p415._1._0._0) ? A4(_user$project$UpdateUtils$defaultRecordDiffs, _user$project$LangUtils$valToString, recurse, _p417, _p416) : _user$project$Results$ok1(
										_elm_lang$core$Maybe$Just(_user$project$Lang$VConstDiffs));
								} else {
									return A4(_user$project$UpdateUtils$defaultRecordDiffs, _user$project$LangUtils$valToString, recurse, _p417, _p416);
								}
							} else {
								return _user$project$Results$ok1(
									_elm_lang$core$Maybe$Just(_user$project$Lang$VConstDiffs));
							}
						} else {
							if (_p414._1.ctor === 'Just') {
								return _user$project$Results$ok1(
									_elm_lang$core$Maybe$Just(_user$project$Lang$VConstDiffs));
							} else {
								return A4(_user$project$UpdateUtils$defaultRecordDiffs, _user$project$LangUtils$valToString, recurse, _p417, _p416);
							}
						}
					} else {
						break _v603_5;
					}
				default:
					break _v603_5;
			}
		} while(false);
		return A2(_user$project$LangUtils$valEqual, original, modified) ? _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing) : _user$project$Results$ok1(
			_elm_lang$core$Maybe$Just(_user$project$Lang$VConstDiffs));
	});
var _user$project$UpdateUtils$defaultEnvDiffsRec = F5(
	function (testEquality, recurse, identsToCompare, elems1, elems2) {
		var aux = F5(
			function (i, identsToCompare, revEnvDiffs, envToCollect1, envToCollect2) {
				aux:
				while (true) {
					if (_elm_lang$core$Set$isEmpty(identsToCompare)) {
						var _p418 = _elm_lang$core$List$reverse(revEnvDiffs);
						if (_p418.ctor === '[]') {
							return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
						} else {
							return _user$project$Results$ok1(
								_elm_lang$core$Maybe$Just(_p418));
						}
					} else {
						var _p419 = {ctor: '_Tuple2', _0: envToCollect1, _1: envToCollect2};
						_v610_2:
						do {
							if (_p419.ctor === '_Tuple2') {
								if (_p419._0.ctor === '[]') {
									if (_p419._1.ctor === '[]') {
										var _p420 = _elm_lang$core$List$reverse(revEnvDiffs);
										if (_p420.ctor === '[]') {
											return _user$project$Results$ok1(_elm_lang$core$Maybe$Nothing);
										} else {
											return _user$project$Results$ok1(
												_elm_lang$core$Maybe$Just(_p420));
										}
									} else {
										break _v610_2;
									}
								} else {
									if (((_p419._0._0.ctor === '_Tuple2') && (_p419._1.ctor === '::')) && (_p419._1._0.ctor === '_Tuple2')) {
										var _p427 = _p419._1._0._1;
										var _p426 = _p419._0._0._1;
										var _p425 = _p419._1._0._0;
										var _p424 = _p419._0._0._0;
										var _p423 = _p419._1._1;
										var _p422 = _p419._0._1;
										if (!_elm_lang$core$Native_Utils.eq(_p424, _p425)) {
											return _elm_lang$core$Result$Err(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'trying to compute a diff on unaligned environments ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p424,
														A2(_elm_lang$core$Basics_ops['++'], ',', _p425))));
										} else {
											if (!A2(_elm_lang$core$Set$member, _p424, identsToCompare)) {
												var _v612 = i + 1,
													_v613 = identsToCompare,
													_v614 = revEnvDiffs,
													_v615 = _p422,
													_v616 = _p423;
												i = _v612;
												identsToCompare = _v613;
												revEnvDiffs = _v614;
												envToCollect1 = _v615;
												envToCollect2 = _v616;
												continue aux;
											} else {
												if (testEquality && A2(_user$project$UpdateUtils$valEqualDiff, _p426, _p427)) {
													var _v617 = i + 1,
														_v618 = A2(_elm_lang$core$Set$remove, _p424, identsToCompare),
														_v619 = revEnvDiffs,
														_v620 = _p422,
														_v621 = _p423;
													i = _v617;
													identsToCompare = _v618;
													revEnvDiffs = _v619;
													envToCollect1 = _v620;
													envToCollect2 = _v621;
													continue aux;
												} else {
													return A2(
														_user$project$Results$andThen,
														A6(
															F7(
																function (i, k1, identsToCompare, etl1, etl2, revEnvDiffs, mbv) {
																	var newRevEnvDiffs = function () {
																		var _p421 = mbv;
																		if (_p421.ctor === 'Nothing') {
																			return revEnvDiffs;
																		} else {
																			return {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: i, _1: _p421._0},
																				_1: revEnvDiffs
																			};
																		}
																	}();
																	return A5(
																		aux,
																		i + 1,
																		A2(_elm_lang$core$Set$remove, k1, identsToCompare),
																		newRevEnvDiffs,
																		etl1,
																		etl2);
																}),
															i,
															_p424,
															identsToCompare,
															_p422,
															_p423,
															revEnvDiffs),
														A2(recurse, _p426, _p427));
												}
											}
										}
									} else {
										break _v610_2;
									}
								}
							} else {
								break _v610_2;
							}
						} while(false);
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Environments do not have the same size: ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$envToString(envToCollect1),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$envToString(envToCollect2)))));
					}
				}
			});
		return A5(
			aux,
			0,
			identsToCompare,
			{ctor: '[]'},
			elems1,
			elems2);
	});
var _user$project$UpdateUtils$valEqualDiff = F2(
	function (original, modified) {
		var _p428 = A2(_user$project$UpdateUtils$defaultVDiffs, original, modified);
		if (((_p428.ctor === 'Ok') && (_p428._0.ctor === 'Cons')) && (_p428._0._0.ctor === 'Nothing')) {
			return true;
		} else {
			return false;
		}
	});
var _user$project$UpdateUtils$defaultVDiffs = F2(
	function (original, modified) {
		return A4(_user$project$UpdateUtils$defaultVDiffsRec, true, _user$project$UpdateUtils$defaultVDiffs, original, modified);
	});
var _user$project$UpdateUtils$defaultEnvDiffs = A2(_user$project$UpdateUtils$defaultEnvDiffsRec, true, _user$project$UpdateUtils$defaultVDiffs);
var _user$project$UpdateUtils$Diff3Conflict = F2(
	function (a, b) {
		return {ctor: 'Diff3Conflict', _0: a, _1: b};
	});
var _user$project$UpdateUtils$Diff3Merged = function (a) {
	return {ctor: 'Diff3Merged', _0: a};
};
var _user$project$UpdateUtils$diff3ChunkMap = F2(
	function (f, d) {
		var _p429 = d;
		if (_p429.ctor === 'Diff3Merged') {
			return _user$project$UpdateUtils$Diff3Merged(
				A2(_user$project$UpdateUtils$diffChunkMap, f, _p429._0));
		} else {
			return A2(
				_user$project$UpdateUtils$Diff3Conflict,
				A2(
					_elm_lang$core$List$map,
					_user$project$UpdateUtils$diffChunkMap(f),
					_p429._0),
				A2(
					_elm_lang$core$List$map,
					_user$project$UpdateUtils$diffChunkMap(f),
					_p429._1));
		}
	});
var _user$project$UpdateUtils$diff3 = F4(
	function (keyOf, original, update1, update2) {
		var modifs1 = A3(_user$project$UpdateUtils$diff, keyOf, original, update1);
		var modifs2 = A3(_user$project$UpdateUtils$diff, keyOf, original, update2);
		var flattenDiff = function (diff) {
			var _p430 = diff;
			switch (_p430.ctor) {
				case 'DiffEqual':
					return A2(_elm_lang$core$List$map, _user$project$UpdateUtils$DiffEqual, _p430._0);
				case 'DiffAdded':
					return A2(_elm_lang$core$List$map, _user$project$UpdateUtils$DiffAdded, _p430._0);
				default:
					return A2(_elm_lang$core$List$map, _user$project$UpdateUtils$DiffRemoved, _p430._0);
			}
		};
		var newKeyOf = function (d) {
			var _p431 = d;
			switch (_p431.ctor) {
				case 'DiffEqual':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'=',
						keyOf(_p431._0));
				case 'DiffAdded':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'+',
						keyOf(_p431._0));
				default:
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'-',
						keyOf(_p431._0));
			}
		};
		var diff1 = A2(_elm_lang$core$List$concatMap, flattenDiff, modifs1);
		var diff2 = A2(_elm_lang$core$List$concatMap, flattenDiff, modifs2);
		var diffOfDiffs = A3(_user$project$UpdateUtils$diff, newKeyOf, diff1, diff2);
		var convertDiffs = F2(
			function (acc, thediffs) {
				convertDiffs:
				while (true) {
					var _p432 = thediffs;
					if (_p432.ctor === '[]') {
						return acc;
					} else {
						switch (_p432._0.ctor) {
							case 'DiffEqual':
								var _v628 = A2(
									_elm_lang$core$Basics_ops['++'],
									acc,
									A2(_elm_lang$core$List$map, _user$project$UpdateUtils$Diff3Merged, _p432._0._0)),
									_v629 = _p432._1;
								acc = _v628;
								thediffs = _v629;
								continue convertDiffs;
							case 'DiffRemoved':
								if ((_p432._1.ctor === '::') && (_p432._1._0.ctor === 'DiffAdded')) {
									var _v630 = A2(
										_elm_lang$core$Basics_ops['++'],
										acc,
										{
											ctor: '::',
											_0: A2(_user$project$UpdateUtils$Diff3Conflict, _p432._0._0, _p432._1._0._0),
											_1: {ctor: '[]'}
										}),
										_v631 = _p432._1._1;
									acc = _v630;
									thediffs = _v631;
									continue convertDiffs;
								} else {
									var _v632 = A2(
										_elm_lang$core$Basics_ops['++'],
										acc,
										A2(_elm_lang$core$List$map, _user$project$UpdateUtils$Diff3Merged, _p432._0._0)),
										_v633 = _p432._1;
									acc = _v632;
									thediffs = _v633;
									continue convertDiffs;
								}
							default:
								var _v634 = A2(
									_elm_lang$core$Basics_ops['++'],
									acc,
									A2(_elm_lang$core$List$map, _user$project$UpdateUtils$Diff3Merged, _p432._0._0)),
									_v635 = _p432._1;
								acc = _v634;
								thediffs = _v635;
								continue convertDiffs;
						}
					}
				}
			});
		return A2(
			convertDiffs,
			{ctor: '[]'},
			diffOfDiffs);
	});
var _user$project$UpdateUtils$autodiff3 = F5(
	function (keyOf, conflictPolicy, original, update1, update2) {
		var originalDiff = A4(_user$project$UpdateUtils$diff3, keyOf, original, update1, update2);
		var assembleDiffs = F3(
			function (acc, currentModif, thediffs) {
				assembleDiffs:
				while (true) {
					var _p433 = {ctor: '_Tuple2', _0: currentModif, _1: thediffs};
					_v636_3:
					do {
						if (_p433._0.ctor === 'Just') {
							if ((_p433._1.ctor === '::') && (_p433._1._0.ctor === 'Diff3Merged')) {
								switch (_p433._0._0.ctor) {
									case 'DiffEqual':
										if (_p433._1._0._0.ctor === 'DiffEqual') {
											var _v637 = acc,
												_v638 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffEqual(
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p433._0._0._0,
														{
															ctor: '::',
															_0: _p433._1._0._0._0,
															_1: {ctor: '[]'}
														}))),
												_v639 = _p433._1._1;
											acc = _v637;
											currentModif = _v638;
											thediffs = _v639;
											continue assembleDiffs;
										} else {
											break _v636_3;
										}
									case 'DiffRemoved':
										if (_p433._1._0._0.ctor === 'DiffRemoved') {
											var _v640 = acc,
												_v641 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffRemoved(
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p433._0._0._0,
														{
															ctor: '::',
															_0: _p433._1._0._0._0,
															_1: {ctor: '[]'}
														}))),
												_v642 = _p433._1._1;
											acc = _v640;
											currentModif = _v641;
											thediffs = _v642;
											continue assembleDiffs;
										} else {
											break _v636_3;
										}
									default:
										if (_p433._1._0._0.ctor === 'DiffAdded') {
											var _v643 = acc,
												_v644 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffAdded(
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p433._0._0._0,
														{
															ctor: '::',
															_0: _p433._1._0._0._0,
															_1: {ctor: '[]'}
														}))),
												_v645 = _p433._1._1;
											acc = _v643;
											currentModif = _v644;
											thediffs = _v645;
											continue assembleDiffs;
										} else {
											break _v636_3;
										}
								}
							} else {
								break _v636_3;
							}
						} else {
							if (_p433._1.ctor === '[]') {
								return acc;
							} else {
								if (_p433._1._0.ctor === 'Diff3Merged') {
									switch (_p433._1._0._0.ctor) {
										case 'DiffEqual':
											var _v646 = acc,
												_v647 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffEqual(
													{
														ctor: '::',
														_0: _p433._1._0._0._0,
														_1: {ctor: '[]'}
													})),
												_v648 = _p433._1._1;
											acc = _v646;
											currentModif = _v647;
											thediffs = _v648;
											continue assembleDiffs;
										case 'DiffRemoved':
											var _v649 = acc,
												_v650 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffRemoved(
													{
														ctor: '::',
														_0: _p433._1._0._0._0,
														_1: {ctor: '[]'}
													})),
												_v651 = _p433._1._1;
											acc = _v649;
											currentModif = _v650;
											thediffs = _v651;
											continue assembleDiffs;
										default:
											var _v652 = acc,
												_v653 = _elm_lang$core$Maybe$Just(
												_user$project$UpdateUtils$DiffAdded(
													{
														ctor: '::',
														_0: _p433._1._0._0._0,
														_1: {ctor: '[]'}
													})),
												_v654 = _p433._1._1;
											acc = _v652;
											currentModif = _v653;
											thediffs = _v654;
											continue assembleDiffs;
									}
								} else {
									var _p434 = function () {
										var _p435 = _user$project$Utils$snocUnapply(acc);
										if (((_p435.ctor === 'Just') && (_p435._0.ctor === '_Tuple2')) && (_p435._0._1.ctor === 'DiffRemoved')) {
											return {ctor: '_Tuple2', _0: _p435._0._0, _1: _p435._0._1._0};
										} else {
											return {
												ctor: '_Tuple2',
												_0: acc,
												_1: {ctor: '[]'}
											};
										}
									}();
									var accNotRemoved = _p434._0;
									var accRemoved = _p434._1;
									var _v656 = A2(
										_elm_lang$core$Basics_ops['++'],
										accNotRemoved,
										_user$project$UpdateUtils$regroupDiffs(
											A3(conflictPolicy, accRemoved, _p433._1._0._0, _p433._1._0._1))),
										_v657 = _elm_lang$core$Maybe$Nothing,
										_v658 = _p433._1._1;
									acc = _v656;
									currentModif = _v657;
									thediffs = _v658;
									continue assembleDiffs;
								}
							}
						}
					} while(false);
					var _v659 = A2(
						_elm_lang$core$Basics_ops['++'],
						acc,
						{
							ctor: '::',
							_0: _p433._0._0,
							_1: {ctor: '[]'}
						}),
						_v660 = _elm_lang$core$Maybe$Nothing,
						_v661 = _p433._1;
					acc = _v659;
					currentModif = _v660;
					thediffs = _v661;
					continue assembleDiffs;
				}
			});
		return A3(
			assembleDiffs,
			{ctor: '[]'},
			_elm_lang$core$Maybe$Nothing,
			originalDiff);
	});
var _user$project$UpdateUtils$mergeListWithDiffs = F5(
	function (keyOf, submerger, original, modified1, modified2) {
		var maybeRemoved = function (r) {
			return A2(_elm_lang$core$List$map, _user$project$UpdateUtils$DiffRemoved, r);
		};
		var conflictPolicy = F3(
			function (previouslyRemoved, ld1, ld2) {
				var _p436 = {ctor: '_Tuple3', _0: previouslyRemoved, _1: ld1, _2: ld2};
				_v662_5:
				do {
					_v662_4:
					do {
						if (_p436._1.ctor === '[]') {
							return A2(
								_elm_lang$core$Basics_ops['++'],
								maybeRemoved(_p436._0),
								_p436._2);
						} else {
							if (_p436._2.ctor === '[]') {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									maybeRemoved(_p436._0),
									_p436._1);
							} else {
								switch (_p436._1._0.ctor) {
									case 'DiffRemoved':
										switch (_p436._2._0.ctor) {
											case 'DiffRemoved':
												return A2(
													_elm_lang$core$Basics_ops['++'],
													maybeRemoved(_p436._0),
													{
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffRemoved(_p436._1._0._0),
														_1: A3(
															conflictPolicy,
															{ctor: '[]'},
															_p436._1._1,
															_p436._2._1)
													});
											case 'DiffEqual':
												break _v662_4;
											default:
												break _v662_4;
										}
									case 'DiffEqual':
										switch (_p436._2._0.ctor) {
											case 'DiffRemoved':
												break _v662_5;
											case 'DiffEqual':
												return {
													ctor: '::',
													_0: _user$project$UpdateUtils$DiffEqual(_p436._1._0._0),
													_1: A3(
														conflictPolicy,
														{ctor: '[]'},
														_p436._1._1,
														_p436._2._1)
												};
											default:
												return {
													ctor: '::',
													_0: _p436._2._0,
													_1: A3(
														conflictPolicy,
														{ctor: '[]'},
														ld1,
														_p436._2._1)
												};
										}
									default:
										switch (_p436._2._0.ctor) {
											case 'DiffRemoved':
												break _v662_5;
											case 'DiffEqual':
												return {
													ctor: '::',
													_0: _p436._1._0,
													_1: A3(
														conflictPolicy,
														{ctor: '[]'},
														_p436._1._1,
														ld2)
												};
											default:
												if (_p436._0.ctor === '::') {
													var _p437 = _p436._0._0;
													return {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffRemoved(_p437),
														_1: {
															ctor: '::',
															_0: _user$project$UpdateUtils$DiffAdded(
																A3(submerger, _p437, _p436._1._0._0, _p436._2._0._0)),
															_1: A3(conflictPolicy, _p436._0._1, _p436._1._1, _p436._2._1)
														}
													};
												} else {
													return {
														ctor: '::',
														_0: _user$project$UpdateUtils$DiffAdded(_p436._1._0._0),
														_1: {
															ctor: '::',
															_0: _user$project$UpdateUtils$DiffAdded(_p436._2._0._0),
															_1: A3(
																conflictPolicy,
																{ctor: '[]'},
																_p436._1._1,
																_p436._2._1)
														}
													};
												}
										}
								}
							}
						}
					} while(false);
					return A2(
						_elm_lang$core$Basics_ops['++'],
						maybeRemoved(_p436._0),
						{
							ctor: '::',
							_0: _p436._2._0,
							_1: A3(
								conflictPolicy,
								{ctor: '[]'},
								ld1,
								_p436._2._1)
						});
				} while(false);
				return A2(
					_elm_lang$core$Basics_ops['++'],
					maybeRemoved(_p436._0),
					{
						ctor: '::',
						_0: _p436._1._0,
						_1: A3(
							conflictPolicy,
							{ctor: '[]'},
							_p436._1._1,
							ld2)
					});
			});
		var thediff = A5(_user$project$UpdateUtils$autodiff3, keyOf, conflictPolicy, original, modified1, modified2);
		var aux = F2(
			function (acc, thediff) {
				aux:
				while (true) {
					var _p438 = thediff;
					if (_p438.ctor === '[]') {
						return acc;
					} else {
						switch (_p438._0.ctor) {
							case 'DiffEqual':
								var _v664 = A2(_elm_lang$core$Basics_ops['++'], acc, _p438._0._0),
									_v665 = _p438._1;
								acc = _v664;
								thediff = _v665;
								continue aux;
							case 'DiffRemoved':
								var _v666 = acc,
									_v667 = _p438._1;
								acc = _v666;
								thediff = _v667;
								continue aux;
							default:
								var _v668 = A2(_elm_lang$core$Basics_ops['++'], acc, _p438._0._0),
									_v669 = _p438._1;
								acc = _v668;
								thediff = _v669;
								continue aux;
						}
					}
				}
			});
		return A2(
			aux,
			{ctor: '[]'},
			thediff);
	});
var _user$project$UpdateUtils$mergeStringHeuristic = F3(
	function (o, s1, s2) {
		var original = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, o);
		var modified1 = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s1);
		var modified2 = A3(_elm_lang$core$Regex$split, _elm_lang$core$Regex$All, _user$project$UpdateUtils$splitRegex, s2);
		return A2(
			_elm_lang$core$String$join,
			'',
			A5(
				_user$project$UpdateUtils$mergeListWithDiffs,
				_elm_lang$core$Basics$identity,
				F3(
					function (ori, ss1, ss2) {
						return _elm_lang$core$Native_Utils.eq(ss1, ori) ? ss2 : ss1;
					}),
				original,
				modified1,
				modified2));
	});
var _user$project$UpdateUtils$DoMerge = F8(
	function (a, b, c, d, e, f, g, h) {
		return {ctor: 'DoMerge', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g, _7: h};
	});
var _user$project$UpdateUtils$DoRight = F4(
	function (a, b, c, d) {
		return {ctor: 'DoRight', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$UpdateUtils$DoLeft = F4(
	function (a, b, c, d) {
		return {ctor: 'DoLeft', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$UpdateUtils$mergeString = F5(
	function (original, modified1, diffs1, modified2, diffs2) {
		var aux = F6(
			function (originalOffset, modified1Offset, modified2Offset, diffs1, diffs2, _p439) {
				aux:
				while (true) {
					var _p440 = _p439;
					var _p460 = _p440._0;
					var _p459 = _p440._1;
					var _p441 = {ctor: '_Tuple2', _0: diffs1, _1: diffs2};
					if (((_p441.ctor === '_Tuple2') && (_p441._0.ctor === '[]')) && (_p441._1.ctor === '[]')) {
						return {
							ctor: '_Tuple2',
							_0: _p460,
							_1: _elm_lang$core$List$reverse(_p459)
						};
					} else {
						var mergeWay = function () {
							var _p442 = {ctor: '_Tuple2', _0: diffs1, _1: diffs2};
							if (_p442._0.ctor === '[]') {
								if (_p442._1.ctor === '[]') {
									return _elm_lang$core$Native_Utils.crashCase(
										'UpdateUtils',
										{
											start: {line: 1964, column: 25},
											end: {line: 1971, column: 83}
										},
										_p442)('impossible');
								} else {
									return A4(_user$project$UpdateUtils$DoRight, _p442._1._0._0, _p442._1._0._1, _p442._1._0._2, _p442._1._1);
								}
							} else {
								if (_p442._1.ctor === '[]') {
									return A4(_user$project$UpdateUtils$DoLeft, _p442._0._0._0, _p442._0._0._1, _p442._0._0._2, _p442._0._1);
								} else {
									var _p451 = _p442._1._1;
									var _p450 = _p442._0._1;
									var _p449 = _p442._1._0._0;
									var _p448 = _p442._0._0._0;
									var _p447 = _p442._1._0._2;
									var _p446 = _p442._0._0._2;
									var _p445 = _p442._1._0._1;
									var _p444 = _p442._0._0._1;
									return (_elm_lang$core$Native_Utils.cmp(_p444, _p449) < 1) ? A4(_user$project$UpdateUtils$DoLeft, _p448, _p444, _p446, _p450) : ((_elm_lang$core$Native_Utils.cmp(_p445, _p448) < 1) ? A4(_user$project$UpdateUtils$DoRight, _p449, _p445, _p447, _p451) : A8(_user$project$UpdateUtils$DoMerge, _p448, _p444, _p446, _p450, _p449, _p445, _p447, _p451));
								}
							}
						}();
						var _p452 = mergeWay;
						switch (_p452.ctor) {
							case 'DoLeft':
								var _p455 = _p452._0;
								var _p454 = _p452._2;
								var _p453 = _p452._1;
								var insertedString = A3(_elm_lang$core$String$slice, _p455 + modified1Offset, (_p455 + modified1Offset) + _p454, modified1);
								var offsetIncrease1 = _p454 - (_p453 - _p455);
								var _v674 = originalOffset + offsetIncrease1,
									_v675 = modified1Offset + offsetIncrease1,
									_v676 = modified2Offset,
									_v677 = _p452._3,
									_v678 = diffs2,
									_v679 = {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										A2(_elm_lang$core$String$left, _p455 + originalOffset, _p460),
										A2(
											_elm_lang$core$Basics_ops['++'],
											insertedString,
											A2(_elm_lang$core$String$dropLeft, _p453 + originalOffset, _p460))),
									_1: {
										ctor: '::',
										_0: A3(_user$project$Lang$StringUpdate, _p455, _p453, _p454),
										_1: _p459
									}
								};
								originalOffset = _v674;
								modified1Offset = _v675;
								modified2Offset = _v676;
								diffs1 = _v677;
								diffs2 = _v678;
								_p439 = _v679;
								continue aux;
							case 'DoRight':
								var _p458 = _p452._0;
								var _p457 = _p452._2;
								var _p456 = _p452._1;
								var insertedString = A3(_elm_lang$core$String$slice, _p458 + modified2Offset, (_p458 + modified2Offset) + _p457, modified2);
								var offsetIncrease2 = _p457 - (_p456 - _p458);
								var _v680 = originalOffset + offsetIncrease2,
									_v681 = modified1Offset,
									_v682 = modified2Offset + offsetIncrease2,
									_v683 = diffs1,
									_v684 = _p452._3,
									_v685 = {
									ctor: '_Tuple2',
									_0: A2(
										_elm_lang$core$Basics_ops['++'],
										A2(_elm_lang$core$String$left, _p458 + originalOffset, _p460),
										A2(
											_elm_lang$core$Basics_ops['++'],
											insertedString,
											A2(_elm_lang$core$String$dropLeft, _p456 + originalOffset, _p460))),
									_1: {
										ctor: '::',
										_0: A3(_user$project$Lang$StringUpdate, _p458, _p456, _p457),
										_1: _p459
									}
								};
								originalOffset = _v680;
								modified1Offset = _v681;
								modified2Offset = _v682;
								diffs1 = _v683;
								diffs2 = _v684;
								_p439 = _v685;
								continue aux;
							default:
								var offsetIncrease1 = _p452._2 - (_p452._1 - _p452._0);
								var _v686 = originalOffset,
									_v687 = modified1Offset + offsetIncrease1,
									_v688 = modified2Offset,
									_v689 = _p452._3,
									_v690 = diffs2,
									_v691 = {ctor: '_Tuple2', _0: _p460, _1: _p459};
								originalOffset = _v686;
								modified1Offset = _v687;
								modified2Offset = _v688;
								diffs1 = _v689;
								diffs2 = _v690;
								_p439 = _v691;
								continue aux;
						}
					}
				}
			});
		return A6(
			aux,
			0,
			0,
			0,
			diffs1,
			diffs2,
			{
				ctor: '_Tuple2',
				_0: original,
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateUtils$mergeExp = F5(
	function (o, e1, ediff1, e2, ediff2) {
		var _p461 = {ctor: '_Tuple2', _0: ediff1, _1: ediff2};
		_v692_6:
		do {
			_v692_1:
			do {
				if (_p461.ctor === '_Tuple2') {
					switch (_p461._0.ctor) {
						case 'EConstDiffs':
							if (_p461._1.ctor === 'EConstDiffs') {
								if ((_p461._0._0.ctor === 'EAnyDiffs') && (_p461._1._0.ctor === 'EOnlyWhitespaceDiffs')) {
									return {ctor: '_Tuple2', _0: e1, _1: ediff1};
								} else {
									break _v692_1;
								}
							} else {
								return {ctor: '_Tuple2', _0: e2, _1: ediff2};
							}
						case 'EStringDiffs':
							switch (_p461._1.ctor) {
								case 'EConstDiffs':
									break _v692_1;
								case 'EStringDiffs':
									var _p462 = {
										ctor: '_Tuple3',
										_0: _user$project$Lang$unwrapExp(o),
										_1: _user$project$Lang$eStrUnapply(e1),
										_2: _user$project$Lang$eStrUnapply(e2)
									};
									if (((((_p462.ctor === '_Tuple3') && (_p462._0.ctor === 'EBase')) && (_p462._0._1.ctor === 'EString')) && (_p462._1.ctor === 'Just')) && (_p462._2.ctor === 'Just')) {
										var _p463 = A5(_user$project$UpdateUtils$mergeString, _p462._0._1._1, _p462._1._0, _p461._0._0, _p462._2._0, _p461._1._0);
										var finalStr = _p463._0;
										var finalDiffs = _p463._1;
										return {
											ctor: '_Tuple2',
											_0: A2(
												_user$project$Lang$replaceE__,
												o,
												A2(
													_user$project$Lang$EBase,
													_p462._0._0,
													A2(_user$project$Lang$EString, _p462._0._1._0, finalStr))),
											_1: _user$project$Lang$EStringDiffs(finalDiffs)
										};
									} else {
										return {ctor: '_Tuple2', _0: e2, _1: ediff2};
									}
								default:
									break _v692_6;
							}
						case 'EListDiffs':
							switch (_p461._1.ctor) {
								case 'EConstDiffs':
									break _v692_1;
								case 'EListDiffs':
									var _p464 = {
										ctor: '_Tuple3',
										_0: _user$project$Lang$unwrapExp(o),
										_1: _user$project$Lang$eListUnapplyWS(e1),
										_2: _user$project$Lang$eListUnapplyWS(e2)
									};
									if (((((_p464.ctor === '_Tuple3') && (_p464._0.ctor === 'EList')) && (_p464._0._3.ctor === 'Nothing')) && (_p464._1.ctor === 'Just')) && (_p464._2.ctor === 'Just')) {
										var _p465 = A6(
											_user$project$UpdateUtils$mergeList,
											F5(
												function (_p468, _p467, d1, _p466, d2) {
													var _p469 = _p468;
													var _p470 = _p467;
													var _p471 = _p466;
													var _p472 = A5(_user$project$UpdateUtils$mergeExp, _p469._1, _p470._1, d1, _p471._1, d2);
													var finale = _p472._0;
													var finald = _p472._1;
													return {
														ctor: '_Tuple2',
														_0: {ctor: '_Tuple2', _0: _p469._0, _1: finale},
														_1: finald
													};
												}),
											_p464._0._1,
											_p464._1._0,
											_p461._0._0,
											_p464._2._0,
											_p461._1._0);
										var finalelems = _p465._0;
										var finaldiff = _p465._1;
										return {
											ctor: '_Tuple2',
											_0: A2(
												_user$project$Lang$replaceE__,
												o,
												A5(_user$project$Lang$EList, _p464._0._0, finalelems, _p464._0._2, _elm_lang$core$Maybe$Nothing, _p464._0._4)),
											_1: _user$project$Lang$EListDiffs(finaldiff)
										};
									} else {
										return _elm_lang$core$Native_Utils.crashCase(
											'UpdateUtils',
											{
												start: {line: 1908, column: 7},
												end: {line: 1916, column: 84}
											},
											_p464)(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'unexpected EListDiffs without lists: ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, o),
													A2(
														_elm_lang$core$Basics_ops['++'],
														', ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e1),
															A2(
																_elm_lang$core$Basics_ops['++'],
																', ',
																A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e2)))))));
									}
								default:
									break _v692_6;
							}
						default:
							switch (_p461._1.ctor) {
								case 'EConstDiffs':
									break _v692_1;
								case 'EChildDiffs':
									var _p474 = {
										ctor: '_Tuple3',
										_0: _user$project$Lang$childExpsExtractors(o),
										_1: _user$project$Lang$childExpsExtractors(e1),
										_2: _user$project$Lang$childExpsExtractors(e2)
									};
									var _p475 = A6(_user$project$UpdateUtils$mergeTuple, _user$project$UpdateUtils$mergeExp, _p474._0._0, _p474._1._0, _p461._0._0, _p474._2._0, _p461._1._0);
									var finalelems = _p475._0;
									var finalDiffs = _p475._1;
									return {
										ctor: '_Tuple2',
										_0: _p474._0._1(finalelems),
										_1: _user$project$Lang$EChildDiffs(finalDiffs)
									};
								default:
									break _v692_6;
							}
					}
				} else {
					break _v692_6;
				}
			} while(false);
			return {ctor: '_Tuple2', _0: e2, _1: ediff2};
		} while(false);
		return {ctor: '_Tuple2', _0: e2, _1: ediff2};
	});
var _user$project$UpdateUtils$mergeVal = F5(
	function (original, modified1, modifs1, modified2, modifs2) {
		var _p476 = {ctor: '_Tuple5', _0: original.v_, _1: modified1.v_, _2: modifs1, _3: modified2.v_, _4: modifs2};
		_v699_6:
		do {
			if (_p476.ctor === '_Tuple5') {
				switch (_p476._0.ctor) {
					case 'VBase':
						if (((((_p476._0._0.ctor === 'VString') && (_p476._1.ctor === 'VBase')) && (_p476._1._0.ctor === 'VString')) && (_p476._3.ctor === 'VBase')) && (_p476._3._0.ctor === 'VString')) {
							switch (_p476._2.ctor) {
								case 'VConstDiffs':
									if (_p476._4.ctor === 'VConstDiffs') {
										return {
											ctor: '_Tuple2',
											_0: A2(
												_user$project$Lang$replaceV_,
												original,
												_user$project$Lang$VBase(
													_user$project$Lang$VString(
														A3(_user$project$UpdateUtils$mergeStringHeuristic, _p476._0._0._0, _p476._1._0._0, _p476._3._0._0)))),
											_1: _user$project$Lang$VConstDiffs
										};
									} else {
										break _v699_6;
									}
								case 'VStringDiffs':
									if (_p476._4.ctor === 'VStringDiffs') {
										var _p477 = A5(_user$project$UpdateUtils$mergeString, _p476._0._0._0, _p476._1._0._0, _p476._2._0, _p476._3._0._0, _p476._4._0);
										var newString = _p477._0;
										var newDiffs = _p477._1;
										return {
											ctor: '_Tuple2',
											_0: A2(
												_user$project$Lang$replaceV_,
												original,
												_user$project$Lang$VBase(
													_user$project$Lang$VString(newString))),
											_1: _user$project$Lang$VStringDiffs(newDiffs)
										};
									} else {
										break _v699_6;
									}
								default:
									break _v699_6;
							}
						} else {
							break _v699_6;
						}
					case 'VList':
						if ((((_p476._1.ctor === 'VList') && (_p476._2.ctor === 'VListDiffs')) && (_p476._3.ctor === 'VList')) && (_p476._4.ctor === 'VListDiffs')) {
							var _p478 = A6(_user$project$UpdateUtils$mergeList, _user$project$UpdateUtils$mergeVal, _p476._0._0, _p476._1._0, _p476._2._0, _p476._3._0, _p476._4._0);
							var newList = _p478._0;
							var newDiffs = _p478._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_user$project$Lang$replaceV_,
									original,
									_user$project$Lang$VList(newList)),
								_1: _user$project$Lang$VListDiffs(newDiffs)
							};
						} else {
							break _v699_6;
						}
					case 'VRecord':
						if ((((_p476._1.ctor === 'VRecord') && (_p476._2.ctor === 'VRecordDiffs')) && (_p476._3.ctor === 'VRecord')) && (_p476._4.ctor === 'VRecordDiffs')) {
							var _p479 = A6(_user$project$UpdateUtils$mergeRecord, _user$project$UpdateUtils$mergeVal, _p476._0._0, _p476._1._0, _p476._2._0, _p476._3._0, _p476._4._0);
							var newDict = _p479._0;
							var newDiffs = _p479._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_user$project$Lang$replaceV_,
									original,
									_user$project$Lang$VRecord(newDict)),
								_1: _user$project$Lang$VRecordDiffs(newDiffs)
							};
						} else {
							break _v699_6;
						}
					case 'VDict':
						if ((((_p476._1.ctor === 'VDict') && (_p476._2.ctor === 'VDictDiffs')) && (_p476._3.ctor === 'VDict')) && (_p476._4.ctor === 'VDictDiffs')) {
							var _p480 = A6(_user$project$UpdateUtils$mergeDict, _user$project$UpdateUtils$mergeVal, _p476._0._0, _p476._1._0, _p476._2._0, _p476._3._0, _p476._4._0);
							var newDict = _p480._0;
							var newDiffs = _p480._1;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_user$project$Lang$replaceV_,
									original,
									_user$project$Lang$VDict(newDict)),
								_1: _user$project$Lang$VDictDiffs(newDiffs)
							};
						} else {
							break _v699_6;
						}
					case 'VClosure':
						if ((((_p476._1.ctor === 'VClosure') && (_p476._2.ctor === 'VClosureDiffs')) && (_p476._3.ctor === 'VClosure')) && (_p476._4.ctor === 'VClosureDiffs')) {
							var _p490 = _p476._1._0;
							var _p489 = _p476._0._0;
							var _p488 = _p476._0._1;
							var _p487 = _p476._4._1;
							var _p486 = _p476._2._1;
							var _p485 = _p476._3._2;
							var _p484 = _p476._1._2;
							if (_elm_lang$core$Native_Utils.eq(_p489, _p490) && _elm_lang$core$Native_Utils.eq(_p490, _p476._3._0)) {
								if (A3(_user$project$UpdateUtils$patsEqual, _p488, _p476._1._1, _p476._3._1)) {
									var _p481 = A5(_user$project$UpdateUtils$mergeEnv, _p476._0._3, _p476._1._3, _p476._2._0, _p476._3._3, _p476._4._0);
									var newEnv = _p481._0;
									var newEnvDiffs = _p481._1;
									var _p482 = function () {
										var _p483 = {ctor: '_Tuple2', _0: _p486, _1: _p487};
										if (_p483._0.ctor === 'Just') {
											if (_p483._1.ctor === 'Just') {
												return A2(
													_elm_lang$core$Tuple$mapSecond,
													_elm_lang$core$Maybe$Just,
													A5(_user$project$UpdateUtils$mergeExp, _p476._0._2, _p484, _p483._0._0, _p485, _p483._1._0));
											} else {
												return {ctor: '_Tuple2', _0: _p484, _1: _p486};
											}
										} else {
											return {ctor: '_Tuple2', _0: _p485, _1: _p487};
										}
									}();
									var newBody = _p482._0;
									var newBodyModifs = _p482._1;
									return {
										ctor: '_Tuple2',
										_0: A2(
											_user$project$Lang$replaceV_,
											original,
											A4(_user$project$Lang$VClosure, _p489, _p488, newBody, newEnv)),
										_1: A2(_user$project$Lang$VClosureDiffs, newEnvDiffs, newBodyModifs)
									};
								} else {
									return A5(_user$project$UpdateUtils$defaultMerge, original, modified1, modifs1, modified2, modifs2);
								}
							} else {
								return A5(_user$project$UpdateUtils$defaultMerge, original, modified1, modifs1, modified2, modifs2);
							}
						} else {
							break _v699_6;
						}
					default:
						break _v699_6;
				}
			} else {
				break _v699_6;
			}
		} while(false);
		return A5(_user$project$UpdateUtils$defaultMerge, original, modified1, modifs1, modified2, modifs2);
	});
var _user$project$UpdateUtils$mergeEnv = F5(
	function (originalEnv_, newEnv2_, modifs2_, newEnv3_, modifs3_) {
		var aux = F8(
			function (i, accEnv, accDiffs, originalEnv, newEnv2, modifs2, newEnv3, modifs3) {
				aux:
				while (true) {
					var _p491 = {ctor: '_Tuple5', _0: originalEnv, _1: newEnv2, _2: modifs2, _3: newEnv3, _4: modifs3};
					_v701_4:
					do {
						if (_p491.ctor === '_Tuple5') {
							if (_p491._2.ctor === '[]') {
								if ((((_p491._4.ctor === '[]') && (_p491._0.ctor === '[]')) && (_p491._1.ctor === '[]')) && (_p491._3.ctor === '[]')) {
									return {
										ctor: '_Tuple2',
										_0: _elm_lang$core$List$reverse(accEnv),
										_1: _elm_lang$core$List$reverse(accDiffs)
									};
								} else {
									return {
										ctor: '_Tuple2',
										_0: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$List$reverse(accEnv),
											newEnv3),
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$List$reverse(accDiffs),
											modifs3)
									};
								}
							} else {
								if (_p491._4.ctor === '[]') {
									return {
										ctor: '_Tuple2',
										_0: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$List$reverse(accEnv),
											newEnv2),
										_1: A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$List$reverse(accDiffs),
											modifs2)
									};
								} else {
									if ((((((((_p491._0.ctor === '::') && (_p491._0._0.ctor === '_Tuple2')) && (_p491._1.ctor === '::')) && (_p491._1._0.ctor === '_Tuple2')) && (_p491._2._0.ctor === '_Tuple2')) && (_p491._3.ctor === '::')) && (_p491._3._0.ctor === '_Tuple2')) && (_p491._4._0.ctor === '_Tuple2')) {
										var _p508 = _p491._3._0._0;
										var _p507 = _p491._1._0._0;
										var _p506 = _p491._0._0._0;
										var _p505 = _p491._3._0._1;
										var _p504 = _p491._1._0._1;
										var _p503 = _p491._0._0._1;
										var _p502 = _p491._0._1;
										var _p501 = _p491._3._1;
										var _p500 = _p491._1._1;
										var _p499 = _p491._4._0._1;
										var _p498 = _p491._2._0._1;
										var _p497 = _p491._4._1;
										var _p496 = _p491._4._0._0;
										var _p495 = _p491._2._1;
										var _p494 = _p491._2._0._0;
										if ((!_elm_lang$core$Native_Utils.eq(_p506, _p507)) || ((!_elm_lang$core$Native_Utils.eq(_p507, _p508)) || (!_elm_lang$core$Native_Utils.eq(_p506, _p508)))) {
											return _elm_lang$core$Native_Utils.crash(
												'UpdateUtils',
												{
													start: {line: 1734, column: 12},
													end: {line: 1734, column: 23}
												})(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Expected environments to have the same variables, got\n',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_p506,
														A2(
															_elm_lang$core$Basics_ops['++'],
															' = ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$LangUtils$valToString(_p503),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'\n',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_p507,
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			' = ',
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_user$project$LangUtils$valToString(_p504),
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'\n',
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						_p508,
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							' = ',
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								_user$project$LangUtils$valToString(_p505),
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'\n',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										A2(
																											_elm_lang$core$String$join,
																											',',
																											A2(
																												_elm_lang$core$List$map,
																												_elm_lang$core$Tuple$first,
																												A2(_elm_lang$core$List$take, 5, originalEnv))),
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											'\n',
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												A2(
																													_elm_lang$core$String$join,
																													',',
																													A2(
																														_elm_lang$core$List$map,
																														_elm_lang$core$Tuple$first,
																														A2(_elm_lang$core$List$take, 5, newEnv2))),
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'\n',
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														A2(
																															_elm_lang$core$String$join,
																															',',
																															A2(
																																_elm_lang$core$List$map,
																																_elm_lang$core$Tuple$first,
																																A2(_elm_lang$core$List$take, 5, newEnv3))),
																														A2(
																															_elm_lang$core$Basics_ops['++'],
																															'\n',
																															A2(
																																_elm_lang$core$Basics_ops['++'],
																																'\nOriginals:\n',
																																A2(
																																	_elm_lang$core$Basics_ops['++'],
																																	_user$project$LangUtils$envToString(originalEnv_),
																																	A2(
																																		_elm_lang$core$Basics_ops['++'],
																																		'\n',
																																		A2(
																																			_elm_lang$core$Basics_ops['++'],
																																			_user$project$LangUtils$envToString(newEnv2_),
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				'\n',
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					_user$project$LangUtils$envToString(newEnv3_),
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						'\nModifications:\n',
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							_elm_lang$core$Basics$toString(modifs2_),
																																							A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								'\n',
																																								_elm_lang$core$Basics$toString(modifs3_))))))))))))))))))))))))))))));
										} else {
											if (_elm_lang$core$Native_Utils.eq(_p494, i) && _elm_lang$core$Native_Utils.eq(_p496, i)) {
												var _p492 = A5(_user$project$UpdateUtils$mergeVal, _p503, _p504, _p498, _p505, _p499);
												var newVal = _p492._0;
												var newDiffs = _p492._1;
												var _v702 = i + 1,
													_v703 = {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: _p506, _1: newVal},
													_1: accEnv
												},
													_v704 = {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: i, _1: newDiffs},
													_1: accDiffs
												},
													_v705 = _p502,
													_v706 = _p500,
													_v707 = _p495,
													_v708 = _p501,
													_v709 = _p497;
												i = _v702;
												accEnv = _v703;
												accDiffs = _v704;
												originalEnv = _v705;
												newEnv2 = _v706;
												modifs2 = _v707;
												newEnv3 = _v708;
												modifs3 = _v709;
												continue aux;
											} else {
												if (_elm_lang$core$Native_Utils.eq(_p494, i)) {
													var _v710 = i + 1,
														_v711 = {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: _p506, _1: _p504},
														_1: accEnv
													},
														_v712 = {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: i, _1: _p498},
														_1: accDiffs
													},
														_v713 = _p502,
														_v714 = _p500,
														_v715 = _p495,
														_v716 = _p501,
														_v717 = modifs3;
													i = _v710;
													accEnv = _v711;
													accDiffs = _v712;
													originalEnv = _v713;
													newEnv2 = _v714;
													modifs2 = _v715;
													newEnv3 = _v716;
													modifs3 = _v717;
													continue aux;
												} else {
													if (_elm_lang$core$Native_Utils.eq(_p496, i)) {
														var _v718 = i + 1,
															_v719 = {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _p506, _1: _p505},
															_1: accEnv
														},
															_v720 = {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: i, _1: _p499},
															_1: accDiffs
														},
															_v721 = _p502,
															_v722 = _p500,
															_v723 = modifs2,
															_v724 = _p501,
															_v725 = _p497;
														i = _v718;
														accEnv = _v719;
														accDiffs = _v720;
														originalEnv = _v721;
														newEnv2 = _v722;
														modifs2 = _v723;
														newEnv3 = _v724;
														modifs3 = _v725;
														continue aux;
													} else {
														var countToIgnore = A2(_elm_lang$core$Basics$min, _p496 - i, _p494 - i);
														var _p493 = A2(_user$project$Utils$split, countToIgnore, originalEnv);
														var toInsert = _p493._0;
														var toRemain = _p493._1;
														var _v726 = i + countToIgnore,
															_v727 = A2(_user$project$Utils$reverseInsert, toInsert, accEnv),
															_v728 = accDiffs,
															_v729 = toRemain,
															_v730 = A2(_elm_lang$core$List$drop, countToIgnore, newEnv2),
															_v731 = modifs2,
															_v732 = A2(_elm_lang$core$List$drop, countToIgnore, newEnv3),
															_v733 = modifs3;
														i = _v726;
														accEnv = _v727;
														accDiffs = _v728;
														originalEnv = _v729;
														newEnv2 = _v730;
														modifs2 = _v731;
														newEnv3 = _v732;
														modifs3 = _v733;
														continue aux;
													}
												}
											}
										}
									} else {
										break _v701_4;
									}
								}
							}
						} else {
							break _v701_4;
						}
					} while(false);
					return _elm_lang$core$Native_Utils.crashCase(
						'UpdateUtils',
						{
							start: {line: 1728, column: 5},
							end: {line: 1756, column: 110}
						},
						_p491)(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Expected environments to have the same size, got\n',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUtils$envToString(originalEnv),
								A2(
									_elm_lang$core$Basics_ops['++'],
									', ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$envToString(newEnv2),
										A2(
											_elm_lang$core$Basics_ops['++'],
											', ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$LangUtils$envToString(newEnv3),
												A2(
													_elm_lang$core$Basics_ops['++'],
													'\nOriginals:\n',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUtils$envToString(originalEnv_),
														A2(
															_elm_lang$core$Basics_ops['++'],
															', ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$LangUtils$envToString(newEnv2_),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	', ',
																	_user$project$LangUtils$envToString(newEnv3_)))))))))))));
				}
			});
		return A8(
			aux,
			0,
			{ctor: '[]'},
			{ctor: '[]'},
			originalEnv_,
			newEnv2_,
			modifs2_,
			newEnv3_,
			modifs3_);
	});
var _user$project$UpdateUtils$recursiveMergeVal = F2(
	function (original, modifications) {
		return A3(
			_user$project$UpdateUtils$recursiveMerge,
			_user$project$UpdateUtils$mergeVal,
			original,
			A2(
				_elm_lang$core$List$filterMap,
				function (_p510) {
					var _p511 = _p510;
					return A2(
						_elm_lang$core$Maybe$map,
						F2(
							function (v0, v1) {
								return {ctor: '_Tuple2', _0: v0, _1: v1};
							})(_p511._0),
						_p511._1);
				},
				modifications));
	});
var _user$project$UpdateUtils$mergeValMaybe = F5(
	function (original, modified1, modifs1, modified2, modifs2) {
		var _p512 = modifs1;
		if (_p512.ctor === 'Nothing') {
			return {ctor: '_Tuple2', _0: modified2, _1: modifs2};
		} else {
			var _p513 = modifs2;
			if (_p513.ctor === 'Nothing') {
				return {ctor: '_Tuple2', _0: modified1, _1: modifs1};
			} else {
				return function (_p514) {
					var _p515 = _p514;
					return {
						ctor: '_Tuple2',
						_0: _p515._0,
						_1: _elm_lang$core$Maybe$Just(_p515._1)
					};
				}(
					A5(_user$project$UpdateUtils$mergeVal, original, modified1, _p512._0, modified2, _p513._0));
			}
		}
	});

var _user$project$UpdatedEnv$foldLeftWithDiff = F3(
	function (acc, updatedEnv, lambda) {
		var aux = F4(
			function (i, env, changes, acc) {
				aux:
				while (true) {
					var _p0 = env;
					if (_p0.ctor === '[]') {
						return acc;
					} else {
						var _p3 = _p0._1;
						var _p2 = _p0._0;
						var _p1 = changes;
						if (_p1.ctor === '[]') {
							var _v2 = i + 1,
								_v3 = _p3,
								_v4 = changes,
								_v5 = A3(lambda, acc, _p2, _elm_lang$core$Maybe$Nothing);
							i = _v2;
							env = _v3;
							changes = _v4;
							acc = _v5;
							continue aux;
						} else {
							if (_elm_lang$core$Native_Utils.cmp(_p1._0._0, i) > 0) {
								var _v6 = i + 1,
									_v7 = _p3,
									_v8 = changes,
									_v9 = A3(lambda, acc, _p2, _elm_lang$core$Maybe$Nothing);
								i = _v6;
								env = _v7;
								changes = _v8;
								acc = _v9;
								continue aux;
							} else {
								var _v10 = i + 1,
									_v11 = _p3,
									_v12 = _p1._1,
									_v13 = A3(
									lambda,
									acc,
									_p2,
									_elm_lang$core$Maybe$Just(_p1._0._1));
								i = _v10;
								env = _v11;
								changes = _v12;
								acc = _v13;
								continue aux;
							}
						}
					}
				}
			});
		return A4(aux, 0, updatedEnv.val, updatedEnv.changes, acc);
	});
var _user$project$UpdatedEnv$show = function (updatedEnv) {
	var prunedEnv = F4(
		function (acc, i, m, e) {
			prunedEnv:
			while (true) {
				var _p4 = {ctor: '_Tuple2', _0: m, _1: e};
				if (_p4._0.ctor === '[]') {
					return _elm_lang$core$List$reverse(acc);
				} else {
					if (_p4._1.ctor === '::') {
						var _p5 = _p4._1._1;
						if (_elm_lang$core$Native_Utils.eq(_p4._0._0._0, i)) {
							var _v15 = {ctor: '::', _0: _p4._1._0, _1: acc},
								_v16 = i + 1,
								_v17 = _p4._0._1,
								_v18 = _p5;
							acc = _v15;
							i = _v16;
							m = _v17;
							e = _v18;
							continue prunedEnv;
						} else {
							var _v19 = acc,
								_v20 = i + 1,
								_v21 = m,
								_v22 = _p5;
							acc = _v19;
							i = _v20;
							m = _v21;
							e = _v22;
							continue prunedEnv;
						}
					} else {
						return _elm_lang$core$List$reverse(acc);
					}
				}
			}
		});
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'modified:',
		A2(
			_elm_lang$core$Basics_ops['++'],
			_user$project$LangUtils$envToString(
				A4(
					prunedEnv,
					{ctor: '[]'},
					0,
					updatedEnv.changes,
					updatedEnv.val)),
			A2(
				_elm_lang$core$Basics_ops['++'],
				'\n(',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$Basics$toString(updatedEnv.changes),
					')'))));
};
var _user$project$UpdatedEnv$isUnmodified = function (menv) {
	return _elm_lang$core$List$isEmpty(menv.changes);
};
var _user$project$UpdatedEnv$offset = _user$project$UpdateUtils$offset;
var _user$project$UpdatedEnv$append = F2(
	function (env1, env2) {
		var n = _elm_lang$core$List$length(env1.val);
		var changes2 = A2(_user$project$UpdatedEnv$offset, n, env2.changes);
		var env = A2(_elm_lang$core$Basics_ops['++'], env1.val, env2.val);
		return A2(
			_user$project$Lang$UpdatedEnv,
			env,
			A2(_elm_lang$core$Basics_ops['++'], env1.changes, changes2));
	});
var _user$project$UpdatedEnv$split = F2(
	function (n, env) {
		var _p6 = A2(
			_user$project$Utils$spanWhile,
			function (_p7) {
				var _p8 = _p7;
				return _elm_lang$core$Native_Utils.cmp(_p8._0, n) < 0;
			},
			env.changes);
		var changes1 = _p6._0;
		var changes2Offset = _p6._1;
		var _p9 = A2(_user$project$Utils$split, n, env.val);
		var env1 = _p9._0;
		var env2 = _p9._1;
		var changes2 = A2(_user$project$UpdatedEnv$offset, 0 - n, changes2Offset);
		return {
			ctor: '_Tuple2',
			_0: A2(_user$project$Lang$UpdatedEnv, env1, changes1),
			_1: A2(_user$project$Lang$UpdatedEnv, env2, changes2)
		};
	});
var _user$project$UpdatedEnv$set = F4(
	function (key, newVal, newDiff, updatedEnv) {
		var aux = F3(
			function (i, env, envDiffs) {
				var _p10 = env;
				if (_p10.ctor === '[]') {
					return {
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: envDiffs
					};
				} else {
					var _p16 = _p10._0._0;
					var _p15 = _p10._1;
					if (_elm_lang$core$Native_Utils.eq(_p16, key)) {
						return {
							ctor: '_Tuple2',
							_0: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p16, _1: newVal},
								_1: _p15
							},
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: i, _1: newDiff},
								_1: envDiffs
							}
						};
					} else {
						var _p11 = function () {
							var _p12 = envDiffs;
							if (_p12.ctor === '[]') {
								return {
									ctor: '_Tuple2',
									_0: {ctor: '[]'},
									_1: _elm_lang$core$Basics$identity
								};
							} else {
								var _p13 = _p12._0._0;
								return _elm_lang$core$Native_Utils.eq(_p13, i) ? {
									ctor: '_Tuple2',
									_0: _p12._1,
									_1: F2(
										function (x, y) {
											return {ctor: '::', _0: x, _1: y};
										})(
										{ctor: '_Tuple2', _0: _p13, _1: _p12._0._1})
								} : ((_elm_lang$core$Native_Utils.cmp(_p13, i) > 0) ? {ctor: '_Tuple2', _0: envDiffs, _1: _elm_lang$core$Basics$identity} : _elm_lang$core$Native_Utils.crash(
									'UpdatedEnv',
									{
										start: {line: 45, column: 23},
										end: {line: 45, column: 34}
									})(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'wrong env differences (set)',
										_user$project$UpdatedEnv$show(updatedEnv))));
							}
						}();
						var tailEnvDiffs = _p11._0;
						var remapEnvDiffs = _p11._1;
						var _p14 = A3(aux, i + 1, _p15, tailEnvDiffs);
						var newTailEnv = _p14._0;
						var newTailEnvDiffs = _p14._1;
						return {
							ctor: '_Tuple2',
							_0: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p16, _1: _p10._0._1},
								_1: newTailEnv
							},
							_1: remapEnvDiffs(newTailEnvDiffs)
						};
					}
				}
			});
		var _p17 = A3(aux, 0, updatedEnv.val, updatedEnv.changes);
		var newEnv = _p17._0;
		var newEnvDiffs = _p17._1;
		return A2(_user$project$Lang$UpdatedEnv, newEnv, newEnvDiffs);
	});
var _user$project$UpdatedEnv$merge = F3(
	function (env, env1, env2) {
		if (_user$project$UpdatedEnv$isUnmodified(env1)) {
			return env2;
		} else {
			if (_user$project$UpdatedEnv$isUnmodified(env2)) {
				return env1;
			} else {
				var _p18 = A5(_user$project$UpdateUtils$mergeEnv, env, env1.val, env1.changes, env2.val, env2.changes);
				var finalEnv = _p18._0;
				var finalChanges = _p18._1;
				return A2(_user$project$Lang$UpdatedEnv, finalEnv, finalChanges);
			}
		}
	});
var _user$project$UpdatedEnv$original = function (env) {
	return A2(
		_user$project$Lang$UpdatedEnv,
		env,
		{ctor: '[]'});
};
var _user$project$UpdatedEnv$recursiveMerge = F2(
	function (env, modifiedEnvs) {
		recursiveMerge:
		while (true) {
			var _p19 = modifiedEnvs;
			if (_p19.ctor === '[]') {
				return _user$project$UpdatedEnv$original(env);
			} else {
				if (_p19._1.ctor === '[]') {
					return _p19._0;
				} else {
					var _v27 = env,
						_v28 = {
						ctor: '::',
						_0: A3(_user$project$UpdatedEnv$merge, env, _p19._0, _p19._1._0),
						_1: _p19._1._1
					};
					env = _v27;
					modifiedEnvs = _v28;
					continue recursiveMerge;
				}
			}
		}
	});
var _user$project$UpdatedEnv$expandRecEnvReverse = F3(
	function (recNames, closureEnv, updatedExpandedEnv) {
		var n = _elm_lang$core$List$length(recNames);
		var _p20 = A2(_user$project$Utils$split, n, closureEnv);
		var nonRecEnv = _p20._0;
		var remainingEnv = _p20._1;
		var _p21 = A2(_user$project$UpdatedEnv$split, n, updatedExpandedEnv);
		var updatedRecEnv2 = _p21._0;
		var updatedRemainingEnv = _p21._1;
		var _p22 = A3(
			_user$project$UpdatedEnv$foldLeftWithDiff,
			{
				ctor: '_Tuple2',
				_0: _user$project$UpdatedEnv$original(nonRecEnv),
				_1: {ctor: '[]'}
			},
			updatedRecEnv2,
			F3(
				function (_p24, _p23, mbVDiffs) {
					var _p25 = _p24;
					var _p34 = _p25._1;
					var _p33 = _p25._0;
					var _p26 = _p23;
					var _p32 = _p26._1;
					var _p31 = _p26._0;
					var _p27 = _p32.v_;
					if (_p27.ctor === 'VClosure') {
						var newClosedEnvDiffs = function () {
							var _p28 = mbVDiffs;
							if ((_p28.ctor === 'Just') && (_p28._0.ctor === 'VClosureDiffs')) {
								return _p28._0._0;
							} else {
								return {ctor: '[]'};
							}
						}();
						var newBodyDiffs = function () {
							var _p29 = mbVDiffs;
							if ((_p29.ctor === 'Just') && (_p29._0.ctor === 'VClosureDiffs')) {
								return _p29._0._1;
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						}();
						var _p30 = A2(
							_user$project$UpdatedEnv$split,
							n,
							A2(_user$project$Lang$UpdatedEnv, _p27._3, newClosedEnvDiffs));
						var updatedNonRecEnv = _p30._0;
						var updatedRemainingEnv = _p30._1;
						var updatedBody = A2(_user$project$Lang$UpdatedExp, _p27._2, newBodyDiffs);
						var updatedClosure = A5(
							_user$project$Lang$updated.vClosure,
							_user$project$ValBuilder$fromVal(_p32),
							{ctor: '[]'},
							_p27._1,
							updatedBody,
							updatedRemainingEnv);
						return {
							ctor: '_Tuple2',
							_0: A3(_user$project$UpdatedEnv$merge, nonRecEnv, _p33, updatedNonRecEnv),
							_1: {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p31, _1: updatedClosure},
								_1: _p34
							}
						};
					} else {
						return {
							ctor: '_Tuple2',
							_0: _p33,
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: _p31,
									_1: A2(_user$project$Lang$UpdatedVal, _p32, mbVDiffs)
								},
								_1: _p34
							}
						};
					}
				}));
		var accNonRecEnv = _p22._0;
		var revAccNameClosuresMbDiffs = _p22._1;
		var globalUpdatedNonRecEnv = _user$project$Lang$updated.env(
			_elm_lang$core$List$reverse(revAccNameClosuresMbDiffs));
		var finalUpdatedNonRecEnv = A3(_user$project$UpdatedEnv$merge, nonRecEnv, accNonRecEnv, globalUpdatedNonRecEnv);
		return A2(_user$project$UpdatedEnv$append, finalUpdatedNonRecEnv, updatedRemainingEnv);
	});

var _user$project$UpdateStack$prevLetsFind = F3(
	function (val_, env, p) {
		var deconstructEnv = F2(
			function (name, env) {
				var _p0 = env;
				if (_p0.ctor === '[]') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Native_Utils.eq(_p0._0._0, name) ? _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple2', _0: _p0._0._1, _1: _p0._1}) : _elm_lang$core$Maybe$Nothing;
				}
			});
		var recurse = F2(
			function (env, p) {
				recurse:
				while (true) {
					var _p1 = p.val.p__;
					switch (_p1.ctor) {
						case 'PVar':
							return A2(deconstructEnv, _p1._1, env);
						case 'PAs':
							return A2(
								_user$project$Utils$maybeOrElseLazy,
								function (_p2) {
									var _p3 = _p2;
									return A2(recurse, env, _p1._3);
								},
								A2(recurse, env, _p1._1));
						case 'PConst':
							return _elm_lang$core$Maybe$Just(
								{
									ctor: '_Tuple2',
									_0: val_(
										A2(
											_user$project$Lang$VConst,
											_elm_lang$core$Maybe$Nothing,
											{ctor: '_Tuple2', _0: _p1._1, _1: _user$project$Lang$dummyTrace})),
									_1: env
								});
						case 'PBase':
							switch (_p1._1.ctor) {
								case 'EBool':
									return _elm_lang$core$Maybe$Just(
										{
											ctor: '_Tuple2',
											_0: val_(
												_user$project$Lang$VBase(
													_user$project$Lang$VBool(_p1._1._0))),
											_1: env
										});
								case 'EString':
									return _elm_lang$core$Maybe$Just(
										{
											ctor: '_Tuple2',
											_0: val_(
												_user$project$Lang$VBase(
													_user$project$Lang$VString(_p1._1._1))),
											_1: env
										});
								default:
									return _elm_lang$core$Maybe$Nothing;
							}
						case 'PWildcard':
							return _elm_lang$core$Maybe$Nothing;
						case 'PParens':
							var _v3 = env,
								_v4 = _p1._1;
							env = _v3;
							p = _v4;
							continue recurse;
						case 'PColonType':
							var _v5 = env,
								_v6 = _p1._1;
							env = _v5;
							p = _v6;
							continue recurse;
						case 'PList':
							if (_p1._1.ctor === '[]') {
								var _p4 = _p1._3;
								if (_p4.ctor === 'Nothing') {
									return _elm_lang$core$Maybe$Just(
										{
											ctor: '_Tuple2',
											_0: val_(
												_user$project$Lang$VList(
													{ctor: '[]'})),
											_1: env
										});
								} else {
									var _v8 = env,
										_v9 = _p4._0;
									env = _v8;
									p = _v9;
									continue recurse;
								}
							} else {
								return A2(
									_elm_lang$core$Maybe$andThen,
									function (_p5) {
										var _p6 = _p5;
										return A2(
											_elm_lang$core$Maybe$andThen,
											function (_p7) {
												var _p8 = _p7;
												return A2(
													_elm_lang$core$Maybe$map,
													function (res) {
														return {
															ctor: '_Tuple2',
															_0: val_(
																_user$project$Lang$VList(
																	{ctor: '::', _0: _p6._0, _1: res})),
															_1: _p8._1
														};
													},
													_user$project$Lang$vListUnapply(_p8._0));
											},
											A2(
												recurse,
												_p6._1,
												A2(
													_user$project$Lang$replaceP__,
													p,
													A5(_user$project$Lang$PList, _p1._0, _p1._1._1, _p1._2, _p1._3, _p1._4))));
									},
									A2(recurse, env, _p1._1._0));
							}
						default:
							var _p9 = _user$project$Lang$pTupleUnapply(p);
							if (_p9.ctor === 'Nothing') {
								return _elm_lang$core$Maybe$Nothing;
							} else {
								var pats = A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$second, _p9._0._1);
								return A2(
									_elm_lang$core$Maybe$andThen,
									function (_p10) {
										var _p11 = _p10;
										return A2(
											_elm_lang$core$Maybe$map,
											function (res) {
												return {
													ctor: '_Tuple2',
													_0: val_(
														_user$project$Lang$vTuple(res)),
													_1: _p11._1
												};
											},
											_user$project$Lang$vListUnapply(_p11._0));
									},
									A2(
										recurse,
										env,
										A2(
											_user$project$Lang$replaceP__,
											p,
											A5(_user$project$Lang$PList, _user$project$Lang$space0, pats, _user$project$Lang$space0, _elm_lang$core$Maybe$Nothing, _user$project$Lang$space0))));
							}
					}
				}
			});
		return A2(recurse, env, p);
	});
var _user$project$UpdateStack$keepLets = F2(
	function (origEnv, newEnv) {
		return _elm_lang$core$List$reverse(
			A2(
				_elm_lang$core$List$take,
				_elm_lang$core$List$length(newEnv) - _elm_lang$core$List$length(origEnv),
				newEnv));
	});
var _user$project$UpdateStack$postMapExp = F2(
	function (f, e) {
		var _p12 = _user$project$Lang$childExpsExtractors(e);
		var children = _p12._0;
		var rebuilder = _p12._1;
		var newChildren = A2(
			_elm_lang$core$List$map,
			_user$project$UpdateStack$postMapExp(f),
			children);
		var newElem = rebuilder(newChildren);
		return A2(
			_elm_lang$core$Maybe$withDefault,
			newElem,
			f(newElem));
	});
var _user$project$UpdateStack$replaceInsertions = F2(
	function (e, f) {
		var _p13 = e.changes;
		if (_p13.ctor === 'Nothing') {
			return e;
		} else {
			var _p14 = _p13._0;
			switch (_p14.ctor) {
				case 'EChildDiffs':
					var _p15 = _user$project$Lang$childExpsExtractors(e.val);
					var children = _p15._0;
					var rebuilder = _p15._1;
					var aux = F4(
						function (i, children, diffs, revAccChildren) {
							aux:
							while (true) {
								var _p16 = diffs;
								if (_p16.ctor === '[]') {
									return A2(
										_user$project$Lang$UpdatedExp,
										rebuilder(
											_elm_lang$core$List$reverse(
												A2(_user$project$Utils$reverseInsert, children, revAccChildren))),
										e.changes);
								} else {
									var _p20 = _p16._1;
									var _p19 = _p16._0._0;
									if (_elm_lang$core$Native_Utils.cmp(_p19, i) > 0) {
										var _p17 = A2(_user$project$Utils$split, _p19 - i, children);
										var childrenOk = _p17._0;
										var childrenTail = _p17._1;
										var _v17 = _p19,
											_v18 = childrenTail,
											_v19 = diffs,
											_v20 = A2(_user$project$Utils$reverseInsert, childrenOk, revAccChildren);
										i = _v17;
										children = _v18;
										diffs = _v19;
										revAccChildren = _v20;
										continue aux;
									} else {
										var _p18 = children;
										if (_p18.ctor === '::') {
											var _v22 = i + 1,
												_v23 = _p18._1,
												_v24 = _p20,
												_v25 = {
												ctor: '::',
												_0: A2(
													_user$project$UpdateStack$replaceInsertions,
													A2(
														_user$project$Lang$UpdatedExp,
														_p18._0,
														_elm_lang$core$Maybe$Just(_p16._0._1)),
													f).val,
												_1: revAccChildren
											};
											i = _v22;
											children = _v23;
											diffs = _v24;
											revAccChildren = _v25;
											continue aux;
										} else {
											var _v26 = i,
												_v27 = children,
												_v28 = _p20,
												_v29 = revAccChildren;
											i = _v26;
											children = _v27;
											diffs = _v28;
											revAccChildren = _v29;
											continue aux;
										}
									}
								}
							}
						});
					return A4(
						aux,
						0,
						children,
						_p14._0,
						{ctor: '[]'});
				case 'EListDiffs':
					var _p21 = _user$project$Lang$unwrapExp(e.val);
					if ((_p21.ctor === 'EList') && (_p21._3.ctor === 'Nothing')) {
						var aux = F4(
							function (i, children, diffs, revAccChildren) {
								aux:
								while (true) {
									var _p22 = diffs;
									if (_p22.ctor === '[]') {
										return A2(
											_user$project$Lang$UpdatedExp,
											A2(
												_user$project$Lang$replaceE__,
												e.val,
												A5(
													_user$project$Lang$EList,
													_p21._0,
													_elm_lang$core$List$reverse(
														A2(_user$project$Utils$reverseInsert, children, revAccChildren)),
													_p21._2,
													_elm_lang$core$Maybe$Nothing,
													_p21._4)),
											e.changes);
									} else {
										var _p30 = _p22._1;
										var _p29 = _p22._0._0;
										if (_elm_lang$core$Native_Utils.cmp(_p29, i) > 0) {
											var count = _p29 - i;
											var _p23 = A2(_user$project$Utils$split, count, children);
											var childrenOk = _p23._0;
											var childrenTail = _p23._1;
											var _v32 = _p29,
												_v33 = childrenTail,
												_v34 = diffs,
												_v35 = A2(_user$project$Utils$reverseInsert, childrenOk, revAccChildren);
											i = _v32;
											children = _v33;
											diffs = _v34;
											revAccChildren = _v35;
											continue aux;
										} else {
											var _p24 = _p22._0._1;
											switch (_p24.ctor) {
												case 'ListElemUpdate':
													var _p25 = children;
													if ((_p25.ctor === '::') && (_p25._0.ctor === '_Tuple2')) {
														var _v38 = i + 1,
															_v39 = _p25._1,
															_v40 = _p30,
															_v41 = {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: _p25._0._0,
																_1: A2(
																	_user$project$UpdateStack$replaceInsertions,
																	A2(
																		_user$project$Lang$UpdatedExp,
																		_p25._0._1,
																		_elm_lang$core$Maybe$Just(_p24._0)),
																	f).val
															},
															_1: revAccChildren
														};
														i = _v38;
														children = _v39;
														diffs = _v40;
														revAccChildren = _v41;
														continue aux;
													} else {
														var _v42 = i,
															_v43 = children,
															_v44 = _p30,
															_v45 = revAccChildren;
														i = _v42;
														children = _v43;
														diffs = _v44;
														revAccChildren = _v45;
														continue aux;
													}
												case 'ListElemDelete':
													var _v46 = i + _p24._0,
														_v47 = children,
														_v48 = _p30,
														_v49 = revAccChildren;
													i = _v46;
													children = _v47;
													diffs = _v48;
													revAccChildren = _v49;
													continue aux;
												default:
													var _p26 = A2(_user$project$Utils$split, _p24._0, children);
													var inserted = _p26._0;
													var rem = _p26._1;
													var insertedMapped = A2(
														_elm_lang$core$List$map,
														function (_p27) {
															var _p28 = _p27;
															return {
																ctor: '_Tuple2',
																_0: _p28._0,
																_1: A2(_user$project$UpdateStack$postMapExp, f, _p28._1)
															};
														},
														inserted);
													var _v51 = i,
														_v52 = rem,
														_v53 = _p30,
														_v54 = A2(_user$project$Utils$reverseInsert, insertedMapped, revAccChildren);
													i = _v51;
													children = _v52;
													diffs = _v53;
													revAccChildren = _v54;
													continue aux;
											}
										}
									}
								}
							});
						return A4(
							aux,
							0,
							_p21._1,
							_p14._0,
							{ctor: '[]'});
					} else {
						return e;
					}
				case 'EConstDiffs':
					return e;
				default:
					return e;
			}
		}
	});
var _user$project$UpdateStack$outputToString = _user$project$ValUnparser$strVal;
var _user$project$UpdateStack$handleResultToString_ = F2(
	function (indent, handleResult) {
		var _p31 = handleResult;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'\n',
			A2(
				_elm_lang$core$Basics_ops['++'],
				indent,
				A2(_elm_lang$core$Basics_ops['++'], 'Prev ', _p31._0)));
	});
var _user$project$UpdateStack$updateStackName_ = F2(
	function (indent, u) {
		var _p32 = u;
		switch (_p32.ctor) {
			case 'UpdateResultS':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Res(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p32._1.val),
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(
										_elm_lang$core$Maybe$withDefault,
										'',
										A2(
											_elm_lang$core$Maybe$map,
											_user$project$UpdateStack$handleResultToString_(indent),
											_p32._2)),
									')')))));
			case 'UpdateContextS':
				if (_p32._6.ctor === 'Just') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Contn(',
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p32._1),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' <-- ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$UpdateStack$outputToString(_p32._4),
											A2(
												_elm_lang$core$Basics_ops['++'],
												')[',
												A2(
													_elm_lang$core$Basics_ops['++'],
													A2(
														_user$project$UpdateStack$handleResultToString_,
														A2(_elm_lang$core$Basics_ops['++'], indent, ' '),
														_p32._6._0),
													']'))))))));
				} else {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						'\n',
						A2(
							_elm_lang$core$Basics_ops['++'],
							indent,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Ctx ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p32._1),
									A2(
										_elm_lang$core$Basics_ops['++'],
										'<--',
										_user$project$UpdateStack$outputToString(_p32._4))))));
				}
			case 'UpdateResultAlternative':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Alt(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$UpdateStack$updateStackName(_p32._1),
								A2(
									_elm_lang$core$Basics_ops['++'],
									') then [',
									function () {
										var _p33 = _elm_lang$lazy$Lazy$force(_p32._2);
										if (_p33.ctor === 'Just') {
											return A2(
												_elm_lang$core$Basics_ops['++'],
												A2(
													_user$project$UpdateStack$updateStackName_,
													A2(_elm_lang$core$Basics_ops['++'], indent, ' '),
													_p33._0),
												']');
										} else {
											return ']';
										}
									}())))));
			case 'UpdateFails':
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(_elm_lang$core$Basics_ops['++'], 'UpdateFails ', _p32._0)));
			default:
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(
						_elm_lang$core$Basics_ops['++'],
						indent,
						A2(_elm_lang$core$Basics_ops['++'], 'UpdateCriticalError ', _p32._0)));
		}
	});
var _user$project$UpdateStack$updateStackName = _user$project$UpdateStack$updateStackName_('');
var _user$project$UpdateStack$updatedExpToStringWithPositions = F2(
	function (e, ue) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			{
				ctor: '_Tuple2',
				_0: '<no change>',
				_1: {ctor: '[]'}
			},
			A2(
				_elm_lang$core$Maybe$map,
				function (_p34) {
					return function (_p35) {
						var _p36 = _p35;
						return {ctor: '_Tuple2', _0: _p36._0, _1: _p36._1._1};
					}(
						A6(
							_user$project$UpdateUtils$eDiffsToStringPositions,
							_user$project$Lang$LeoSyntax,
							'',
							{
								ctor: '_Tuple2',
								_0: A2(_user$project$Pos$Pos, 0, 0),
								_1: {ctor: '_Tuple2', _0: 0, _1: 0}
							},
							e,
							ue.val,
							_p34));
				},
				ue.changes));
	});
var _user$project$UpdateStack$updatedExpToString = F2(
	function (e, ue) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			'<no change>',
			A2(
				_elm_lang$core$Maybe$map,
				A3(_user$project$UpdateUtils$eDiffsToString, '', e, ue.val),
				ue.changes));
	});
var _user$project$UpdateStack$HandlePreviousResult = F2(
	function (a, b) {
		return {ctor: 'HandlePreviousResult', _0: a, _1: b};
	});
var _user$project$UpdateStack$Fork = F4(
	function (a, b, c, d) {
		return {ctor: 'Fork', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$UpdateStack$UpdateCriticalError = function (a) {
	return {ctor: 'UpdateCriticalError', _0: a};
};
var _user$project$UpdateStack$UpdateFails = function (a) {
	return {ctor: 'UpdateFails', _0: a};
};
var _user$project$UpdateStack$UpdateResultAlternative = F3(
	function (a, b, c) {
		return {ctor: 'UpdateResultAlternative', _0: a, _1: b, _2: c};
	});
var _user$project$UpdateStack$updateResults = F2(
	function (updateStack, lazyAlternatives) {
		return A3(
			_user$project$UpdateStack$UpdateResultAlternative,
			'fromUpdateREsult',
			updateStack,
			A2(
				_elm_lang$lazy$Lazy$map,
				function (alternatives) {
					var _p37 = alternatives;
					if (_p37.ctor === 'Nil') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Just(
							A2(_user$project$UpdateStack$updateResults, _p37._0, _p37._1));
					}
				},
				lazyAlternatives));
	});
var _user$project$UpdateStack$updateResultList = F2(
	function (msg, alternatives) {
		var _p38 = alternatives;
		if (_p38.ctor === 'Nil') {
			return _user$project$UpdateStack$UpdateFails(msg);
		} else {
			return A2(_user$project$UpdateStack$updateResults, _p38._0, _p38._1);
		}
	});
var _user$project$UpdateStack$updateManyMbHeadTail = F3(
	function (firstdiff, otherdiffs, builder) {
		return A2(
			_user$project$UpdateStack$updateResults,
			builder(firstdiff),
			A2(
				_elm_lang$lazy$Lazy$map,
				function (otherdiffs) {
					return A2(
						_user$project$LazyList$map,
						builder,
						A2(_user$project$LazyList$filterMap, _elm_lang$core$Basics$identity, otherdiffs));
				},
				otherdiffs));
	});
var _user$project$UpdateStack$updateMany = F3(
	function (diffResult, onSame, builder) {
		var _p39 = diffResult;
		if (_p39.ctor === 'Err') {
			return _user$project$UpdateStack$UpdateCriticalError(_p39._0);
		} else {
			var _p40 = _p39._0;
			if (_p40.ctor === 'Nil') {
				return _user$project$UpdateStack$UpdateCriticalError('[internal error] Expected at least one diff, got nothing');
			} else {
				if (_p40._0.ctor === 'Nothing') {
					return onSame(
						{ctor: '_Tuple0'});
				} else {
					return A3(_user$project$UpdateStack$updateManyMbHeadTail, _p40._0._0, _p40._1, builder);
				}
			}
		}
	});
var _user$project$UpdateStack$updateManyHeadTail = F3(
	function (firstdiff, otherdiffs, builder) {
		return A2(
			_user$project$UpdateStack$updateResults,
			builder(firstdiff),
			A2(
				_elm_lang$lazy$Lazy$map,
				function (otherdiffs) {
					return A2(_user$project$LazyList$map, builder, otherdiffs);
				},
				otherdiffs));
	});
var _user$project$UpdateStack$updateManys = F2(
	function (diffResult, builder) {
		var _p41 = diffResult;
		if (_p41.ctor === 'Err') {
			return _user$project$UpdateStack$UpdateCriticalError(_p41._0);
		} else {
			var _p42 = _p41._0;
			if (_p42.ctor === 'Nil') {
				return _user$project$UpdateStack$UpdateCriticalError('[internal error] Expected at least one diff, got nothing');
			} else {
				return A3(_user$project$UpdateStack$updateManyHeadTail, _p42._0, _p42._1, builder);
			}
		}
	});
var _user$project$UpdateStack$updateMaybeFirst = F3(
	function (msg, mb, ll) {
		var _p43 = mb;
		if (_p43.ctor === 'Nothing') {
			return ll(
				{ctor: '_Tuple0'});
		} else {
			var _p45 = _p43._0._0;
			return _p43._0._1 ? A3(
				_user$project$UpdateStack$UpdateResultAlternative,
				msg,
				_p45,
				_elm_lang$lazy$Lazy$lazy(
					function (_p44) {
						return _elm_lang$core$Maybe$Just(
							ll(
								{ctor: '_Tuple0'}));
					})) : _p45;
		}
	});
var _user$project$UpdateStack$updateMaybeFirst2 = F4(
	function (msg, canContinueAfter, mb, ll) {
		var _p46 = mb;
		if (_p46.ctor === 'Nothing') {
			return A2(
				_elm_lang$core$Maybe$map,
				function (u) {
					return {ctor: '_Tuple2', _0: u, _1: canContinueAfter};
				},
				ll(
					{ctor: '_Tuple0'}));
		} else {
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: A3(
						_user$project$UpdateStack$UpdateResultAlternative,
						msg,
						_p46._0,
						_elm_lang$lazy$Lazy$lazy(
							function (_p47) {
								return ll(
									{ctor: '_Tuple0'});
							})),
					_1: canContinueAfter
				});
		}
	});
var _user$project$UpdateStack$UpdateContextS = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'UpdateContextS', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$UpdateStack$updateContinue = F8(
	function (msg, env, exp, prevLets, oldVal, newVal, newValDiffs, continuation) {
		return A7(
			_user$project$UpdateStack$UpdateContextS,
			env,
			exp,
			prevLets,
			oldVal,
			newVal,
			newValDiffs,
			_elm_lang$core$Maybe$Just(
				A2(_user$project$UpdateStack$HandlePreviousResult, msg, continuation)));
	});
var _user$project$UpdateStack$updateContinueMultiple = F6(
	function (msg, env, prevLets, totalExpValOut, diffs, continuation) {
		var totalExp = _user$project$Lang$withDummyExpInfo(
			A5(
				_user$project$Lang$EList,
				_user$project$Lang$space0,
				A2(
					_elm_lang$core$List$map,
					function (_p48) {
						var _p49 = _p48;
						return {ctor: '_Tuple2', _0: _user$project$Lang$space1, _1: _p49._0};
					},
					totalExpValOut),
				_user$project$Lang$space0,
				_elm_lang$core$Maybe$Nothing,
				_user$project$Lang$space0));
		var aux = F6(
			function (i, revAccExps, revAccEDiffs, updatedEnvAcc, expValOut, diffs) {
				aux:
				while (true) {
					var _p50 = diffs;
					if (_p50.ctor === '[]') {
						var finalExpTupleDiffs = function () {
							var _p51 = _elm_lang$core$List$reverse(revAccEDiffs);
							if (_p51.ctor === '[]') {
								return _elm_lang$core$Maybe$Nothing;
							} else {
								return _elm_lang$core$Maybe$Just(_p51);
							}
						}();
						return A2(
							continuation,
							updatedEnvAcc,
							A2(
								_user$project$Lang$UpdatedExpTuple,
								_elm_lang$core$List$reverse(
									A2(
										_user$project$Utils$reverseInsert,
										A2(
											_elm_lang$core$List$map,
											function (_p52) {
												var _p53 = _p52;
												return _p53._0;
											},
											expValOut),
										revAccExps)),
								finalExpTupleDiffs));
					} else {
						var _p60 = _p50._0._0;
						if (_elm_lang$core$Native_Utils.cmp(_p60, i) > 0) {
							var _p54 = A2(_user$project$Utils$split, _p60 - i, expValOut);
							var unchanged = _p54._0;
							var remaining = _p54._1;
							var unchangedExps = A2(
								_elm_lang$core$List$map,
								function (_p55) {
									var _p56 = _p55;
									return _p56._0;
								},
								unchanged);
							var _v72 = _p60,
								_v73 = A2(_user$project$Utils$reverseInsert, unchangedExps, revAccExps),
								_v74 = revAccEDiffs,
								_v75 = updatedEnvAcc,
								_v76 = remaining,
								_v77 = diffs;
							i = _v72;
							revAccExps = _v73;
							revAccEDiffs = _v74;
							updatedEnvAcc = _v75;
							expValOut = _v76;
							diffs = _v77;
							continue aux;
						} else {
							if (_elm_lang$core$Native_Utils.cmp(_p60, i) < 0) {
								return _elm_lang$core$Native_Utils.crash(
									'UpdateStack',
									{
										start: {line: 172, column: 32},
										end: {line: 172, column: 43}
									})(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Unexpected modification index : ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(_p60),
											A2(
												_elm_lang$core$Basics_ops['++'],
												', expected ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Basics$toString(i),
													' or above.')))));
							} else {
								var _p57 = expValOut;
								if (_p57.ctor === '::') {
									return A8(
										_user$project$UpdateStack$updateContinue,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_elm_lang$core$Basics$toString(i + 1),
											A2(
												_elm_lang$core$Basics_ops['++'],
												'/',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Basics$toString(
														_elm_lang$core$List$length(totalExpValOut)),
													A2(_elm_lang$core$Basics_ops['++'], ' ', msg)))),
										env,
										_p57._0._0,
										prevLets,
										_p57._0._1,
										_p57._0._2,
										_p50._0._1,
										F2(
											function (newUpdatedEnv, newUpdatedExp) {
												var newUpdatedEnvAcc = A3(_user$project$UpdatedEnv$merge, env, updatedEnvAcc, newUpdatedEnv);
												var newRevAccEDiffs = function () {
													var _p58 = newUpdatedExp.changes;
													if (_p58.ctor === 'Nothing') {
														return revAccEDiffs;
													} else {
														return {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: i, _1: _p58._0},
															_1: revAccEDiffs
														};
													}
												}();
												return A6(
													aux,
													i + 1,
													{ctor: '::', _0: newUpdatedExp.val, _1: revAccExps},
													newRevAccEDiffs,
													newUpdatedEnvAcc,
													_p57._1,
													_p50._1);
											}));
								} else {
									return _elm_lang$core$Native_Utils.crashCase(
										'UpdateStack',
										{
											start: {line: 174, column: 15},
											end: {line: 187, column: 126}
										},
										_p57)(
										A2(
											_elm_lang$core$Basics_ops['++'],
											msg,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Expected at least one element because it was modified at index ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Basics$toString(_p60),
													A2(
														_elm_lang$core$Basics_ops['++'],
														', got nothing. We are at index ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															_elm_lang$core$Basics$toString(i),
															A2(
																_elm_lang$core$Basics_ops['++'],
																' / length = ',
																_elm_lang$core$Basics$toString(
																	_elm_lang$core$List$length(totalExpValOut)))))))));
								}
							}
						}
					}
				}
			});
		return A6(
			aux,
			0,
			{ctor: '[]'},
			{ctor: '[]'},
			_user$project$UpdatedEnv$original(env),
			totalExpValOut,
			diffs);
	});
var _user$project$UpdateStack$updateContext = F7(
	function (msg, env, exp, prevLets, oldVal, newVal, newValDiffs) {
		return A7(_user$project$UpdateStack$UpdateContextS, env, exp, prevLets, oldVal, newVal, newValDiffs, _elm_lang$core$Maybe$Nothing);
	});
var _user$project$UpdateStack$UpdateResultS = F3(
	function (a, b, c) {
		return {ctor: 'UpdateResultS', _0: a, _1: b, _2: c};
	});
var _user$project$UpdateStack$updateResult = F2(
	function (updatedEnv, exp) {
		return A3(_user$project$UpdateStack$UpdateResultS, updatedEnv, exp, _elm_lang$core$Maybe$Nothing);
	});
var _user$project$UpdateStack$updateResultSameEnvExp = F2(
	function (env, exp) {
		return A2(
			_user$project$UpdateStack$updateResult,
			_user$project$UpdatedEnv$original(env),
			A2(_user$project$Lang$UpdatedExp, exp, _elm_lang$core$Maybe$Nothing));
	});
var _user$project$UpdateStack$updateResultSameEnv = F2(
	function (env, exp) {
		return A2(
			_user$project$UpdateStack$updateResult,
			_user$project$UpdatedEnv$original(env),
			A2(
				_user$project$Lang$UpdatedExp,
				exp,
				_elm_lang$core$Maybe$Just(
					_user$project$Lang$EConstDiffs(_user$project$Lang$EAnyDiffs))));
	});
var _user$project$UpdateStack$updateResultSameEnvDiffs = F3(
	function (env, exp, diffs) {
		return A2(
			_user$project$UpdateStack$updateResult,
			_user$project$UpdatedEnv$original(env),
			A2(
				_user$project$Lang$UpdatedExp,
				exp,
				_elm_lang$core$Maybe$Just(diffs)));
	});
var _user$project$UpdateStack$updateOpMultiple = F7(
	function (hint, env, es, eBuilder, prevLets, prevOutputs, outputs) {
		var aux = F4(
			function (nth, outputsHead, diffResult, lazyTail) {
				var $continue = function () {
					var _p61 = diffResult;
					if (_p61.ctor === 'Err') {
						return function (continuation) {
							return _user$project$UpdateStack$UpdateCriticalError(_p61._0);
						};
					} else {
						if (_p61._0.ctor === 'Nil') {
							return function (continuation) {
								return _user$project$UpdateStack$UpdateCriticalError('[internal error] Empty diffs in updateOpMultiple');
							};
						} else {
							if (_p61._0._0.ctor === 'Nothing') {
								return function (continuation) {
									return A2(
										continuation,
										_user$project$UpdatedEnv$original(env),
										A2(_user$project$Lang$UpdatedExpTuple, es, _elm_lang$core$Maybe$Nothing));
								};
							} else {
								return function (continuation) {
									return A3(
										_user$project$UpdateStack$updateManyMbHeadTail,
										_p61._0._0._0,
										_p61._0._1,
										function (diff) {
											return A6(
												_user$project$UpdateStack$updateContinueMultiple,
												A2(
													_elm_lang$core$Basics_ops['++'],
													hint,
													A2(
														_elm_lang$core$Basics_ops['++'],
														' #',
														_elm_lang$core$Basics$toString(nth))),
												env,
												prevLets,
												A3(_user$project$Utils$zip3, es, prevOutputs, outputsHead),
												diff,
												continuation);
										});
								};
							}
						}
					}
				}();
				return A3(
					_user$project$UpdateStack$UpdateResultAlternative,
					'UpdateResultAlternative maybeOp',
					$continue(
						F2(
							function (newUpdatedEnv, newUpdatedOpArgs) {
								var newUpdatedExp = A2(
									_user$project$Lang$UpdatedExp,
									eBuilder(newUpdatedOpArgs.val),
									A2(_elm_lang$core$Maybe$map, _user$project$Lang$EChildDiffs, newUpdatedOpArgs.changes));
								return A2(_user$project$UpdateStack$updateResult, newUpdatedEnv, newUpdatedExp);
							})),
					A2(
						_elm_lang$lazy$Lazy$map,
						function (ll) {
							var _p62 = ll;
							if (_p62.ctor === 'Nil') {
								return _elm_lang$core$Maybe$Nothing;
							} else {
								return _elm_lang$core$Maybe$Just(
									A4(aux, nth + 1, _p62._0._0, _p62._0._1, _p62._1));
							}
						},
						lazyTail));
			});
		var _p63 = outputs;
		if (_p63.ctor === 'Nil') {
			return _user$project$UpdateStack$UpdateFails(
				A2(_elm_lang$core$Basics_ops['++'], '[Internal error] No result for updating ', hint));
		} else {
			return A4(aux, 1, _p63._0._0, _p63._0._1, _p63._1);
		}
	});
var _user$project$UpdateStack$updateContinueRepeat = F9(
	function (msg, env, e, prevLets, oldVal, newVal, diffsResults, otherNewValModifs, continuation) {
		return A3(
			_user$project$UpdateStack$updateMany,
			diffsResults,
			function (_p64) {
				var _p65 = _p64;
				return A2(
					continuation,
					_user$project$UpdatedEnv$original(env),
					A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing));
			},
			function (diffs) {
				return A8(
					_user$project$UpdateStack$updateContinue,
					msg,
					env,
					e,
					prevLets,
					oldVal,
					newVal,
					diffs,
					F2(
						function (newUpdatedEnv, newUpdatedE) {
							return A3(
								_user$project$UpdateStack$UpdateResultAlternative,
								A2(_elm_lang$core$Basics_ops['++'], 'Alternative to ', msg),
								A3(
									_user$project$UpdateStack$UpdateResultS,
									newUpdatedEnv,
									newUpdatedE,
									_elm_lang$core$Maybe$Just(
										A2(
											_user$project$UpdateStack$HandlePreviousResult,
											A2(_elm_lang$core$Basics_ops['++'], 'alternative continuation to ', msg),
											continuation))),
								A2(
									_elm_lang$lazy$Lazy$map,
									function (ll) {
										var _p66 = ll;
										if (_p66.ctor === 'Nil') {
											return _elm_lang$core$Maybe$Nothing;
										} else {
											return _elm_lang$core$Maybe$Just(
												A9(_user$project$UpdateStack$updateContinueRepeat, msg, env, e, prevLets, oldVal, _p66._0._0, _p66._0._1, _p66._1, continuation));
										}
									},
									otherNewValModifs));
						}));
			});
	});
var _user$project$UpdateStack$updateAlternatives = F7(
	function (msg, env, e, prevLets, oldVal, newValsDiffs, continuation) {
		var _p67 = newValsDiffs;
		if (_p67.ctor === 'Nil') {
			return _user$project$UpdateStack$UpdateFails(
				A2(_elm_lang$core$Basics_ops['++'], 'No solution for ', msg));
		} else {
			return A9(_user$project$UpdateStack$updateContinueRepeat, msg, env, e, prevLets, oldVal, _p67._0._0, _p67._0._1, _p67._1, continuation);
		}
	});

var _user$project$GroupStartMap$end = function ($this) {
	return $this.start + function () {
		var _p0 = $this.matched;
		if (_p0.ctor === 'Nothing') {
			return 0;
		} else {
			return _elm_lang$core$String$length(_p0._0);
		}
	}();
};
var _user$project$GroupStartMap$foreach = F3(
	function (f, l, $return) {
		foreach:
		while (true) {
			var _p1 = l;
			if (_p1.ctor === '[]') {
				return $return;
			} else {
				var _p2 = f(_p1._0);
				var _v2 = f,
					_v3 = _p1._1,
					_v4 = $return;
				f = _v2;
				l = _v3;
				$return = _v4;
				continue foreach;
			}
		}
	});
var _user$project$GroupStartMap$nodeUnapply = function (n) {
	return {ctor: '_Tuple2', _0: n.originalGroup, _1: n.nodeType};
};
var _user$project$GroupStartMap$isBackReference = function (r) {
	return (_elm_lang$core$Native_Utils.cmp(
		_elm_lang$core$String$length(r),
		2) > -1) && function () {
		var _p3 = _elm_lang$core$String$uncons(r);
		if (_p3.ctor === 'Just') {
			return _elm_lang$core$Native_Utils.eq(
				_p3._0._0,
				_elm_lang$core$Native_Utils.chr('\\')) && A2(_elm_lang$core$String$all, _elm_lang$core$Char$isDigit, _p3._0._1);
		} else {
			return false;
		}
	}();
};
var _user$project$GroupStartMap$backReferenceLeafUnapply = function (leaf) {
	var _p4 = leaf;
	if (_p4.ctor === 'RegexLeaf') {
		var _p6 = _p4._0;
		if (_user$project$GroupStartMap$isBackReference(_p6)) {
			var _p5 = _elm_lang$core$String$uncons(_p6);
			if (_p5.ctor === 'Nothing') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				return _elm_lang$core$Result$toMaybe(
					_elm_lang$core$String$toInt(_p5._0._1));
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$GroupStartMap$splitWhereAux = F4(
	function (input, splitter, res, acc) {
		splitWhereAux:
		while (true) {
			var _p7 = input;
			if (_p7.ctor === '[]') {
				return _elm_lang$core$List$reverse(
					{
						ctor: '::',
						_0: _elm_lang$core$List$reverse(acc),
						_1: res
					});
			} else {
				var _p9 = _p7._1;
				var _p8 = _p7._0;
				if (splitter(_p8)) {
					var _v9 = _p9,
						_v10 = splitter,
						_v11 = {
						ctor: '::',
						_0: _elm_lang$core$List$reverse(acc),
						_1: res
					},
						_v12 = {ctor: '[]'};
					input = _v9;
					splitter = _v10;
					res = _v11;
					acc = _v12;
					continue splitWhereAux;
				} else {
					var _v13 = _p9,
						_v14 = splitter,
						_v15 = res,
						_v16 = {ctor: '::', _0: _p8, _1: acc};
					input = _v13;
					splitter = _v14;
					res = _v15;
					acc = _v16;
					continue splitWhereAux;
				}
			}
		}
	});
var _user$project$GroupStartMap$splitWhere = F2(
	function (input, splitter) {
		return A4(
			_user$project$GroupStartMap$splitWhereAux,
			input,
			splitter,
			{ctor: '[]'},
			{ctor: '[]'});
	});
var _user$project$GroupStartMap$foldNodeType = F4(
	function ($this, regexF, childrenF, childrenD) {
		var _p10 = $this;
		switch (_p10.ctor) {
			case 'RegexLeaf':
				return regexF(_p10._0);
			case 'ParentNode':
				return childrenF(_p10._0);
			default:
				return childrenD(_p10._0);
		}
	});
var _user$project$GroupStartMap$setNewGroup = F2(
	function ($this, index) {
		var _p11 = A3(_user$project$ImpureGoodies$mutateRecordField, $this, 'newGroup', index);
		return A4(
			_user$project$GroupStartMap$foldNodeType,
			$this.nodeType,
			function (r) {
				return index + 1;
			},
			function (children) {
				return A3(_elm_lang$core$List$foldl, _user$project$GroupStartMap$setNewGroup, index + 1, children);
			},
			function (children) {
				return A3(_elm_lang$core$List$foldl, _user$project$GroupStartMap$setNewGroup, index + 1, children);
			});
	});
var _user$project$GroupStartMap$setMatch = F2(
	function (stringForGroupNumber, $this) {
		var _p12 = A3(
			_user$project$ImpureGoodies$mutateRecordField,
			$this,
			'matched',
			stringForGroupNumber($this.newGroup));
		return A4(
			_user$project$GroupStartMap$foldNodeType,
			$this.nodeType,
			function (r) {
				return {ctor: '_Tuple0'};
			},
			function (children) {
				return A3(
					_user$project$GroupStartMap$foreach,
					_user$project$GroupStartMap$setMatch(stringForGroupNumber),
					children,
					{ctor: '_Tuple0'});
			},
			function (children) {
				return A3(
					_user$project$GroupStartMap$foreach,
					_user$project$GroupStartMap$setMatch(stringForGroupNumber),
					children,
					{ctor: '_Tuple0'});
			});
	});
var _user$project$GroupStartMap$originallyWrapped = {
	isRepeatModifier: function (modifier) {
		return _elm_lang$core$Native_Utils.eq(modifier, '?') || (_elm_lang$core$Native_Utils.eq(modifier, '??') || (_elm_lang$core$Native_Utils.eq(modifier, '*') || (_elm_lang$core$Native_Utils.eq(modifier, '+') || (_elm_lang$core$Native_Utils.eq(modifier, '*?') || (_elm_lang$core$Native_Utils.eq(modifier, '+?') || A2(_elm_lang$core$String$startsWith, '{', modifier))))));
	},
	repeaterUnapply: function (e) {
		var _p13 = e;
		if (_p13.ctor === 'OriginallyWrapped') {
			var _p14 = _p13._1;
			return (_elm_lang$core$Native_Utils.eq(_p13._0, '') && _user$project$GroupStartMap$originallyWrapped.isRepeatModifier(_p14)) ? _elm_lang$core$Maybe$Just(_p14) : _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	},
	absoluteUnapply: function (e) {
		var _p15 = e;
		if (_p15.ctor === 'OriginallyWrapped') {
			var _p16 = _p15._0;
			return (_elm_lang$core$Native_Utils.eq(_p16, '(?!') || _elm_lang$core$Native_Utils.eq(_p16, '(?=')) && _elm_lang$core$Native_Utils.eq(_p15._1, ')');
		} else {
			return false;
		}
	}
};
var _user$project$GroupStartMap$setStartReturnEnd = F2(
	function ($this, offset) {
		var _p17 = A3(
			_user$project$ImpureGoodies$mutateRecordField,
			$this,
			'start',
			function () {
				var _p18 = $this.matched;
				if (_p18.ctor === 'Nothing') {
					return -1;
				} else {
					return offset;
				}
			}());
		var _p19 = function () {
			var _p20 = _user$project$GroupStartMap$originallyWrapped.repeaterUnapply($this.originalGroup);
			if (_p20.ctor === 'Just') {
				return _user$project$GroupStartMap$propagateEnd($this);
			} else {
				return _user$project$GroupStartMap$propagateStart($this);
			}
		}();
		return _user$project$GroupStartMap$originallyWrapped.absoluteUnapply($this.originalGroup) ? offset : _user$project$GroupStartMap$end($this);
	});
var _user$project$GroupStartMap$propagateEnd = function ($this) {
	var _p21 = A4(
		_user$project$GroupStartMap$foldNodeType,
		$this.nodeType,
		function (regex) {
			return 0;
		},
		function (children) {
			return A3(
				_elm_lang$core$List$foldr,
				_user$project$GroupStartMap$setEndReturnStart,
				_user$project$GroupStartMap$end($this),
				children);
		},
		function (children) {
			return A3(
				_user$project$GroupStartMap$foreach,
				function (child) {
					return A2(
						_user$project$GroupStartMap$setEndReturnStart,
						child,
						_user$project$GroupStartMap$end($this));
				},
				children,
				0);
		});
	return {ctor: '_Tuple0'};
};
var _user$project$GroupStartMap$setEndReturnStart = F2(
	function ($this, newEnd) {
		var _p22 = A3(
			_user$project$ImpureGoodies$mutateRecordField,
			$this,
			'start',
			function () {
				if (_user$project$GroupStartMap$originallyWrapped.absoluteUnapply($this.originalGroup)) {
					return newEnd;
				} else {
					var _p23 = $this.matched;
					if (_p23.ctor === 'Nothing') {
						return -1;
					} else {
						return newEnd - _elm_lang$core$String$length(_p23._0);
					}
				}
			}());
		var _p24 = _user$project$GroupStartMap$propagateStart($this);
		return $this.start;
	});
var _user$project$GroupStartMap$propagateStart = function ($this) {
	var _p25 = A4(
		_user$project$GroupStartMap$foldNodeType,
		$this.nodeType,
		function (regex) {
			return 0;
		},
		function (children) {
			return A3(_elm_lang$core$List$foldl, _user$project$GroupStartMap$setStartReturnEnd, $this.start, children);
		},
		function (children) {
			return A3(
				_user$project$GroupStartMap$foreach,
				function (child) {
					return A2(_user$project$GroupStartMap$setStartReturnEnd, child, $this.start);
				},
				children,
				0);
		});
	return {ctor: '_Tuple0'};
};
var _user$project$GroupStartMap$foldOriginalRegex = F3(
	function ($this, numberE, leftRightF) {
		var _p26 = $this;
		if (_p26.ctor === 'OriginallyGroupped') {
			return numberE(_p26._0);
		} else {
			return A2(leftRightF, _p26._0, _p26._1);
		}
	});
var _user$project$GroupStartMap$buildRegex = function ($this) {
	var leftRegex = A3(
		_user$project$GroupStartMap$foldOriginalRegex,
		$this.originalGroup,
		function (groupNum) {
			return '(';
		},
		F2(
			function (left, right) {
				return A2(_elm_lang$core$Basics_ops['++'], '((?:', left);
			}));
	var middleRegex = A4(
		_user$project$GroupStartMap$foldNodeType,
		$this.nodeType,
		function (regex) {
			return regex;
		},
		function (children) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'(?:',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$String$concat(
						A2(_elm_lang$core$List$map, _user$project$GroupStartMap$buildRegex, children)),
					')'));
		},
		function (children) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'(?:',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_elm_lang$core$String$concat(
						A2(
							_elm_lang$core$List$intersperse,
							'|',
							A2(_elm_lang$core$List$map, _user$project$GroupStartMap$buildRegex, children))),
					')'));
		});
	var rightRegex = A3(
		_user$project$GroupStartMap$foldOriginalRegex,
		$this.originalGroup,
		function (groupNum) {
			return ')';
		},
		F2(
			function (left, right) {
				return A2(
					_elm_lang$core$Basics_ops['++'],
					')',
					A2(_elm_lang$core$Basics_ops['++'], right, ')'));
			}));
	return A2(
		_elm_lang$core$Basics_ops['++'],
		leftRegex,
		A2(_elm_lang$core$Basics_ops['++'], middleRegex, rightRegex));
};
var _user$project$GroupStartMap$getGroupNodeMap = function ($this) {
	var thisGroupNodeMap = A3(
		_user$project$GroupStartMap$foldOriginalRegex,
		$this.originalGroup,
		function (groupNum) {
			return A2(_elm_lang$core$Dict$singleton, groupNum, $this);
		},
		F2(
			function (_p28, _p27) {
				return _elm_lang$core$Dict$empty;
			}));
	var childGroupNodeMap = A4(
		_user$project$GroupStartMap$foldNodeType,
		$this.nodeType,
		function (regex) {
			return _elm_lang$core$Dict$empty;
		},
		function (children) {
			return A3(
				_elm_lang$core$List$foldl,
				F2(
					function (child, mapping) {
						return A2(
							_elm_lang$core$Dict$union,
							_user$project$GroupStartMap$getGroupNodeMap(child),
							mapping);
					}),
				_elm_lang$core$Dict$empty,
				children);
		},
		function (children) {
			return A3(
				_elm_lang$core$List$foldl,
				F2(
					function (child, mapping) {
						return A2(
							_elm_lang$core$Dict$union,
							_user$project$GroupStartMap$getGroupNodeMap(child),
							mapping);
					}),
				_elm_lang$core$Dict$empty,
				children);
		});
	return A2(_elm_lang$core$Dict$union, childGroupNodeMap, thisGroupNodeMap);
};
var _user$project$GroupStartMap$stringCharAt = function (i) {
	return function (_p29) {
		return A2(
			_elm_lang$core$Maybe$map,
			_elm_lang$core$String$fromChar,
			A2(_user$project$ImpureGoodies$stringCharAt, i, _p29));
	};
};
var _user$project$GroupStartMap$Match = F4(
	function (a, b, c, d) {
		return {match: a, submatches: b, index: c, number: d};
	});
var _user$project$GroupStartMap$Node = F5(
	function (a, b, c, d, e) {
		return {originalGroup: a, nodeType: b, newGroup: c, matched: d, start: e};
	});
var _user$project$GroupStartMap$nodeApply = F2(
	function (originalGroup, nodeType) {
		return A5(
			_user$project$GroupStartMap$Node,
			originalGroup,
			nodeType,
			0,
			_elm_lang$core$Maybe$Just(''),
			0);
	});
var _user$project$GroupStartMap$GroupStartMap = F3(
	function (a, b, c) {
		return {string: a, start: b, pattern: c};
	});
var _user$project$GroupStartMap$OriginallyWrapped = F2(
	function (a, b) {
		return {ctor: 'OriginallyWrapped', _0: a, _1: b};
	});
var _user$project$GroupStartMap$OriginallyGroupped = function (a) {
	return {ctor: 'OriginallyGroupped', _0: a};
};
var _user$project$GroupStartMap$DisjunctNode = function (a) {
	return {ctor: 'DisjunctNode', _0: a};
};
var _user$project$GroupStartMap$nodeDisjunct = function (nodes) {
	return A5(
		_user$project$GroupStartMap$Node,
		A2(_user$project$GroupStartMap$OriginallyWrapped, '', ''),
		_user$project$GroupStartMap$DisjunctNode(nodes),
		0,
		_elm_lang$core$Maybe$Just(''),
		0);
};
var _user$project$GroupStartMap$ParentNode = function (a) {
	return {ctor: 'ParentNode', _0: a};
};
var _user$project$GroupStartMap$RegexLeaf = function (a) {
	return {ctor: 'RegexLeaf', _0: a};
};
var _user$project$GroupStartMap$createParentNode = function (children) {
	var disjuncts = A2(
		_user$project$GroupStartMap$splitWhere,
		children,
		function (c) {
			return _elm_lang$core$Native_Utils.eq(
				c.nodeType,
				_user$project$GroupStartMap$RegexLeaf('|'));
		});
	return _elm_lang$core$Native_Utils.eq(
		_elm_lang$core$List$length(disjuncts),
		1) ? _user$project$GroupStartMap$ParentNode(children) : _user$project$GroupStartMap$DisjunctNode(
		A2(_elm_lang$core$List$map, _user$project$GroupStartMap$nodeApplyP, disjuncts));
};
var _user$project$GroupStartMap$nodeApplyP = function (nodes) {
	return A5(
		_user$project$GroupStartMap$Node,
		A2(_user$project$GroupStartMap$OriginallyWrapped, '', ''),
		_user$project$GroupStartMap$createParentNode(nodes),
		0,
		_elm_lang$core$Maybe$Just(''),
		0);
};
var _user$project$GroupStartMap$nodeApplyR = function (regex) {
	return A5(
		_user$project$GroupStartMap$Node,
		A2(_user$project$GroupStartMap$OriginallyWrapped, '', ''),
		_user$project$GroupStartMap$RegexLeaf(regex),
		0,
		_elm_lang$core$Maybe$Just(''),
		0);
};
var _user$project$GroupStartMap$transformGroupNumber = F2(
	function (mapping, $this) {
		var _p30 = _user$project$GroupStartMap$backReferenceLeafUnapply($this.nodeType);
		if (_p30.ctor === 'Just') {
			return A3(
				_user$project$ImpureGoodies$mutateRecordField,
				$this,
				'nodeType',
				_user$project$GroupStartMap$RegexLeaf(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'\\',
						_elm_lang$core$Basics$toString(
							A2(
								_elm_lang$core$Maybe$withDefault,
								0,
								A2(_elm_lang$core$Dict$get, _p30._0, mapping))))));
		} else {
			var _p31 = $this.nodeType;
			switch (_p31.ctor) {
				case 'RegexLeaf':
					return $this;
				case 'ParentNode':
					return A3(
						_user$project$GroupStartMap$foreach,
						_user$project$GroupStartMap$transformGroupNumber(mapping),
						_p31._0,
						$this);
				default:
					return A3(
						_user$project$GroupStartMap$foreach,
						_user$project$GroupStartMap$transformGroupNumber(mapping),
						_p31._0,
						$this);
			}
		}
	});
var _user$project$GroupStartMap$simplifyNode = function ($this) {
	var _p32 = _user$project$GroupStartMap$nodeUnapply($this);
	if (((((_p32.ctor === '_Tuple2') && (_p32._0.ctor === 'OriginallyGroupped')) && (_p32._1.ctor === 'ParentNode')) && (_p32._1._0.ctor === '::')) && (_p32._1._0._1.ctor === '[]')) {
		var _p33 = _user$project$GroupStartMap$nodeUnapply(_p32._1._0._0);
		if (((((_p33.ctor === '_Tuple2') && (_p33._0.ctor === 'OriginallyWrapped')) && (_p33._0._0 === '')) && (_p33._0._1 === '')) && (_p33._1.ctor === 'RegexLeaf')) {
			return A2(
				_user$project$GroupStartMap$nodeApply,
				_user$project$GroupStartMap$OriginallyGroupped(_p32._0._0),
				_user$project$GroupStartMap$RegexLeaf(_p33._1._0));
		} else {
			return $this;
		}
	} else {
		return $this;
	}
};
var _user$project$GroupStartMap$parseRegex = function (pattern) {
	var parseClosingParenthesis = function (pIndex) {
		return pIndex + 1;
	};
	var positionEndNextBrace = function (pIndex) {
		positionEndNextBrace:
		while (true) {
			if (_elm_lang$core$Native_Utils.eq(
				A2(_user$project$GroupStartMap$stringCharAt, pIndex, pattern),
				_elm_lang$core$Maybe$Just('}'))) {
				return pIndex + 1;
			} else {
				if (_elm_lang$core$Native_Utils.cmp(
					_elm_lang$core$String$length(pattern),
					pIndex) < 1) {
					return pIndex;
				} else {
					var _v28 = pIndex + 1;
					pIndex = _v28;
					continue positionEndNextBrace;
				}
			}
		}
	};
	var positionEndSquareBracket = function (pIndex) {
		positionEndSquareBracket:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(
				_elm_lang$core$String$length(pattern),
				pIndex) < 1) {
				return pIndex;
			} else {
				if (_elm_lang$core$Native_Utils.eq(
					A2(_user$project$GroupStartMap$stringCharAt, pIndex, pattern),
					_elm_lang$core$Maybe$Just('\\')) && (_elm_lang$core$Native_Utils.cmp(
					_elm_lang$core$String$length(pattern),
					1) > 0)) {
					var _v29 = pIndex + 2;
					pIndex = _v29;
					continue positionEndSquareBracket;
				} else {
					if (_elm_lang$core$Native_Utils.eq(
						A2(_user$project$GroupStartMap$stringCharAt, pIndex, pattern),
						_elm_lang$core$Maybe$Just(']'))) {
						return pIndex + 1;
					} else {
						var _v30 = pIndex + 1;
						pIndex = _v30;
						continue positionEndSquareBracket;
					}
				}
			}
		}
	};
	var positionAfterLastDigit = function (pIndex) {
		positionAfterLastDigit:
		while (true) {
			if ((_elm_lang$core$Native_Utils.cmp(
				pIndex,
				_elm_lang$core$String$length(pattern)) < 0) && A2(
				_elm_lang$core$String$all,
				_elm_lang$core$Char$isDigit,
				A2(
					_elm_lang$core$Maybe$withDefault,
					'c',
					A2(_user$project$GroupStartMap$stringCharAt, pIndex, pattern)))) {
				var _v31 = pIndex + 1;
				pIndex = _v31;
				continue positionAfterLastDigit;
			} else {
				return pIndex;
			}
		}
	};
	var parse = F2(
		function (pIndex, nextGroupIndex) {
			if (_elm_lang$core$Native_Utils.cmp(
				pIndex,
				_elm_lang$core$String$length(pattern)) > -1) {
				return {
					ctor: '_Tuple3',
					_0: {ctor: '[]'},
					_1: pIndex,
					_2: nextGroupIndex
				};
			} else {
				var simplify = function (nodes) {
					simplify:
					while (true) {
						var _p34 = nodes;
						if ((_p34.ctor === '::') && (_p34._1.ctor === '::')) {
							var _p42 = _p34._1._1;
							var _p41 = _p34._0;
							var _p35 = {
								ctor: '_Tuple2',
								_0: _user$project$GroupStartMap$nodeUnapply(_p41),
								_1: _user$project$GroupStartMap$nodeUnapply(_p34._1._0)
							};
							_v33_2:
							do {
								if ((((_p35.ctor === '_Tuple2') && (_p35._0.ctor === '_Tuple2')) && (_p35._1.ctor === '_Tuple2')) && (_p35._1._1.ctor === 'RegexLeaf')) {
									if (((((((_p35._0._0.ctor === 'OriginallyWrapped') && (_p35._0._0._0 === '')) && (_p35._0._0._1 === '')) && (_p35._0._1.ctor === 'RegexLeaf')) && (_p35._1._0.ctor === 'OriginallyWrapped')) && (_p35._1._0._0 === '')) && (_p35._1._0._1 === '')) {
										var _p37 = _p35._1._1._0;
										var _p36 = _p35._0._1._0;
										if ((!_user$project$GroupStartMap$isBackReference(_p36)) && ((!_elm_lang$core$Native_Utils.eq(_p36, '|')) && ((!_user$project$GroupStartMap$isBackReference(_p37)) && (!_elm_lang$core$Native_Utils.eq(_p37, '|'))))) {
											var _v34 = {
												ctor: '::',
												_0: _user$project$GroupStartMap$nodeApplyR(
													A2(_elm_lang$core$Basics_ops['++'], _p36, _p37)),
												_1: _p42
											};
											nodes = _v34;
											continue simplify;
										} else {
											return nodes;
										}
									} else {
										if (_p35._1._1._0 === '') {
											var _p38 = _user$project$GroupStartMap$originallyWrapped.repeaterUnapply(_p35._1._0);
											if (_p38.ctor === 'Just') {
												var _p40 = _p38._0;
												var _p39 = _p35._0._0;
												if (_p39.ctor === 'OriginallyWrapped') {
													var _v37 = {
														ctor: '::',
														_0: A2(
															_user$project$GroupStartMap$nodeApply,
															A2(
																_user$project$GroupStartMap$OriginallyWrapped,
																_p39._0,
																A2(_elm_lang$core$Basics_ops['++'], _p39._1, _p40)),
															_p35._0._1),
														_1: _p42
													};
													nodes = _v37;
													continue simplify;
												} else {
													var _v38 = {
														ctor: '::',
														_0: A2(
															_user$project$GroupStartMap$nodeApply,
															A2(_user$project$GroupStartMap$OriginallyWrapped, '', _p40),
															_user$project$GroupStartMap$ParentNode(
																{
																	ctor: '::',
																	_0: _p41,
																	_1: {ctor: '[]'}
																})),
														_1: _p42
													};
													nodes = _v38;
													continue simplify;
												}
											} else {
												return nodes;
											}
										} else {
											break _v33_2;
										}
									}
								} else {
									break _v33_2;
								}
							} while(false);
							return nodes;
						} else {
							return nodes;
						}
					}
				};
				var addSiblings = F3(
					function (node, remaining, nextGroupIndex) {
						var _p43 = A2(parse, remaining, nextGroupIndex);
						var siblings = _p43._0;
						var finalRemaining = _p43._1;
						var finalGroupIndex = _p43._2;
						return {
							ctor: '_Tuple3',
							_0: simplify(
								{ctor: '::', _0: node, _1: siblings}),
							_1: finalRemaining,
							_2: finalGroupIndex
						};
					});
				var $default = function (e) {
					return A3(
						addSiblings,
						_user$project$GroupStartMap$nodeApplyR(e),
						pIndex + 1,
						nextGroupIndex);
				};
				var _p44 = A2(_user$project$GroupStartMap$stringCharAt, pIndex, pattern);
				if (_p44.ctor === 'Nothing') {
					return _elm_lang$core$Native_Utils.crashCase(
						'GroupStartMap',
						{
							start: {line: 517, column: 6},
							end: {line: 580, column: 26}
						},
						_p44)('Internal error: should have not reached the end of regex');
				} else {
					var _p50 = _p44._0;
					var _p46 = _p50;
					switch (_p46) {
						case '(':
							if ((_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$String$length(pattern),
								pIndex + 3) > -1) && (_elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
								_elm_lang$core$Maybe$Just('?')) && (_elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 2, pattern),
								_elm_lang$core$Maybe$Just('=')) || _elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 2, pattern),
								_elm_lang$core$Maybe$Just('!'))))) {
								var _p47 = A2(parse, pIndex + 3, nextGroupIndex);
								var parsed = _p47._0;
								var remaining = _p47._1;
								var newNextGroupIndex = _p47._2;
								var remaining1 = parseClosingParenthesis(remaining);
								return A3(
									addSiblings,
									A2(
										_user$project$GroupStartMap$nodeApply,
										A2(
											_user$project$GroupStartMap$OriginallyWrapped,
											A2(
												_elm_lang$core$Basics_ops['++'],
												'(?',
												A2(
													_elm_lang$core$Maybe$withDefault,
													'',
													A2(_user$project$GroupStartMap$stringCharAt, pIndex + 2, pattern))),
											')'),
										_user$project$GroupStartMap$createParentNode(parsed)),
									remaining1,
									newNextGroupIndex);
							} else {
								if ((_elm_lang$core$Native_Utils.cmp(
									_elm_lang$core$String$length(pattern),
									pIndex + 3) < 0) || ((!_elm_lang$core$Native_Utils.eq(
									A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
									_elm_lang$core$Maybe$Just('?'))) || (!_elm_lang$core$Native_Utils.eq(
									A2(_user$project$GroupStartMap$stringCharAt, pIndex + 2, pattern),
									_elm_lang$core$Maybe$Just(':'))))) {
									var _p48 = A2(parse, pIndex + 1, nextGroupIndex + 1);
									var parsed = _p48._0;
									var remaining = _p48._1;
									var newNextGroupIndex = _p48._2;
									var remaining1 = parseClosingParenthesis(remaining);
									return A3(
										addSiblings,
										_user$project$GroupStartMap$simplifyNode(
											A2(
												_user$project$GroupStartMap$nodeApply,
												_user$project$GroupStartMap$OriginallyGroupped(nextGroupIndex),
												_user$project$GroupStartMap$createParentNode(parsed))),
										remaining1,
										newNextGroupIndex);
								} else {
									if ((_elm_lang$core$Native_Utils.cmp(
										_elm_lang$core$String$length(pattern),
										pIndex + 3) > -1) && (_elm_lang$core$Native_Utils.eq(
										A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
										_elm_lang$core$Maybe$Just('?')) && _elm_lang$core$Native_Utils.eq(
										A2(_user$project$GroupStartMap$stringCharAt, pIndex + 2, pattern),
										_elm_lang$core$Maybe$Just(':')))) {
										var _p49 = A2(parse, pIndex + 3, nextGroupIndex);
										var parsedNodes = _p49._0;
										var remaining = _p49._1;
										var newNextGroupIndex = _p49._2;
										var remaining1 = parseClosingParenthesis(remaining);
										return A3(
											addSiblings,
											_user$project$GroupStartMap$simplifyNode(
												_user$project$GroupStartMap$nodeApplyP(parsedNodes)),
											remaining1,
											newNextGroupIndex);
									} else {
										return $default(_p50);
									}
								}
							}
						case ')':
							return {
								ctor: '_Tuple3',
								_0: {ctor: '[]'},
								_1: pIndex,
								_2: nextGroupIndex
							};
						case '\\':
							if (_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$String$length(pattern),
								pIndex + 2) > -1) {
								var nextIndex = A2(
									_elm_lang$core$Maybe$withDefault,
									false,
									A2(
										_elm_lang$core$Maybe$map,
										_elm_lang$core$String$all(_elm_lang$core$Char$isDigit),
										A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern))) ? positionAfterLastDigit(pIndex + 1) : (pIndex + 2);
								var regexPart = A3(_elm_lang$core$String$slice, pIndex, nextIndex, pattern);
								return A3(
									addSiblings,
									_user$project$GroupStartMap$nodeApplyR(regexPart),
									nextIndex,
									nextGroupIndex);
							} else {
								return $default(_p50);
							}
						case '+':
							var nextIndex = ((_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$String$length(pattern),
								pIndex + 2) > -1) && _elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
								_elm_lang$core$Maybe$Just('?'))) ? (pIndex + 2) : (pIndex + 1);
							var repeater = A3(_elm_lang$core$String$slice, pIndex, nextIndex, pattern);
							return A3(
								addSiblings,
								A2(
									_user$project$GroupStartMap$nodeApply,
									A2(_user$project$GroupStartMap$OriginallyWrapped, '', repeater),
									_user$project$GroupStartMap$RegexLeaf('')),
								nextIndex,
								nextGroupIndex);
						case '*':
							var nextIndex = ((_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$String$length(pattern),
								pIndex + 2) > -1) && _elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
								_elm_lang$core$Maybe$Just('?'))) ? (pIndex + 2) : (pIndex + 1);
							var repeater = A3(_elm_lang$core$String$slice, pIndex, nextIndex, pattern);
							return A3(
								addSiblings,
								A2(
									_user$project$GroupStartMap$nodeApply,
									A2(_user$project$GroupStartMap$OriginallyWrapped, '', repeater),
									_user$project$GroupStartMap$RegexLeaf('')),
								nextIndex,
								nextGroupIndex);
						case '?':
							var nextIndex = ((_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$String$length(pattern),
								pIndex + 2) > -1) && _elm_lang$core$Native_Utils.eq(
								A2(_user$project$GroupStartMap$stringCharAt, pIndex + 1, pattern),
								_elm_lang$core$Maybe$Just('?'))) ? (pIndex + 2) : (pIndex + 1);
							var repeater = A3(_elm_lang$core$String$slice, pIndex, nextIndex, pattern);
							return A3(
								addSiblings,
								A2(
									_user$project$GroupStartMap$nodeApply,
									A2(_user$project$GroupStartMap$OriginallyWrapped, '', repeater),
									_user$project$GroupStartMap$RegexLeaf('')),
								nextIndex,
								nextGroupIndex);
						case '{':
							var nextIndex = positionEndNextBrace(pIndex + 1);
							var repeater = A3(_elm_lang$core$String$slice, pIndex, nextIndex, pattern);
							return A3(
								addSiblings,
								A2(
									_user$project$GroupStartMap$nodeApply,
									A2(_user$project$GroupStartMap$OriginallyWrapped, '', repeater),
									_user$project$GroupStartMap$RegexLeaf('')),
								nextIndex,
								nextGroupIndex);
						case '[':
							var remaining = positionEndSquareBracket(pIndex + 1);
							var inside = A3(_elm_lang$core$String$slice, pIndex, remaining, pattern);
							return A3(
								addSiblings,
								_user$project$GroupStartMap$nodeApplyR(inside),
								remaining,
								nextGroupIndex);
						default:
							return $default(_p50);
					}
				}
			}
		});
	var _p51 = A2(parse, 0, 1);
	if (_p51._0.ctor === '[]') {
		return _user$project$GroupStartMap$nodeApplyR('');
	} else {
		if (_p51._0._1.ctor === '[]') {
			return _p51._0._0;
		} else {
			return _user$project$GroupStartMap$nodeApplyP(_p51._0);
		}
	}
};
var _user$project$GroupStartMap$find = F3(
	function (howMany, reg, string) {
		var node = _user$project$GroupStartMap$parseRegex(reg);
		var _p52 = A2(_user$project$GroupStartMap$setNewGroup, node, 1);
		var groupNodeMap = _user$project$GroupStartMap$getGroupNodeMap(node);
		var _p53 = A2(
			_user$project$GroupStartMap$transformGroupNumber,
			A2(
				_elm_lang$core$Dict$map,
				F2(
					function (k, v) {
						return v.newGroup;
					}),
				groupNodeMap),
			node);
		var allMatchingRegexStr = _user$project$GroupStartMap$buildRegex(node);
		var allMatchingRegex = _elm_lang$core$Regex$regex(allMatchingRegexStr);
		var findResult = A3(_elm_lang$core$Regex$find, howMany, allMatchingRegex, string);
		return A2(
			_elm_lang$core$List$map,
			function (match) {
				var _p54 = A2(
					_user$project$GroupStartMap$setMatch,
					function (x) {
						var _p55 = A2(
							_elm_lang$core$List$take,
							1,
							A2(_elm_lang$core$List$drop, x - 1, match.submatches));
						if ((_p55.ctor === '::') && (_p55._1.ctor === '[]')) {
							return _p55._0;
						} else {
							return _elm_lang$core$Native_Utils.crashCase(
								'GroupStartMap',
								{
									start: {line: 368, column: 29},
									end: {line: 370, column: 105}
								},
								_p55)(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'[internal error]',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_elm_lang$core$Basics$toString(x),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' Index ouf of bounds',
											_elm_lang$core$Basics$toString(_p55)))));
						}
					},
					node);
				var _p57 = A2(_user$project$GroupStartMap$setStartReturnEnd, node, match.index);
				var matchesWithStart = A2(
					_elm_lang$core$List$map,
					function (_p58) {
						var _p59 = _p58;
						var _p60 = _p59._1;
						return {match: _p60.matched, start: _p60.start};
					},
					A2(
						_elm_lang$core$List$sortBy,
						_elm_lang$core$Tuple$first,
						_elm_lang$core$Dict$toList(groupNodeMap)));
				return A4(_user$project$GroupStartMap$Match, match.match, matchesWithStart, match.index, match.number);
			},
			findResult);
	});
var _user$project$GroupStartMap$replace = F4(
	function (howMany, reg, replacementFun, string) {
		var node = _user$project$GroupStartMap$parseRegex(reg);
		var _p61 = A2(_user$project$GroupStartMap$setNewGroup, node, 1);
		var groupNodeMap = _user$project$GroupStartMap$getGroupNodeMap(node);
		var _p62 = A2(
			_user$project$GroupStartMap$transformGroupNumber,
			A2(
				_elm_lang$core$Dict$map,
				F2(
					function (k, v) {
						return v.newGroup;
					}),
				groupNodeMap),
			node);
		var allMatchingRegexStr = _user$project$GroupStartMap$buildRegex(node);
		var allMatchingRegex = _elm_lang$core$Regex$regex(allMatchingRegexStr);
		var f = function (match) {
			var _p63 = A2(
				_user$project$GroupStartMap$setMatch,
				function (x) {
					var _p64 = A2(
						_elm_lang$core$List$take,
						1,
						A2(_elm_lang$core$List$drop, x - 1, match.submatches));
					if ((_p64.ctor === '::') && (_p64._1.ctor === '[]')) {
						return _p64._0;
					} else {
						return _elm_lang$core$Native_Utils.crashCase(
							'GroupStartMap',
							{
								start: {line: 393, column: 31},
								end: {line: 395, column: 106}
							},
							_p64)(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'[internal error]',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(x),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' Index ouf of bounds',
										_elm_lang$core$Basics$toString(_p64)))));
					}
				},
				node);
			var _p66 = A2(_user$project$GroupStartMap$setStartReturnEnd, node, match.index);
			var g = A2(
				_elm_lang$core$Dict$map,
				F2(
					function (k, v) {
						return v.start;
					}),
				groupNodeMap);
			var matchesWithStart = A2(
				_elm_lang$core$List$map,
				function (_p67) {
					var _p68 = _p67;
					var _p69 = _p68._1;
					return {match: _p69.matched, start: _p69.start};
				},
				A2(
					_elm_lang$core$List$sortBy,
					_elm_lang$core$Tuple$first,
					_elm_lang$core$Dict$toList(groupNodeMap)));
			var m = A4(_user$project$GroupStartMap$Match, match.match, matchesWithStart, match.index, match.number);
			return replacementFun(m);
		};
		return A4(_elm_lang$core$Regex$replace, howMany, allMatchingRegex, f, string);
	});

var _user$project$UpdateRegex$allInterleavingsIn = F2(
	function (separators, string) {
		if (_elm_lang$core$Native_Utils.eq(
			_elm_lang$core$List$length(separators),
			0)) {
			return A2(
				_user$project$LazyList$Cons,
				{
					ctor: '::',
					_0: string,
					_1: {ctor: '[]'}
				},
				_elm_lang$lazy$Lazy$lazy(
					function (_p0) {
						return _user$project$LazyList$Nil;
					}));
		} else {
			var aux = F2(
				function (remainingSeparators, numrepetitions) {
					var _p1 = {ctor: '_Tuple2', _0: remainingSeparators, _1: numrepetitions};
					_v0_2:
					do {
						if (_p1.ctor === '_Tuple2') {
							if (_p1._0.ctor === '[]') {
								if (_p1._1.ctor === '[]') {
									return '(.*?)';
								} else {
									break _v0_2;
								}
							} else {
								if (_p1._1.ctor === '::') {
									var escapedHead = _elm_lang$core$Regex$escape(_p1._0._0);
									return A2(
										_elm_lang$core$Basics_ops['++'],
										'(.*?',
										A2(
											_elm_lang$core$Basics_ops['++'],
											A2(
												_elm_lang$core$String$repeat,
												_p1._1._0,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'(?:(?=',
													A2(_elm_lang$core$Basics_ops['++'], escapedHead, ').).*?'))),
											A2(
												_elm_lang$core$Basics_ops['++'],
												')',
												A2(
													_elm_lang$core$Basics_ops['++'],
													escapedHead,
													A2(aux, _p1._0._1, _p1._1._1)))));
								} else {
									break _v0_2;
								}
							}
						} else {
							break _v0_2;
						}
					} while(false);
					return _elm_lang$core$Native_Utils.crashCase(
						'UpdateRegex',
						{
							start: {line: 930, column: 48},
							end: {line: 935, column: 99}
						},
						_p1)('internal error: the two lists of allinterleavings should have the same size');
				});
			var lastIndex = _elm_lang$core$List$length(separators) - 1;
			var next = F2(
				function (index, numReps) {
					var _p3 = numReps;
					if (_p3.ctor === '[]') {
						return _elm_lang$core$Native_Utils.crashCase(
							'UpdateRegex',
							{
								start: {line: 940, column: 5},
								end: {line: 946, column: 42}
							},
							_p3)('Internal error: empty numRep');
					} else {
						var _p7 = _p3._1;
						var _p6 = _p3._0;
						return _elm_lang$core$Native_Utils.eq(index, 0) ? {
							ctor: '::',
							_0: _p6 + 1,
							_1: A2(
								_elm_lang$core$List$map,
								function (_p5) {
									return 0;
								},
								_p7)
						} : {
							ctor: '::',
							_0: _p6,
							_1: A2(next, index - 1, _p7)
						};
					}
				});
			var initNumRep = A2(
				_elm_lang$core$List$map,
				function (_p8) {
					return 0;
				},
				separators);
			var findMatchFor = F2(
				function (indexRepToModify, numRep) {
					var r = _elm_lang$core$Regex$regex(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'^',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(aux, separators, numRep),
								'$')));
					var $default = function (_p9) {
						var _p10 = _p9;
						return _elm_lang$core$Native_Utils.eq(indexRepToModify, 0) ? _user$project$LazyList$Nil : A2(
							findMatchFor,
							indexRepToModify - 1,
							A2(next, indexRepToModify - 1, numRep));
					};
					var _p11 = A3(
						_elm_lang$core$Regex$find,
						_elm_lang$core$Regex$AtMost(1),
						r,
						string);
					if ((_p11.ctor === '::') && (_p11._1.ctor === '[]')) {
						var _p12 = _user$project$Utils$projJusts(_p11._0.submatches);
						if (_p12.ctor === 'Just') {
							return A2(
								_user$project$LazyList$Cons,
								_p12._0,
								_elm_lang$lazy$Lazy$lazy(
									function (_p13) {
										return A2(
											findMatchFor,
											lastIndex,
											A2(next, lastIndex, numRep));
									}));
						} else {
							return $default(
								{ctor: '_Tuple0'});
						}
					} else {
						return $default(
							{ctor: '_Tuple0'});
					}
				});
			return A2(
				findMatchFor,
				_elm_lang$core$List$length(separators) - 1,
				initNumRep);
		}
	});
var _user$project$UpdateRegex$evalRegexExtractFirstIn = F2(
	function (regexpV, stringV) {
		var _p14 = {ctor: '_Tuple2', _0: regexpV.v_, _1: stringV.v_};
		if (((((_p14.ctor === '_Tuple2') && (_p14._0.ctor === 'VBase')) && (_p14._0._0.ctor === 'VString')) && (_p14._1.ctor === 'VBase')) && (_p14._1._0.ctor === 'VString')) {
			var matches = A3(
				_user$project$GroupStartMap$find,
				_elm_lang$core$Regex$AtMost(1),
				_p14._0._0._0,
				_p14._1._0._0);
			var _p15 = matches;
			if (_p15.ctor === '[]') {
				return _elm_lang$core$Result$Ok(
					A3(
						_user$project$ValBuilder$constructor,
						_user$project$ValBuilder$fromVal(stringV),
						'Nothing',
						{ctor: '[]'}));
			} else {
				return _elm_lang$core$Result$Ok(
					A3(
						_user$project$ValBuilder$constructor,
						_user$project$ValBuilder$fromVal(stringV),
						'Just',
						{
							ctor: '::',
							_0: A3(
								_user$project$ValBuilder$list,
								F2(
									function (v, _p16) {
										var _p17 = _p16;
										return A2(
											_user$project$ValBuilder$string,
											v,
											A2(_elm_lang$core$Maybe$withDefault, '', _p17.match));
									}),
								_user$project$ValBuilder$fromVal(stringV),
								_p15._0.submatches),
							_1: {ctor: '[]'}
						}));
			}
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected two strings, a regex and a string, got ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUtils$valToString(regexpV),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' and ',
							_user$project$LangUtils$valToString(stringV)))));
		}
	});
var _user$project$UpdateRegex$recoverStringDiffs = F5(
	function (recoverSubExpressionStringDiffs, recoverSubStringsDiffs, oldConcatenationStarts, newConcatenation, diffs) {
		var aux = F5(
			function (i, oldConcatenationStarts, newConcatenation, diffs, accRes) {
				aux:
				while (true) {
					var currentDiff = function () {
						var _p18 = diffs;
						if (_p18.ctor === '[]') {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							return (_elm_lang$core$Native_Utils.cmp(_p18._0._0, i) > 0) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
								{ctor: '_Tuple2', _0: _p18._0._1, _1: _p18._1});
						}
					}();
					var _p19 = currentDiff;
					if (_p19.ctor === 'Nothing') {
						var _p20 = {ctor: '_Tuple2', _0: oldConcatenationStarts, _1: newConcatenation};
						if (_p20._0.ctor === '[]') {
							return _elm_lang$core$Result$Err('[Internal error] oldConcatenationStarts should never be empty');
						} else {
							if (_p20._1.ctor === '[]') {
								if (_p20._0._1.ctor === '[]') {
									return accRes;
								} else {
									var _p21 = _p20._0._0;
									return A2(
										_user$project$Results$map,
										function (acc) {
											return {
												ctor: '::',
												_0: {
													ctor: '_Tuple3',
													_0: _p21,
													_1: A2(_user$project$Utils$last, 'UpdateRegex.recoverStringDiffs', oldConcatenationStarts) - _p21,
													_2: ''
												},
												_1: acc
											};
										},
										accRes);
								}
							} else {
								var _p23 = _p20._1._0;
								var newRes = function () {
									var _p22 = recoverSubStringsDiffs(_p23);
									if (_p22.ctor === 'Just') {
										return accRes;
									} else {
										return A3(
											_user$project$Results$map2,
											F2(
												function (l1, l2) {
													return A2(_elm_lang$core$Basics_ops['++'], l1, l2);
												}),
											accRes,
											recoverSubExpressionStringDiffs(_p23));
									}
								}();
								var _v12 = i + 1,
									_v13 = _p20._0._1,
									_v14 = _p20._1._1,
									_v15 = diffs,
									_v16 = newRes;
								i = _v12;
								oldConcatenationStarts = _v13;
								newConcatenation = _v14;
								diffs = _v15;
								accRes = _v16;
								continue aux;
							}
						}
					} else {
						var _p36 = _p19._0._1;
						var _p24 = _p19._0._0;
						switch (_p24.ctor) {
							case 'ListElemInsert':
								var _p29 = _p24._0;
								var _p25 = A2(_user$project$Utils$split, _p29, newConcatenation);
								var inserted = _p25._0;
								var remainingNewConcatenation = _p25._1;
								var insertedStr = A2(
									_elm_lang$core$Result$map,
									_elm_lang$core$String$join(''),
									_user$project$Utils$projOk(
										A2(
											_elm_lang$core$List$map,
											function (_p26) {
												return A2(
													_elm_lang$core$Result$fromMaybe,
													'insertion of something else than strings in regex joins not supported',
													_user$project$Lang$eStrUnapply(_p26));
											},
											inserted)));
								var _p27 = {ctor: '_Tuple2', _0: oldConcatenationStarts, _1: insertedStr};
								if (_p27._1.ctor === 'Err') {
									return _elm_lang$core$Result$Err(_p27._1._0);
								} else {
									if (_p27._0.ctor === '[]') {
										return _elm_lang$core$Result$Err('[Internal error] oldConcatenationStarts should never be empty');
									} else {
										var _p28 = _p27._0._0;
										var _v19 = i,
											_v20 = A2(_elm_lang$core$List$drop, _p29, oldConcatenationStarts),
											_v21 = remainingNewConcatenation,
											_v22 = _p36,
											_v23 = A2(
											_user$project$Results$map,
											function (acc) {
												return {
													ctor: '::',
													_0: {ctor: '_Tuple3', _0: _p28, _1: _p28, _2: _p27._1._0},
													_1: acc
												};
											},
											accRes);
										i = _v19;
										oldConcatenationStarts = _v20;
										newConcatenation = _v21;
										diffs = _v22;
										accRes = _v23;
										continue aux;
									}
								}
							case 'ListElemDelete':
								var _p32 = _p24._0;
								var _p30 = A2(_user$project$Utils$split, _p32, oldConcatenationStarts);
								var deleted = _p30._0;
								var remainingOldConcatenationStarts = _p30._1;
								var _p31 = {ctor: '_Tuple2', _0: oldConcatenationStarts, _1: remainingOldConcatenationStarts};
								if (_p31._1.ctor === '[]') {
									return _elm_lang$core$Result$Err('[Internal error] remainingOldConcatenationStarts should never be empty');
								} else {
									if (_p31._0.ctor === '[]') {
										return _elm_lang$core$Result$Err('[Internal error] oldConcatenationStarts should never be empty');
									} else {
										var _v25 = i + _p32,
											_v26 = remainingOldConcatenationStarts,
											_v27 = newConcatenation,
											_v28 = _p36,
											_v29 = A2(
											_user$project$Results$map,
											function (acc) {
												return {
													ctor: '::',
													_0: {ctor: '_Tuple3', _0: _p31._0._0, _1: _p31._1._0, _2: ''},
													_1: acc
												};
											},
											accRes);
										i = _v25;
										oldConcatenationStarts = _v26;
										newConcatenation = _v27;
										diffs = _v28;
										accRes = _v29;
										continue aux;
									}
								}
							default:
								var _p33 = {ctor: '_Tuple2', _0: oldConcatenationStarts, _1: newConcatenation};
								if (_p33._0.ctor === '[]') {
									return _elm_lang$core$Result$Err('[Internal error] oldConcatenationStarts should never be empty');
								} else {
									if (_p33._1.ctor === '[]') {
										return _elm_lang$core$Result$Err('[Internal error] newConcatenation was empty');
									} else {
										var _p35 = _p33._1._0;
										var _p34 = A2(
											_elm_lang$core$Maybe$andThen,
											function (k) {
												return k(_p24._0);
											},
											recoverSubStringsDiffs(_p35));
										if (_p34.ctor === 'Nothing') {
											return _elm_lang$core$Result$Err(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'[Internal error] Cannot update something else than a string in regex join, got ',
													A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p35)));
										} else {
											var _v32 = i + 1,
												_v33 = _p33._0._1,
												_v34 = _p33._1._1,
												_v35 = _p36,
												_v36 = A2(
												_user$project$Results$map,
												function (acc) {
													return A2(
														_elm_lang$core$Basics_ops['++'],
														acc,
														A2(_user$project$UpdateUtils$offsetConcStr, _p33._0._0, _p34._0));
												},
												accRes);
											i = _v32;
											oldConcatenationStarts = _v33;
											newConcatenation = _v34;
											diffs = _v35;
											accRes = _v36;
											continue aux;
										}
									}
								}
						}
					}
				}
			});
		return A5(
			aux,
			0,
			oldConcatenationStarts,
			newConcatenation,
			diffs,
			_user$project$Results$ok1(
				{ctor: '[]'}));
	});
var _user$project$UpdateRegex$interleavingStrings = F2(
	function (string, matchList) {
		var _p37 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (m, _p38) {
					var _p39 = _p38;
					return {
						ctor: '_Tuple2',
						_0: m.index + _elm_lang$core$String$length(m.match),
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							_p39._1,
							{
								ctor: '::',
								_0: A3(_elm_lang$core$String$slice, _p39._0, m.index, string),
								_1: {ctor: '[]'}
							})
					};
				}),
			{
				ctor: '_Tuple2',
				_0: 0,
				_1: {ctor: '[]'}
			},
			matchList);
		var lastEnd = _p37._0;
		var initStrings = _p37._1;
		var lastString = A2(_elm_lang$core$String$dropLeft, lastEnd, string);
		return {ctor: '_Tuple2', _0: initStrings, _1: lastString};
	});
var _user$project$UpdateRegex$dummyUpdate = function (updateStack) {
	return _elm_lang$core$Result$Err('[internal error] Should not call dummyUpdate');
};
var _user$project$UpdateRegex$unconcat = F2(
	function (e, mbdiffs) {
		var _p40 = _user$project$Lang$eAppUnapply1(e);
		if (_p40.ctor === 'Nothing') {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'[internal error] Not a join [], instead ',
					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
		} else {
			var _p41 = _user$project$Lang$eListUnapply(_p40._0._1);
			if (_p41.ctor === 'Nothing') {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'[internal error] Not a join [], instead ',
						A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
			} else {
				var _p43 = _p41._0;
				var _p42 = mbdiffs;
				if (_p42.ctor === 'Just') {
					if ((((((_p42._0.ctor === 'EChildDiffs') && (_p42._0._0.ctor === '::')) && (_p42._0._0._0.ctor === '_Tuple2')) && (_p42._0._0._0._0 === 1)) && (_p42._0._0._0._1.ctor === 'EListDiffs')) && (_p42._0._0._1.ctor === '[]')) {
						return _elm_lang$core$Result$Ok(
							{ctor: '_Tuple2', _0: _p43, _1: _p42._0._0._0._1._0});
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'[Internal error] not a Nothing or Just EChildDiffs [(1, EListDiffs l)], instead ',
								_elm_lang$core$Basics$toString(mbdiffs)));
					}
				} else {
					return _elm_lang$core$Result$Ok(
						{
							ctor: '_Tuple2',
							_0: _p43,
							_1: {ctor: '[]'}
						});
				}
			}
		}
	});
var _user$project$UpdateRegex$concat = F2(
	function (joinName, l) {
		return A2(
			_user$project$Lang$eApp,
			_user$project$Lang$eVar(joinName),
			{
				ctor: '::',
				_0: A2(_user$project$Lang$eList, l, _elm_lang$core$Maybe$Nothing),
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateRegex$eitherToVal = F5(
	function (subroutine1, subroutine1b, subroutine2, vb, either) {
		var _p44 = either;
		if (_p44.ctor === 'Left') {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Left',
				{
					ctor: '::',
					_0: A2(subroutine1, vb, _p44._0._0),
					_1: {
						ctor: '::',
						_0: A2(subroutine1b, vb, _p44._0._1),
						_1: {ctor: '[]'}
					}
				});
		} else {
			return A3(
				_user$project$ValBuilder$constructor,
				vb,
				'Right',
				{
					ctor: '::',
					_0: A2(subroutine2, vb, _p44._0),
					_1: {ctor: '[]'}
				});
		}
	});
var _user$project$UpdateRegex$mergeTransformations = F2(
	function (originalString, replacements) {
		var aux = F3(
			function (maxReplacementIndex, string, transformations) {
				aux:
				while (true) {
					var _p45 = transformations;
					if (_p45.ctor === '[]') {
						return string;
					} else {
						var _p48 = _p45._0._0;
						var _p47 = _p45._1;
						var _p46 = _p45._0._1;
						if ((_elm_lang$core$Native_Utils.cmp(_p48, 0) > -1) && (_elm_lang$core$Native_Utils.cmp(_p46, maxReplacementIndex) < 1)) {
							var updatedString = A2(
								_elm_lang$core$Basics_ops['++'],
								A2(_elm_lang$core$String$left, _p48, string),
								A2(
									_elm_lang$core$Basics_ops['++'],
									_p45._0._2,
									A2(_elm_lang$core$String$dropLeft, _p46, string)));
							var _v43 = _p48,
								_v44 = updatedString,
								_v45 = _p47;
							maxReplacementIndex = _v43;
							string = _v44;
							transformations = _v45;
							continue aux;
						} else {
							var _v46 = maxReplacementIndex,
								_v47 = string,
								_v48 = _p47;
							maxReplacementIndex = _v46;
							string = _v47;
							transformations = _v48;
							continue aux;
						}
					}
				}
			});
		return A3(
			aux,
			_elm_lang$core$String$length(originalString),
			originalString,
			A2(
				_elm_lang$core$List$sortBy,
				function (_p49) {
					var _p50 = _p49;
					return 0 - _p50._0;
				},
				replacements));
	});
var _user$project$UpdateRegex$updateRegexExtractFirstIn = F4(
	function (regexpV, stringV, oldVal, newVal) {
		var _p51 = {ctor: '_Tuple2', _0: regexpV.v_, _1: stringV.v_};
		if (((((_p51.ctor === '_Tuple2') && (_p51._0.ctor === 'VBase')) && (_p51._0._0.ctor === 'VString')) && (_p51._1.ctor === 'VBase')) && (_p51._1._0.ctor === 'VString')) {
			var _p58 = _p51._1._0._0;
			var matches = A3(
				_user$project$GroupStartMap$find,
				_elm_lang$core$Regex$AtMost(1),
				_p51._0._0._0,
				_p58);
			var _p52 = matches;
			if (_p52.ctor === '[]') {
				var _p53 = A2(
					_elm_lang$core$Debug$log,
					'No match! Workaround: just return original string',
					{ctor: '_Tuple0'});
				return _user$project$Results$ok1(stringV);
			} else {
				var _p54 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, newVal);
				if (((((_p54.ctor === 'Ok') && (_p54._0.ctor === '_Tuple2')) && (_p54._0._0 === 'Just')) && (_p54._0._1.ctor === '::')) && (_p54._0._1._1.ctor === '[]')) {
					return A2(
						_user$project$Results$andThen,
						function (newGroups) {
							var transformations = A2(
								_elm_lang$core$List$filterMap,
								_elm_lang$core$Basics$identity,
								A3(
									_elm_lang$core$List$map2,
									F2(
										function (_p55, newValue) {
											var _p56 = _p55;
											var _p57 = _p56.start;
											return A2(
												_elm_lang$core$Maybe$andThen,
												function (match) {
													return _elm_lang$core$Native_Utils.eq(match, newValue) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(
														{
															ctor: '_Tuple3',
															_0: _p57,
															_1: _p57 + _elm_lang$core$String$length(match),
															_2: newValue
														});
												},
												_p56.match);
										}),
									_p52._0.submatches,
									newGroups));
							return _user$project$Results$ok1(
								A2(
									_user$project$ValBuilder$string,
									_user$project$ValBuilder$fromVal(stringV),
									A2(_user$project$UpdateRegex$mergeTransformations, _p58, transformations)));
						},
						_user$project$Results$fromResult(
							A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$string, _p54._0._1._0)));
				} else {
					return _elm_lang$core$Result$Err('Updating from not a just');
				}
			}
		} else {
			return _elm_lang$core$Result$Err('Internal error: Expected two strings, a regex, a string, the old value and the new value, got something else');
		}
	});
var _user$project$UpdateRegex$recoverMatchedStringDiffs = F3(
	function (oldRegexMatch, newRegexMatch, mbdiffs) {
		var oldMatch = oldRegexMatch.match;
		var _p59 = mbdiffs;
		if (_p59.ctor === 'Nothing') {
			return _user$project$Results$ok1(
				{ctor: '[]'});
		} else {
			var _p87 = _p59._0;
			var _p60 = _p87;
			if (_p60.ctor === 'VRecordDiffs') {
				var _p86 = _p60._0;
				var newGroups = newRegexMatch.group;
				var newSubmatches = newRegexMatch.submatches;
				var newMatch = newRegexMatch.match;
				var ensureThereIsNo = F2(
					function (list, continuation) {
						ensureThereIsNo:
						while (true) {
							var _p61 = list;
							if (_p61.ctor === '[]') {
								return continuation(
									{ctor: '_Tuple0'});
							} else {
								var _p63 = _p61._0;
								var _p62 = A2(_elm_lang$core$Dict$get, _p63, _p86);
								if (_p62.ctor === 'Just') {
									return _elm_lang$core$Result$Err(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Cannot update the .',
											A2(_elm_lang$core$Basics_ops['++'], _p63, ' of of a regex match, only the string itself !')));
								} else {
									var _v58 = _p61._1,
										_v59 = continuation;
									list = _v58;
									continuation = _v59;
									continue ensureThereIsNo;
								}
							}
						}
					});
				var _p64 = A2(_elm_lang$core$Dict$get, 'match', _p86);
				if (_p64.ctor === 'Just') {
					if (_p64._0.ctor === 'VStringDiffs') {
						return _user$project$Results$ok1(
							A2(
								_elm_lang$core$List$map,
								function (_p65) {
									var _p66 = _p65;
									return {ctor: '_Tuple3', _0: _p66._0 + oldRegexMatch.index, _1: _p66._1 + oldRegexMatch.index, _2: _p66._2};
								},
								A2(_user$project$UpdateUtils$strDiffToConcreteDiff, newMatch, _p64._0._0)));
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected a VStringDiffs for match, got ',
								_elm_lang$core$Basics$toString(_p64._0)));
					}
				} else {
					return A2(
						ensureThereIsNo,
						{
							ctor: '::',
							_0: 'index',
							_1: {
								ctor: '::',
								_0: 'number',
								_1: {
									ctor: '::',
									_0: 'start',
									_1: {ctor: '[]'}
								}
							}
						},
						function (_p67) {
							var makeTupleStringDiffs = F3(
								function (oldStringList, newStringList, a) {
									return _user$project$Results$fromResult(
										A2(
											_elm_lang$core$Result$andThen,
											function (tuplediffs) {
												return _user$project$Utils$projOk(
													A2(
														_elm_lang$core$List$map,
														function (d) {
															var _p68 = d;
															if ((_p68.ctor === '_Tuple2') && (_p68._1.ctor === 'VStringDiffs')) {
																return _elm_lang$core$Result$Ok(
																	{ctor: '_Tuple2', _0: _p68._0, _1: _p68._1._0});
															} else {
																return _elm_lang$core$Result$Err(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'Expected vStringDiffs, got ',
																		_elm_lang$core$Basics$toString(d)));
															}
														},
														tuplediffs));
											},
											A2(
												_elm_lang$core$Result$fromMaybe,
												'No insertion/deletion allowed in the .submatches of a regex match',
												A2(
													_elm_lang$core$Maybe$andThen,
													_user$project$UpdateUtils$toTupleDiffs,
													function () {
														var _p69 = a;
														if (_p69.ctor === 'VListDiffs') {
															return _elm_lang$core$Maybe$Just(_p69._0);
														} else {
															return _elm_lang$core$Maybe$Nothing;
														}
													}()))));
								});
							var finalGroupAndDiffs = function () {
								var submatchesTupleDiffs = function () {
									var _p70 = A2(_elm_lang$core$Dict$get, 'submatches', _p86);
									if (_p70.ctor === 'Nothing') {
										return _elm_lang$core$Maybe$Nothing;
									} else {
										return _elm_lang$core$Maybe$Just(
											A2(
												_user$project$Results$map,
												function (gTupleDiff) {
													return {
														ctor: '_Tuple2',
														_0: {ctor: '::', _0: newMatch, _1: newRegexMatch.submatches},
														_1: A2(_user$project$UpdateUtils$offset, 1, gTupleDiff)
													};
												},
												A3(makeTupleStringDiffs, oldRegexMatch.submatches, oldRegexMatch.submatches, _p70._0)));
									}
								}();
								var groupTupleDiffs = function () {
									var _p71 = A2(_elm_lang$core$Dict$get, 'group', _p86);
									if (_p71.ctor === 'Nothing') {
										return _elm_lang$core$Maybe$Nothing;
									} else {
										return _elm_lang$core$Maybe$Just(
											A2(
												_user$project$Results$map,
												function (gTupleDiff) {
													return {ctor: '_Tuple2', _0: newRegexMatch.group, _1: gTupleDiff};
												},
												A3(makeTupleStringDiffs, oldRegexMatch.group, oldRegexMatch.group, _p71._0)));
									}
								}();
								var _p72 = {ctor: '_Tuple2', _0: submatchesTupleDiffs, _1: groupTupleDiffs};
								if (_p72._0.ctor === 'Nothing') {
									if (_p72._1.ctor === 'Nothing') {
										return _user$project$Results$ok1(
											{
												ctor: '_Tuple2',
												_0: oldRegexMatch.group,
												_1: {ctor: '[]'}
											});
									} else {
										return _p72._1._0;
									}
								} else {
									if (_p72._1.ctor === 'Nothing') {
										return _p72._0._0;
									} else {
										return A3(
											_user$project$Results$map2,
											F2(
												function (_p74, _p73) {
													var _p75 = _p74;
													var _p76 = _p73;
													return A6(_user$project$UpdateUtils$mergeTuple, _user$project$UpdateUtils$mergeString, oldRegexMatch.group, _p75._0, _p75._1, _p76._0, _p76._1);
												}),
											_p72._0._0,
											_p72._1._0);
									}
								}
							}();
							return A3(
								_elm_lang$core$Basics$flip,
								_user$project$Results$andThen,
								finalGroupAndDiffs,
								function (_p77) {
									var _p78 = _p77;
									var diffByGroupIndex = _elm_lang$core$Dict$fromList(_p78._1);
									return _user$project$Results$fromResult(
										A2(
											_elm_lang$core$Result$map,
											function (listlist) {
												return A2(_elm_lang$core$List$concatMap, _elm_lang$core$Basics$identity, listlist);
											},
											_user$project$Utils$projOk(
												A3(
													_elm_lang$core$List$map2,
													F2(
														function (_p79, groupStart) {
															var _p80 = _p79;
															var _p81 = A2(_elm_lang$core$Dict$get, _p80._1, diffByGroupIndex);
															if (_p81.ctor === 'Nothing') {
																return _elm_lang$core$Result$Ok(
																	{ctor: '[]'});
															} else {
																var aux = F3(
																	function (offset, diffs, revAcc) {
																		aux:
																		while (true) {
																			var _p82 = diffs;
																			if (_p82.ctor === '[]') {
																				return _elm_lang$core$List$reverse(revAcc);
																			} else {
																				var _p85 = _p82._0._0;
																				var _p84 = _p82._0._2;
																				var _p83 = _p82._0._1;
																				var _v73 = (offset + _p84) - (_p83 - _p85),
																					_v74 = _p82._1,
																					_v75 = {
																					ctor: '::',
																					_0: {
																						ctor: '_Tuple3',
																						_0: groupStart + _p85,
																						_1: groupStart + _p83,
																						_2: A3(_elm_lang$core$String$slice, _p85 + offset, (_p85 + _p84) + offset, _p80._0)
																					},
																					_1: revAcc
																				};
																				offset = _v73;
																				diffs = _v74;
																				revAcc = _v75;
																				continue aux;
																			}
																		}
																	});
																return _elm_lang$core$Result$Ok(
																	A3(
																		aux,
																		0,
																		_p81._0,
																		{ctor: '[]'}));
															}
														}),
													_user$project$Utils$zipWithIndex(_p78._0),
													oldRegexMatch.start))));
								});
						});
				}
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Expected VRecordDiffs, got ',
						_elm_lang$core$Basics$toString(_p87)));
			}
		}
	});
var _user$project$UpdateRegex$extractHeadTail = F3(
	function (msg, list, continuation) {
		var _p88 = list;
		if (_p88.ctor === '[]') {
			return _elm_lang$core$Result$Err(msg);
		} else {
			return continuation(
				{ctor: '_Tuple2', _0: _p88._0, _1: _p88._1});
		}
	});
var _user$project$UpdateRegex$appMatchArg = function (e) {
	var _p89 = A2(_user$project$Lang$eOpUnapply1, _user$project$Lang$ToStrExceptStr, e);
	if (_p89.ctor === 'Nothing') {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected ToStrExceptStr, got ',
				A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
	} else {
		var _p93 = _p89._0;
		var _p90 = _user$project$Lang$eAppUnapply1(_p93);
		if (_p90.ctor === 'Nothing') {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'In ToStrExceptStr, expected f x, got ',
					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p93)));
		} else {
			var _p92 = _p90._0._1;
			var _p91 = _user$project$Lang$eVarUnapply(_p92);
			if (_p91.ctor === 'Nothing') {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'In ToStrExceptStr (f x), expected x to be a variable name, got ',
						A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p92)));
			} else {
				return _elm_lang$core$Result$Ok(_p91._0);
			}
		}
	}
};
var _user$project$UpdateRegex$matchApp = F2(
	function (replacementName, argumentName) {
		return A2(
			_user$project$Lang$eOp,
			_user$project$Lang$ToStrExceptStr,
			{
				ctor: '::',
				_0: A2(
					_user$project$Lang$eApp,
					_user$project$Lang$eVar(replacementName),
					{
						ctor: '::',
						_0: _user$project$Lang$eVar(argumentName),
						_1: {ctor: '[]'}
					}),
				_1: {ctor: '[]'}
			});
	});
var _user$project$UpdateRegex$matchToVal = F2(
	function (vb, m) {
		return A3(
			_user$project$ValBuilder$record,
			_user$project$ValBuilder$identity,
			vb,
			_elm_lang$core$Dict$fromList(
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'match',
						_1: A2(_user$project$ValBuilder$string, vb, m.match)
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: 'submatches',
							_1: A3(_user$project$ValBuilder$list, _user$project$ValBuilder$string, vb, m.submatches)
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'group',
								_1: A3(_user$project$ValBuilder$list, _user$project$ValBuilder$string, vb, m.group)
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'start',
									_1: A3(_user$project$ValBuilder$list, _user$project$ValBuilder$int, vb, m.start)
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'index',
										_1: A2(_user$project$ValBuilder$int, vb, m.index)
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'number',
											_1: A2(_user$project$ValBuilder$int, vb, m.number)
										},
										_1: {ctor: '[]'}
									}
								}
							}
						}
					}
				}));
	});
var _user$project$UpdateRegex$gsmMatchToRegexMatch = function (m) {
	var submatches = A2(
		_elm_lang$core$List$map,
		function (_p94) {
			var _p95 = _p94;
			return A2(_elm_lang$core$Maybe$withDefault, '', _p95.match);
		},
		m.submatches);
	return {
		match: m.match,
		submatches: submatches,
		group: {ctor: '::', _0: m.match, _1: submatches},
		start: {
			ctor: '::',
			_0: m.index,
			_1: A2(
				_elm_lang$core$List$map,
				function (_p96) {
					var _p97 = _p96;
					return _p97.start;
				},
				m.submatches)
		},
		index: m.index,
		number: m.number
	};
};
var _user$project$UpdateRegex$evalReplacement = F3(
	function ($eval, closureReplacementV, gsmMatch) {
		var replacementName = 'user_callback';
		var argumentName = 'x';
		var matchVal = A2(
			_user$project$UpdateRegex$matchToVal,
			_user$project$Lang$builtinVal('matchToVal'),
			_user$project$UpdateRegex$gsmMatchToRegexMatch(gsmMatch));
		var localEnv = {
			ctor: '::',
			_0: {ctor: '_Tuple2', _0: replacementName, _1: closureReplacementV},
			_1: {
				ctor: '::',
				_0: {ctor: '_Tuple2', _0: argumentName, _1: matchVal},
				_1: {ctor: '[]'}
			}
		};
		var localExp = A2(_user$project$UpdateRegex$matchApp, replacementName, argumentName);
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			A2($eval, localEnv, localExp));
	});
var _user$project$UpdateRegex$lambdaToString = F3(
	function (oldConcatenationStarts, valAfter, vdiffs) {
		var _p98 = {ctor: '_Tuple2', _0: valAfter.v_, _1: vdiffs};
		if ((((((_p98.ctor === '_Tuple2') && (_p98._0.ctor === 'VClosure')) && (_p98._0._0.ctor === '[]')) && (_p98._0._1.ctor === '::')) && (_p98._0._1._1.ctor === '[]')) && (_p98._1.ctor === 'VClosureDiffs')) {
			if (_p98._1._1.ctor === 'Nothing') {
				return _user$project$Results$ok1(
					{ctor: '[]'});
			} else {
				return A3(
					_elm_lang$core$Basics$flip,
					_user$project$Results$andThen,
					_user$project$Results$fromResult(
						A2(_user$project$UpdateRegex$unconcat, _p98._0._2, _p98._1._1)),
					function (_p99) {
						var _p100 = _p99;
						var recoverSubExpressionStringDiffs = function (e) {
							return _user$project$Results$ok1(
								{ctor: '[]'});
						};
						var recoverSubStringsDiffs = function (e) {
							var _p101 = _user$project$Lang$eAppUnapply1(e);
							if ((_p101.ctor === 'Just') && (_p101._0.ctor === '_Tuple2')) {
								var _p102 = _user$project$Lang$eStrUnapply(_p101._0._1);
								if (_p102.ctor === 'Just') {
									return _elm_lang$core$Maybe$Just(
										function (sd) {
											var _p103 = sd;
											if ((((((_p103.ctor === 'EChildDiffs') && (_p103._0.ctor === '::')) && (_p103._0._0.ctor === '_Tuple2')) && (_p103._0._0._0 === 1)) && (_p103._0._0._1.ctor === 'EStringDiffs')) && (_p103._0._1.ctor === '[]')) {
												return _elm_lang$core$Maybe$Just(
													A2(_user$project$UpdateUtils$strDiffToConcreteDiff, _p102._0, _p103._0._0._1._0));
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										});
								} else {
									return _elm_lang$core$Maybe$Nothing;
								}
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						};
						return A5(_user$project$UpdateRegex$recoverStringDiffs, recoverSubExpressionStringDiffs, recoverSubStringsDiffs, oldConcatenationStarts, _p100._0, _p100._1);
					});
			}
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'UpdateRegex',
				{
					start: {line: 281, column: 3},
					end: {line: 296, column: 104}
				},
				_p98)('Trying to call lambdaToString with something else than a closure or closurediffs');
		}
	});
var _user$project$UpdateRegex$escapeSlashDollar = function (s) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$All,
		_elm_lang$core$Regex$regex('\\$'),
		function (_p105) {
			return '\\\\\\$';
		},
		s);
};
var _user$project$UpdateRegex$replaceDollarOrSlash = A2(
	_user$project$Lang$builtinVal,
	'UpdateRegex.replaceDollarOrSlash',
	A4(
		_user$project$Lang$VFun,
		'replaceDollarOrSlash',
		{
			ctor: '::',
			_0: 'm',
			_1: {ctor: '[]'}
		},
		function (margs) {
			var _p106 = margs;
			if ((_p106.ctor === '::') && (_p106._1.ctor === '[]')) {
				var _p109 = _p106._0;
				var _p107 = _p109.v_;
				if (_p107.ctor === 'VRecord') {
					var _p108 = A2(
						_elm_lang$core$Maybe$andThen,
						_user$project$Lang$vStrUnapply,
						A2(_elm_lang$core$Dict$get, 'match', _p107._0));
					if ((_p108.ctor === 'Just') && (_p108._0 === '\\$')) {
						return _elm_lang$core$Result$Ok(
							{
								ctor: '_Tuple2',
								_0: A2(
									_user$project$Lang$replaceV_,
									_p109,
									_user$project$Lang$VBase(
										_user$project$Lang$VString('$'))),
								_1: {ctor: '[]'}
							});
					} else {
						return _elm_lang$core$Result$Ok(
							{
								ctor: '_Tuple2',
								_0: A2(
									_user$project$Lang$replaceV_,
									_p109,
									_user$project$Lang$VBase(
										_user$project$Lang$VString('\\'))),
								_1: {ctor: '[]'}
							});
					}
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'replaceDollarOrSlash expected a record, got ',
							_user$project$LangUtils$valToString(_p109)));
				}
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'replaceDollarOrSlash expected 1 argument, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(margs))));
			}
		},
		_elm_lang$core$Maybe$Just(
			F4(
				function (margs, oldval, newval, diffs) {
					var _p110 = margs;
					if ((_p110.ctor === '::') && (_p110._1.ctor === '[]')) {
						var _p123 = _p110._0;
						var _p111 = {ctor: '_Tuple4', _0: _p123.v_, _1: oldval.v_, _2: newval.v_, _3: diffs};
						if (((((((_p111.ctor === '_Tuple4') && (_p111._0.ctor === 'VRecord')) && (_p111._1.ctor === 'VBase')) && (_p111._1._0.ctor === 'VString')) && (_p111._2.ctor === 'VBase')) && (_p111._2._0.ctor === 'VString')) && (_p111._3.ctor === 'VStringDiffs')) {
							var _p122 = _p111._1._0._0;
							var _p121 = _p111._3._0;
							if (_elm_lang$core$Native_Utils.eq(
								_p121,
								{ctor: '[]'})) {
								return _user$project$Results$ok1(
									{
										ctor: '_Tuple2',
										_0: margs,
										_1: {ctor: '[]'}
									});
							} else {
								var aux = F4(
									function (offset, lastEnd, ldiffs, _p112) {
										aux:
										while (true) {
											var _p113 = _p112;
											var _p119 = _p113._0;
											var _p118 = _p113._1;
											var _p114 = ldiffs;
											if (_p114.ctor === '[]') {
												return {
													ctor: '_Tuple2',
													_0: A2(
														_elm_lang$core$Basics_ops['++'],
														_p119,
														A2(_elm_lang$core$String$dropLeft, lastEnd, _p122)),
													_1: _elm_lang$core$List$reverse(_p118)
												};
											} else {
												var _p117 = _p114._0._2;
												var _p116 = _p114._0._1;
												var _p115 = _p114._0._0;
												var stringReplaced = A3(_elm_lang$core$String$slice, _p115 + offset, (_p115 + _p117) + offset, _p111._2._0._0);
												var stringReplacedEscaped = _user$project$UpdateRegex$escapeSlashDollar(stringReplaced);
												var newR = _elm_lang$core$String$length(stringReplacedEscaped);
												var _v94 = ((offset + _p116) - _p115) + _p117,
													_v95 = _p116,
													_v96 = _p114._1,
													_v97 = {
													ctor: '_Tuple2',
													_0: A2(
														_elm_lang$core$Basics_ops['++'],
														_p119,
														A2(
															_elm_lang$core$Basics_ops['++'],
															A3(_elm_lang$core$String$slice, lastEnd, _p115, _p122),
															stringReplacedEscaped)),
													_1: {
														ctor: '::',
														_0: A3(
															_user$project$Lang$StringUpdate,
															_elm_lang$core$Native_Utils.eq(_p115, 0) ? 0 : 2,
															_elm_lang$core$Native_Utils.eq(_p116, 0) ? 0 : 2,
															newR),
														_1: _p118
													}
												};
												offset = _v94;
												lastEnd = _v95;
												ldiffs = _v96;
												_p112 = _v97;
												continue aux;
											}
										}
									});
								var _p120 = A4(
									aux,
									0,
									0,
									_p121,
									{
										ctor: '_Tuple2',
										_0: '',
										_1: {ctor: '[]'}
									});
								var newStr = _p120._0;
								var newStrDiffs = _p120._1;
								var newRecord = A2(
									_user$project$Lang$replaceV_,
									_p123,
									_user$project$Lang$VRecord(
										A3(
											_elm_lang$core$Dict$insert,
											'match',
											A2(
												_user$project$Lang$replaceV_,
												oldval,
												_user$project$Lang$VBase(
													_user$project$Lang$VString(newStr))),
											_p111._0._0)));
								var newRecordDiff = _user$project$Lang$VRecordDiffs(
									_elm_lang$core$Dict$fromList(
										{
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: 'match',
												_1: _user$project$Lang$VStringDiffs(newStrDiffs)
											},
											_1: {ctor: '[]'}
										}));
								return _user$project$Results$ok1(
									{
										ctor: '_Tuple2',
										_0: {
											ctor: '::',
											_0: newRecord,
											_1: {ctor: '[]'}
										},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: 0, _1: newRecordDiff},
											_1: {ctor: '[]'}
										}
									});
							}
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'replaceDollarOrSlash update expected a record, a string and a stringdiffs, got ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$valToString(_p123),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$LangUtils$valToString(newval),
												A2(
													_elm_lang$core$Basics_ops['++'],
													' ',
													_elm_lang$core$Basics$toString(diffs)))))));
						}
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'replaceDollarOrSlash expected 1 argument, got ',
								_elm_lang$core$Basics$toString(
									_elm_lang$core$List$length(margs))));
					}
				}))));
var _user$project$UpdateRegex$nth = A2(
	_user$project$Lang$builtinVal,
	'UpdateRegex.nth',
	A4(
		_user$project$Lang$VFun,
		'nth',
		{
			ctor: '::',
			_0: 'list',
			_1: {
				ctor: '::',
				_0: 'n',
				_1: {ctor: '[]'}
			}
		},
		function (args) {
			var _p124 = args;
			if (((_p124.ctor === '::') && (_p124._1.ctor === '::')) && (_p124._1._1.ctor === '[]')) {
				var _p127 = _p124._1._0;
				var _p126 = _p124._0;
				var _p125 = {ctor: '_Tuple2', _0: _p126.v_, _1: _p127.v_};
				if ((((_p125.ctor === '_Tuple2') && (_p125._0.ctor === 'VList')) && (_p125._1.ctor === 'VConst')) && (_p125._1._1.ctor === '_Tuple2')) {
					return A2(
						_elm_lang$core$Result$map,
						function (v) {
							return {
								ctor: '_Tuple2',
								_0: v,
								_1: {ctor: '[]'}
							};
						},
						A2(
							_user$project$Utils$nth,
							_p125._0._0,
							_elm_lang$core$Basics$floor(_p125._1._1._0)));
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'nth Expected a list and an integer, got ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUtils$valToString(_p126),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' ',
									_user$project$LangUtils$valToString(_p127)))));
				}
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'nth expects two arguments, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args))));
			}
		},
		_elm_lang$core$Maybe$Just(
			F4(
				function (args, oldVal, newVal, diffs) {
					var _p128 = args;
					if (((_p128.ctor === '::') && (_p128._1.ctor === '::')) && (_p128._1._1.ctor === '[]')) {
						var _p132 = _p128._1._0;
						var _p131 = _p128._0;
						var _p129 = {ctor: '_Tuple2', _0: _p131.v_, _1: _p132.v_};
						if ((((_p129.ctor === '_Tuple2') && (_p129._0.ctor === 'VList')) && (_p129._1.ctor === 'VConst')) && (_p129._1._1.ctor === '_Tuple2')) {
							var _p130 = _p129._0._0;
							var nInt = _elm_lang$core$Basics$floor(_p129._1._1._0);
							return _user$project$Results$ok1(
								{
									ctor: '_Tuple2',
									_0: {
										ctor: '::',
										_0: A2(
											_user$project$Lang$replaceV_,
											_p131,
											_user$project$Lang$VList(
												A2(
													_elm_lang$core$Basics_ops['++'],
													A2(_elm_lang$core$List$take, nInt, _p130),
													A2(
														_elm_lang$core$Basics_ops['++'],
														{
															ctor: '::',
															_0: newVal,
															_1: {ctor: '[]'}
														},
														A2(_elm_lang$core$List$drop, nInt + 1, _p130))))),
										_1: {ctor: '[]'}
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 0,
											_1: _user$project$Lang$VListDiffs(
												{
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: nInt,
														_1: _user$project$Lang$ListElemUpdate(diffs)
													},
													_1: {ctor: '[]'}
												})
										},
										_1: {ctor: '[]'}
									}
								});
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'nth Expected a list and an integer, got ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$valToString(_p131),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' ',
											_user$project$LangUtils$valToString(_p132)))));
						}
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'nth expects two arguments, got ',
								_elm_lang$core$Basics$toString(
									_elm_lang$core$List$length(args))));
					}
				}))));
var _user$project$UpdateRegex$join = function () {
	var preferStringInsertionToLeft_ = F3(
		function (s1, inserted, s2) {
			return _elm_lang$core$Native_Utils.cmp(
				A2(_user$project$UpdateUtils$affinity, s1, inserted),
				A2(_user$project$UpdateUtils$affinity, inserted, s2)) > 0;
		});
	var length = _elm_lang$core$String$length;
	var drop = _elm_lang$core$String$dropLeft;
	var take = _elm_lang$core$String$left;
	var substring = _elm_lang$core$String$slice;
	return A2(
		_user$project$Lang$builtinVal,
		'UpdateRegex.join',
		A4(
			_user$project$Lang$VFun,
			'__joinEmpty__',
			{
				ctor: '::',
				_0: 'list',
				_1: {ctor: '[]'}
			},
			function (args) {
				var _p133 = args;
				if ((_p133.ctor === '::') && (_p133._1.ctor === '[]')) {
					var _p136 = _p133._0;
					var _p134 = _p136.v_;
					if (_p134.ctor === 'VList') {
						var strExps = _user$project$Utils$projOk(
							A2(
								_elm_lang$core$List$map,
								function (v) {
									var _p135 = v.v_;
									if ((_p135.ctor === 'VBase') && (_p135._0.ctor === 'VString')) {
										return _elm_lang$core$Result$Ok(_p135._0._0);
									} else {
										return _elm_lang$core$Result$Err(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'join expects a list of strings, got ',
												_user$project$LangUtils$valToString(v)));
									}
								},
								_p134._0));
						return A3(
							_elm_lang$core$Basics$flip,
							_elm_lang$core$Result$map,
							strExps,
							function (strList) {
								return {
									ctor: '_Tuple2',
									_0: A2(
										_user$project$Lang$replaceV_,
										_p136,
										_user$project$Lang$VBase(
											_user$project$Lang$VString(
												A2(_elm_lang$core$String$join, '', strList)))),
									_1: {ctor: '[]'}
								};
							});
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'join Expectes a list of strings, got ',
								_user$project$LangUtils$valToString(_p136)));
					}
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'join expects two arguments, got ',
							_elm_lang$core$Basics$toString(
								_elm_lang$core$List$length(args))));
				}
			},
			_elm_lang$core$Maybe$Just(
				F4(
					function (args, oldVal, newVal, diffs) {
						var _p137 = args;
						if ((_p137.ctor === '::') && (_p137._1.ctor === '[]')) {
							var _p171 = _p137._0;
							var _p138 = {ctor: '_Tuple4', _0: _p171.v_, _1: oldVal.v_, _2: newVal.v_, _3: diffs};
							if (((((((_p138.ctor === '_Tuple4') && (_p138._0.ctor === 'VList')) && (_p138._1.ctor === 'VBase')) && (_p138._1._0.ctor === 'VString')) && (_p138._2.ctor === 'VBase')) && (_p138._2._0.ctor === 'VString')) && (_p138._3.ctor === 'VStringDiffs')) {
								var _p170 = _p138._1._0._0;
								var _p169 = _p138._2._0._0;
								var strExps = _user$project$Utils$projOk(
									A2(
										_elm_lang$core$List$map,
										function (v) {
											var _p139 = v.v_;
											if ((_p139.ctor === 'VBase') && (_p139._0.ctor === 'VString')) {
												return _elm_lang$core$Result$Ok(_p139._0._0);
											} else {
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'join expects a list of strings, got ',
														_user$project$LangUtils$valToString(v)));
											}
										},
										_p138._0._0));
								return A2(
									_user$project$Results$andThen,
									function (input) {
										var lastIndex = _elm_lang$core$List$length(input) - 1;
										var gather = F7(
											function (lastIndexDeleted, input, indexInput, startHead, deltaLengthHeadInput, offsetOutput, diffs) {
												var _p140 = diffs;
												if (_p140.ctor === '[]') {
													return _user$project$Results$ok1(
														{
															ctor: '_Tuple2',
															_0: input,
															_1: {ctor: '[]'}
														});
												} else {
													var _p164 = _p140._0._0;
													var _p163 = _p140._0._2;
													var _p162 = _p140._0._1;
													var _p161 = _p140._1;
													var _p141 = input;
													if (_p141.ctor === '[]') {
														var inserted = A3(substring, _p164 + offsetOutput, (_p162 + offsetOutput) + _p163, _p169);
														return _user$project$Results$ok1(
															{
																ctor: '_Tuple2',
																_0: {
																	ctor: '::',
																	_0: inserted,
																	_1: {ctor: '[]'}
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: indexInput,
																		_1: _user$project$Lang$ListElemInsert(1)
																	},
																	_1: {ctor: '[]'}
																}
															});
													} else {
														var _p160 = _p141._1;
														var _p159 = _p141._0;
														var endHead = (startHead + length(_p159)) + deltaLengthHeadInput;
														if ((_elm_lang$core$Native_Utils.cmp(_p164, endHead) < 0) && (_elm_lang$core$Native_Utils.cmp(_p162, endHead) > 0)) {
															var firstReplaced = A7(
																gather,
																lastIndexDeleted,
																input,
																indexInput,
																startHead,
																deltaLengthHeadInput,
																offsetOutput,
																{
																	ctor: '::',
																	_0: A3(_user$project$Lang$StringUpdate, _p164, endHead, 0),
																	_1: {
																		ctor: '::',
																		_0: A3(_user$project$Lang$StringUpdate, endHead, _p162, _p163),
																		_1: _p161
																	}
																});
															return _elm_lang$core$Native_Utils.eq(_p163, 0) ? firstReplaced : A2(
																_user$project$Results$andAlso,
																A7(
																	gather,
																	lastIndexDeleted,
																	input,
																	indexInput,
																	startHead,
																	deltaLengthHeadInput,
																	offsetOutput,
																	{
																		ctor: '::',
																		_0: A3(_user$project$Lang$StringUpdate, _p164, endHead, _p163),
																		_1: {
																			ctor: '::',
																			_0: A3(_user$project$Lang$StringUpdate, endHead, _p162, 0),
																			_1: _p161
																		}
																	}),
																firstReplaced);
														} else {
															if (((_elm_lang$core$Native_Utils.cmp(_p164, endHead) > 0) || (_elm_lang$core$Native_Utils.eq(_p164, endHead) && (_elm_lang$core$Native_Utils.cmp(_p162, _p164) > 0))) && (!_elm_lang$core$Native_Utils.eq(indexInput, lastIndex))) {
																return A2(
																	_user$project$Results$andThen,
																	function (_p142) {
																		var _p143 = _p142;
																		return _user$project$Results$ok1(
																			{
																				ctor: '_Tuple2',
																				_0: {ctor: '::', _0: _p159, _1: _p143._0},
																				_1: _p143._1
																			});
																	},
																	A7(gather, lastIndexDeleted, _p160, indexInput + 1, endHead, 0, offsetOutput, diffs));
															} else {
																if (_elm_lang$core$Native_Utils.eq(_p164, endHead) && _elm_lang$core$Native_Utils.eq(_p162, _p164)) {
																	var inserted = A3(substring, _p164 + offsetOutput, (_p162 + offsetOutput) + _p163, _p169);
																	var sa = A3(substring, 0, _p164, _p170);
																	var sb = A2(drop, _p162, _p170);
																	var newHead = A2(_elm_lang$core$Basics_ops['++'], _p159, inserted);
																	var newOffsetOutput = (offsetOutput + _p163) - (_p162 - _p164);
																	var appendNow = A2(
																		_user$project$Results$andThen,
																		function (_p144) {
																			var _p145 = _p144;
																			return _user$project$Results$ok1(
																				{
																					ctor: '_Tuple2',
																					_0: {ctor: '::', _0: newHead, _1: _p145._0},
																					_1: {
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: indexInput,
																							_1: _user$project$Lang$ListElemUpdate(
																								_user$project$Lang$VStringDiffs(
																									{
																										ctor: '::',
																										_0: A3(_user$project$Lang$StringUpdate, _p164 - startHead, _p162 - startHead, _p163),
																										_1: {ctor: '[]'}
																									}))
																						},
																						_1: _p145._1
																					}
																				});
																		},
																		A7(gather, -1, _p160, indexInput + 1, endHead, 0, newOffsetOutput, _p161));
																	if (_elm_lang$core$Native_Utils.eq(indexInput, lastIndex)) {
																		return appendNow;
																	} else {
																		var appendLater = A2(
																			_user$project$Results$andThen,
																			function (_p146) {
																				var _p147 = _p146;
																				return _user$project$Results$ok1(
																					{
																						ctor: '_Tuple2',
																						_0: {ctor: '::', _0: _p159, _1: _p147._0},
																						_1: _p147._1
																					});
																			},
																			A7(gather, -1, _p160, indexInput + 1, endHead, 0, offsetOutput, diffs));
																		return A3(preferStringInsertionToLeft_, sa, inserted, sb) ? A2(_user$project$Results$andAlso, appendLater, appendNow) : A2(_user$project$Results$andAlso, appendNow, appendLater);
																	}
																} else {
																	var offsetChange = _p163 - (_p162 - _p164);
																	var newOffsetOutput = offsetOutput + offsetChange;
																	if (_elm_lang$core$Native_Utils.eq(_p164, startHead) && (_elm_lang$core$Native_Utils.eq(_p162, endHead) && _elm_lang$core$Native_Utils.eq(_p163, 0))) {
																		var resultsWithDelete = A2(
																			_user$project$Results$andThen,
																			function (_p148) {
																				var _p149 = _p148;
																				return _user$project$Results$ok1(
																					{
																						ctor: '_Tuple2',
																						_0: _p149._0,
																						_1: {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: indexInput,
																								_1: _user$project$Lang$ListElemDelete(1)
																							},
																							_1: _p149._1
																						}
																					});
																			},
																			A7(gather, _p162, _p160, indexInput + 1, endHead, 0, newOffsetOutput, _p161));
																		var deleteAnyway = _elm_lang$core$Native_Utils.eq(lastIndexDeleted, _p164) && function () {
																			var _p150 = _p161;
																			if ((_p150.ctor === '::') && (_p150._0._2 === 0)) {
																				var _p151 = _p150._0._0;
																				return _elm_lang$core$Native_Utils.eq(_p151, endHead) && (_elm_lang$core$Native_Utils.cmp(_p150._0._1, _p151) > 0);
																			} else {
																				return _elm_lang$core$Native_Utils.eq(indexInput, lastIndex);
																			}
																		}();
																		var resultsWithEmptyString = A2(
																			_user$project$Results$andThen,
																			function (_p152) {
																				var _p153 = _p152;
																				return _user$project$Results$ok1(
																					{
																						ctor: '_Tuple2',
																						_0: {ctor: '::', _0: '', _1: _p153._0},
																						_1: {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: indexInput,
																								_1: _user$project$Lang$ListElemUpdate(
																									_user$project$Lang$VStringDiffs(
																										{
																											ctor: '::',
																											_0: A3(_user$project$Lang$StringUpdate, 0, endHead - startHead, 0),
																											_1: {ctor: '[]'}
																										}))
																							},
																							_1: _p153._1
																						}
																					});
																			},
																			A7(gather, _p162, _p160, indexInput + 1, endHead, 0, newOffsetOutput, _p161));
																		return deleteAnyway ? resultsWithDelete : A2(_user$project$Results$andAlso, resultsWithEmptyString, resultsWithDelete);
																	} else {
																		var inserted = A3(substring, _p164 + offsetOutput, (_p164 + offsetOutput) + _p163, _p169);
																		var newHead = A2(
																			_elm_lang$core$Basics_ops['++'],
																			A3(substring, 0, (_p164 - startHead) - deltaLengthHeadInput, _p159),
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				inserted,
																				A2(drop, (_p162 - startHead) - deltaLengthHeadInput, _p159)));
																		var newDeltaLengthHeadInput = deltaLengthHeadInput - offsetChange;
																		var thisDiff = A3(_user$project$Lang$StringUpdate, _p164 - startHead, _p162 - startHead, _p163);
																		return A2(
																			_user$project$Results$andThen,
																			function (_p154) {
																				var _p155 = _p154;
																				var _p158 = _p155._1;
																				var finalDiffs = function () {
																					var _p156 = _p158;
																					if ((((_p156.ctor === '::') && (_p156._0.ctor === '_Tuple2')) && (_p156._0._1.ctor === 'ListElemUpdate')) && (_p156._0._1._0.ctor === 'VStringDiffs')) {
																						var _p157 = _p156._0._0;
																						return _elm_lang$core$Native_Utils.eq(_p157, indexInput) ? {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: _p157,
																								_1: _user$project$Lang$ListElemUpdate(
																									_user$project$Lang$VStringDiffs(
																										{ctor: '::', _0: thisDiff, _1: _p156._0._1._0._0}))
																							},
																							_1: _p156._1
																						} : {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: indexInput,
																								_1: _user$project$Lang$ListElemUpdate(
																									_user$project$Lang$VStringDiffs(
																										{
																											ctor: '::',
																											_0: thisDiff,
																											_1: {ctor: '[]'}
																										}))
																							},
																							_1: _p158
																						};
																					} else {
																						return {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: indexInput,
																								_1: _user$project$Lang$ListElemUpdate(
																									_user$project$Lang$VStringDiffs(
																										{
																											ctor: '::',
																											_0: thisDiff,
																											_1: {ctor: '[]'}
																										}))
																							},
																							_1: _p158
																						};
																					}
																				}();
																				return _user$project$Results$ok1(
																					{ctor: '_Tuple2', _0: _p155._0, _1: finalDiffs});
																			},
																			A7(
																				gather,
																				_elm_lang$core$Native_Utils.eq(_p163, 0) ? _p162 : -1,
																				{ctor: '::', _0: newHead, _1: _p160},
																				indexInput,
																				startHead,
																				newDeltaLengthHeadInput,
																				newOffsetOutput,
																				_p161));
																	}
																}
															}
														}
													}
												}
											});
										return A2(
											_user$project$Results$map,
											function (_p165) {
												var _p166 = _p165;
												var _p168 = _p166._1;
												return {
													ctor: '_Tuple2',
													_0: {
														ctor: '::',
														_0: A2(
															_user$project$Lang$replaceV_,
															_p171,
															_user$project$Lang$VList(
																A2(
																	_elm_lang$core$List$map,
																	function (_p167) {
																		return A2(
																			_user$project$Lang$replaceV_,
																			oldVal,
																			_user$project$Lang$VBase(
																				_user$project$Lang$VString(_p167)));
																	},
																	_p166._0))),
														_1: {ctor: '[]'}
													},
													_1: _elm_lang$core$Native_Utils.eq(
														_p168,
														{ctor: '[]'}) ? {ctor: '[]'} : {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: 0,
															_1: _user$project$Lang$VListDiffs(_p168)
														},
														_1: {ctor: '[]'}
													}
												};
											},
											A7(gather, -1, input, 0, 0, 0, 0, _p138._3._0));
									},
									_user$project$Results$fromResult(strExps));
							} else {
								return _elm_lang$core$Result$Err(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'join expects a list of strings, got ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUtils$valToString(_p171),
											A2(
												_elm_lang$core$Basics_ops['++'],
												' updated with ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$LangUtils$valToString(newVal),
													A2(
														_elm_lang$core$Basics_ops['++'],
														' and ',
														_elm_lang$core$Basics$toString(diffs)))))));
							}
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'join expects two arguments, got ',
									_elm_lang$core$Basics$toString(
										_elm_lang$core$List$length(args))));
						}
					}))));
}();
var _user$project$UpdateRegex$RegexMatch = F6(
	function (a, b, c, d, e, f) {
		return {match: a, submatches: b, group: c, start: d, index: e, number: f};
	});
var _user$project$UpdateRegex$valToMatch = function (v) {
	var $try = F2(
		function (a, b) {
			return A2(_elm_lang$core$Result$andThen, b, a);
		});
	var get = F2(
		function (d, k) {
			return $try(
				A2(
					_elm_lang$core$Result$fromMaybe,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Key ',
						A2(_elm_lang$core$Basics_ops['++'], k, ' not found')),
					A2(_elm_lang$core$Dict$get, k, d)));
		});
	return A2(
		$try,
		A2(_user$project$ValUnbuilder$record, _user$project$ValUnbuilder$identity, v),
		function (rd) {
			var g = get(rd);
			return A2(
				g,
				'match',
				function (vmatch) {
					return A2(
						g,
						'submatches',
						function (vsubmatches) {
							return A2(
								g,
								'group',
								function (vgroup) {
									return A2(
										g,
										'start',
										function (vstart) {
											return A2(
												g,
												'index',
												function (vindex) {
													return A2(
														g,
														'number',
														function (vnumber) {
															return A2(
																$try,
																_user$project$ValUnbuilder$string(vmatch),
																function (match) {
																	return A2(
																		$try,
																		_user$project$ValUnbuilder$int(vindex),
																		function (index) {
																			return A2(
																				$try,
																				_user$project$ValUnbuilder$int(vnumber),
																				function (number) {
																					return A2(
																						$try,
																						A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$string, vsubmatches),
																						function (submatches) {
																							return A2(
																								$try,
																								A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$string, vgroup),
																								function (groups) {
																									return A2(
																										$try,
																										A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$int, vstart),
																										function (start) {
																											return _elm_lang$core$Result$Ok(
																												A6(_user$project$UpdateRegex$RegexMatch, match, submatches, groups, start, index, number));
																										});
																								});
																						});
																				});
																		});
																});
														});
												});
										});
								});
						});
				});
		});
};
var _user$project$UpdateRegex$valToMatchContinue = F2(
	function (v, continuation) {
		var _p172 = _user$project$UpdateRegex$valToMatch(v);
		if (_p172.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p172._0);
		} else {
			return continuation(_p172._0);
		}
	});
var _user$project$UpdateRegex$EvaluationError = function (a) {
	return {ctor: 'EvaluationError', _0: a};
};
var _user$project$UpdateRegex$evalRegexReplaceByIn = F5(
	function (howmany, $eval, regexpV, replacementV, stringV) {
		evalRegexReplaceByIn:
		while (true) {
			var _p173 = {ctor: '_Tuple3', _0: regexpV.v_, _1: replacementV.v_, _2: stringV.v_};
			if (((((_p173.ctor === '_Tuple3') && (_p173._0.ctor === 'VBase')) && (_p173._0._0.ctor === 'VString')) && (_p173._2.ctor === 'VBase')) && (_p173._2._0.ctor === 'VString')) {
				if ((_p173._1.ctor === 'VBase') && (_p173._1._0.ctor === 'VString')) {
					var _p174 = A6(
						_user$project$UpdateRegex$stringToLambda,
						$eval,
						_user$project$UpdateRegex$dummyUpdate,
						_user$project$UpdateRegex$nth,
						_user$project$UpdateRegex$join,
						_user$project$Lang$replaceV_(replacementV),
						_p173._1._0._0);
					var lambdaReplacement = _p174._0;
					var _v121 = howmany,
						_v122 = $eval,
						_v123 = regexpV,
						_v124 = lambdaReplacement,
						_v125 = stringV;
					howmany = _v121;
					$eval = _v122;
					regexpV = _v123;
					replacementV = _v124;
					stringV = _v125;
					continue evalRegexReplaceByIn;
				} else {
					return A3(
						_user$project$ImpureGoodies$tryCatch,
						'EvaluationError',
						function (_p175) {
							var _p176 = _p175;
							var newString = A4(
								_user$project$GroupStartMap$replace,
								howmany,
								_p173._0._0._0,
								function (m) {
									var _p177 = A3(_user$project$UpdateRegex$evalReplacement, $eval, replacementV, m);
									if (_p177.ctor === 'Err') {
										return _user$project$ImpureGoodies$throw(
											_user$project$UpdateRegex$EvaluationError(_p177._0));
									} else {
										var _p178 = _p177._0.v_;
										if ((_p178.ctor === 'VBase') && (_p178._0.ctor === 'VString')) {
											return _p178._0._0;
										} else {
											return _user$project$ImpureGoodies$throw(
												_user$project$UpdateRegex$EvaluationError('[internal error] The function ToStrExceptStr returned something else than a string'));
										}
									}
								},
								_p173._2._0._0);
							return _elm_lang$core$Result$Ok(
								{
									ctor: '_Tuple2',
									_0: A2(
										_user$project$Lang$replaceV_,
										replacementV,
										_user$project$Lang$VBase(
											_user$project$Lang$VString(newString))),
									_1: {ctor: '[]'}
								});
						},
						function (_p179) {
							var _p180 = _p179;
							return _elm_lang$core$Result$Err(_p180._0);
						});
				}
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'replaceAllIn expects a regex (String), a replacement (string/lambda), and the text. Got instead  ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUtils$valToString(regexpV),
							A2(
								_elm_lang$core$Basics_ops['++'],
								', ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(replacementV),
									A2(
										_elm_lang$core$Basics_ops['++'],
										', ',
										_user$project$LangUtils$valToString(stringV)))))));
			}
		}
	});
var _user$project$UpdateRegex$stringToLambda = F6(
	function ($eval, update, nth, join, toVal, s) {
		var l = A2(
			_elm_lang$core$List$map,
			function (m) {
				return {
					ctor: '_Tuple3',
					_0: m,
					_1: m.index,
					_2: _elm_lang$core$String$length(m.match) + m.index
				};
			},
			A3(
				_elm_lang$core$Regex$find,
				_elm_lang$core$Regex$All,
				_elm_lang$core$Regex$regex('(\\\\\\$|\\\\\\\\|\\$(\\d))'),
				s));
		var _p181 = A3(
			_elm_lang$core$List$foldl,
			F2(
				function (_p183, _p182) {
					var _p184 = _p183;
					var _p186 = _p184._2;
					var _p185 = _p182;
					return {
						ctor: '_Tuple2',
						_0: _p186,
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							_p185._1,
							{
								ctor: '::',
								_0: {ctor: '_Tuple4', _0: _p184._0, _1: _p185._0, _2: _p184._1, _3: _p186},
								_1: {ctor: '[]'}
							})
					};
				}),
			{
				ctor: '_Tuple2',
				_0: 0,
				_1: {ctor: '[]'}
			},
			l);
		var finalLastStart = _p181._0;
		var lWithPrevStart = _p181._1;
		var oldConcatenationStarts = A2(
			_elm_lang$core$Basics_ops['++'],
			{
				ctor: '::',
				_0: 0,
				_1: A2(
					_elm_lang$core$List$concatMap,
					function (_p187) {
						var _p188 = _p187;
						return {
							ctor: '::',
							_0: _p188._2,
							_1: {
								ctor: '::',
								_0: _p188._3,
								_1: {ctor: '[]'}
							}
						};
					},
					lWithPrevStart)
			},
			{
				ctor: '::',
				_0: _elm_lang$core$String$length(s),
				_1: {ctor: '[]'}
			});
		var m = _user$project$Lang$eVar('m');
		var tmp = A2(
			_elm_lang$core$List$concatMap,
			function (_p189) {
				var _p190 = _p189;
				var _p194 = _p190._0;
				var groupIndexMaybe = function () {
					var _p191 = _p194.submatches;
					_v134_2:
					do {
						if ((_p191.ctor === '::') && (_p191._1.ctor === '::')) {
							if (_p191._1._0.ctor === 'Nothing') {
								if (_p191._1._1.ctor === '[]') {
									return _elm_lang$core$Maybe$Nothing;
								} else {
									break _v134_2;
								}
							} else {
								if (_p191._1._1.ctor === '[]') {
									var _p192 = _elm_lang$core$String$toInt(_p191._1._0._0);
									if (_p192.ctor === 'Ok') {
										return _elm_lang$core$Maybe$Just(_p192._0);
									} else {
										return _user$project$ImpureGoodies$throw(
											_user$project$UpdateRegex$EvaluationError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p194.match,
													A2(_elm_lang$core$Basics_ops['++'], ' is not a valid group match: ', _p192._0))));
									}
								} else {
									break _v134_2;
								}
							}
						} else {
							break _v134_2;
						}
					} while(false);
					return _user$project$ImpureGoodies$throw(
						_user$project$UpdateRegex$EvaluationError(
							A2(_elm_lang$core$Basics_ops['++'], _p194.match, ' is not a valid group match')));
				}();
				var _p193 = groupIndexMaybe;
				if (_p193.ctor === 'Nothing') {
					return {ctor: '[]'};
				} else {
					return {
						ctor: '::',
						_0: A2(
							_user$project$Lang$eApp,
							_user$project$Lang$eVar('unescapeSlashDollar'),
							{
								ctor: '::',
								_0: _user$project$Lang$eStr(
									A3(_elm_lang$core$String$slice, _p190._1, _p190._2, s)),
								_1: {ctor: '[]'}
							}),
						_1: {
							ctor: '::',
							_0: A2(
								_user$project$Lang$eApp,
								_user$project$Lang$eVar('nth'),
								{
									ctor: '::',
									_0: A2(_user$project$Lang$eSelect, m, 'group'),
									_1: {
										ctor: '::',
										_0: _user$project$Lang$eConstDummyLoc(
											_elm_lang$core$Basics$toFloat(_p193._0)),
										_1: {ctor: '[]'}
									}
								}),
							_1: {ctor: '[]'}
						}
					};
				}
			},
			lWithPrevStart);
		var lambdaBody = A2(
			_user$project$UpdateRegex$concat,
			'join',
			A2(
				_elm_lang$core$Basics_ops['++'],
				tmp,
				{
					ctor: '::',
					_0: A2(
						_user$project$Lang$eApp,
						_user$project$Lang$eVar('unescapeSlashDollar'),
						{
							ctor: '::',
							_0: _user$project$Lang$eStr(
								A2(_elm_lang$core$String$dropLeft, finalLastStart, s)),
							_1: {ctor: '[]'}
						}),
					_1: {ctor: '[]'}
				}));
		return {
			ctor: '_Tuple2',
			_0: toVal(
				A4(
					_user$project$Lang$VClosure,
					{ctor: '[]'},
					{
						ctor: '::',
						_0: _user$project$Lang$pVar('m'),
						_1: {ctor: '[]'}
					},
					lambdaBody,
					{
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 'nth', _1: nth},
						_1: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: 'join', _1: join},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'unescapeSlashDollar',
									_1: A2(_user$project$UpdateRegex$unescapeSlashDollar, $eval, update)
								},
								_1: {ctor: '[]'}
							}
						}
					})),
			_1: oldConcatenationStarts
		};
	});
var _user$project$UpdateRegex$unescapeSlashDollar = F2(
	function ($eval, update) {
		var localEnv = function (args) {
			return A2(
				_elm_lang$core$Basics_ops['++'],
				{
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: 'replace',
						_1: A2(_user$project$UpdateRegex$replaceAllByIn, $eval, update)
					},
					_1: {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: 'replacement', _1: _user$project$UpdateRegex$replaceDollarOrSlash},
						_1: {ctor: '[]'}
					}
				},
				A2(
					_elm_lang$core$List$map,
					function (arg) {
						return {ctor: '_Tuple2', _0: 'string', _1: arg};
					},
					args));
		};
		var localExp = A2(
			_user$project$Lang$eApp,
			_user$project$Lang$eVar('replace'),
			{
				ctor: '::',
				_0: _user$project$Lang$eStr('\\\\\\$|\\\\\\\\'),
				_1: {
					ctor: '::',
					_0: _user$project$Lang$eVar('replacement'),
					_1: {
						ctor: '::',
						_0: _user$project$Lang$eVar('string'),
						_1: {ctor: '[]'}
					}
				}
			});
		return A2(
			_user$project$Lang$builtinVal,
			'UpdateRegex.unescapeSlashDollar',
			A4(
				_user$project$Lang$VFun,
				'unescapeSlashDollar',
				{
					ctor: '::',
					_0: 's',
					_1: {ctor: '[]'}
				},
				function (args) {
					return A2(
						$eval,
						localEnv(args),
						localExp);
				},
				_elm_lang$core$Maybe$Just(
					F4(
						function (args, oldVal, newVal, diffs) {
							var prevEnv = localEnv(args);
							return A2(
								_user$project$Results$andThen,
								function (_p195) {
									var _p196 = _p195;
									var _p200 = _p196._0;
									var _p197 = _p200.val;
									if ((((_p197.ctor === '::') && (_p197._1.ctor === '::')) && (_p197._1._1.ctor === '::')) && (_p197._1._1._0.ctor === '_Tuple2')) {
										var _p199 = _p197._1._1._0._1;
										var _p198 = _p200.changes;
										if (((_p198.ctor === '::') && (_p198._0.ctor === '_Tuple2')) && (_p198._0._0 === 2)) {
											return _user$project$Results$ok1(
												{
													ctor: '_Tuple2',
													_0: {
														ctor: '::',
														_0: _p199,
														_1: {ctor: '[]'}
													},
													_1: {
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: 0, _1: _p198._0._1},
														_1: {ctor: '[]'}
													}
												});
										} else {
											return _user$project$Results$ok1(
												{
													ctor: '_Tuple2',
													_0: {
														ctor: '::',
														_0: _p199,
														_1: {ctor: '[]'}
													},
													_1: {ctor: '[]'}
												});
										}
									} else {
										return _elm_lang$core$Result$Err(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'The environment should have contained at least 3 variables, got ',
												_elm_lang$core$Basics$toString(
													_elm_lang$core$List$length(_p200.val))));
									}
								},
								update(
									A7(
										_user$project$UpdateStack$updateContext,
										'unescapeSlashDollar',
										prevEnv,
										localExp,
										{ctor: '[]'},
										oldVal,
										newVal,
										diffs)));
						}))));
	});
var _user$project$UpdateRegex$replaceAllByIn = F2(
	function ($eval, update) {
		return A4(_user$project$UpdateRegex$replaceByIn, _elm_lang$core$Regex$All, 'replaceAllByIn', $eval, update);
	});
var _user$project$UpdateRegex$replaceByIn = F4(
	function (howmany, name, evaluate, update) {
		return A2(
			_user$project$Lang$builtinVal,
			'UpdateRegex.replaceByIn',
			A4(
				_user$project$Lang$VFun,
				name,
				{
					ctor: '::',
					_0: 'regex',
					_1: {
						ctor: '::',
						_0: 'replacement',
						_1: {
							ctor: '::',
							_0: 'string',
							_1: {ctor: '[]'}
						}
					}
				},
				function (args) {
					var _p201 = args;
					if ((((_p201.ctor === '::') && (_p201._1.ctor === '::')) && (_p201._1._1.ctor === '::')) && (_p201._1._1._1.ctor === '[]')) {
						return A5(_user$project$UpdateRegex$evalRegexReplaceByIn, howmany, evaluate, _p201._0, _p201._1._0, _p201._1._1._0);
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'regex replacement expects three arguments, got ',
								_elm_lang$core$Basics$toString(
									_elm_lang$core$List$length(args))));
					}
				},
				_elm_lang$core$Maybe$Just(
					F4(
						function (args, oldVal, newVal, diffs) {
							var _p202 = args;
							if ((((_p202.ctor === '::') && (_p202._1.ctor === '::')) && (_p202._1._1.ctor === '::')) && (_p202._1._1._1.ctor === '[]')) {
								return A9(_user$project$UpdateRegex$updateRegexReplaceByIn, howmany, evaluate, update, _p202._0, _p202._1._0, _p202._1._1._0, oldVal, newVal, diffs);
							} else {
								return _elm_lang$core$Result$Err(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'regex replacement expects three arguments, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(args))));
							}
						}))));
	});
var _user$project$UpdateRegex$updateRegexReplaceByIn = F9(
	function (howmany, $eval, update, regexpV, replacementV, stringV, oldOutV, newOutV, diffs) {
		var _p203 = {ctor: '_Tuple4', _0: regexpV.v_, _1: replacementV.v_, _2: stringV.v_, _3: newOutV.v_};
		_v142_2:
		do {
			if (((((_p203.ctor === '_Tuple4') && (_p203._0.ctor === 'VBase')) && (_p203._0._0.ctor === 'VString')) && (_p203._2.ctor === 'VBase')) && (_p203._2._0.ctor === 'VString')) {
				if ((_p203._1.ctor === 'VBase') && (_p203._1._0.ctor === 'VString')) {
					var _p214 = _p203._1._0._0;
					var _p204 = A6(
						_user$project$UpdateRegex$stringToLambda,
						$eval,
						update,
						_user$project$UpdateRegex$nth,
						_user$project$UpdateRegex$join,
						_user$project$Lang$replaceV_(replacementV),
						_p214);
					var lambdaReplacementV = _p204._0;
					var oldConcatenationStarts = _p204._1;
					return A2(
						_user$project$Results$andThen,
						function (_p205) {
							var _p206 = _p205;
							var _p213 = _p206._1;
							var _p212 = _p206._0;
							var _p207 = _p212;
							if ((((_p207.ctor === '::') && (_p207._1.ctor === '::')) && (_p207._1._1.ctor === '::')) && (_p207._1._1._1.ctor === '[]')) {
								var replacementDiffs = function () {
									var _p208 = A2(_user$project$UpdateUtils$diffsAt, 1, _p213);
									if (_p208.ctor === 'Nothing') {
										return _user$project$Results$ok1(
											{ctor: '_Tuple2', _0: replacementV, _1: _p213});
									} else {
										return A3(
											_elm_lang$core$Basics$flip,
											_user$project$Results$andThen,
											A3(_user$project$UpdateRegex$lambdaToString, oldConcatenationStarts, _p207._1._0, _p208._0),
											function (newReplacementConcreteDiffs) {
												var _p209 = A2(
													_user$project$UpdateUtils$applyConcreteDiffs,
													_p214,
													_user$project$UpdateUtils$pruneConcreteDiffs(newReplacementConcreteDiffs));
												var newReplacementStr = _p209._0;
												var newReplacementDiffs = _p209._1;
												return _user$project$Results$ok1(
													{
														ctor: '_Tuple2',
														_0: A2(
															_user$project$Lang$replaceV_,
															replacementV,
															_user$project$Lang$VBase(
																_user$project$Lang$VString(newReplacementStr))),
														_1: A3(
															_user$project$UpdateUtils$replace,
															1,
															_user$project$Lang$VStringDiffs(newReplacementDiffs),
															_p213)
													});
											});
									}
								}();
								return A3(
									_elm_lang$core$Basics$flip,
									_user$project$Results$map,
									replacementDiffs,
									function (_p210) {
										var _p211 = _p210;
										return {
											ctor: '_Tuple2',
											_0: {
												ctor: '::',
												_0: _p207._0,
												_1: {
													ctor: '::',
													_0: _p211._0,
													_1: {
														ctor: '::',
														_0: _p207._1._1._0,
														_1: {ctor: '[]'}
													}
												}
											},
											_1: _p211._1
										};
									});
							} else {
								return _elm_lang$core$Result$Err(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Expected 3 arguments, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(_p212))));
							}
						},
						A9(_user$project$UpdateRegex$updateRegexReplaceByIn, howmany, $eval, update, regexpV, lambdaReplacementV, stringV, oldOutV, newOutV, diffs));
				} else {
					if ((_p203._3.ctor === 'VBase') && (_p203._3._0.ctor === 'VString')) {
						var _p245 = _p203._2._0._0;
						var matches = A3(_user$project$GroupStartMap$find, howmany, _p203._0._0._0, _p245);
						var _p215 = A2(_user$project$UpdateRegex$interleavingStrings, _p245, matches);
						var initStrings = _p215._0;
						var lastString = _p215._1;
						var replacementName = 'user_callback';
						var _p216 = A5(_user$project$UpdateRegex$evalRegexReplaceByIn, _elm_lang$core$Regex$All, $eval, regexpV, replacementV, stringV);
						if (_p216.ctor === 'Err') {
							return _elm_lang$core$Result$Err(_p216._0);
						} else {
							var argName = function (i) {
								return A2(
									_elm_lang$core$Basics_ops['++'],
									'match',
									_elm_lang$core$Basics$toString(i));
							};
							var concatenation = A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$List$concatMap,
									_elm_lang$core$Basics$identity,
									A3(
										_elm_lang$core$List$map2,
										F2(
											function (_p217, s) {
												var _p218 = _p217;
												return {
													ctor: '::',
													_0: _user$project$Lang$eStr(s),
													_1: {
														ctor: '::',
														_0: A2(
															_user$project$UpdateRegex$matchApp,
															replacementName,
															argName(_p218._1)),
														_1: {ctor: '[]'}
													}
												};
											}),
										_user$project$Utils$zipWithIndex(matches),
										initStrings)),
								{
									ctor: '::',
									_0: _user$project$Lang$eStr(lastString),
									_1: {ctor: '[]'}
								});
							var oldConcatenationStarts = A2(
								_elm_lang$core$Basics_ops['++'],
								{
									ctor: '::',
									_0: 0,
									_1: A2(
										_elm_lang$core$List$concatMap,
										function (_p219) {
											var _p220 = _p219;
											var _p221 = _p220.index;
											return {
												ctor: '::',
												_0: _p221,
												_1: {
													ctor: '::',
													_0: _p221 + _elm_lang$core$String$length(_p220.match),
													_1: {ctor: '[]'}
												}
											};
										},
										matches)
								},
								{
									ctor: '::',
									_0: _elm_lang$core$String$length(_p245),
									_1: {ctor: '[]'}
								});
							var expressionReplacement = A2(_user$project$UpdateRegex$concat, 'join', concatenation);
							var argumentsMatches = A2(
								_elm_lang$core$List$map,
								function (_p222) {
									var _p223 = _p222;
									return {
										ctor: '_Tuple2',
										_0: argName(_p223._1),
										_1: _user$project$UpdateRegex$gsmMatchToRegexMatch(_p223._0)
									};
								},
								_user$project$Utils$zipWithIndex(matches));
							var argumentsEnv = A2(
								_elm_lang$core$List$map,
								function (_p224) {
									var _p225 = _p224;
									return {
										ctor: '_Tuple2',
										_0: _p225._0,
										_1: A2(
											_user$project$UpdateRegex$matchToVal,
											_user$project$Lang$builtinVal('matchToVal'),
											_p225._1)
									};
								},
								argumentsMatches);
							var argNameToIndex = _elm_lang$core$Dict$fromList(
								A2(
									_elm_lang$core$List$indexedMap,
									F2(
										function (i, _p226) {
											var _p227 = _p226;
											return {ctor: '_Tuple2', _0: _p227._0, _1: i};
										}),
									argumentsMatches));
							var argumentsMatchesDict = _elm_lang$core$Dict$fromList(argumentsMatches);
							var envWithReplacement = {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: replacementName, _1: replacementV},
								_1: {
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: 'join', _1: _user$project$UpdateRegex$join},
									_1: argumentsEnv
								}
							};
							return A2(
								_user$project$Results$andThen,
								function (_p228) {
									var _p229 = _p228;
									var _p244 = _p229._1;
									var _p243 = _p229._0;
									var _p230 = _p243.val;
									if (((_p230.ctor === '::') && (_p230._0.ctor === '_Tuple2')) && (_p230._1.ctor === '::')) {
										var newRemplacementVChanges = function () {
											var _p231 = _p243.changes;
											if (((_p231.ctor === '::') && (_p231._0.ctor === '_Tuple2')) && (_p231._0._0 === 0)) {
												return {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 1, _1: _p231._0._1},
													_1: {ctor: '[]'}
												};
											} else {
												return {ctor: '[]'};
											}
										}();
										var argChangeByIndex = _elm_lang$core$Dict$fromList(
											A2(_user$project$UpdateUtils$dropDiffs, 2, _p243.changes));
										var getArgChange = function (name) {
											return A2(
												_elm_lang$core$Maybe$andThen,
												A2(_elm_lang$core$Basics$flip, _elm_lang$core$Dict$get, argChangeByIndex),
												A2(_elm_lang$core$Dict$get, name, argNameToIndex));
										};
										return A3(
											_elm_lang$core$Basics$flip,
											_user$project$Results$andThen,
											_user$project$Results$fromResult(
												A2(_user$project$UpdateRegex$unconcat, _p244.val, _p244.changes)),
											function (_p232) {
												var _p233 = _p232;
												var newArgumentsDicts = _elm_lang$core$Dict$fromList(_p230._1._1);
												var recoverSubExpressionStringDiffs = function (e) {
													var _p234 = _user$project$UpdateRegex$appMatchArg(e);
													if (_p234.ctor === 'Err') {
														return _elm_lang$core$Result$Err(_p234._0);
													} else {
														var _p237 = _p234._0;
														var _p235 = A2(_elm_lang$core$Dict$get, _p237, argumentsMatchesDict);
														if (_p235.ctor === 'Nothing') {
															return _elm_lang$core$Result$Err(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Could not find ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_p237,
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			' in ',
																			_elm_lang$core$Basics$toString(argumentsMatchesDict)))));
														} else {
															var _p236 = A2(_elm_lang$core$Dict$get, _p237, newArgumentsDicts);
															if (_p236.ctor === 'Nothing') {
																return _elm_lang$core$Result$Err(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'Could not find ',
																		A2(_elm_lang$core$Basics_ops['++'], _p237, ' in new environment')));
															} else {
																return A2(
																	_user$project$UpdateRegex$valToMatchContinue,
																	_p236._0,
																	function (newMatch) {
																		return A3(
																			_user$project$UpdateRegex$recoverMatchedStringDiffs,
																			_p235._0,
																			newMatch,
																			getArgChange(_p237));
																	});
															}
														}
													}
												};
												var recoverSubStringsDiffs = function (e) {
													var _p238 = _user$project$Lang$eStrUnapply(e);
													if (_p238.ctor === 'Just') {
														return _elm_lang$core$Maybe$Just(
															function (sd) {
																var _p239 = sd;
																if (_p239.ctor === 'EStringDiffs') {
																	return _elm_lang$core$Maybe$Just(
																		A2(_user$project$UpdateUtils$strDiffToConcreteDiff, _p238._0, _p239._0));
																} else {
																	return _elm_lang$core$Maybe$Nothing;
																}
															});
													} else {
														return _elm_lang$core$Maybe$Nothing;
													}
												};
												return A2(
													_user$project$Results$andThen,
													function (newStringDiffs) {
														var _p240 = A2(
															_user$project$UpdateUtils$applyConcreteDiffs,
															_p245,
															_user$project$UpdateUtils$pruneConcreteDiffs(newStringDiffs));
														var newString = _p240._0;
														var finalStringDiffs = _p240._1;
														var newStringVChanges = function () {
															var _p241 = finalStringDiffs;
															if (_p241.ctor === '[]') {
																return {ctor: '[]'};
															} else {
																return {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: 2,
																		_1: _user$project$Lang$VStringDiffs(_p241)
																	},
																	_1: {ctor: '[]'}
																};
															}
														}();
														var newChanges = A2(_elm_lang$core$Basics_ops['++'], newRemplacementVChanges, newStringVChanges);
														return _user$project$Results$ok1(
															{
																ctor: '_Tuple2',
																_0: {
																	ctor: '::',
																	_0: regexpV,
																	_1: {
																		ctor: '::',
																		_0: _p230._0._1,
																		_1: {
																			ctor: '::',
																			_0: A2(
																				_user$project$ValBuilder$string,
																				_user$project$ValBuilder$fromVal(stringV),
																				newString),
																			_1: {ctor: '[]'}
																		}
																	}
																},
																_1: newChanges
															});
													},
													A5(_user$project$UpdateRegex$recoverStringDiffs, recoverSubExpressionStringDiffs, recoverSubStringsDiffs, oldConcatenationStarts, _p233._0, _p233._1));
											});
									} else {
										return _elm_lang$core$Native_Utils.crashCase(
											'UpdateRegex',
											{
												start: {line: 766, column: 15},
												end: {line: 813, column: 79}
											},
											_p230)('A variable disappeared from the environment');
									}
								},
								update(
									A7(
										_user$project$UpdateStack$updateContext,
										'regex replace',
										envWithReplacement,
										expressionReplacement,
										{ctor: '[]'},
										_p216._0._0,
										newOutV,
										diffs)));
						}
					} else {
						break _v142_2;
					}
				}
			} else {
				break _v142_2;
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'replaceAllIn expects a regex (String), a replacement (string/lambda), and the text. Got instead  ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_user$project$LangUtils$valToString(regexpV),
					A2(
						_elm_lang$core$Basics_ops['++'],
						', ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LangUtils$valToString(replacementV),
							A2(
								_elm_lang$core$Basics_ops['++'],
								', ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$LangUtils$valToString(stringV),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' updated by ',
										_user$project$LangUtils$valToString(newOutV)))))))));
	});
var _user$project$UpdateRegex$updateReplace = F2(
	function ($eval, update) {
		return A2(
			_user$project$Lang$builtinVal,
			'UpdateRegex.updateReplace',
			A4(
				_user$project$Lang$VFun,
				'updateReplace',
				{
					ctor: '::',
					_0: 'regex',
					_1: {
						ctor: '::',
						_0: 'replacement',
						_1: {
							ctor: '::',
							_0: 'string',
							_1: {
								ctor: '::',
								_0: 'diffs',
								_1: {ctor: '[]'}
							}
						}
					}
				},
				function (margs) {
					var _p246 = margs;
					if (((((_p246.ctor === '::') && (_p246._1.ctor === '::')) && (_p246._1._1.ctor === '::')) && (_p246._1._1._1.ctor === '::')) && (_p246._1._1._1._1.ctor === '[]')) {
						var _p259 = _p246._1._1._0;
						var _p258 = _p246._1._1._1._0;
						var _p257 = _p246._1._0;
						var _p256 = _p246._0;
						var _p247 = {
							ctor: '_Tuple3',
							_0: _p256.v_,
							_1: _p259.v_,
							_2: _user$project$UpdateUtils$valToVDiffs(_p258)
						};
						if (((((((_p247.ctor === '_Tuple3') && (_p247._0.ctor === 'VBase')) && (_p247._0._0.ctor === 'VString')) && (_p247._1.ctor === 'VBase')) && (_p247._1._0.ctor === 'VString')) && (_p247._2.ctor === 'Ok')) && (_p247._2._0.ctor === 'VStringDiffs')) {
							var _p255 = _p247._1._0._0;
							var closure = function () {
								var _p248 = _p257.v_;
								if ((_p248.ctor === 'VBase') && (_p248._0.ctor === 'VString')) {
									return _elm_lang$core$Tuple$first(
										A6(
											_user$project$UpdateRegex$stringToLambda,
											$eval,
											update,
											_user$project$UpdateRegex$nth,
											_user$project$UpdateRegex$join,
											_user$project$Lang$replaceV_(_p257),
											_p248._0._0));
								} else {
									return _p257;
								}
							}();
							var matches = A3(_user$project$GroupStartMap$find, _elm_lang$core$Regex$All, _p247._0._0._0, _p255);
							var replacements = A2(
								_elm_lang$core$List$map,
								A2(_user$project$UpdateRegex$evalReplacement, $eval, closure),
								matches);
							var _p249 = A2(_user$project$UpdateRegex$interleavingStrings, _p255, matches);
							var initStrings = _p249._0;
							var lastString = _p249._1;
							return function (x) {
								var _p250 = A2(_elm_lang$core$Result$map, _elm_lang$core$List$unzip, x);
								if (_p250.ctor === 'Err') {
									return _elm_lang$core$Result$Err(_p250._0);
								} else {
									var finalStr = A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$String$join,
											'',
											A3(
												_elm_lang$core$List$map2,
												F2(
													function (s, t) {
														return A2(_elm_lang$core$Basics_ops['++'], s, t);
													}),
												initStrings,
												_p250._0._1)),
										lastString);
									var finalStrDiffs = A2(_user$project$UpdateUtils$composeStringDiffs, _p247._2._0._0, _p250._0._0);
									return _elm_lang$core$Result$Ok(
										{
											ctor: '_Tuple2',
											_0: A4(
												_user$project$ValBuilder$tuple2,
												_user$project$ValBuilder$string,
												_user$project$UpdateUtils$vDiffsToVal,
												_user$project$ValBuilder$fromVal(_p259),
												{
													ctor: '_Tuple2',
													_0: finalStr,
													_1: _user$project$Lang$VStringDiffs(finalStrDiffs)
												}),
											_1: {ctor: '[]'}
										});
								}
							}(
								_user$project$Utils$projOk(
									A3(
										_elm_lang$core$List$map2,
										F2(
											function (m, evalResult) {
												var _p251 = evalResult;
												if (_p251.ctor === 'Err') {
													return _elm_lang$core$Result$Err(_p251._0);
												} else {
													var _p254 = _p251._0;
													var _p252 = _p254.v_;
													if ((_p252.ctor === 'VBase') && (_p252._0.ctor === 'VString')) {
														var _p253 = _p252._0._0;
														return _elm_lang$core$Result$Ok(
															{
																ctor: '_Tuple2',
																_0: A3(
																	_user$project$Lang$StringUpdate,
																	m.index,
																	m.index + _elm_lang$core$String$length(m.match),
																	_elm_lang$core$String$length(_p253)),
																_1: _p253
															});
													} else {
														return _elm_lang$core$Result$Err(
															A2(
																_elm_lang$core$Basics_ops['++'],
																'the regex callback did not return a string, got ',
																_user$project$LangUtils$valToString(_p254)));
													}
												}
											}),
										matches,
										replacements)));
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'updateReplace expected a regex, a replacement string/closure, a string, original diffs made to the string, got ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$valToString(_p256),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$LangUtils$valToString(_p257),
												A2(
													_elm_lang$core$Basics_ops['++'],
													' ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUtils$valToString(_p259),
														A2(
															_elm_lang$core$Basics_ops['++'],
															' ',
															_user$project$LangUtils$valToString(_p258)))))))));
						}
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'updateReplace expected 4 arguments, got ',
								_elm_lang$core$Basics$toString(
									_elm_lang$core$List$length(margs))));
					}
				},
				_elm_lang$core$Maybe$Nothing));
	});
var _user$project$UpdateRegex$replaceFirstByIn = F2(
	function ($eval, update) {
		return A4(
			_user$project$UpdateRegex$replaceByIn,
			_elm_lang$core$Regex$AtMost(1),
			'replaceFirstByIn',
			$eval,
			update);
	});
var _user$project$UpdateRegex$Right = function (a) {
	return {ctor: 'Right', _0: a};
};
var _user$project$UpdateRegex$Left = function (a) {
	return {ctor: 'Left', _0: a};
};
var _user$project$UpdateRegex$valToEither = F4(
	function (subroutine1, subroutine1b, subroutine2, v) {
		var _p260 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
		_v169_3:
		do {
			if (_p260.ctor === 'Err') {
				return _elm_lang$core$Result$Err(_p260._0);
			} else {
				if (_p260._0._1.ctor === '::') {
					if (_p260._0._1._1.ctor === '::') {
						if ((_p260._0._0 === 'Left') && (_p260._0._1._1._1.ctor === '[]')) {
							return A2(
								_elm_lang$core$Result$map,
								_user$project$UpdateRegex$Left,
								A3(
									_elm_lang$core$Result$map2,
									F2(
										function (v0, v1) {
											return {ctor: '_Tuple2', _0: v0, _1: v1};
										}),
									subroutine1(_p260._0._1._0),
									subroutine1b(_p260._0._1._1._0)));
						} else {
							break _v169_3;
						}
					} else {
						if (_p260._0._0 === 'Right') {
							return A2(
								_elm_lang$core$Result$map,
								_user$project$UpdateRegex$Right,
								subroutine2(_p260._0._1._0));
						} else {
							break _v169_3;
						}
					}
				} else {
					break _v169_3;
				}
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected Left or Right with 1 argument, got ',
				A2(
					_elm_lang$core$Basics_ops['++'],
					_p260._0._0,
					A2(
						_elm_lang$core$Basics_ops['++'],
						' with ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_elm_lang$core$Basics$toString(
								_elm_lang$core$List$length(_p260._0._1)),
							' arguments')))));
	});
var _user$project$UpdateRegex$updateRegexFindInterleavings = F6(
	function (howmanyV, regexpV, stringV, oldVal, newVal, diffs) {
		var _p261 = {ctor: '_Tuple3', _0: howmanyV.v_, _1: regexpV.v_, _2: stringV.v_};
		if (((((((_p261.ctor === '_Tuple3') && (_p261._0.ctor === 'VConst')) && (_p261._0._1.ctor === '_Tuple2')) && (_p261._1.ctor === 'VBase')) && (_p261._1._0.ctor === 'VString')) && (_p261._2.ctor === 'VBase')) && (_p261._2._0.ctor === 'VString')) {
			var decoder = _user$project$ValUnbuilder$list(
				A3(_user$project$UpdateRegex$valToEither, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$int, _user$project$UpdateRegex$valToMatch));
			var _p262 = {
				ctor: '_Tuple3',
				_0: decoder(oldVal),
				_1: decoder(newVal),
				_2: diffs
			};
			if (_p262._0.ctor === 'Ok') {
				if (_p262._1.ctor === 'Ok') {
					if (_p262._2.ctor === 'VListDiffs') {
						var _p289 = _p262._0._0;
						var _p263 = A3(
							_user$project$Utils$foldLeft,
							{
								ctor: '_Tuple2',
								_0: 0,
								_1: {ctor: '[]'}
							},
							_p289,
							F2(
								function (_p264, eithersm) {
									var _p265 = _p264;
									var _p268 = _p265._1;
									var _p267 = _p265._0;
									var _p266 = eithersm;
									if (_p266.ctor === 'Left') {
										return {
											ctor: '_Tuple2',
											_0: _p267 + _elm_lang$core$String$length(_p266._0._0),
											_1: {ctor: '::', _0: _p267, _1: _p268}
										};
									} else {
										return {
											ctor: '_Tuple2',
											_0: _p267 + _elm_lang$core$String$length(_p266._0.match),
											_1: {ctor: '::', _0: _p267, _1: _p268}
										};
									}
								}));
						var lastIndex = _p263._0;
						var revOldStartsIncomplete = _p263._1;
						var oldConcatenationStarts = _elm_lang$core$List$reverse(
							{ctor: '::', _0: lastIndex, _1: revOldStartsIncomplete});
						var aux = F6(
							function (i, oldConcatenationStarts, oldInterleavings, newInterleavings, ds, newStringDiffs) {
								aux:
								while (true) {
									var _p269 = ds;
									if (_p269.ctor === '[]') {
										var _p270 = A2(
											_user$project$UpdateUtils$applyConcreteDiffs,
											_p261._2._0._0,
											_user$project$UpdateUtils$pruneConcreteDiffs(newStringDiffs));
										var newString = _p270._0;
										var finalStringDiffs = _p270._1;
										var newStringVChanges = function () {
											var _p271 = finalStringDiffs;
											if (_p271.ctor === '[]') {
												return {ctor: '[]'};
											} else {
												return {
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: 2,
														_1: _user$project$Lang$VStringDiffs(_p271)
													},
													_1: {ctor: '[]'}
												};
											}
										}();
										return _user$project$Results$ok1(
											{
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: howmanyV,
													_1: {
														ctor: '::',
														_0: regexpV,
														_1: {
															ctor: '::',
															_0: A2(
																_user$project$Lang$replaceV_,
																stringV,
																_user$project$Lang$VBase(
																	_user$project$Lang$VString(newString))),
															_1: {ctor: '[]'}
														}
													}
												},
												_1: newStringVChanges
											});
									} else {
										var _p288 = _p269._0._0;
										var _p287 = _p269._1;
										if (_elm_lang$core$Native_Utils.cmp(i, _p288) < 0) {
											var count = _p288 - i;
											var _v176 = _p288,
												_v177 = A2(_elm_lang$core$List$drop, count, oldConcatenationStarts),
												_v178 = A2(_elm_lang$core$List$drop, count, oldInterleavings),
												_v179 = A2(_elm_lang$core$List$drop, count, newInterleavings),
												_v180 = ds,
												_v181 = newStringDiffs;
											i = _v176;
											oldConcatenationStarts = _v177;
											oldInterleavings = _v178;
											newInterleavings = _v179;
											ds = _v180;
											newStringDiffs = _v181;
											continue aux;
										} else {
											if (_elm_lang$core$Native_Utils.cmp(i, _p288) > 0) {
												return _elm_lang$core$Result$Err('Internal error: diffs not aligned in UpdateRegex');
											} else {
												var _p272 = _p269._0._1;
												switch (_p272.ctor) {
													case 'ListElemInsert':
														var _p273 = A2(_user$project$Utils$split, _p272._0, newInterleavings);
														var inserted = _p273._0;
														var remaining = _p273._1;
														var insertionPoint = A2(_user$project$Utils$head, 'UpdateRegex', oldConcatenationStarts);
														var _v184 = i,
															_v185 = oldConcatenationStarts,
															_v186 = oldInterleavings,
															_v187 = remaining,
															_v188 = _p287,
															_v189 = A2(
															_elm_lang$core$Basics_ops['++'],
															newStringDiffs,
															A2(
																_elm_lang$core$List$map,
																function (eithersm) {
																	var _p274 = eithersm;
																	if (_p274.ctor === 'Left') {
																		return {ctor: '_Tuple3', _0: insertionPoint, _1: insertionPoint, _2: _p274._0._0};
																	} else {
																		return {ctor: '_Tuple3', _0: insertionPoint, _1: insertionPoint, _2: _p274._0.match};
																	}
																},
																inserted));
														i = _v184;
														oldConcatenationStarts = _v185;
														oldInterleavings = _v186;
														newInterleavings = _v187;
														ds = _v188;
														newStringDiffs = _v189;
														continue aux;
													case 'ListElemDelete':
														var _p278 = _p272._0;
														var _p275 = A2(_user$project$Utils$split, _p278, oldConcatenationStarts);
														var removedStarts = _p275._0;
														var keptStarts = _p275._1;
														var _p276 = A2(_user$project$Utils$split, _p278, oldInterleavings);
														var removedInterleavings = _p276._0;
														var keptInterleavings = _p276._1;
														var _v191 = i + _p278,
															_v192 = keptStarts,
															_v193 = keptInterleavings,
															_v194 = newInterleavings,
															_v195 = _p287,
															_v196 = A2(
															_elm_lang$core$Basics_ops['++'],
															newStringDiffs,
															A3(
																_elm_lang$core$List$map2,
																F2(
																	function (start, eithersm) {
																		var _p277 = eithersm;
																		if (_p277.ctor === 'Left') {
																			return {
																				ctor: '_Tuple3',
																				_0: start,
																				_1: start + _elm_lang$core$String$length(_p277._0._0),
																				_2: ''
																			};
																		} else {
																			return {
																				ctor: '_Tuple3',
																				_0: start,
																				_1: start + _elm_lang$core$String$length(_p277._0.match),
																				_2: ''
																			};
																		}
																	}),
																removedStarts,
																removedInterleavings));
														i = _v191;
														oldConcatenationStarts = _v192;
														oldInterleavings = _v193;
														newInterleavings = _v194;
														ds = _v195;
														newStringDiffs = _v196;
														continue aux;
													default:
														var _p279 = {ctor: '_Tuple3', _0: oldConcatenationStarts, _1: oldInterleavings, _2: newInterleavings};
														if ((((_p279.ctor === '_Tuple3') && (_p279._0.ctor === '::')) && (_p279._1.ctor === '::')) && (_p279._2.ctor === '::')) {
															var _p286 = _p279._1._1;
															var _p285 = _p279._0._1;
															var _p284 = _p279._0._0;
															var _p283 = _p279._2._1;
															var _p280 = {
																ctor: '_Tuple3',
																_0: _p279._1._0,
																_1: _p279._2._0,
																_2: A2(_user$project$Lang$vDatatypeDiffsGet, '_1', _p272._0)
															};
															_v198_3:
															do {
																if (_p280.ctor === '_Tuple3') {
																	if (_p280._2.ctor === 'Nothing') {
																		var _v199 = i + 1,
																			_v200 = _p285,
																			_v201 = _p286,
																			_v202 = _p283,
																			_v203 = _p287,
																			_v204 = newStringDiffs;
																		i = _v199;
																		oldConcatenationStarts = _v200;
																		oldInterleavings = _v201;
																		newInterleavings = _v202;
																		ds = _v203;
																		newStringDiffs = _v204;
																		continue aux;
																	} else {
																		if (_p280._0.ctor === 'Left') {
																			if ((((_p280._0._0.ctor === '_Tuple2') && (_p280._1.ctor === 'Left')) && (_p280._1._0.ctor === '_Tuple2')) && (_p280._2._0.ctor === 'VStringDiffs')) {
																				var _v206 = i + 1,
																					_v207 = _p285,
																					_v208 = _p286,
																					_v209 = _p283,
																					_v210 = _p287,
																					_v211 = A2(
																					_elm_lang$core$Basics_ops['++'],
																					newStringDiffs,
																					A2(
																						_elm_lang$core$List$map,
																						function (_p281) {
																							var _p282 = _p281;
																							return {ctor: '_Tuple3', _0: _p282._0 + _p284, _1: _p282._1 + _p284, _2: _p282._2};
																						},
																						A2(_user$project$UpdateUtils$strDiffToConcreteDiff, _p280._1._0._0, _p280._2._0._0)));
																				i = _v206;
																				oldConcatenationStarts = _v207;
																				oldInterleavings = _v208;
																				newInterleavings = _v209;
																				ds = _v210;
																				newStringDiffs = _v211;
																				continue aux;
																			} else {
																				break _v198_3;
																			}
																		} else {
																			if (_p280._1.ctor === 'Right') {
																				return A2(
																					_user$project$Results$andThen,
																					function (additionalStringDiffs) {
																						return A6(
																							aux,
																							i + 1,
																							_p285,
																							_p286,
																							_p283,
																							_p287,
																							A2(_elm_lang$core$Basics_ops['++'], newStringDiffs, additionalStringDiffs));
																					},
																					A3(_user$project$UpdateRegex$recoverMatchedStringDiffs, _p280._0._0, _p280._1._0, _p280._2));
																			} else {
																				break _v198_3;
																			}
																		}
																	}
																} else {
																	break _v198_3;
																}
															} while(false);
															return _elm_lang$core$Result$Err('Cannot update a string with a match or vice-versa');
														} else {
															return _elm_lang$core$Result$Err('Internal error, the number of elements do not match');
														}
												}
											}
										}
									}
								}
							});
						return A6(
							aux,
							0,
							oldConcatenationStarts,
							_p289,
							_p262._1._0,
							_p262._2._0,
							{ctor: '[]'});
					} else {
						return _elm_lang$core$Result$Err(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected VListDiffs for updating findInterleavings, got ',
								_elm_lang$core$Basics$toString(diffs)));
					}
				} else {
					return _elm_lang$core$Result$Err(_p262._1._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p262._0._0);
			}
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'findInterleavings expects a number (0 for all) a regex (String) and the text. Got instead  ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUtils$valToString(howmanyV),
						A2(
							_elm_lang$core$Basics_ops['++'],
							', ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUtils$valToString(regexpV),
								A2(
									_elm_lang$core$Basics_ops['++'],
									', ',
									_user$project$LangUtils$valToString(stringV)))))));
		}
	});
var _user$project$UpdateRegex$evalRegexFindInterleavings = F3(
	function (howmanyV, regexpV, stringV) {
		var _p290 = {ctor: '_Tuple3', _0: howmanyV.v_, _1: regexpV.v_, _2: stringV.v_};
		if (((((((_p290.ctor === '_Tuple3') && (_p290._0.ctor === 'VConst')) && (_p290._0._1.ctor === '_Tuple2')) && (_p290._1.ctor === 'VBase')) && (_p290._1._0.ctor === 'VString')) && (_p290._2.ctor === 'VBase')) && (_p290._2._0.ctor === 'VString')) {
			var _p296 = _p290._2._0._0;
			var _p295 = _p290._0._1._0;
			var howmany = _elm_lang$core$Native_Utils.eq(
				_elm_lang$core$Basics$floor(_p295),
				0) ? _elm_lang$core$Regex$All : _elm_lang$core$Regex$AtMost(
				_elm_lang$core$Basics$floor(_p295));
			var matches = A3(_user$project$GroupStartMap$find, howmany, _p290._1._0._0, _p296);
			var _p291 = A3(
				_user$project$Utils$foldLeft,
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: 0
				},
				matches,
				F2(
					function (_p292, match) {
						var _p293 = _p292;
						var _p294 = _p293._1;
						return {
							ctor: '_Tuple2',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								_p293._0,
								{
									ctor: '::',
									_0: _user$project$UpdateRegex$Left(
										{
											ctor: '_Tuple2',
											_0: A3(_elm_lang$core$String$slice, _p294, match.index, _p296),
											_1: _p294
										}),
									_1: {
										ctor: '::',
										_0: _user$project$UpdateRegex$Right(
											_user$project$UpdateRegex$gsmMatchToRegexMatch(match)),
										_1: {ctor: '[]'}
									}
								}),
							_1: match.index + _elm_lang$core$String$length(match.match)
						};
					}));
			var resultWithoutLast = _p291._0;
			var lastIndex = _p291._1;
			var resultUnencoded = A2(
				_elm_lang$core$Basics_ops['++'],
				resultWithoutLast,
				{
					ctor: '::',
					_0: _user$project$UpdateRegex$Left(
						{
							ctor: '_Tuple2',
							_0: A2(_elm_lang$core$String$dropLeft, lastIndex, _p296),
							_1: lastIndex
						}),
					_1: {ctor: '[]'}
				});
			var resultEncoded = A3(
				_user$project$ValBuilder$list,
				A3(_user$project$UpdateRegex$eitherToVal, _user$project$ValBuilder$string, _user$project$ValBuilder$int, _user$project$UpdateRegex$matchToVal),
				_user$project$ValBuilder$fromVal(stringV),
				resultUnencoded);
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple2',
					_0: resultEncoded,
					_1: {ctor: '[]'}
				});
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'findInterleavings expects a number (0 for all) a regex (String) and the text. Got instead  ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUtils$valToString(howmanyV),
						A2(
							_elm_lang$core$Basics_ops['++'],
							', ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$LangUtils$valToString(regexpV),
								A2(
									_elm_lang$core$Basics_ops['++'],
									', ',
									_user$project$LangUtils$valToString(stringV)))))));
		}
	});
var _user$project$UpdateRegex$findInterleavings = function (update) {
	return A2(
		_user$project$Lang$builtinVal,
		'UpdateRegex.findInterleavings',
		A4(
			_user$project$Lang$VFun,
			'findInterleavings',
			{
				ctor: '::',
				_0: 'howmany',
				_1: {
					ctor: '::',
					_0: 'regex',
					_1: {
						ctor: '::',
						_0: 'string',
						_1: {ctor: '[]'}
					}
				}
			},
			function (args) {
				var _p297 = args;
				if ((((_p297.ctor === '::') && (_p297._1.ctor === '::')) && (_p297._1._1.ctor === '::')) && (_p297._1._1._1.ctor === '[]')) {
					return A3(_user$project$UpdateRegex$evalRegexFindInterleavings, _p297._0, _p297._1._0, _p297._1._1._0);
				} else {
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'findInterleavings expects three arguments, got ',
							_elm_lang$core$Basics$toString(
								_elm_lang$core$List$length(args))));
				}
			},
			_elm_lang$core$Maybe$Just(
				F4(
					function (args, oldVal, newVal, diffs) {
						var _p298 = args;
						if ((((_p298.ctor === '::') && (_p298._1.ctor === '::')) && (_p298._1._1.ctor === '::')) && (_p298._1._1._1.ctor === '[]')) {
							return A6(_user$project$UpdateRegex$updateRegexFindInterleavings, _p298._0, _p298._1._0, _p298._1._1._0, oldVal, newVal, diffs);
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'findInterleavings expects three arguments, got ',
									_elm_lang$core$Basics$toString(
										_elm_lang$core$List$length(args))));
						}
					}))));
};

var _user$project$Eval$errorPrefix = '[Evaluation Error]';
var _user$project$Eval$crashWithMsg = function (s) {
	return _elm_lang$core$Native_Utils.crash(
		'Eval',
		{
			start: {line: 839, column: 19},
			end: {line: 839, column: 30}
		})(
		A2(
			_elm_lang$core$Basics_ops['++'],
			_user$project$Eval$errorPrefix,
			A2(_elm_lang$core$Basics_ops['++'], '\n\n', s)));
};
var _user$project$Eval$btString = F2(
	function (syntax, bt) {
		var _p0 = bt;
		if (_p0.ctor === '[]') {
			return '';
		} else {
			var singleLineExpStrs = A2(
				_elm_lang$core$String$join,
				'\n',
				_elm_lang$core$List$reverse(
					A2(
						_elm_lang$core$List$map,
						function (_p1) {
							return _user$project$Utils$head_(
								_elm_lang$core$String$lines(
									_elm_lang$core$String$trimLeft(
										A2(_user$project$Syntax$unparser, syntax, _p1))));
						},
						_p0._1)));
			return A2(
				_elm_lang$core$Basics_ops['++'],
				singleLineExpStrs,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'\n',
					A2(_user$project$Syntax$unparser, syntax, _p0._0)));
		}
	});
var _user$project$Eval$backtraceMessage = F3(
	function (syntax, bt, message) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			message,
			A2(
				_elm_lang$core$Basics_ops['++'],
				'\nTrace leading to this error:\n',
				A2(_user$project$Eval$btString, syntax, bt)));
	});
var _user$project$Eval$crashWithBacktrace = F3(
	function (syntax, bt, message) {
		return _user$project$Eval$crashWithMsg(
			A2(
				_elm_lang$core$Basics_ops['++'],
				A2(_user$project$Eval$btString, syntax, bt),
				A2(_elm_lang$core$Basics_ops['++'], '\n', message)));
	});
var _user$project$Eval$postProcessWidgets = function (widgets) {
	var dedupedWidgets = widgets;
	var _p2 = A2(
		_elm_lang$core$List$partition,
		function (widget) {
			var _p3 = widget;
			switch (_p3.ctor) {
				case 'WIntSlider':
					if (_p3._6 === false) {
						return true;
					} else {
						return false;
					}
				case 'WNumSlider':
					if (_p3._6 === false) {
						return true;
					} else {
						return false;
					}
				case 'WPoint':
					return false;
				case 'WOffset1D':
					return false;
				default:
					return false;
			}
		},
		dedupedWidgets);
	var rangeWidgets = _p2._0;
	var pointWidgets = _p2._1;
	return A2(_elm_lang$core$Basics_ops['++'], rangeWidgets, pointWidgets);
};
var _user$project$Eval$eBaseToVBase = function (eBaseVal) {
	var _p4 = eBaseVal;
	switch (_p4.ctor) {
		case 'EBool':
			return _user$project$Lang$VBool(_p4._0);
		case 'EString':
			return _user$project$Lang$VString(_p4._1);
		default:
			return _user$project$Lang$VNull;
	}
};
var _user$project$Eval$evalDelta = F4(
	function (syntax, bt, op, is) {
		var _p5 = A2(_user$project$Lang$maybeEvalMathOp, op, is);
		if (_p5.ctor === 'Just') {
			return _p5._0;
		} else {
			return A3(
				_user$project$Eval$crashWithBacktrace,
				syntax,
				bt,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Little evaluator bug: Eval.evalDelta ',
					_user$project$ValUnparser$strOp(op)));
		}
	});
var _user$project$Eval$mkCap = F2(
	function (mcap, l) {
		var s = function () {
			var _p6 = {ctor: '_Tuple2', _0: mcap, _1: l};
			if (_p6._0.ctor === 'Just') {
				return _p6._0._0.val;
			} else {
				if (_p6._1._2 === '') {
					return _user$project$ValUnparser$strLoc(l);
				} else {
					return _p6._1._2;
				}
			}
		}();
		return A2(_elm_lang$core$Basics_ops['++'], s, ': ');
	});
var _user$project$Eval$lookupVar = F5(
	function (syntax, env, bt, x, pos) {
		var _p7 = A2(_user$project$Utils$maybeFind, x, env);
		if (_p7.ctor === 'Just') {
			return _elm_lang$core$Result$Ok(_p7._0);
		} else {
			return _elm_lang$core$Result$Err(
				A3(
					_user$project$Eval$backtraceMessage,
					syntax,
					bt,
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$Lang$strPos(pos),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' variable not found: ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								x,
								A2(
									_elm_lang$core$Basics_ops['++'],
									'\nVariables in scope: ',
									A2(
										_elm_lang$core$String$join,
										' ',
										A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$first, env))))))));
		}
	});
var _user$project$Eval$match = function (_p8) {
	match:
	while (true) {
		var _p9 = _p8;
		var _p18 = _p9._1;
		var _p10 = {ctor: '_Tuple2', _0: _p9._0.val.p__, _1: _p18.v_};
		_v7_5:
		do {
			switch (_p10._0.ctor) {
				case 'PWildcard':
					return _elm_lang$core$Maybe$Just(
						{ctor: '[]'});
				case 'PVar':
					return _elm_lang$core$Maybe$Just(
						{
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p10._0._1, _1: _p18},
							_1: {ctor: '[]'}
						});
				case 'PAs':
					var _p11 = _user$project$Eval$match(
						{ctor: '_Tuple2', _0: _p10._0._1, _1: _p18});
					if (_p11.ctor === 'Just') {
						var _p12 = _user$project$Eval$match(
							{ctor: '_Tuple2', _0: _p10._0._3, _1: _p18});
						if (_p12.ctor === 'Just') {
							return _elm_lang$core$Maybe$Just(
								A2(_elm_lang$core$Basics_ops['++'], _p12._0, _p11._0));
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				case 'PList':
					if (_p10._0._3.ctor === 'Nothing') {
						if (_p10._1.ctor === 'VList') {
							return A2(
								_user$project$Utils$bindMaybe,
								_user$project$Eval$matchList,
								A2(_user$project$Utils$maybeZip, _p10._0._1, _p10._1._0));
						} else {
							break _v7_5;
						}
					} else {
						if (_p10._1.ctor === 'VList') {
							var _p16 = _p10._1._0;
							var _p15 = _p10._0._1;
							var _p13 = {
								ctor: '_Tuple2',
								_0: _elm_lang$core$List$length(_p15),
								_1: _elm_lang$core$List$length(_p16)
							};
							var n = _p13._0;
							var m = _p13._1;
							if (_elm_lang$core$Native_Utils.cmp(n, m) > 0) {
								return _elm_lang$core$Maybe$Nothing;
							} else {
								var _p14 = A2(_user$project$Utils$split, n, _p16);
								var vs1 = _p14._0;
								var vs2 = _p14._1;
								var vRest = {
									v_: _user$project$Lang$VList(vs2),
									provenance: A3(
										_user$project$Lang$Provenance,
										_user$project$Lang$provenanceEnv(_p18.provenance),
										A2(
											_user$project$Lang$eApp,
											_user$project$Lang$eVar0('drop'),
											{
												ctor: '::',
												_0: _user$project$Lang$provenanceExp(_p18.provenance),
												_1: {
													ctor: '::',
													_0: _user$project$Lang$eConstDummyLoc(
														_elm_lang$core$Basics$toFloat(n)),
													_1: {ctor: '[]'}
												}
											}),
										{
											ctor: '::',
											_0: _p18,
											_1: {ctor: '[]'}
										}),
									parents: _user$project$Lang$Parents(
										{ctor: '[]'})
								};
								return A2(
									_user$project$Eval$cons,
									{ctor: '_Tuple2', _0: _p10._0._3._0, _1: vRest},
									_user$project$Eval$matchList(
										A2(_user$project$Utils$zip, _p15, vs1)));
							}
						} else {
							break _v7_5;
						}
					}
				case 'PConst':
					if ((_p10._1.ctor === 'VConst') && (_p10._1._1.ctor === '_Tuple2')) {
						return _elm_lang$core$Native_Utils.eq(_p10._0._1, _p10._1._1._0) ? _elm_lang$core$Maybe$Just(
							{ctor: '[]'}) : _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				case 'PBase':
					if (_p10._1.ctor === 'VBase') {
						return _elm_lang$core$Native_Utils.eq(
							_user$project$Eval$eBaseToVBase(_p10._0._1),
							_p10._1._0) ? _elm_lang$core$Maybe$Just(
							{ctor: '[]'}) : _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				case 'PParens':
					var _v10 = {ctor: '_Tuple2', _0: _p10._0._1, _1: _p18};
					_p8 = _v10;
					continue match;
				case 'PRecord':
					if (_p10._1.ctor === 'VRecord') {
						var mbPatValues = _user$project$Utils$projJusts(
							A2(
								_elm_lang$core$List$map,
								function (p) {
									var k = _user$project$Utils$recordKey(p);
									var pv = _user$project$Utils$recordValue(p);
									var mbV = A2(_elm_lang$core$Dict$get, k, _p10._1._0);
									return A2(
										_elm_lang$core$Maybe$map,
										function (v) {
											return {ctor: '_Tuple2', _0: pv, _1: v};
										},
										mbV);
								},
								_p10._0._1));
						var _p17 = mbPatValues;
						if (_p17.ctor === 'Nothing') {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							return _user$project$Eval$matchList(_p17._0);
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				default:
					if (A2(_user$project$Types$valIsType, _p18, _p10._0._3)) {
						var _v12 = {ctor: '_Tuple2', _0: _p10._0._1, _1: _p18};
						_p8 = _v12;
						continue match;
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$Eval$cons = F2(
	function (pv, menv) {
		var _p19 = {
			ctor: '_Tuple2',
			_0: menv,
			_1: _user$project$Eval$match(pv)
		};
		if (((_p19.ctor === '_Tuple2') && (_p19._0.ctor === 'Just')) && (_p19._1.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A2(_elm_lang$core$Basics_ops['++'], _p19._1._0, _p19._0._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Eval$matchList = function (pvs) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (pv, acc) {
				var _p20 = {
					ctor: '_Tuple2',
					_0: acc,
					_1: _user$project$Eval$match(pv)
				};
				if (((_p20.ctor === '_Tuple2') && (_p20._0.ctor === 'Just')) && (_p20._1.ctor === 'Just')) {
					return _elm_lang$core$Maybe$Just(
						A2(_elm_lang$core$Basics_ops['++'], _p20._1._0, _p20._0._0));
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			}),
		_elm_lang$core$Maybe$Just(
			{ctor: '[]'}),
		pvs);
};
var _user$project$Eval$valToDictKey = F3(
	function (syntax, bt, v) {
		var _p21 = A2(_user$project$LangUtils$valToDictKey, syntax, v);
		if (_p21.ctor === 'Err') {
			return _elm_lang$core$Result$Err(
				A3(_user$project$Eval$backtraceMessage, syntax, bt, _p21._0));
		} else {
			return _elm_lang$core$Result$Ok(_p21._0);
		}
	});
var _user$project$Eval$evalOp = F8(
	function (syntax, env, e, bt, opWithInfo, es, vs, wss) {
		var args = A2(
			_elm_lang$core$List$map,
			function (_) {
				return _.v_;
			},
			vs);
		var addProvenance = function (val_) {
			return A3(
				_user$project$Lang$Val,
				val_,
				A3(_user$project$Lang$Provenance, env, e, vs),
				_user$project$Lang$Parents(
					{ctor: '[]'}));
		};
		var addProvenanceOk = function (val_) {
			return _elm_lang$core$Result$Ok(
				addProvenance(val_));
		};
		var _p22 = {ctor: '_Tuple2', _0: opWithInfo.val, _1: opWithInfo.start};
		var op = _p22._0;
		var opStart = _p22._1;
		var error = function (_p23) {
			var _p24 = _p23;
			return _elm_lang$core$Result$Err(
				A3(
					_user$project$Eval$backtraceMessage,
					syntax,
					bt,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'Bad arguments to ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$ValUnparser$strOp(op),
							A2(
								_elm_lang$core$Basics_ops['++'],
								' operator ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$strPos(opStart),
									A2(
										_elm_lang$core$Basics_ops['++'],
										':\n',
										_user$project$Utils$lines(
											A2(
												_elm_lang$core$List$map,
												function (_p25) {
													var _p26 = _p25;
													return A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUtils$valToString(_p26._0),
														A2(
															_elm_lang$core$Basics_ops['++'],
															' from ',
															A2(_user$project$Syntax$unparser, syntax, _p26._1)));
												},
												A2(_user$project$Utils$zip, vs, es))))))))));
		};
		var mkClosureOrError = function (_p27) {
			var _p28 = _p27;
			var vLength = _elm_lang$core$List$length(vs);
			var nbArgs = _user$project$LeoLang$arity(opWithInfo);
			if (_elm_lang$core$Native_Utils.cmp(vLength, nbArgs) > -1) {
				return error(
					{ctor: '_Tuple0'});
			} else {
				var vars = A2(
					_elm_lang$core$List$map,
					function (i) {
						return A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$LeoParser$implicitVarName,
							_elm_lang$core$Native_Utils.eq(i, 1) ? '' : _elm_lang$core$Basics$toString(i));
					},
					A2(_elm_lang$core$List$range, 1, nbArgs));
				var _p29 = A2(_user$project$Utils$split, vLength, vars);
				var varsComputed = _p29._0;
				var varsRemaining = _p29._1;
				return addProvenanceOk(
					A4(
						_user$project$Lang$VClosure,
						{ctor: '[]'},
						A2(_elm_lang$core$List$map, _user$project$Lang$pVar, varsRemaining),
						A2(
							_user$project$Lang$eOp,
							opWithInfo.val,
							A2(_elm_lang$core$List$map, _user$project$Lang$eVar, vars)),
						A2(
							_user$project$Utils$reverseInsert,
							A3(
								_elm_lang$core$List$map2,
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									}),
								varsComputed,
								vs),
							env)));
			}
		};
		var unaryMathOp = F2(
			function (op, args) {
				var _p30 = args;
				if ((((_p30.ctor === '::') && (_p30._0.ctor === 'VConst')) && (_p30._0._1.ctor === '_Tuple2')) && (_p30._1.ctor === '[]')) {
					return addProvenanceOk(
						A2(
							_user$project$Lang$VConst,
							_elm_lang$core$Maybe$Nothing,
							{
								ctor: '_Tuple2',
								_0: A4(
									_user$project$Eval$evalDelta,
									syntax,
									bt,
									op,
									{
										ctor: '::',
										_0: _p30._0._1._0,
										_1: {ctor: '[]'}
									}),
								_1: A2(
									_user$project$Lang$TrOp,
									op,
									{
										ctor: '::',
										_0: _p30._0._1._1,
										_1: {ctor: '[]'}
									})
							}));
				} else {
					return mkClosureOrError(
						{ctor: '_Tuple0'});
				}
			});
		var binMathOp = F2(
			function (op, args) {
				var _p31 = args;
				if (((((((_p31.ctor === '::') && (_p31._0.ctor === 'VConst')) && (_p31._0._1.ctor === '_Tuple2')) && (_p31._1.ctor === '::')) && (_p31._1._0.ctor === 'VConst')) && (_p31._1._0._1.ctor === '_Tuple2')) && (_p31._1._1.ctor === '[]')) {
					var maybeAxisAndOtherDim = function () {
						var _p32 = {ctor: '_Tuple3', _0: op, _1: _p31._0._0, _2: _p31._1._0._0};
						_v21_3:
						do {
							if (_p32.ctor === '_Tuple3') {
								if (_p32._1.ctor === 'Nothing') {
									if ((_p32._0.ctor === 'Plus') && (_p32._2.ctor === 'Just')) {
										return _elm_lang$core$Maybe$Just(_p32._2._0);
									} else {
										break _v21_3;
									}
								} else {
									if (_p32._2.ctor === 'Nothing') {
										switch (_p32._0.ctor) {
											case 'Plus':
												return _elm_lang$core$Maybe$Just(_p32._1._0);
											case 'Minus':
												return _elm_lang$core$Maybe$Just(_p32._1._0);
											default:
												break _v21_3;
										}
									} else {
										break _v21_3;
									}
								}
							} else {
								break _v21_3;
							}
						} while(false);
						return _elm_lang$core$Maybe$Nothing;
					}();
					return addProvenanceOk(
						A2(
							_user$project$Lang$VConst,
							maybeAxisAndOtherDim,
							{
								ctor: '_Tuple2',
								_0: A4(
									_user$project$Eval$evalDelta,
									syntax,
									bt,
									op,
									{
										ctor: '::',
										_0: _p31._0._1._0,
										_1: {
											ctor: '::',
											_0: _p31._1._0._1._0,
											_1: {ctor: '[]'}
										}
									}),
								_1: A2(
									_user$project$Lang$TrOp,
									op,
									{
										ctor: '::',
										_0: _p31._0._1._1,
										_1: {
											ctor: '::',
											_0: _p31._1._0._1._1,
											_1: {ctor: '[]'}
										}
									})
							}));
				} else {
					return mkClosureOrError(
						{ctor: '_Tuple0'});
				}
			});
		var nullaryOp = F2(
			function (args, retVal_) {
				var _p33 = args;
				if (_p33.ctor === '[]') {
					return addProvenanceOk(retVal_);
				} else {
					return error(
						{ctor: '_Tuple0'});
				}
			});
		var newValRes = function () {
			var _p34 = op;
			switch (_p34.ctor) {
				case 'Plus':
					var _p35 = args;
					if (((((((_p35.ctor === '::') && (_p35._0.ctor === 'VBase')) && (_p35._0._0.ctor === 'VString')) && (_p35._1.ctor === '::')) && (_p35._1._0.ctor === 'VBase')) && (_p35._1._0._0.ctor === 'VString')) && (_p35._1._1.ctor === '[]')) {
						return addProvenanceOk(
							_user$project$Lang$VBase(
								_user$project$Lang$VString(
									A2(_elm_lang$core$Basics_ops['++'], _p35._0._0._0, _p35._1._0._0._0))));
					} else {
						return A2(binMathOp, op, args);
					}
				case 'Minus':
					return A2(binMathOp, op, args);
				case 'Mult':
					return A2(binMathOp, op, args);
				case 'Div':
					return A2(binMathOp, op, args);
				case 'Mod':
					return A2(binMathOp, op, args);
				case 'Pow':
					return A2(binMathOp, op, args);
				case 'ArcTan2':
					return A2(binMathOp, op, args);
				case 'Lt':
					var _p36 = args;
					_v25_2:
					do {
						if (((_p36.ctor === '::') && (_p36._1.ctor === '::')) && (_p36._1._1.ctor === '[]')) {
							switch (_p36._0.ctor) {
								case 'VConst':
									if (((_p36._0._1.ctor === '_Tuple2') && (_p36._1._0.ctor === 'VConst')) && (_p36._1._0._1.ctor === '_Tuple2')) {
										return addProvenanceOk(
											_user$project$Lang$VBase(
												_user$project$Lang$VBool(
													_elm_lang$core$Native_Utils.cmp(_p36._0._1._0, _p36._1._0._1._0) < 0)));
									} else {
										break _v25_2;
									}
								case 'VBase':
									if (((_p36._0._0.ctor === 'VString') && (_p36._1._0.ctor === 'VBase')) && (_p36._1._0._0.ctor === 'VString')) {
										return addProvenanceOk(
											_user$project$Lang$VBase(
												_user$project$Lang$VBool(
													_elm_lang$core$Native_Utils.cmp(_p36._0._0._0, _p36._1._0._0._0) < 0)));
									} else {
										break _v25_2;
									}
								default:
									break _v25_2;
							}
						} else {
							break _v25_2;
						}
					} while(false);
					return mkClosureOrError(
						{ctor: '_Tuple0'});
				case 'Eq':
					if (_elm_lang$core$Native_Utils.cmp(
						_elm_lang$core$List$length(vs),
						2) < 0) {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					} else {
						var valEquals = function (args) {
							var _p37 = args;
							_v26_5:
							do {
								if (((_p37.ctor === '::') && (_p37._1.ctor === '::')) && (_p37._1._1.ctor === '[]')) {
									switch (_p37._0.ctor) {
										case 'VConst':
											if (((_p37._0._1.ctor === '_Tuple2') && (_p37._1._0.ctor === 'VConst')) && (_p37._1._0._1.ctor === '_Tuple2')) {
												return _elm_lang$core$Result$Ok(
													_elm_lang$core$Native_Utils.eq(_p37._0._1._0, _p37._1._0._1._0));
											} else {
												break _v26_5;
											}
										case 'VBase':
											if (_p37._1._0.ctor === 'VBase') {
												return _elm_lang$core$Result$Ok(
													_elm_lang$core$Native_Utils.eq(_p37._0._0, _p37._1._0._0));
											} else {
												break _v26_5;
											}
										case 'VDict':
											if (_p37._1._0.ctor === 'VDict') {
												return A6(
													_elm_lang$core$Dict$merge,
													F3(
														function (k1, v1, b) {
															return _elm_lang$core$Result$Ok(false);
														}),
													F4(
														function (k, v1, v2, b) {
															return A2(
																_elm_lang$core$Result$andThen,
																function (bo) {
																	return bo ? valEquals(
																		{
																			ctor: '::',
																			_0: v1.v_,
																			_1: {
																				ctor: '::',
																				_0: v2.v_,
																				_1: {ctor: '[]'}
																			}
																		}) : _elm_lang$core$Result$Ok(bo);
																},
																b);
														}),
													F3(
														function (k2, v2, b) {
															return _elm_lang$core$Result$Ok(false);
														}),
													_p37._0._0,
													_p37._1._0._0,
													_elm_lang$core$Result$Ok(true));
											} else {
												break _v26_5;
											}
										case 'VRecord':
											if (_p37._1._0.ctor === 'VRecord') {
												return A6(
													_elm_lang$core$Dict$merge,
													F3(
														function (k1, v1, b) {
															return _elm_lang$core$Result$Ok(false);
														}),
													F4(
														function (k, v1, v2, b) {
															return A2(
																_elm_lang$core$Result$andThen,
																function (bo) {
																	return bo ? valEquals(
																		{
																			ctor: '::',
																			_0: v1.v_,
																			_1: {
																				ctor: '::',
																				_0: v2.v_,
																				_1: {ctor: '[]'}
																			}
																		}) : _elm_lang$core$Result$Ok(bo);
																},
																b);
														}),
													F3(
														function (k2, v2, b) {
															return _elm_lang$core$Result$Ok(false);
														}),
													_p37._0._0,
													_p37._1._0._0,
													_elm_lang$core$Result$Ok(true));
											} else {
												break _v26_5;
											}
										case 'VList':
											if (_p37._1._0.ctor === 'VList') {
												var _p41 = _p37._1._0._0;
												var _p40 = _p37._0._0;
												return (!_elm_lang$core$Native_Utils.eq(
													_elm_lang$core$List$length(_p40),
													_elm_lang$core$List$length(_p41))) ? _elm_lang$core$Result$Ok(false) : A3(
													_elm_lang$core$List$foldl,
													F2(
														function (_p38, b) {
															var _p39 = _p38;
															return A2(
																_elm_lang$core$Result$andThen,
																function (bo) {
																	return bo ? valEquals(
																		{
																			ctor: '::',
																			_0: _p39._0.v_,
																			_1: {
																				ctor: '::',
																				_0: _p39._1.v_,
																				_1: {ctor: '[]'}
																			}
																		}) : _elm_lang$core$Result$Ok(bo);
																},
																b);
														}),
													_elm_lang$core$Result$Ok(true),
													A2(_user$project$Utils$zip, _p40, _p41));
											} else {
												break _v26_5;
											}
										default:
											break _v26_5;
									}
								} else {
									return _elm_lang$core$Result$Err('Equality has exactly two arguments');
								}
							} while(false);
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Values not comparable:',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$String$join,
											'==',
											A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, vs)),
										'Values should have the same types and not be closures')));
						};
						return A2(
							_elm_lang$core$Result$map,
							function (x) {
								return addProvenance(
									_user$project$Lang$VBase(
										_user$project$Lang$VBool(x)));
							},
							valEquals(args));
					}
				case 'Pi':
					return A2(
						nullaryOp,
						args,
						A2(
							_user$project$Lang$VConst,
							_elm_lang$core$Maybe$Nothing,
							{
								ctor: '_Tuple2',
								_0: _elm_lang$core$Basics$pi,
								_1: A2(
									_user$project$Lang$TrOp,
									op,
									{ctor: '[]'})
							}));
				case 'DictEmpty':
					return A2(
						nullaryOp,
						args,
						_user$project$Lang$VDict(_elm_lang$core$Dict$empty));
				case 'CurrentEnv':
					return A2(
						nullaryOp,
						args,
						A3(
							_user$project$ValBuilder$list,
							A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$identity),
							_user$project$Lang$builtinVal('env'),
							env).v_);
				case 'DictFromList':
					var _p42 = vs;
					if ((_p42.ctor === '::') && (_p42._1.ctor === '[]')) {
						var _p43 = A2(
							_user$project$ValUnbuilder$list,
							A2(_user$project$ValUnbuilder$tuple2, _elm_lang$core$Result$Ok, _elm_lang$core$Result$Ok),
							_p42._0);
						if (_p43.ctor === 'Ok') {
							return A2(
								_elm_lang$core$Result$map,
								function (_p44) {
									return addProvenance(
										_user$project$Lang$VDict(
											_elm_lang$core$Dict$fromList(_p44)));
								},
								_user$project$Utils$projOk(
									A2(
										_elm_lang$core$List$map,
										function (_p45) {
											var _p46 = _p45;
											return A2(
												_elm_lang$core$Result$map,
												function (dkey) {
													return {ctor: '_Tuple2', _0: dkey, _1: _p46._1};
												},
												A3(_user$project$Eval$valToDictKey, syntax, bt, _p46._0));
										},
										_p43._0)));
						} else {
							return error(
								{ctor: '_Tuple0'});
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'DictInsert':
					var _p47 = vs;
					if ((((_p47.ctor === '::') && (_p47._1.ctor === '::')) && (_p47._1._1.ctor === '::')) && (_p47._1._1._1.ctor === '[]')) {
						var _p48 = _p47._1._1._0.v_;
						if (_p48.ctor === 'VDict') {
							return A2(
								_elm_lang$core$Result$map,
								function (dkey) {
									return addProvenance(
										_user$project$Lang$VDict(
											A3(_elm_lang$core$Dict$insert, dkey, _p47._1._0, _p48._0)));
								},
								A3(_user$project$Eval$valToDictKey, syntax, bt, _p47._0));
						} else {
							return error(
								{ctor: '_Tuple0'});
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'DictGet':
					var _p49 = vs;
					if (((_p49.ctor === '::') && (_p49._1.ctor === '::')) && (_p49._1._1.ctor === '[]')) {
						var _p50 = _p49._1._0.v_;
						if (_p50.ctor === 'VDict') {
							return A2(
								_elm_lang$core$Result$map,
								function (dkey) {
									var _p51 = A2(_elm_lang$core$Dict$get, dkey, _p50._0);
									if (_p51.ctor === 'Nothing') {
										return A3(
											_user$project$ValBuilder$constructor,
											addProvenance,
											'Nothing',
											{ctor: '[]'});
									} else {
										return A3(
											_user$project$ValBuilder$constructor,
											addProvenance,
											'Just',
											{
												ctor: '::',
												_0: _p51._0,
												_1: {ctor: '[]'}
											});
									}
								},
								A3(_user$project$Eval$valToDictKey, syntax, bt, _p49._0));
						} else {
							return error(
								{ctor: '_Tuple0'});
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'DictRemove':
					var _p52 = vs;
					if (((_p52.ctor === '::') && (_p52._1.ctor === '::')) && (_p52._1._1.ctor === '[]')) {
						var _p53 = _p52._1._0.v_;
						if (_p53.ctor === 'VDict') {
							return A2(
								_elm_lang$core$Result$map,
								function (dkey) {
									return addProvenance(
										_user$project$Lang$VDict(
											A2(_elm_lang$core$Dict$remove, dkey, _p53._0)));
								},
								A3(_user$project$Eval$valToDictKey, syntax, bt, _p52._0));
						} else {
							return error(
								{ctor: '_Tuple0'});
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'Cos':
					return A2(unaryMathOp, op, args);
				case 'Sin':
					return A2(unaryMathOp, op, args);
				case 'ArcCos':
					return A2(unaryMathOp, op, args);
				case 'ArcSin':
					return A2(unaryMathOp, op, args);
				case 'Floor':
					return A2(unaryMathOp, op, args);
				case 'Ceil':
					return A2(unaryMathOp, op, args);
				case 'Round':
					return A2(unaryMathOp, op, args);
				case 'Sqrt':
					return A2(unaryMathOp, op, args);
				case 'Explode':
					var _p54 = args;
					if ((((_p54.ctor === '::') && (_p54._0.ctor === 'VBase')) && (_p54._0._0.ctor === 'VString')) && (_p54._1.ctor === '[]')) {
						return addProvenanceOk(
							_user$project$Lang$VList(
								A2(
									_user$project$Utils$mapi0,
									function (_p55) {
										var _p56 = _p55;
										return {
											v_: _user$project$Lang$VBase(
												_user$project$Lang$VString(_p56._1)),
											provenance: A3(
												_user$project$Lang$Provenance,
												env,
												A2(
													_user$project$Lang$eCall,
													'nth',
													{
														ctor: '::',
														_0: e,
														_1: {
															ctor: '::',
															_0: _user$project$Lang$eConstDummyLoc(
																_elm_lang$core$Basics$toFloat(_p56._0)),
															_1: {ctor: '[]'}
														}
													}),
												vs),
											parents: _user$project$Lang$Parents(
												{ctor: '[]'})
										};
									},
									A2(
										_elm_lang$core$List$map,
										_elm_lang$core$String$fromChar,
										_elm_lang$core$String$toList(_p54._0._0._0)))));
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'DebugLog':
					var _p57 = vs;
					if ((_p57.ctor === '::') && (_p57._1.ctor === '[]')) {
						var _p61 = _p57._0;
						var _p58 = _p61.v_;
						if ((_p58.ctor === 'VBase') && (_p58._0.ctor === 'VString')) {
							var _p59 = _user$project$ImpureGoodies$log(_p58._0._0);
							return _elm_lang$core$Result$Ok(_p61);
						} else {
							var _p60 = _user$project$ImpureGoodies$log(
								_user$project$LangUtils$valToString(_p61));
							return _elm_lang$core$Result$Ok(_p61);
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'NoWidgets':
					var _p62 = vs;
					if ((_p62.ctor === '::') && (_p62._1.ctor === '[]')) {
						return _elm_lang$core$Result$Ok(_p62._0);
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'ToStr':
					var _p63 = vs;
					if ((_p63.ctor === '::') && (_p63._1.ctor === '[]')) {
						return addProvenanceOk(
							_user$project$Lang$VBase(
								_user$project$Lang$VString(
									_user$project$LangUtils$valToString(_p63._0))));
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'ToStrExceptStr':
					var _p64 = vs;
					if ((_p64.ctor === '::') && (_p64._1.ctor === '[]')) {
						var _p66 = _p64._0;
						var _p65 = _p66.v_;
						if ((_p65.ctor === 'VBase') && (_p65._0.ctor === 'VString')) {
							return addProvenanceOk(_p65);
						} else {
							return addProvenanceOk(
								_user$project$Lang$VBase(
									_user$project$Lang$VString(
										_user$project$LangUtils$valToString(_p66))));
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				case 'RegexExtractFirstIn':
					var _p67 = vs;
					if (((_p67.ctor === '::') && (_p67._1.ctor === '::')) && (_p67._1._1.ctor === '[]')) {
						return A2(_user$project$UpdateRegex$evalRegexExtractFirstIn, _p67._0, _p67._1._0);
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
				default:
					var _p68 = vs;
					if ((_p68.ctor === '::') && (_p68._1.ctor === '[]')) {
						var _p69 = _p68._0.v_;
						if ((_p69.ctor === 'VBase') && (_p69._0.ctor === 'VString')) {
							return addProvenanceOk(
								A2(
									_user$project$Lang$VConst,
									_elm_lang$core$Maybe$Nothing,
									{
										ctor: '_Tuple2',
										_0: _elm_lang$core$Basics$toFloat(
											_elm_lang$core$String$length(_p69._0._0)),
										_1: _user$project$Lang$dummyTrace
									}));
						} else {
							return mkClosureOrError(
								{ctor: '_Tuple0'});
						}
					} else {
						return mkClosureOrError(
							{ctor: '_Tuple0'});
					}
			}
		}();
		var _p70 = newValRes;
		if (_p70.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p70._0);
		} else {
			var _p88 = _p70._0;
			var newWidgets = function () {
				var _p71 = {ctor: '_Tuple3', _0: op, _1: args, _2: vs};
				_v50_3:
				do {
					if (((_p71.ctor === '_Tuple3') && (_p71._1.ctor === '::')) && (_p71._1._0.ctor === 'VConst')) {
						if (_p71._1._0._0.ctor === 'Nothing') {
							if (((((((((_p71._0.ctor === 'Plus') && (_p71._1._1.ctor === '::')) && (_p71._1._1._0.ctor === 'VConst')) && (_p71._1._1._0._0.ctor === 'Just')) && (_p71._1._1._0._0._0.ctor === '_Tuple3')) && (_p71._1._1._1.ctor === '[]')) && (_p71._2.ctor === '::')) && (_p71._2._1.ctor === '::')) && (_p71._2._1._1.ctor === '[]')) {
								var _p81 = _p71._1._1._0._0._0._2;
								var _p80 = _p71._1._1._0._0._0._1;
								var _p79 = _p71._1._1._0._1;
								var _p78 = _p71._1._1._0._0._0._0;
								var _p77 = _elm_lang$core$Native_Utils.eq(_p78, _user$project$Lang$X) ? {ctor: '_Tuple4', _0: _p79, _1: _p80, _2: _p88, _3: _p81} : {ctor: '_Tuple4', _0: _p80, _1: _p79, _2: _p81, _3: _p88};
								var baseXNumTr = _p77._0;
								var baseYNumTr = _p77._1;
								var endXVal = _p77._2;
								var endYVal = _p77._3;
								return {
									ctor: '::',
									_0: A8(_user$project$Lang$WOffset1D, baseXNumTr, baseYNumTr, _p78, _user$project$Lang$Positive, _p71._1._0._1, _p71._2._0, endXVal, endYVal),
									_1: {ctor: '[]'}
								};
							} else {
								break _v50_3;
							}
						} else {
							if ((((((((_p71._1._0._0._0.ctor === '_Tuple3') && (_p71._1._1.ctor === '::')) && (_p71._1._1._0.ctor === 'VConst')) && (_p71._1._1._0._0.ctor === 'Nothing')) && (_p71._1._1._1.ctor === '[]')) && (_p71._2.ctor === '::')) && (_p71._2._1.ctor === '::')) && (_p71._2._1._1.ctor === '[]')) {
								switch (_p71._0.ctor) {
									case 'Plus':
										var _p76 = _p71._1._0._0._0._2;
										var _p75 = _p71._1._0._0._0._1;
										var _p74 = _p71._1._0._1;
										var _p73 = _p71._1._0._0._0._0;
										var _p72 = _elm_lang$core$Native_Utils.eq(_p73, _user$project$Lang$X) ? {ctor: '_Tuple4', _0: _p74, _1: _p75, _2: _p88, _3: _p76} : {ctor: '_Tuple4', _0: _p75, _1: _p74, _2: _p76, _3: _p88};
										var baseXNumTr = _p72._0;
										var baseYNumTr = _p72._1;
										var endXVal = _p72._2;
										var endYVal = _p72._3;
										return {
											ctor: '::',
											_0: A8(_user$project$Lang$WOffset1D, baseXNumTr, baseYNumTr, _p73, _user$project$Lang$Positive, _p71._1._1._0._1, _p71._2._1._0, endXVal, endYVal),
											_1: {ctor: '[]'}
										};
									case 'Minus':
										var _p86 = _p71._1._0._0._0._2;
										var _p85 = _p71._1._0._0._0._1;
										var _p84 = _p71._1._0._1;
										var _p83 = _p71._1._0._0._0._0;
										var _p82 = _elm_lang$core$Native_Utils.eq(_p83, _user$project$Lang$X) ? {ctor: '_Tuple4', _0: _p84, _1: _p85, _2: _p88, _3: _p86} : {ctor: '_Tuple4', _0: _p85, _1: _p84, _2: _p86, _3: _p88};
										var baseXNumTr = _p82._0;
										var baseYNumTr = _p82._1;
										var endXVal = _p82._2;
										var endYVal = _p82._3;
										return {
											ctor: '::',
											_0: A8(_user$project$Lang$WOffset1D, baseXNumTr, baseYNumTr, _p83, _user$project$Lang$Negative, _p71._1._1._0._1, _p71._2._1._0, endXVal, endYVal),
											_1: {ctor: '[]'}
										};
									default:
										break _v50_3;
								}
							} else {
								break _v50_3;
							}
						}
					} else {
						break _v50_3;
					}
				} while(false);
				return {ctor: '[]'};
			}();
			var widgets = function () {
				var _p87 = op;
				if (_p87.ctor === 'NoWidgets') {
					return {ctor: '[]'};
				} else {
					return A2(_elm_lang$core$Basics_ops['++'], wss, newWidgets);
				}
			}();
			return _elm_lang$core$Result$Ok(
				{ctor: '_Tuple2', _0: _p88, _1: widgets});
		}
	});
var _user$project$Eval$EvalOptions = F3(
	function (a, b, c) {
		return {recordParents: a, recordProvenance: b, recordWidgets: c};
	});
var _user$project$Eval$withParentsProvenanceWidgets = A3(_user$project$Eval$EvalOptions, true, true, true);
var _user$project$Eval$withoutParentsProvenanceWidgets = A3(_user$project$Eval$EvalOptions, false, false, false);
var _user$project$Eval$EvalContinue = F6(
	function (a, b, c, d, e, f) {
		return {ctor: 'EvalContinue', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f};
	});
var _user$project$Eval$evalContext = F5(
	function (options, syntax, env, bt, e) {
		return A6(_user$project$Eval$EvalContinue, options, syntax, env, bt, e, _elm_lang$core$Maybe$Nothing);
	});
var _user$project$Eval$evalContinue = F6(
	function (options, syntax, env, bt, e, continuation) {
		return A6(
			_user$project$Eval$EvalContinue,
			options,
			syntax,
			env,
			bt,
			e,
			_elm_lang$core$Maybe$Just(continuation));
	});
var _user$project$Eval$evalBranches = F8(
	function (options, syntax, env, bt, v, bs, ifError, continuation) {
		var aux = function (bs) {
			aux:
			while (true) {
				var _p89 = bs;
				if (_p89.ctor === '[]') {
					return ifError(
						{ctor: '_Tuple0'});
				} else {
					var _p90 = _p89._0.val;
					var pat = _p90._1;
					var exp = _p90._2;
					var _p91 = A2(
						_user$project$Eval$cons,
						{ctor: '_Tuple2', _0: pat, _1: v},
						_elm_lang$core$Maybe$Just(env));
					if (_p91.ctor === 'Nothing') {
						var _v54 = _p89._1;
						bs = _v54;
						continue aux;
					} else {
						return A6(_user$project$Eval$evalContinue, options, syntax, _p91._0, bt, exp, continuation);
					}
				}
			}
		};
		return aux(bs);
	});
var _user$project$Eval$EvalError = function (a) {
	return {ctor: 'EvalError', _0: a};
};
var _user$project$Eval$errorMsg = function (s) {
	return _user$project$Eval$EvalError(
		A2(
			_elm_lang$core$Basics_ops['++'],
			_user$project$Eval$errorPrefix,
			A2(_elm_lang$core$Basics_ops['++'], '\n\n', s)));
};
var _user$project$Eval$errorWithBacktrace = F3(
	function (syntax, bt, message) {
		return _user$project$Eval$errorMsg(
			A3(_user$project$Eval$backtraceMessage, syntax, bt, message));
	});
var _user$project$Eval$evalDeclarations = F6(
	function (options, syntax, env, bt, _p92, continuation) {
		var _p93 = _p92;
		var aux = F3(
			function (letexpsGroups, widgets, env) {
				var _p94 = letexpsGroups;
				if (_p94.ctor === '[]') {
					return A2(continuation, env, widgets);
				} else {
					var _p111 = _p94._1;
					var _p110 = _p94._0._1;
					var evalGroup = F4(
						function (revPs, revVs, revWs, group) {
							var _p95 = group;
							if (_p95.ctor === '::') {
								return A6(
									_user$project$Eval$evalContinue,
									options,
									syntax,
									env,
									bt,
									_p95._0._5,
									function (_p96) {
										var _p97 = _p96;
										return A4(
											evalGroup,
											{ctor: '::', _0: _p95._0._2, _1: revPs},
											{ctor: '::', _0: _p97._0._0, _1: revVs},
											A2(_user$project$Utils$reverseInsert, _p97._0._1, revWs),
											_p95._1);
									});
							} else {
								var newWidgets = _elm_lang$core$List$reverse(revWs);
								var values = _elm_lang$core$List$reverse(revVs);
								var patterns = _elm_lang$core$List$reverse(revPs);
								if (_p94._0._0) {
									var allNames = _user$project$Utils$projOk(
										A2(
											_elm_lang$core$List$map,
											function (p) {
												var _p98 = function (_) {
													return _.p__;
												}(
													function (_) {
														return _.val;
													}(
														_user$project$Lang$patEffectivePat(p)));
												if (_p98.ctor === 'PVar') {
													return _elm_lang$core$Result$Ok(_p98._1);
												} else {
													return _elm_lang$core$Result$Err('Recursive function with non-variable pattern!');
												}
											},
											patterns));
									var _p99 = allNames;
									if (_p99.ctor === 'Err') {
										return _user$project$Eval$EvalError(_p99._0);
									} else {
										var _p102 = _p99._0;
										var nonRecEnv = A3(
											_elm_lang$core$List$map2,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												}),
											_p102,
											values);
										var newValues = _user$project$Utils$projOk(
											A3(
												_elm_lang$core$List$map2,
												F2(
													function (name, value) {
														var _p100 = value.v_;
														if ((_p100.ctor === 'VClosure') && (_p100._0.ctor === '[]')) {
															return _elm_lang$core$Result$Ok(
																A2(
																	_user$project$Lang$replaceV_,
																	value,
																	A4(
																		_user$project$Lang$VClosure,
																		_p102,
																		_p100._1,
																		_p100._2,
																		A2(_elm_lang$core$Basics_ops['++'], nonRecEnv, env))));
														} else {
															return _elm_lang$core$Result$Err(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Expected VClosures for recursivity, got ',
																	_user$project$LangUtils$valToString(value)));
														}
													}),
												_p102,
												values));
										var _p101 = newValues;
										if (_p101.ctor === 'Err') {
											return _user$project$Eval$EvalError(_p101._0);
										} else {
											var newEnv = A2(
												_elm_lang$core$Basics_ops['++'],
												A3(
													_elm_lang$core$List$map2,
													F2(
														function (v0, v1) {
															return {ctor: '_Tuple2', _0: v0, _1: v1};
														}),
													_p102,
													_p101._0),
												env);
											return A3(
												aux,
												_p111,
												A2(_elm_lang$core$Basics_ops['++'], widgets, newWidgets),
												newEnv);
										}
									}
								} else {
									var _p105 = A3(
										_user$project$Utils$foldLeft,
										_elm_lang$core$Maybe$Just(env),
										A2(_user$project$Utils$zip, patterns, values),
										F2(
											function (mbEnv, _p103) {
												var _p104 = _p103;
												return A2(
													_user$project$Eval$cons,
													{ctor: '_Tuple2', _0: _p104._0, _1: _p104._1},
													mbEnv);
											}));
									if (_p105.ctor === 'Just') {
										return A3(
											aux,
											_p111,
											A2(_elm_lang$core$Basics_ops['++'], widgets, newWidgets),
											_p105._0);
									} else {
										return A3(
											_user$project$Eval$errorWithBacktrace,
											syntax,
											bt,
											A2(
												_elm_lang$core$Basics_ops['++'],
												_user$project$Lang$strPos(
													function (_p106) {
														var _p107 = _p106;
														return _p107._0.start;
													}(
														A2(_user$project$Utils$head, 'bt.first', bt))),
												A2(
													_elm_lang$core$Basics_ops['++'],
													'match error in deconstructing the value of ',
													A2(
														_elm_lang$core$String$join,
														'\n',
														A2(
															_elm_lang$core$List$map,
															function (_p108) {
																var _p109 = _p108;
																return A2(
																	_elm_lang$core$Basics_ops['++'],
																	A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, _p109._0),
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		' with ',
																		_user$project$LangUtils$valToString(_p109._1)));
															},
															A2(_user$project$Utils$zip, patterns, values))))));
									}
								}
							}
						});
					var i = _elm_lang$core$List$length(_p110);
					return A4(
						evalGroup,
						{ctor: '[]'},
						{ctor: '[]'},
						{ctor: '[]'},
						_p110);
				}
			});
		return A3(
			aux,
			_p93._3,
			{ctor: '[]'},
			env);
	});
var _user$project$Eval$apply = function (options) {
	return function (syntax) {
		return function (env) {
			return function (bt) {
				return function (bt_) {
					return function (_p112) {
						return function (psLeft) {
							return function (esLeft) {
								return function (funcBody) {
									return function (closureEnv) {
										return function (continuation) {
											var _p113 = _p112;
											var _p125 = _p113._0;
											var aux = F6(
												function (psLeft, esLeft, funcBody, closureEnv, revArgVals, revArgWidgets) {
													var _p114 = {ctor: '_Tuple2', _0: psLeft, _1: esLeft};
													if (_p114._0.ctor === '[]') {
														if (_p114._1.ctor === '[]') {
															return A6(
																_user$project$Eval$evalContinue,
																options,
																syntax,
																closureEnv,
																bt_,
																funcBody,
																continuation(
																	_elm_lang$core$List$reverse(revArgVals)));
														} else {
															return A6(
																_user$project$Eval$evalContinue,
																options,
																syntax,
																closureEnv,
																bt_,
																funcBody,
																function (_p115) {
																	var _p116 = _p115;
																	var _p117 = _p116._0._0.v_;
																	if (_p117.ctor === 'VClosure') {
																		var _p118 = _p117._3;
																		var recEnv = A2(
																			_elm_lang$core$List$map,
																			function (fName) {
																				return {
																					ctor: '_Tuple2',
																					_0: fName,
																					_1: A2(
																						_user$project$Utils$fromJust_,
																						'[Internal error] Did not find recursive closure in its environment',
																						A2(_user$project$Utils$maybeFind, fName, _p118))
																				};
																			},
																			_p117._0);
																		return A6(
																			aux,
																			_p117._1,
																			_p114._1,
																			_p117._2,
																			A2(_elm_lang$core$Basics_ops['++'], recEnv, _p118),
																			revArgVals,
																			A2(_user$project$Utils$reverseInsert, _p116._0._1, revArgWidgets));
																	} else {
																		return A3(
																			_user$project$Eval$errorWithBacktrace,
																			syntax,
																			{ctor: '::', _0: _p113, _1: bt},
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_user$project$Lang$strPos(_p125.start),
																				' too many arguments given to function'));
																	}
																});
														}
													} else {
														if (_p114._1.ctor === '[]') {
															var finalVal = {
																v_: A4(
																	_user$project$Lang$VClosure,
																	{ctor: '[]'},
																	_p114._0,
																	funcBody,
																	closureEnv),
																provenance: _user$project$Lang$dummyProvenance,
																parents: _user$project$Lang$Parents(
																	{ctor: '[]'})
															};
															return A2(
																continuation,
																_elm_lang$core$List$reverse(revArgVals),
																{
																	ctor: '_Tuple2',
																	_0: {
																		ctor: '_Tuple2',
																		_0: finalVal,
																		_1: {ctor: '[]'}
																	},
																	_1: env
																});
														} else {
															var _p124 = _p114._0._0;
															var _p123 = _p114._1._0;
															return A6(
																_user$project$Eval$evalContinue,
																options,
																syntax,
																env,
																bt_,
																_p123,
																function (_p119) {
																	var _p120 = _p119;
																	var _p122 = _p120._0._0;
																	var _p121 = A2(
																		_user$project$Eval$cons,
																		{ctor: '_Tuple2', _0: _p124, _1: _p122},
																		_elm_lang$core$Maybe$Just(closureEnv));
																	if (_p121.ctor === 'Just') {
																		return A6(
																			aux,
																			_p114._0._1,
																			_p114._1._1,
																			funcBody,
																			_p121._0,
																			{ctor: '::', _0: _p122, _1: revArgVals},
																			A2(_user$project$Utils$reverseInsert, _p120._0._1, revArgWidgets));
																	} else {
																		return A3(
																			_user$project$Eval$errorWithBacktrace,
																			syntax,
																			{ctor: '::', _0: _p123, _1: bt},
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_user$project$Lang$strPos(_p125.start),
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					' bad arguments to function, cannot match ',
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, _p124),
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							' with ',
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p123),
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'(evaluates to ',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_user$project$LangUtils$valToString(_p122),
																										')'))))))));
																	}
																});
														}
													}
												});
											return A6(
												aux,
												psLeft,
												esLeft,
												funcBody,
												closureEnv,
												{ctor: '[]'},
												{ctor: '[]'});
										};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var _user$project$Eval$EvalReturn = F2(
	function (a, b) {
		return {ctor: 'EvalReturn', _0: a, _1: b};
	});
var _user$project$Eval$evalReturn = function (r) {
	return A2(_user$project$Eval$EvalReturn, r, _elm_lang$core$Maybe$Nothing);
};
var _user$project$Eval$getEvalStack = F5(
	function (options, syntax, env, bt, _p126) {
		var _p127 = _p126;
		var _p259 = _p127;
		var e_start = _p127._0.start;
		var addParent = function () {
			if (options.recordParents) {
				var addParent_ = F2(
					function (vParent, v) {
						var _p128 = function () {
							var _p129 = v.v_;
							switch (_p129.ctor) {
								case 'VConst':
									return {ctor: '_Tuple0'};
								case 'VBase':
									return {ctor: '_Tuple0'};
								case 'VClosure':
									return {ctor: '_Tuple0'};
								case 'VList':
									var _p130 = A2(
										_elm_lang$core$List$map,
										addParent_(vParent),
										_p129._0);
									return {ctor: '_Tuple0'};
								case 'VDict':
									var _p131 = A2(
										_elm_lang$core$Dict$map,
										F2(
											function (_p132, val) {
												return A2(addParent_, vParent, val);
											}),
										_p129._0);
									return {ctor: '_Tuple0'};
								case 'VRecord':
									var _p133 = A2(
										_elm_lang$core$Dict$map,
										F2(
											function (_p134, val) {
												return A2(addParent_, vParent, val);
											}),
										_p129._0);
									return {ctor: '_Tuple0'};
								default:
									return {ctor: '_Tuple0'};
							}
						}();
						var priorParents = _user$project$Lang$valParents(v);
						var _p135 = A3(
							_user$project$ImpureGoodies$mutateRecordField,
							v.parents,
							'_0',
							{ctor: '::', _0: vParent, _1: priorParents});
						return {ctor: '_Tuple0'};
					});
				return function (v) {
					if (_user$project$LeoParser$isProgramEId(
						_user$project$Lang$expEId(_p259))) {
						var _p136 = v.v_;
						switch (_p136.ctor) {
							case 'VConst':
								return v;
							case 'VBase':
								return v;
							case 'VClosure':
								return v;
							case 'VList':
								var _p137 = A2(
									_elm_lang$core$List$map,
									addParent_(v),
									_p136._0);
								return v;
							case 'VDict':
								var _p138 = A2(
									_elm_lang$core$Dict$map,
									F2(
										function (_p139, val) {
											return A2(addParent_, v, val);
										}),
									_p136._0);
								return v;
							case 'VRecord':
								var _p140 = A2(
									_elm_lang$core$Dict$map,
									F2(
										function (_p141, val) {
											return A2(addParent_, v, val);
										}),
									_p136._0);
								return v;
							default:
								return v;
						}
					} else {
						return v;
					}
				};
			} else {
				return _elm_lang$core$Basics$identity;
			}
		}();
		var makeProvenance = function (basedOn) {
			return A3(_user$project$Lang$Provenance, env, _p259, basedOn);
		};
		var introduceVal = options.recordParents ? F2(
			function (basedOn, v_) {
				return addParent(
					A3(
						_user$project$Lang$Val,
						v_,
						makeProvenance(basedOn),
						_user$project$Lang$Parents(
							{ctor: '[]'})));
			}) : F2(
			function (basedOn, v_) {
				return A3(
					_user$project$Lang$Val,
					v_,
					makeProvenance(basedOn),
					_user$project$Lang$Parents(
						{ctor: '[]'}));
			});
		var retBoth = F2(
			function (basedOn, _p142) {
				var _p143 = _p142;
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: A2(introduceVal, basedOn, _p143._0),
						_1: _p143._1
					},
					_1: env
				};
			});
		var ret = F2(
			function (basedOn, v_) {
				return A2(
					retBoth,
					basedOn,
					{
						ctor: '_Tuple2',
						_0: v_,
						_1: {ctor: '[]'}
					});
			});
		var retV = options.recordProvenance ? F2(
			function (basedOn, v) {
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: addParent(
							_elm_lang$core$Native_Utils.update(
								v,
								{
									provenance: makeProvenance(basedOn)
								})),
						_1: {ctor: '[]'}
					},
					_1: env
				};
			}) : (options.recordParents ? F2(
			function (basedOn, v) {
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: addParent(v),
						_1: {ctor: '[]'}
					},
					_1: env
				};
			}) : F2(
			function (basedOn, v) {
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: v,
						_1: {ctor: '[]'}
					},
					_1: env
				};
			}));
		var retVBoth = options.recordParents ? F2(
			function (basedOn, _p144) {
				var _p145 = _p144;
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: addParent(
							_elm_lang$core$Native_Utils.update(
								_p145._0,
								{
									provenance: makeProvenance(basedOn)
								})),
						_1: _p145._1
					},
					_1: env
				};
			}) : F2(
			function (basedOn, _p146) {
				var _p147 = _p146;
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: _elm_lang$core$Native_Utils.update(
							_p147._0,
							{
								provenance: makeProvenance(basedOn)
							}),
						_1: _p147._1
					},
					_1: env
				};
			});
		var retAddWs = F2(
			function (ws1, _p148) {
				var _p149 = _p148;
				return {
					ctor: '_Tuple2',
					_0: _p149._0,
					_1: A2(_elm_lang$core$Basics_ops['++'], ws1, _p149._1)
				};
			});
		var addParentToRet = function (_p150) {
			var _p151 = _p150;
			return {
				ctor: '_Tuple2',
				_0: {
					ctor: '_Tuple2',
					_0: addParent(_p151._0._0),
					_1: _p151._0._1
				},
				_1: _p151._1
			};
		};
		var addProvenanceToValWidgets = F2(
			function (basedOn, _p152) {
				var _p153 = _p152;
				return {
					ctor: '_Tuple2',
					_0: addParent(
						_elm_lang$core$Native_Utils.update(
							_p153._0,
							{
								provenance: makeProvenance(basedOn)
							})),
					_1: _p153._1
				};
			});
		var addProvenanceToRet = F2(
			function (basedOn, _p154) {
				var _p155 = _p154;
				return {
					ctor: '_Tuple2',
					_0: A2(addProvenanceToValWidgets, basedOn, _p155._0),
					_1: _p155._1
				};
			});
		var addWidgets = F2(
			function (ws1, _p156) {
				var _p157 = _p156;
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: _p157._0._0,
						_1: A2(_elm_lang$core$Basics_ops['++'], ws1, _p157._0._1)
					},
					_1: _p157._1
				};
			});
		var bt_ = (_elm_lang$core$Native_Utils.cmp(e_start.line, 1) > -1) ? {ctor: '::', _0: _p259, _1: bt} : bt;
		var _p158 = _user$project$Lang$unwrapExp(_p259);
		switch (_p158.ctor) {
			case 'EConst':
				var _p161 = _p158._1;
				var _p160 = _p158._2;
				var v_ = A2(
					_user$project$Lang$VConst,
					_elm_lang$core$Maybe$Nothing,
					{
						ctor: '_Tuple2',
						_0: _p161,
						_1: _user$project$Lang$TrLoc(_p160)
					});
				var retVal = A2(
					introduceVal,
					{ctor: '[]'},
					v_);
				if (options.recordWidgets) {
					return _user$project$Eval$evalReturn(
						{
							ctor: '_Tuple2',
							_0: {
								ctor: '_Tuple2',
								_0: retVal,
								_1: {ctor: '[]'}
							},
							_1: env
						});
				} else {
					var _p159 = _p158._3.val;
					switch (_p159.ctor) {
						case 'NoWidgetDecl':
							return _user$project$Eval$evalReturn(
								{
									ctor: '_Tuple2',
									_0: {
										ctor: '_Tuple2',
										_0: retVal,
										_1: {ctor: '[]'}
									},
									_1: env
								});
						case 'IntSlider':
							var widget = A7(
								_user$project$Lang$WIntSlider,
								_p159._0.val,
								_p159._2.val,
								A2(_user$project$Eval$mkCap, _p159._3, _p160),
								_elm_lang$core$Basics$floor(_p161),
								retVal,
								_p160,
								_p159._4);
							return _user$project$Eval$evalReturn(
								{
									ctor: '_Tuple2',
									_0: {
										ctor: '_Tuple2',
										_0: retVal,
										_1: {
											ctor: '::',
											_0: widget,
											_1: {ctor: '[]'}
										}
									},
									_1: env
								});
						default:
							var widget = A7(
								_user$project$Lang$WNumSlider,
								_p159._0.val,
								_p159._2.val,
								A2(_user$project$Eval$mkCap, _p159._3, _p160),
								_p161,
								retVal,
								_p160,
								_p159._4);
							return _user$project$Eval$evalReturn(
								{
									ctor: '_Tuple2',
									_0: {
										ctor: '_Tuple2',
										_0: retVal,
										_1: {
											ctor: '::',
											_0: widget,
											_1: {ctor: '[]'}
										}
									},
									_1: env
								});
					}
				}
			case 'EBase':
				return _user$project$Eval$evalReturn(
					A2(
						ret,
						{ctor: '[]'},
						_user$project$Lang$VBase(
							_user$project$Eval$eBaseToVBase(_p158._1))));
			case 'EVar':
				var _p162 = A5(
					_user$project$Eval$lookupVar,
					syntax,
					env,
					{ctor: '::', _0: _p259, _1: bt},
					_p158._1,
					e_start);
				if (_p162.ctor === 'Err') {
					return _user$project$Eval$EvalError(_p162._0);
				} else {
					var _p163 = _p162._0;
					return _user$project$Eval$evalReturn(
						A2(
							retV,
							{
								ctor: '::',
								_0: _p163,
								_1: {ctor: '[]'}
							},
							_p163));
				}
			case 'EFun':
				return _user$project$Eval$evalReturn(
					A2(
						ret,
						{ctor: '[]'},
						A4(
							_user$project$Lang$VClosure,
							{ctor: '[]'},
							_p158._1,
							_p158._2,
							env)));
			case 'EOp':
				var _p169 = _p158._3;
				var aux = F3(
					function (revVsComputed, revWsComputed, esRemaining) {
						var _p164 = esRemaining;
						if (_p164.ctor === '[]') {
							var _p165 = A8(
								_user$project$Eval$evalOp,
								syntax,
								env,
								_p259,
								{ctor: '::', _0: _p259, _1: bt},
								_p158._2,
								_p169,
								_elm_lang$core$List$reverse(revVsComputed),
								_elm_lang$core$List$reverse(revWsComputed));
							if (_p165.ctor === 'Err') {
								return _user$project$Eval$EvalError(_p165._0);
							} else {
								var _p166 = _p165._0;
								return _user$project$Eval$evalReturn(
									options.recordParents ? addParentToRet(
										{ctor: '_Tuple2', _0: _p166, _1: env}) : {ctor: '_Tuple2', _0: _p166, _1: env});
							}
						} else {
							return A6(
								_user$project$Eval$evalContinue,
								options,
								syntax,
								env,
								bt_,
								_p164._0,
								function (_p167) {
									var _p168 = _p167;
									return A3(
										aux,
										{ctor: '::', _0: _p168._0._0, _1: revVsComputed},
										A2(_user$project$Utils$reverseInsert, _p168._0._1, revWsComputed),
										_p164._1);
								});
						}
					});
				return A3(
					aux,
					{ctor: '[]'},
					{ctor: '[]'},
					_p169);
			case 'EList':
				var aux = F3(
					function (revVsComputed, revWsComputed, esRemaining) {
						var _p170 = esRemaining;
						if (_p170.ctor === '[]') {
							var vs = _elm_lang$core$List$reverse(revVsComputed);
							var ws = _elm_lang$core$List$reverse(revWsComputed);
							var _p171 = _p158._3;
							if (_p171.ctor === 'Nothing') {
								return _user$project$Eval$evalReturn(
									A2(
										retBoth,
										vs,
										{
											ctor: '_Tuple2',
											_0: _user$project$Lang$VList(vs),
											_1: ws
										}));
							} else {
								return A6(
									_user$project$Eval$evalContinue,
									options,
									syntax,
									env,
									bt_,
									_p171._0,
									function (_p172) {
										var _p173 = _p172;
										var _p175 = _p173._0._0;
										var _p174 = _p175.v_;
										if (_p174.ctor === 'VList') {
											return _user$project$Eval$evalReturn(
												A2(
													retBoth,
													A2(
														_elm_lang$core$Basics_ops['++'],
														vs,
														{
															ctor: '::',
															_0: _p175,
															_1: {ctor: '[]'}
														}),
													{
														ctor: '_Tuple2',
														_0: _user$project$Lang$VList(
															A2(_elm_lang$core$Basics_ops['++'], vs, _p174._0)),
														_1: A2(_elm_lang$core$Basics_ops['++'], ws, _p173._0._1)
													}));
										} else {
											return A3(
												_user$project$Eval$errorWithBacktrace,
												syntax,
												{ctor: '::', _0: _p259, _1: bt},
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$Lang$strPos(_p171._0._0.start),
													A2(
														_elm_lang$core$Basics_ops['++'],
														' rest expression not a list, but ',
														_user$project$LangUtils$valToString(_p175))));
										}
									});
							}
						} else {
							return A6(
								_user$project$Eval$evalContinue,
								options,
								syntax,
								env,
								bt_,
								_p170._0._1,
								function (_p176) {
									var _p177 = _p176;
									return A3(
										aux,
										{ctor: '::', _0: _p177._0._0, _1: revVsComputed},
										A2(_user$project$Utils$reverseInsert, _p177._0._1, revWsComputed),
										_p170._1);
								});
						}
					});
				return A3(
					aux,
					{ctor: '[]'},
					{ctor: '[]'},
					_p158._1);
			case 'ERecord':
				var computeResInitDictWidgets = function (continuation) {
					var _p178 = _p158._1;
					if (_p178.ctor === 'Nothing') {
						return A3(
							continuation,
							_elm_lang$core$Maybe$Nothing,
							_elm_lang$core$Dict$empty,
							{ctor: '[]'});
					} else {
						return A6(
							_user$project$Eval$evalContinue,
							options,
							syntax,
							env,
							bt_,
							_p178._0._0,
							function (_p179) {
								var _p180 = _p179;
								var _p182 = _p180._0._0;
								var _p181 = _p182.v_;
								if (_p181.ctor === 'VRecord') {
									return A3(
										continuation,
										_elm_lang$core$Maybe$Just(_p182),
										_p181._0,
										_p180._0._1);
								} else {
									return A3(
										_user$project$Eval$errorWithBacktrace,
										syntax,
										{ctor: '::', _0: _p259, _1: bt},
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$strPos(_p178._0._0._0.start),
											A2(
												_elm_lang$core$Basics_ops['++'],
												' init expression not a record, but ',
												_user$project$LangUtils$valToString(_p182))));
								}
							});
					}
				};
				return computeResInitDictWidgets(
					F3(
						function (v, d, ws) {
							return A6(
								_user$project$Eval$evalDeclarations,
								options,
								syntax,
								env,
								bt_,
								_p158._2,
								F2(
									function (newEnv, widgets) {
										var ids = A2(
											_elm_lang$core$List$concatMap,
											function (_p183) {
												var _p184 = _p183;
												return _user$project$Lang$publicIdentifiersListIntPat(_p184._2);
											},
											_user$project$Lang$elemsOf(_p158._2._3));
										var kvs = _user$project$Lang$VRecord(
											A2(
												_elm_lang$core$Dict$union,
												_elm_lang$core$Dict$fromList(
													_elm_lang$core$Set$toList(
														A2(
															_elm_lang$core$Set$map,
															function (i) {
																return {
																	ctor: '_Tuple2',
																	_0: i,
																	_1: A2(
																		_user$project$Utils$fromOk,
																		'Record variable',
																		A5(
																			_user$project$Eval$lookupVar,
																			syntax,
																			newEnv,
																			{ctor: '::', _0: _p259, _1: bt},
																			i,
																			e_start))
																};
															},
															_elm_lang$core$Set$fromList(ids)))),
												d));
										return _user$project$Eval$evalReturn(
											A2(
												retBoth,
												A2(
													_elm_lang$core$Maybe$withDefault,
													{ctor: '[]'},
													A2(
														_elm_lang$core$Maybe$map,
														function (x) {
															return {
																ctor: '::',
																_0: x,
																_1: {ctor: '[]'}
															};
														},
														v)),
												{ctor: '_Tuple2', _0: kvs, _1: ws}));
									}));
						}));
			case 'ESelect':
				var _p198 = _p158._4;
				var _p197 = _p158._1;
				return A6(
					_user$project$Eval$evalContinue,
					options,
					syntax,
					env,
					bt_,
					_p197,
					function (_p185) {
						var _p186 = _p185;
						var _p196 = _p186._0._0;
						var _p187 = _p196.v_;
						if (_p187.ctor === 'VRecord') {
							var _p195 = _p187._0;
							var _p188 = A2(_elm_lang$core$Dict$get, _p198, _p195);
							if (_p188.ctor === 'Just') {
								var _p193 = _p188._0;
								var $default = function (_p189) {
									var _p190 = _p189;
									return _user$project$Eval$evalReturn(
										A2(
											retBoth,
											{
												ctor: '::',
												_0: _p196,
												_1: {ctor: '[]'}
											},
											{ctor: '_Tuple2', _0: _p193.v_, _1: _p186._0._1}));
								};
								var _p191 = _p193.v_;
								if ((_p191.ctor === 'VClosure') && (_p191._1.ctor === '::')) {
									var _p192 = _user$project$Lang$pVarUnapply(_p191._1._0);
									if ((_p192.ctor === 'Just') && (_p192._0 === 'this')) {
										return A5(
											_user$project$Eval$evalContext,
											options,
											syntax,
											{
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: 'this', _1: _p196},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 'recRecordMethod', _1: _p193},
													_1: {ctor: '[]'}
												}
											},
											bt,
											A2(
												_user$project$Lang$eApp,
												_user$project$Lang$eVar('recRecordMethod'),
												{
													ctor: '::',
													_0: _user$project$Lang$eVar('this'),
													_1: {ctor: '[]'}
												}));
									} else {
										return $default(
											{ctor: '_Tuple0'});
									}
								} else {
									return $default(
										{ctor: '_Tuple0'});
								}
							} else {
								var suggestions = A2(
									_user$project$Utils$stringSuggestions,
									_elm_lang$core$Dict$keys(_p195),
									_p198);
								return A3(
									_user$project$Eval$errorWithBacktrace,
									syntax,
									{ctor: '::', _0: _p197, _1: bt},
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$Lang$strPos(_p158._3.end),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' Key ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p198,
												A2(
													_elm_lang$core$Basics_ops['++'],
													' not found.',
													function () {
														var _p194 = suggestions;
														if (_p194.ctor === '[]') {
															return '';
														} else {
															return A2(
																_elm_lang$core$Basics_ops['++'],
																' Did you mean \'',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	A2(_elm_lang$core$String$join, '\', or \'', _p194),
																	'\'?'));
														}
													}())))));
							}
						} else {
							return A3(
								_user$project$Eval$errorWithBacktrace,
								syntax,
								{ctor: '::', _0: _p197, _1: bt},
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$strPos(_p158._1._0.start),
									' select expression applied to non-dict '));
						}
					});
			case 'EIf':
				return A6(
					_user$project$Eval$evalContinue,
					options,
					syntax,
					env,
					bt,
					_p158._1,
					function (_p199) {
						var _p200 = _p199;
						var afterEval = function (_p201) {
							var _p202 = _p201;
							return _user$project$Eval$evalReturn(
								A2(
									addProvenanceToRet,
									{
										ctor: '::',
										_0: _p202._0._0,
										_1: {ctor: '[]'}
									},
									A2(addWidgets, _p200._0._1, _p202)));
						};
						var _p203 = _p200._0._0.v_;
						if ((_p203.ctor === 'VBase') && (_p203._0.ctor === 'VBool')) {
							if (_p203._0._0 === true) {
								return A6(_user$project$Eval$evalContinue, options, syntax, env, bt, _p158._3, afterEval);
							} else {
								return A6(_user$project$Eval$evalContinue, options, syntax, env, bt, _p158._5, afterEval);
							}
						} else {
							return A3(
								_user$project$Eval$errorWithBacktrace,
								syntax,
								{ctor: '::', _0: _p259, _1: bt},
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Lang$strPos(_p158._1._0.start),
									' if-exp expected a Bool but got something else.'));
						}
					});
			case 'ECase':
				return A6(
					_user$project$Eval$evalContinue,
					options,
					syntax,
					env,
					{ctor: '::', _0: _p259, _1: bt},
					_p158._1,
					function (_p204) {
						var _p205 = _p204;
						var _p211 = _p205._0._0;
						return A8(
							_user$project$Eval$evalBranches,
							options,
							syntax,
							env,
							{ctor: '::', _0: _p259, _1: bt},
							_p211,
							_p158._2,
							function (_p206) {
								var _p207 = _p206;
								return A3(
									_user$project$Eval$errorWithBacktrace,
									syntax,
									{ctor: '::', _0: _p259, _1: bt},
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$Lang$strPos(_p158._1._0.start),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' non-exhaustive case statement, cannot match ',
											_user$project$LangUtils$valToString(_p211))));
							},
							function (_p208) {
								var _p209 = _p208;
								var _p210 = _p209._0._0;
								return _user$project$Eval$evalReturn(
									A2(
										retVBoth,
										{
											ctor: '::',
											_0: _p210,
											_1: {ctor: '[]'}
										},
										{
											ctor: '_Tuple2',
											_0: _p210,
											_1: A2(_elm_lang$core$Basics_ops['++'], _p205._0._1, _p209._0._1)
										}));
							});
					});
			case 'EApp':
				var _p245 = _p158._0;
				var _p244 = _p158._1._0;
				var _p243 = _p158._2;
				var e1 = _user$project$Lang$Expr(_p244);
				if (_elm_lang$core$Native_Utils.eq(_p158._3, _user$project$Lang$InfixApp) && _elm_lang$core$Native_Utils.eq(
					_user$project$Lang$eVarUnapply(e1),
					_elm_lang$core$Maybe$Just('++'))) {
					var _p212 = _p243;
					if (((_p212.ctor === '::') && (_p212._1.ctor === '::')) && (_p212._1._1.ctor === '[]')) {
						var _p221 = _p212._1._0;
						var _p220 = _p212._0;
						return A6(
							_user$project$Eval$evalContinue,
							options,
							syntax,
							env,
							bt_,
							_p220,
							function (_p213) {
								var _p214 = _p213;
								var _p219 = _p214._0._0;
								return A6(
									_user$project$Eval$evalContinue,
									options,
									syntax,
									env,
									bt_,
									_p221,
									function (_p215) {
										var _p216 = _p215;
										var _p218 = _p216._0._0;
										var _p217 = {ctor: '_Tuple2', _0: _p219.v_, _1: _p218.v_};
										if (((((_p217.ctor === '_Tuple2') && (_p217._0.ctor === 'VBase')) && (_p217._0._0.ctor === 'VString')) && (_p217._1.ctor === 'VBase')) && (_p217._1._0.ctor === 'VString')) {
											return A5(
												_user$project$Eval$evalContext,
												options,
												syntax,
												A2(
													_elm_lang$core$Basics_ops['++'],
													{
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: 'x', _1: _p219},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: 'y', _1: _p218},
															_1: {ctor: '[]'}
														}
													},
													env),
												bt_,
												A2(
													_user$project$Lang$replaceE__,
													_p259,
													A5(
														_user$project$Lang$EOp,
														_user$project$Lang$space1,
														_user$project$Lang$space1,
														_user$project$Lang$withDummyRange(_user$project$Lang$Plus),
														{
															ctor: '::',
															_0: A2(
																_user$project$Lang$replaceE__,
																_p220,
																A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'x')),
															_1: {
																ctor: '::',
																_0: A2(
																	_user$project$Lang$replaceE__,
																	_p221,
																	A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'y')),
																_1: {ctor: '[]'}
															}
														},
														_user$project$Lang$space0)));
										} else {
											return A5(
												_user$project$Eval$evalContext,
												options,
												syntax,
												A2(
													_elm_lang$core$Basics_ops['++'],
													{
														ctor: '::',
														_0: {ctor: '_Tuple2', _0: 'x', _1: _p219},
														_1: {
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: 'y', _1: _p218},
															_1: {ctor: '[]'}
														}
													},
													env),
												bt_,
												A2(
													_user$project$Lang$replaceE__,
													_p259,
													A5(
														_user$project$Lang$EApp,
														_p245,
														A2(
															_user$project$Lang$replaceE__,
															e1,
															A2(_user$project$Lang$EVar, _p245, 'append')),
														{
															ctor: '::',
															_0: A2(
																_user$project$Lang$replaceE__,
																_p220,
																A2(_user$project$Lang$EVar, _user$project$Lang$space1, 'x')),
															_1: {
																ctor: '::',
																_0: A2(
																	_user$project$Lang$replaceE__,
																	_p221,
																	A2(_user$project$Lang$EVar, _user$project$Lang$space1, 'y')),
																_1: {ctor: '[]'}
															}
														},
														_user$project$Lang$SpaceApp,
														_p158._4)));
										}
									});
							});
					} else {
						return _user$project$Eval$EvalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'++ should be called with two arguments, was called on ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(
										_elm_lang$core$List$length(_p243)),
									'. ')));
					}
				} else {
					return A6(
						_user$project$Eval$evalContinue,
						options,
						syntax,
						env,
						bt_,
						e1,
						function (_p222) {
							var _p223 = _p222;
							var evalVApp = F3(
								function (v1, ws, es) {
									evalVApp:
									while (true) {
										var _p224 = v1.v_;
										switch (_p224.ctor) {
											case 'VClosure':
												var _p229 = _p224._2;
												return _user$project$Eval$apply(options)(syntax)(env)(bt)(bt_)(_p259)(_p224._1)(es)(_p229)(
													A2(_user$project$Lang$expandRecEnv, _p224._0, _p224._3))(
													F2(
														function (argVals, _p225) {
															var _p226 = _p225;
															var _p228 = _p226._0._1;
															var _p227 = _p226._0._0;
															var perhapsCallWidget = (options.recordWidgets && (_user$project$LeoParser$isProgramEId(
																_user$project$Lang$expEId(_p259)) && _user$project$LeoParser$isProgramEId(
																_user$project$Lang$expEId(_p229)))) ? {
																ctor: '::',
																_0: A4(_user$project$Lang$WCall, v1, argVals, _p227, _p228),
																_1: {ctor: '[]'}
															} : {ctor: '[]'};
															return _user$project$Eval$evalReturn(
																A2(
																	retVBoth,
																	{
																		ctor: '::',
																		_0: _p227,
																		_1: {ctor: '[]'}
																	},
																	{
																		ctor: '_Tuple2',
																		_0: _p227,
																		_1: A2(
																			_elm_lang$core$Basics_ops['++'],
																			_p223._0._1,
																			A2(_elm_lang$core$Basics_ops['++'], _p228, perhapsCallWidget))
																	}));
														}));
											case 'VFun':
												var _p237 = _p224._0;
												var _p236 = _p224._1;
												var availableArgs = _elm_lang$core$List$length(es);
												var arity = _elm_lang$core$List$length(_p236);
												if (_elm_lang$core$Native_Utils.cmp(availableArgs, arity) < 0) {
													var funconverted = A2(
														_user$project$Lang$replaceV_,
														v1,
														A4(
															_user$project$Lang$VClosure,
															{ctor: '[]'},
															A2(
																_elm_lang$core$List$map,
																function (a) {
																	return _user$project$Lang$withDummyPatInfo(
																		A3(_user$project$Lang$PVar, _user$project$Lang$space1, a, _user$project$Lang$noWidgetDecl));
																},
																_p236),
															A2(
																_user$project$Lang$replaceE__,
																_p259,
																A5(
																	_user$project$Lang$EApp,
																	_p245,
																	A2(
																		_user$project$Lang$replaceE__,
																		_p259,
																		A2(_user$project$Lang$EVar, _user$project$Lang$space1, _p237)),
																	A2(
																		_elm_lang$core$List$map,
																		function (_p230) {
																			return _user$project$Lang$withDummyExpInfo(
																				A2(_user$project$Lang$EVar, _user$project$Lang$space1, _p230));
																		},
																		_p236),
																	_user$project$Lang$SpaceApp,
																	_p245)),
															{
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: _p237, _1: v1},
																_1: env
															}));
													var _v119 = funconverted,
														_v120 = ws,
														_v121 = es;
													v1 = _v119;
													ws = _v120;
													es = _v121;
													continue evalVApp;
												} else {
													var _p231 = A2(_user$project$Utils$split, arity, es);
													var $arguments = _p231._0;
													var remaining = _p231._1;
													var aux = F3(
														function ($arguments, revArgVals, revArgWidgets) {
															var _p232 = $arguments;
															if (_p232.ctor === '::') {
																return A6(
																	_user$project$Eval$evalContinue,
																	options,
																	syntax,
																	env,
																	bt_,
																	_p232._0,
																	function (_p233) {
																		var _p234 = _p233;
																		return A3(
																			aux,
																			_p232._1,
																			{ctor: '::', _0: _p234._0._0, _1: revArgVals},
																			A2(_user$project$Utils$reverseInsert, _p234._0._1, revArgWidgets));
																	});
															} else {
																var argumentsVal = _elm_lang$core$List$reverse(revArgVals);
																var basicResult = _p224._2(argumentsVal);
																var _p235 = basicResult;
																if (_p235.ctor === 'Err') {
																	return A3(_user$project$Eval$errorWithBacktrace, syntax, bt_, _p235._0);
																} else {
																	return (_elm_lang$core$Native_Utils.cmp(
																		_elm_lang$core$List$length(remaining),
																		0) > 0) ? A3(
																		evalVApp,
																		_p235._0._0,
																		_elm_lang$core$List$reverse(
																			A2(_user$project$Utils$reverseInsert, _p235._0._1, revArgWidgets)),
																		remaining) : _user$project$Eval$evalReturn(
																		{ctor: '_Tuple2', _0: _p235._0, _1: env});
																}
															}
														});
													return A3(
														aux,
														$arguments,
														{ctor: '[]'},
														_elm_lang$core$List$reverse(ws));
												}
											case 'VRecord':
												var _p238 = {
													ctor: '_Tuple2',
													_0: A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorDataType, v1),
													_1: A2(
														_elm_lang$core$Maybe$andThen,
														_user$project$Lang$vRecordUnapply,
														A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorArgs, v1))
												};
												if (((_p238.ctor === '_Tuple2') && (_p238._0.ctor === 'Just')) && (_p238._1.ctor === 'Just')) {
													var _p242 = _p238._1._0;
													var positionArgToAdd = _elm_lang$core$Dict$size(_p242) + 1;
													var aux = F4(
														function (n, $arguments, newArgs, revArgWidgets) {
															var _p239 = $arguments;
															if (_p239.ctor === '::') {
																return A6(
																	_user$project$Eval$evalContinue,
																	options,
																	syntax,
																	env,
																	bt_,
																	_p239._0,
																	function (_p240) {
																		var _p241 = _p240;
																		return A4(
																			aux,
																			n + 1,
																			_p239._1,
																			A3(
																				_elm_lang$core$Dict$insert,
																				_user$project$Lang$argName(n),
																				_p241._0._0,
																				newArgs),
																			A2(_user$project$Utils$reverseInsert, _p241._0._1, revArgWidgets));
																	});
															} else {
																var basicResult = A2(
																	_user$project$Lang$replaceV_,
																	v1,
																	_user$project$Lang$VRecord(
																		A3(
																			_elm_lang$core$Dict$insert,
																			_user$project$Lang$ctorArgs,
																			A2(
																				_user$project$Lang$replaceV_,
																				v1,
																				_user$project$Lang$VRecord(newArgs)),
																			_p224._0)));
																var vw = {
																	ctor: '_Tuple2',
																	_0: basicResult,
																	_1: _elm_lang$core$List$reverse(revArgWidgets)
																};
																return _user$project$Eval$evalReturn(
																	{ctor: '_Tuple2', _0: vw, _1: env});
															}
														});
													return A4(
														aux,
														positionArgToAdd,
														es,
														_p242,
														_elm_lang$core$List$reverse(ws));
												} else {
													return A3(
														_user$project$Eval$errorWithBacktrace,
														syntax,
														{ctor: '::', _0: _p259, _1: bt},
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$Lang$strPos(_p244.start),
															' not a function or a partially applied datatype'));
												}
											default:
												return A3(
													_user$project$Eval$errorWithBacktrace,
													syntax,
													{ctor: '::', _0: _p259, _1: bt},
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$Lang$strPos(_p244.start),
														' not a function or a partially applied datatype'));
										}
									}
								});
							return A3(
								evalVApp,
								_p223._0._0,
								{ctor: '[]'},
								_p243);
						});
				}
			case 'ELet':
				return A6(
					_user$project$Eval$evalDeclarations,
					options,
					syntax,
					env,
					bt_,
					_p158._2,
					F2(
						function (newEnv, widgets) {
							return A6(
								_user$project$Eval$evalContinue,
								options,
								syntax,
								newEnv,
								bt_,
								_p158._4,
								function (result) {
									return _user$project$Eval$evalReturn(
										A2(addWidgets, widgets, result));
								});
						}));
			case 'EColonType':
				var _p257 = _p158._1;
				var _p246 = _p158._3.val.t__;
				if ((_p246.ctor === 'TVar') && (_p246._1 === 'Point')) {
					return A6(
						_user$project$Eval$evalContinue,
						options,
						syntax,
						env,
						bt,
						_p257,
						function (_p247) {
							var _p248 = _p247;
							var _p256 = _p248._0._0;
							var _p255 = _p248;
							if (options.recordWidgets) {
								var _p249 = _p256.v_;
								if ((((_p249.ctor === 'VList') && (_p249._0.ctor === '::')) && (_p249._0._1.ctor === '::')) && (_p249._0._1._1.ctor === '[]')) {
									var _p254 = _p249._0._1._0;
									var _p253 = _p249._0._0;
									var _p250 = {ctor: '_Tuple2', _0: _p253.v_, _1: _p254.v_};
									if (((_p250.ctor === '_Tuple2') && (_p250._0.ctor === 'VConst')) && (_p250._1.ctor === 'VConst')) {
										var _p252 = _p250._1._1;
										var _p251 = _p250._0._1;
										var vNew = _elm_lang$core$Native_Utils.update(
											_p256,
											{
												v_: _user$project$Lang$VList(
													{
														ctor: '::',
														_0: _elm_lang$core$Native_Utils.update(
															_p253,
															{
																v_: A2(
																	_user$project$Lang$VConst,
																	_elm_lang$core$Maybe$Just(
																		{ctor: '_Tuple3', _0: _user$project$Lang$X, _1: _p252, _2: _p254}),
																	_p251)
															}),
														_1: {
															ctor: '::',
															_0: _elm_lang$core$Native_Utils.update(
																_p254,
																{
																	v_: A2(
																		_user$project$Lang$VConst,
																		_elm_lang$core$Maybe$Just(
																			{ctor: '_Tuple3', _0: _user$project$Lang$Y, _1: _p251, _2: _p253}),
																		_p252)
																}),
															_1: {ctor: '[]'}
														}
													})
											});
										return _user$project$Eval$evalReturn(
											{
												ctor: '_Tuple2',
												_0: {
													ctor: '_Tuple2',
													_0: vNew,
													_1: A2(
														_elm_lang$core$Basics_ops['++'],
														_p248._0._1,
														{
															ctor: '::',
															_0: A4(_user$project$Lang$WPoint, _p251, _p253, _p252, _p254),
															_1: {ctor: '[]'}
														})
												},
												_1: _p248._1
											});
									} else {
										return _user$project$Eval$evalReturn(_p255);
									}
								} else {
									return _user$project$Eval$evalReturn(_p255);
								}
							} else {
								return _user$project$Eval$evalReturn(_p255);
							}
						});
				} else {
					return A5(_user$project$Eval$evalContext, options, syntax, env, bt, _p257);
				}
			case 'EParens':
				return A5(_user$project$Eval$evalContext, options, syntax, env, bt, _p158._1);
			default:
				if (_p158._1.ctor === 'ESnapHole') {
					var _p258 = _p158._1._0;
					return _user$project$Eval$evalReturn(
						A2(
							retV,
							{
								ctor: '::',
								_0: _p258,
								_1: {ctor: '[]'}
							},
							_p258));
				} else {
					return A3(
						_user$project$Eval$errorWithBacktrace,
						syntax,
						{ctor: '::', _0: _p259, _1: bt},
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$Lang$strPos(e_start),
							' empty hole!'));
				}
		}
	});
var _user$project$Eval$eval = F2(
	function (callbacks, currentStack) {
		$eval:
		while (true) {
			var _p260 = currentStack;
			switch (_p260.ctor) {
				case 'EvalError':
					return _elm_lang$core$Result$Err(_p260._0);
				case 'EvalReturn':
					var _p262 = _p260._0;
					var _p261 = A2(_user$project$Utils$maybeCons, _p260._1, callbacks);
					if (_p261.ctor === '[]') {
						return _elm_lang$core$Result$Ok(_p262);
					} else {
						var _v134 = _p261._1,
							_v135 = _p261._0(_p262);
						callbacks = _v134;
						currentStack = _v135;
						continue $eval;
					}
				default:
					var _v136 = A2(_user$project$Utils$maybeCons, _p260._5, callbacks),
						_v137 = A5(_user$project$Eval$getEvalStack, _p260._0, _p260._1, _p260._2, _p260._3, _p260._4);
					callbacks = _v136;
					currentStack = _v137;
					continue $eval;
			}
		}
	});
var _user$project$Eval$doEval = F4(
	function (options, syntax, env, e) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p263) {
				var _p264 = _p263;
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: _p264._0._0,
						_1: _user$project$Eval$postProcessWidgets(_p264._0._1)
					},
					_1: _p264._1
				};
			},
			A2(
				_user$project$Eval$eval,
				{ctor: '[]'},
				A5(
					_user$project$Eval$evalContext,
					options,
					syntax,
					env,
					{ctor: '[]'},
					e)));
	});
var _user$project$Eval$eval_ = F5(
	function (options, syntax, env, bt, e) {
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			A2(
				_user$project$Eval$eval,
				{ctor: '[]'},
				A5(_user$project$Eval$evalContext, options, syntax, env, bt, e)));
	});

var _user$project$Native_MissingNumberMethods = {
  exp: Math.exp,
  power: function(a) { return function(b) { return Math.pow(a, b); }},
  modulo: function(a) { return function(b) { return a % b; }},
};
var _user$project$MissingNumberMethods_ops = _user$project$MissingNumberMethods_ops || {};
_user$project$MissingNumberMethods_ops['%%'] = F2(
	function (a, b) {
		return A2(_user$project$Native_MissingNumberMethods.modulo, a, b);
	});
var _user$project$MissingNumberMethods_ops = _user$project$MissingNumberMethods_ops || {};
_user$project$MissingNumberMethods_ops['**'] = F2(
	function (a, b) {
		return A2(_user$project$Native_MissingNumberMethods.power, a, b);
	});
var _user$project$MissingNumberMethods$exp = function (a) {
	return _user$project$Native_MissingNumberMethods.exp(a);
};

var _user$project$LangSvg$fetchMovieFrameVal = F5(
	function (syntax, slideNumber, movieNumber, movieTime, movieVal) {
		var _p0 = _user$project$Lang$unwrapVList(movieVal);
		_v0_2:
		do {
			if (((((_p0.ctor === 'Just') && (_p0._0.ctor === '::')) && (_p0._0._0.ctor === 'VBase')) && (_p0._0._0._0.ctor === 'VString')) && (_p0._0._1.ctor === '::')) {
				if (_p0._0._1._1.ctor === '[]') {
					if ((_p0._0._0._0._0 === 'Static') && (_p0._0._1._0.ctor === 'VClosure')) {
						var getFrameValClosure = A2(
							_user$project$Utils$geti,
							2,
							A2(_user$project$Lang$vListToVals, 'fetchMovieFrameVal1', movieVal));
						return A2(
							_elm_lang$core$Result$map,
							function (_p1) {
								var _p2 = _p1;
								return _p2._0._0;
							},
							A4(
								_user$project$Eval$doEval,
								_user$project$Eval$withParentsProvenanceWidgets,
								syntax,
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: 'getFrameVal', _1: getFrameValClosure},
									_1: {ctor: '[]'}
								},
								A2(
									_user$project$Lang$eCall,
									'getFrameVal',
									{
										ctor: '::',
										_0: _user$project$Lang$eConstDummyLoc(
											_elm_lang$core$Basics$toFloat(slideNumber)),
										_1: {
											ctor: '::',
											_0: _user$project$Lang$eConstDummyLoc(
												_elm_lang$core$Basics$toFloat(movieNumber)),
											_1: {ctor: '[]'}
										}
									})));
					} else {
						break _v0_2;
					}
				} else {
					if ((((((((_p0._0._0._0._0 === 'Dynamic') && (_p0._0._1._0.ctor === 'VConst')) && (_p0._0._1._0._1.ctor === '_Tuple2')) && (_p0._0._1._1._0.ctor === 'VClosure')) && (_p0._0._1._1._1.ctor === '::')) && (_p0._0._1._1._1._0.ctor === 'VBase')) && (_p0._0._1._1._1._0._0.ctor === 'VBool')) && (_p0._0._1._1._1._1.ctor === '[]')) {
						var getFrameValClosure = A2(
							_user$project$Utils$geti,
							3,
							A2(_user$project$Lang$vListToVals, 'fetchMovieFrameVal2', movieVal));
						return A2(
							_elm_lang$core$Result$map,
							function (_p3) {
								var _p4 = _p3;
								return _p4._0._0;
							},
							A4(
								_user$project$Eval$doEval,
								_user$project$Eval$withParentsProvenanceWidgets,
								syntax,
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: 'getFrameVal', _1: getFrameValClosure},
									_1: {ctor: '[]'}
								},
								A2(
									_user$project$Lang$eCall,
									'getFrameVal',
									{
										ctor: '::',
										_0: _user$project$Lang$eConstDummyLoc(
											_elm_lang$core$Basics$toFloat(slideNumber)),
										_1: {
											ctor: '::',
											_0: _user$project$Lang$eConstDummyLoc(
												_elm_lang$core$Basics$toFloat(movieNumber)),
											_1: {
												ctor: '::',
												_0: _user$project$Lang$eConstDummyLoc(movieTime),
												_1: {ctor: '[]'}
											}
										}
									})));
					} else {
						break _v0_2;
					}
				}
			} else {
				break _v0_2;
			}
		} while(false);
		return _elm_lang$core$Result$Ok(movieVal);
	});
var _user$project$LangSvg$fetchMovieDurationAndContinueBool = function (movieVal) {
	var _p5 = _user$project$Lang$unwrapVList(movieVal);
	_v3_2:
	do {
		if (((((_p5.ctor === 'Just') && (_p5._0.ctor === '::')) && (_p5._0._0.ctor === 'VBase')) && (_p5._0._0._0.ctor === 'VString')) && (_p5._0._1.ctor === '::')) {
			if (_p5._0._1._1.ctor === '[]') {
				if ((_p5._0._0._0._0 === 'Static') && (_p5._0._1._0.ctor === 'VClosure')) {
					return {ctor: '_Tuple2', _0: 0.0, _1: false};
				} else {
					break _v3_2;
				}
			} else {
				if ((((((((_p5._0._0._0._0 === 'Dynamic') && (_p5._0._1._0.ctor === 'VConst')) && (_p5._0._1._0._1.ctor === '_Tuple2')) && (_p5._0._1._1._0.ctor === 'VClosure')) && (_p5._0._1._1._1.ctor === '::')) && (_p5._0._1._1._1._0.ctor === 'VBase')) && (_p5._0._1._1._1._0._0.ctor === 'VBool')) && (_p5._0._1._1._1._1.ctor === '[]')) {
					return {ctor: '_Tuple2', _0: _p5._0._1._0._1._0, _1: _p5._0._1._1._1._0._0._0};
				} else {
					break _v3_2;
				}
			}
		} else {
			break _v3_2;
		}
	} while(false);
	return {ctor: '_Tuple2', _0: 0.0, _1: false};
};
var _user$project$LangSvg$fetchMovieCount = function (slideVal) {
	var _p6 = _user$project$Lang$unwrapVList(slideVal);
	if ((((((_p6.ctor === 'Just') && (_p6._0.ctor === '::')) && (_p6._0._0.ctor === 'VConst')) && (_p6._0._0._1.ctor === '_Tuple2')) && (_p6._0._1.ctor === '::')) && (_p6._0._1._1.ctor === '[]')) {
		return _elm_lang$core$Basics$round(_p6._0._0._1._0);
	} else {
		return 1;
	}
};
var _user$project$LangSvg$fetchSlideCount = function (val) {
	var _p7 = _user$project$Lang$unwrapVList(val);
	if ((((((_p7.ctor === 'Just') && (_p7._0.ctor === '::')) && (_p7._0._0.ctor === 'VConst')) && (_p7._0._0._1.ctor === '_Tuple2')) && (_p7._0._1.ctor === '::')) && (_p7._0._1._1.ctor === '[]')) {
		return _elm_lang$core$Basics$round(_p7._0._0._1._0);
	} else {
		return 1;
	}
};
var _user$project$LangSvg$vNumFrozen = function (n) {
	return {
		v_: A2(
			_user$project$Lang$VConst,
			_elm_lang$core$Maybe$Nothing,
			{
				ctor: '_Tuple2',
				_0: n,
				_1: _user$project$Lang$TrLoc(
					{
						ctor: '_Tuple3',
						_0: -999,
						_1: _user$project$Lang$frozen,
						_2: _elm_lang$core$Basics$toString(n)
					})
			}),
		provenance: A3(
			_user$project$Lang$Provenance,
			{ctor: '[]'},
			_user$project$Lang$eConstDummyLoc0(n),
			{ctor: '[]'}),
		parents: _user$project$Lang$Parents(
			{ctor: '[]'})
	};
};
var _user$project$LangSvg$vIntFrozen = function (i) {
	return _user$project$LangSvg$vNumFrozen(
		_elm_lang$core$Basics$toFloat(i));
};
var _user$project$LangSvg$fetchSlideVal = F3(
	function (syntax, slideNumber, val) {
		var _p8 = _user$project$Lang$unwrapVList(val);
		if (((((((((_p8.ctor === 'Just') && (_p8._0.ctor === '::')) && (_p8._0._0.ctor === 'VConst')) && (_p8._0._0._1.ctor === '_Tuple2')) && (_p8._0._1.ctor === '::')) && (_p8._0._1._0.ctor === 'VClosure')) && (_p8._0._1._0._1.ctor === '::')) && (_p8._0._1._0._1._1.ctor === '[]')) && (_p8._0._1._1.ctor === '[]')) {
			var _p12 = _p8._0._1._0._1._0;
			var _p9 = _p12.val.p__;
			if (_p9.ctor === 'PVar') {
				var fenv_ = {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: _p9._1,
						_1: _user$project$LangSvg$vIntFrozen(slideNumber)
					},
					_1: _p8._0._1._0._3
				};
				return A2(
					_elm_lang$core$Result$map,
					function (_p10) {
						var _p11 = _p10;
						return _p11._0._0;
					},
					A4(_user$project$Eval$doEval, _user$project$Eval$withParentsProvenanceWidgets, syntax, fenv_, _p8._0._1._0._2));
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'expected slide function to take a single argument, got ',
						_elm_lang$core$Basics$toString(_p12.val.p__)));
			}
		} else {
			return _elm_lang$core$Result$Ok(val);
		}
	});
var _user$project$LangSvg$resolveToMovieCount = F3(
	function (syntax, slideNumber, val) {
		return A2(
			_elm_lang$core$Result$map,
			_user$project$LangSvg$fetchMovieCount,
			A3(_user$project$LangSvg$fetchSlideVal, syntax, slideNumber, val));
	});
var _user$project$LangSvg$fetchMovieVal = F3(
	function (syntax, movieNumber, slideVal) {
		var _p13 = _user$project$Lang$unwrapVList(slideVal);
		if (((((((((_p13.ctor === 'Just') && (_p13._0.ctor === '::')) && (_p13._0._0.ctor === 'VConst')) && (_p13._0._0._1.ctor === '_Tuple2')) && (_p13._0._1.ctor === '::')) && (_p13._0._1._0.ctor === 'VClosure')) && (_p13._0._1._0._1.ctor === '::')) && (_p13._0._1._0._1._1.ctor === '[]')) && (_p13._0._1._1.ctor === '[]')) {
			var _p17 = _p13._0._1._0._1._0;
			var _p14 = _p17.val.p__;
			if (_p14.ctor === 'PVar') {
				var fenv_ = {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: _p14._1,
						_1: _user$project$LangSvg$vIntFrozen(movieNumber)
					},
					_1: _p13._0._1._0._3
				};
				return A2(
					_elm_lang$core$Result$map,
					function (_p15) {
						var _p16 = _p15;
						return _p16._0._0;
					},
					A4(_user$project$Eval$doEval, _user$project$Eval$withParentsProvenanceWidgets, syntax, fenv_, _p13._0._1._0._2));
			} else {
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'expected movie function to take a single argument, got ',
						_elm_lang$core$Basics$toString(_p17.val.p__)));
			}
		} else {
			return _elm_lang$core$Result$Ok(slideVal);
		}
	});
var _user$project$LangSvg$fetchEverything_ = F5(
	function (syntax, slideNumber, movieNumber, movieTime, val) {
		var slideCount = _user$project$LangSvg$fetchSlideCount(val);
		return A2(
			_elm_lang$core$Result$andThen,
			function (slideVal) {
				var movieCount = _user$project$LangSvg$fetchMovieCount(slideVal);
				return A2(
					_elm_lang$core$Result$andThen,
					function (movieVal) {
						var _p18 = _user$project$LangSvg$fetchMovieDurationAndContinueBool(movieVal);
						var movieDuration = _p18._0;
						var $continue = _p18._1;
						return A2(
							_elm_lang$core$Result$map,
							function (movieFrameVal) {
								return {ctor: '_Tuple5', _0: slideCount, _1: movieCount, _2: movieDuration, _3: $continue, _4: movieFrameVal};
							},
							A5(_user$project$LangSvg$fetchMovieFrameVal, syntax, slideNumber, movieNumber, movieTime, movieVal));
					},
					A3(_user$project$LangSvg$fetchMovieVal, syntax, movieNumber, slideVal));
			},
			A3(_user$project$LangSvg$fetchSlideVal, syntax, slideNumber, val));
	});
var _user$project$LangSvg$resolveToMovieFrameVal = F5(
	function (syntax, slideNumber, movieNumber, movieTime, val) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p19) {
				var _p20 = _p19;
				return _p20._4;
			},
			A5(_user$project$LangSvg$fetchEverything_, syntax, slideNumber, movieNumber, movieTime, val));
	});
var _user$project$LangSvg$foldSlate = F3(
	function (_p21, acc, f) {
		var _p22 = _p21;
		var foldNode = F2(
			function (i, acc) {
				var node = A3(_user$project$Utils$justGet_, 'foldSlate', i, _p22._1);
				var _p23 = node.interpreted;
				if (_p23.ctor === 'TextNode') {
					return A3(f, i, node, acc);
				} else {
					return A3(
						f,
						i,
						node,
						A3(_elm_lang$core$List$foldl, foldNode, acc, _p23._2));
				}
			});
		return A2(foldNode, _p22._0, acc);
	});
var _user$project$LangSvg$foldSlateNodeInfo = F3(
	function (slate, acc, f) {
		return A3(
			_user$project$LangSvg$foldSlate,
			slate,
			acc,
			F2(
				function (i, node) {
					var _p24 = node.interpreted;
					if (_p24.ctor === 'TextNode') {
						return f(
							_user$project$Either$Left(
								{ctor: '_Tuple2', _0: i, _1: _p24._0}));
					} else {
						return f(
							_user$project$Either$Right(
								{ctor: '_Tuple3', _0: i, _1: _p24._0, _2: _p24._1}));
					}
				}));
	});
var _user$project$LangSvg$childNodeIds = function (node) {
	var _p25 = node.interpreted;
	if (_p25.ctor === 'SvgNode') {
		return _p25._2;
	} else {
		return {ctor: '[]'};
	}
};
var _user$project$LangSvg$descendantNodeIds = F2(
	function (indexedTree, node) {
		var childIds = _user$project$LangSvg$childNodeIds(node);
		var deeperIds = A2(
			_elm_lang$core$List$concatMap,
			_user$project$LangSvg$descendantNodeIds(indexedTree),
			A2(
				_elm_lang$core$List$filterMap,
				function (nodeId) {
					return A2(_elm_lang$core$Dict$get, nodeId, indexedTree);
				},
				childIds));
		return A2(_elm_lang$core$Basics_ops['++'], childIds, deeperIds);
	});
var _user$project$LangSvg$maybeGetSvgNode = F2(
	function (nodeId, _p26) {
		var _p27 = _p26;
		var _p28 = A2(
			_elm_lang$core$Maybe$map,
			function (_) {
				return _.interpreted;
			},
			A2(_elm_lang$core$Dict$get, nodeId, _p27._1));
		if ((_p28.ctor === 'Just') && (_p28._0.ctor === 'SvgNode')) {
			return _elm_lang$core$Maybe$Just(
				{ctor: '_Tuple3', _0: _p28._0._0, _1: _p28._0._1, _2: _p28._0._2});
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$LangSvg$justGetSvgNode = F3(
	function (cap, nodeId, slate) {
		return A2(
			_user$project$Utils$fromJust_,
			A2(_elm_lang$core$Basics_ops['++'], 'justGetSvgNode: ', cap),
			A2(_user$project$LangSvg$maybeGetSvgNode, nodeId, slate));
	});
var _user$project$LangSvg$maybeFindBounds = function (l) {
	var _p29 = A2(_user$project$Utils$maybeFind, 'BOUNDS', l);
	if (_p29.ctor === 'Nothing') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		var roundBounds = true;
		var _p30 = {ctor: '_Tuple2', _0: _p29._0.interpreted, _1: roundBounds};
		_v20_2:
		do {
			if ((_p30.ctor === '_Tuple2') && (_p30._0.ctor === 'ABounds')) {
				if (_p30._1 === false) {
					return _elm_lang$core$Maybe$Just(_p30._0._0);
				} else {
					if (_p30._0._0.ctor === '_Tuple4') {
						var f = _elm_lang$core$Tuple$mapFirst(
							function (_p31) {
								return _elm_lang$core$Basics$toFloat(
									_elm_lang$core$Basics$round(_p31));
							});
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple4',
								_0: f(_p30._0._0._0),
								_1: f(_p30._0._0._1),
								_2: f(_p30._0._0._2),
								_3: f(_p30._0._0._3)
							});
					} else {
						break _v20_2;
					}
				}
			} else {
				break _v20_2;
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangSvg$maybeFindBlobId = function (l) {
	var _p32 = A2(_user$project$Utils$maybeFind, 'BLOB', l);
	if (_p32.ctor === 'Nothing') {
		return _elm_lang$core$Maybe$Nothing;
	} else {
		var _p33 = _p32._0.interpreted;
		if (_p33.ctor === 'AString') {
			return _elm_lang$core$Maybe$Just(
				_user$project$Utils$parseInt(_p33._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	}
};
var _user$project$LangSvg$findAVal = F2(
	function (attr, attrs) {
		var _p34 = A2(_user$project$Utils$maybeFind, attr, attrs);
		if (_p34.ctor === 'Just') {
			return _p34._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'LangSvg',
				{
					start: {line: 847, column: 3},
					end: {line: 849, column: 53}
				},
				_p34)(
				A2(_elm_lang$core$Basics_ops['++'], 'findAVal: ', attr));
		}
	});
var _user$project$LangSvg$aVal = function (av_) {
	return {
		interpreted: av_,
		val: {
			v_: _user$project$Lang$VList(
				{ctor: '[]'}),
			provenance: _user$project$Lang$dummyProvenance,
			parents: _user$project$Lang$Parents(
				{ctor: '[]'})
		}
	};
};
var _user$project$LangSvg$unescapeStyleScript = F2(
	function (kind, childrenRawStr) {
		var _p36 = kind;
		switch (_p36) {
			case 'style':
				return A2(
					_elm_lang$core$String$join,
					'>',
					A2(_elm_lang$core$String$split, '&gt;', childrenRawStr));
			case 'script':
				return A2(
					_elm_lang$core$String$join,
					'&',
					A2(
						_elm_lang$core$String$split,
						'&amp;',
						A2(
							_elm_lang$core$String$join,
							'<',
							A2(
								_elm_lang$core$String$split,
								'&lt;',
								A2(
									_elm_lang$core$String$join,
									'>',
									A2(_elm_lang$core$String$split, '&gt;', childrenRawStr))))));
			default:
				return childrenRawStr;
		}
	});
var _user$project$LangSvg$htmlSourceToVal = F2(
	function (namespace, source) {
		return A2(
			_elm_lang$core$Result$map,
			_user$project$HTMLValParser$htmlNodeToElmViewInLeo(
				_user$project$Lang$builtinVal('LangSvg')),
			A2(
				_elm_lang$core$Result$mapError,
				_user$project$ParserUtils$showError,
				A2(
					_MikaelMayer$parser$Parser$run,
					A3(
						_user$project$HTMLParser$parseNode,
						_user$project$HTMLParser$Raw,
						{ctor: '[]'},
						namespace),
					source)));
	});
var _user$project$LangSvg$getBoundsAttrs = function (attrs0) {
	return A2(
		_elm_lang$core$Maybe$andThen,
		function (_p37) {
			var _p38 = _p37;
			return A2(
				_elm_lang$core$Maybe$andThen,
				function (_p39) {
					var _p40 = _p39;
					return A2(
						_elm_lang$core$Maybe$andThen,
						function (_p41) {
							var _p42 = _p41;
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (_p43) {
									var _p44 = _p43;
									var _p45 = {ctor: '_Tuple4', _0: _p38._0.interpreted, _1: _p42._0.interpreted, _2: _p40._0.interpreted, _3: _p44._0.interpreted};
									if (((((((((_p45.ctor === '_Tuple4') && (_p45._0.ctor === 'ANum')) && (_p45._0._0.ctor === '_Tuple2')) && (_p45._1.ctor === 'ANum')) && (_p45._1._0.ctor === '_Tuple2')) && (_p45._2.ctor === 'ANum')) && (_p45._2._0.ctor === '_Tuple2')) && (_p45._3.ctor === 'ANum')) && (_p45._3._0.ctor === '_Tuple2')) {
										return _elm_lang$core$Maybe$Just(
											{ctor: '_Tuple5', _0: _p45._0._0._0, _1: _p45._1._0._0, _2: _p45._2._0._0, _3: _p45._3._0._0, _4: _p44._1});
									} else {
										return _elm_lang$core$Maybe$Nothing;
									}
								},
								A2(_user$project$Utils$maybeRemoveFirst, 'BOT', _p42._1));
						},
						A2(_user$project$Utils$maybeRemoveFirst, 'TOP', _p40._1));
				},
				A2(_user$project$Utils$maybeRemoveFirst, 'RIGHT', _p38._1));
		},
		A2(_user$project$Utils$maybeRemoveFirst, 'LEFT', attrs0));
};
var _user$project$LangSvg$specialAttrs = {
	ctor: '::',
	_0: 'HIDDEN',
	_1: {
		ctor: '::',
		_0: 'ZONES',
		_1: {ctor: '[]'}
	}
};
var _user$project$LangSvg$removeSpecialAttrs = _elm_lang$core$List$filter(
	function (_p46) {
		var _p47 = _p46;
		return !A2(_elm_lang$core$List$member, _p47._0, _user$project$LangSvg$specialAttrs);
	});
var _user$project$LangSvg$printAttrRaw = F2(
	function (prettyPrint, _p48) {
		var _p49 = _p48;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			' ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				_p49._0,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'=',
					A2(_user$project$HTMLParser$printAttrValueRaw, prettyPrint, _p49._1))));
	});
var _user$project$LangSvg$valToHTMLSource = F2(
	function (namespace, v) {
		var _p50 = v.v_;
		_v32_2:
		do {
			if (((_p50.ctor === 'VList') && (_p50._0.ctor === '::')) && (_p50._0._1.ctor === '::')) {
				if (_p50._0._1._1.ctor === '[]') {
					var _p51 = {ctor: '_Tuple2', _0: _p50._0._0.v_, _1: _p50._0._1._0.v_};
					_v33_2:
					do {
						if (((((_p51.ctor === '_Tuple2') && (_p51._0.ctor === 'VBase')) && (_p51._0._0.ctor === 'VString')) && (_p51._1.ctor === 'VBase')) && (_p51._1._0.ctor === 'VString')) {
							switch (_p51._0._0._0) {
								case 'TEXT':
									var content = _user$project$ImpureGoodies$htmlescape(_p51._1._0._0);
									return _elm_lang$core$Result$Ok(
										A4(
											_elm_lang$core$Regex$replace,
											_elm_lang$core$Regex$All,
											_elm_lang$core$Regex$regex('&gt;'),
											function (_p52) {
												return '>';
											},
											content));
								case 'COMMENT':
									return _elm_lang$core$Result$Ok(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'<!--',
											A2(_elm_lang$core$Basics_ops['++'], _p51._1._0._0, '-->')));
								default:
									break _v33_2;
							}
						} else {
							break _v33_2;
						}
					} while(false);
					return _elm_lang$core$Result$Err(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Don\'t know how to convert this 2-element list to an HTML node : ',
							_user$project$LangUtils$valToString(v)));
				} else {
					if (_p50._0._1._1._1.ctor === '[]') {
						var _p53 = {ctor: '_Tuple3', _0: _p50._0._0.v_, _1: _p50._0._1._0.v_, _2: _p50._0._1._1._0.v_};
						if (((((_p53.ctor === '_Tuple3') && (_p53._0.ctor === 'VBase')) && (_p53._0._0.ctor === 'VString')) && (_p53._1.ctor === 'VList')) && (_p53._2.ctor === 'VList')) {
							var _p61 = _p53._0._0._0;
							var ending = function () {
								var _p54 = namespace;
								if (_p54.ctor === 'HTML') {
									return _user$project$HTMLParser$isVoidElement(_p61) ? '' : A3(_user$project$Utils$delimit, '</', '>', _p61);
								} else {
									return A3(_user$project$Utils$delimit, '</', '>', _p61);
								}
							}();
							var newNamespace = _user$project$HTMLParser$isForeignElement(_p61) ? _user$project$HTMLParser$Foreign : namespace;
							var resAttributes = A2(
								_elm_lang$core$Result$map,
								_elm_lang$core$String$join(''),
								_user$project$Utils$projOk(
									A2(
										_elm_lang$core$List$map,
										function (vAttr) {
											var _p55 = vAttr.v_;
											if ((((_p55.ctor === 'VList') && (_p55._0.ctor === '::')) && (_p55._0._1.ctor === '::')) && (_p55._0._1._1.ctor === '[]')) {
												var _p56 = {ctor: '_Tuple2', _0: _p55._0._0.v_, _1: _p55._0._1._0.v_};
												_v37_2:
												do {
													if (((_p56.ctor === '_Tuple2') && (_p56._0.ctor === 'VBase')) && (_p56._0._0.ctor === 'VString')) {
														switch (_p56._1.ctor) {
															case 'VBase':
																if (_p56._1._0.ctor === 'VString') {
																	return _elm_lang$core$Result$Ok(
																		A2(
																			_user$project$LangSvg$printAttrRaw,
																			false,
																			{ctor: '_Tuple2', _0: _p56._0._0._0, _1: _p56._1._0._0}));
																} else {
																	break _v37_2;
																}
															case 'VList':
																if (_p56._0._0._0 === 'style') {
																	return A2(
																		_elm_lang$core$Result$map,
																		function (v) {
																			return A2(
																				_user$project$LangSvg$printAttrRaw,
																				false,
																				{ctor: '_Tuple2', _0: 'style', _1: v});
																		},
																		A2(
																			_elm_lang$core$Result$map,
																			_elm_lang$core$String$join(';'),
																			_user$project$Utils$projOk(
																				A2(
																					_elm_lang$core$List$map,
																					function (vStyle) {
																						var _p57 = vStyle.v_;
																						if ((((_p57.ctor === 'VList') && (_p57._0.ctor === '::')) && (_p57._0._1.ctor === '::')) && (_p57._0._1._1.ctor === '[]')) {
																							var _p58 = {ctor: '_Tuple2', _0: _p57._0._0.v_, _1: _p57._0._1._0.v_};
																							if (((((_p58.ctor === '_Tuple2') && (_p58._0.ctor === 'VBase')) && (_p58._0._0.ctor === 'VString')) && (_p58._1.ctor === 'VBase')) && (_p58._1._0.ctor === 'VString')) {
																								return _elm_lang$core$Result$Ok(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_p58._0._0._0,
																										A2(_elm_lang$core$Basics_ops['++'], ':', _p58._1._0._0)));
																							} else {
																								return _elm_lang$core$Result$Err(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'Style attrs should be [string, string], got ',
																										_user$project$LangUtils$valToString(vStyle)));
																							}
																						} else {
																							return _elm_lang$core$Result$Err(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'Style attrs should be [string, string], got ',
																									_user$project$LangUtils$valToString(vStyle)));
																						}
																					},
																					_p56._1._0))));
																} else {
																	break _v37_2;
																}
															default:
																break _v37_2;
														}
													} else {
														break _v37_2;
													}
												} while(false);
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Expected string=string or string=list for attribute, got ',
														_user$project$LangUtils$valToString(vAttr)));
											} else {
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'Expected 2-element list for attribute, got ',
														_user$project$LangUtils$valToString(vAttr)));
											}
										},
										_p53._1._0)));
							var _p59 = resAttributes;
							if (_p59.ctor === 'Err') {
								return _elm_lang$core$Result$Err(_p59._0);
							} else {
								var _p60 = _user$project$Utils$projOk(
									A2(
										_elm_lang$core$List$map,
										_user$project$LangSvg$valToHTMLSource(newNamespace),
										_p53._2._0));
								if (_p60.ctor === 'Err') {
									return _elm_lang$core$Result$Err(_p60._0);
								} else {
									var childrenRawStr = A2(_elm_lang$core$String$join, '', _p60._0);
									var childrenStr = A2(_user$project$LangSvg$unescapeStyleScript, _p61, childrenRawStr);
									return _elm_lang$core$Result$Ok(
										A2(
											_elm_lang$core$Basics_ops['++'],
											A3(
												_user$project$Utils$delimit,
												'<',
												'>',
												A2(_elm_lang$core$Basics_ops['++'], _p61, _p59._0)),
											A2(_elm_lang$core$Basics_ops['++'], childrenStr, ending)));
								}
							}
						} else {
							return _elm_lang$core$Result$Err(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Don\'t know how to convert this 3-element list to an HTML node : ',
									_user$project$LangUtils$valToString(v)));
						}
					} else {
						break _v32_2;
					}
				}
			} else {
				break _v32_2;
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Don\'t know how to convert this to an HTML node : ',
				_user$project$LangUtils$valToString(v)));
	});
var _user$project$LangSvg$strBounds = function (_p62) {
	var _p63 = _p62;
	return _user$project$Utils$spaces(
		A2(
			_elm_lang$core$List$map,
			function (_p64) {
				return _elm_lang$core$Basics$toString(
					_elm_lang$core$Tuple$first(_p64));
			},
			{
				ctor: '::',
				_0: _p63._0,
				_1: {
					ctor: '::',
					_0: _p63._1,
					_1: {
						ctor: '::',
						_0: _p63._2,
						_1: {
							ctor: '::',
							_0: _p63._3,
							_1: {ctor: '[]'}
						}
					}
				}
			}));
};
var _user$project$LangSvg$strTransformCmd = function (cmd) {
	var _p65 = cmd;
	switch (_p65.ctor) {
		case 'Rot':
			var nums = A2(
				_elm_lang$core$List$map,
				function (_p66) {
					return _elm_lang$core$Basics$toString(
						_elm_lang$core$Tuple$first(_p66));
				},
				{
					ctor: '::',
					_0: _p65._0,
					_1: {
						ctor: '::',
						_0: _p65._1,
						_1: {
							ctor: '::',
							_0: _p65._2,
							_1: {ctor: '[]'}
						}
					}
				});
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'rotate',
				_user$project$Utils$parens(
					_user$project$Utils$spaces(nums)));
		case 'Scale':
			var nums = A2(
				_elm_lang$core$List$map,
				function (_p67) {
					return _elm_lang$core$Basics$toString(
						_elm_lang$core$Tuple$first(_p67));
				},
				{
					ctor: '::',
					_0: _p65._0,
					_1: {
						ctor: '::',
						_0: _p65._1,
						_1: {ctor: '[]'}
					}
				});
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'scale',
				_user$project$Utils$parens(
					_user$project$Utils$spaces(nums)));
		default:
			var nums = A2(
				_elm_lang$core$List$map,
				function (_p68) {
					return _elm_lang$core$Basics$toString(
						_elm_lang$core$Tuple$first(_p68));
				},
				{
					ctor: '::',
					_0: _p65._0,
					_1: {
						ctor: '::',
						_0: _p65._1,
						_1: {ctor: '[]'}
					}
				});
			return A2(
				_elm_lang$core$Basics_ops['++'],
				'translate',
				_user$project$Utils$parens(
					_user$project$Utils$spaces(nums)));
	}
};
var _user$project$LangSvg$strAPathCmds = function () {
	var strPt = function (_p69) {
		var _p70 = _p69;
		return A2(
			_elm_lang$core$Basics_ops['++'],
			_elm_lang$core$Basics$toString(
				_elm_lang$core$Tuple$first(_p70._1._0)),
			A2(
				_elm_lang$core$Basics_ops['++'],
				' ',
				_elm_lang$core$Basics$toString(
					_elm_lang$core$Tuple$first(_p70._1._1))));
	};
	var strNum = function (_p71) {
		var _p72 = _p71;
		return _elm_lang$core$Basics$toString(_p72._0);
	};
	var strPathCmd = function (c) {
		var _p73 = c;
		switch (_p73.ctor) {
			case 'CmdZ':
				return _p73._0;
			case 'CmdMLT':
				return _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: _p73._0,
						_1: {
							ctor: '::',
							_0: strPt(_p73._1),
							_1: {ctor: '[]'}
						}
					});
			case 'CmdHV':
				return _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: _p73._0,
						_1: {
							ctor: '::',
							_0: strNum(_p73._1),
							_1: {ctor: '[]'}
						}
					});
			case 'CmdC':
				return _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: _p73._0,
						_1: A2(
							_elm_lang$core$List$map,
							strPt,
							{
								ctor: '::',
								_0: _p73._1,
								_1: {
									ctor: '::',
									_0: _p73._2,
									_1: {
										ctor: '::',
										_0: _p73._3,
										_1: {ctor: '[]'}
									}
								}
							})
					});
			case 'CmdSQ':
				return _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: _p73._0,
						_1: A2(
							_elm_lang$core$List$map,
							strPt,
							{
								ctor: '::',
								_0: _p73._1,
								_1: {
									ctor: '::',
									_0: _p73._2,
									_1: {ctor: '[]'}
								}
							})
					});
			default:
				return _user$project$Utils$spaces(
					{
						ctor: '::',
						_0: _p73._0,
						_1: A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_elm_lang$core$List$map,
								strNum,
								{
									ctor: '::',
									_0: _p73._1,
									_1: {
										ctor: '::',
										_0: _p73._2,
										_1: {
											ctor: '::',
											_0: _p73._3,
											_1: {
												ctor: '::',
												_0: _p73._4,
												_1: {
													ctor: '::',
													_0: _p73._5,
													_1: {ctor: '[]'}
												}
											}
										}
									}
								}),
							{
								ctor: '::',
								_0: strPt(_p73._6),
								_1: {ctor: '[]'}
							})
					});
		}
	};
	return function (_p74) {
		return _user$project$Utils$spaces(
			A2(_elm_lang$core$List$map, strPathCmd, _p74));
	};
}();
var _user$project$LangSvg$matchCmd = F2(
	function (cmd, s) {
		var c = _user$project$Utils$unwrap1(
			_elm_lang$core$String$toList(cmd));
		var cs = _elm_lang$core$String$toList(s);
		return A2(
			_elm_lang$core$List$member,
			c,
			A2(
				_elm_lang$core$Basics_ops['++'],
				cs,
				A2(_elm_lang$core$List$map, _elm_lang$core$Char$toLower, cs)));
	});
var _user$project$LangSvg$projConsts = F2(
	function (k, vs) {
		var _p75 = {
			ctor: '_Tuple2',
			_0: _elm_lang$core$Native_Utils.eq(k, 0),
			_1: vs
		};
		_v47_2:
		do {
			if (_p75.ctor === '_Tuple2') {
				if (_p75._0 === true) {
					return {
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: vs
					};
				} else {
					if (_p75._1.ctor === '::') {
						var _p76 = _p75._1._0.v_;
						if (_p76.ctor === 'VConst') {
							var _p77 = A2(_user$project$LangSvg$projConsts, k - 1, _p75._1._1);
							var l1 = _p77._0;
							var l2 = _p77._1;
							return {
								ctor: '_Tuple2',
								_0: {ctor: '::', _0: _p76._1, _1: l1},
								_1: l2
							};
						} else {
							return _elm_lang$core$Native_Utils.crashCase(
								'LangSvg',
								{
									start: {line: 423, column: 7},
									end: {line: 428, column: 35}
								},
								_p76)('projConsts');
						}
					} else {
						break _v47_2;
					}
				}
			} else {
				break _v47_2;
			}
		} while(false);
		return _elm_lang$core$Native_Utils.crashCase(
			'LangSvg',
			{
				start: {line: 420, column: 3},
				end: {line: 430, column: 31}
			},
			_p75)('projConsts');
	});
var _user$project$LangSvg$addIdPoints = F3(
	function (cmd, counts, pts) {
		var c = _user$project$Utils$unwrap1(
			_elm_lang$core$String$toList(cmd));
		if (_elm_lang$core$Char$isLower(c)) {
			return {
				ctor: '_Tuple2',
				_0: counts,
				_1: A2(
					_elm_lang$core$List$map,
					F2(
						function (v0, v1) {
							return {ctor: '_Tuple2', _0: v0, _1: v1};
						})(_elm_lang$core$Maybe$Nothing),
					pts)
			};
		} else {
			if (_elm_lang$core$Char$isUpper(c)) {
				var _p80 = A3(
					_elm_lang$core$List$foldl,
					F2(
						function (pt, _p81) {
							var _p82 = _p81;
							var _p83 = _p82._0;
							var nextId = 1 + _p83.numPoints;
							var acc1_ = _elm_lang$core$Native_Utils.update(
								_p83,
								{numPoints: nextId});
							var acc2_ = {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: _elm_lang$core$Maybe$Just(nextId),
									_1: pt
								},
								_1: _p82._1
							};
							return {ctor: '_Tuple2', _0: acc1_, _1: acc2_};
						}),
					{
						ctor: '_Tuple2',
						_0: counts,
						_1: {ctor: '[]'}
					},
					pts);
				var counts_ = _p80._0;
				var l = _p80._1;
				return {
					ctor: '_Tuple2',
					_0: counts_,
					_1: _elm_lang$core$List$reverse(l)
				};
			} else {
				return _elm_lang$core$Native_Utils.crash(
					'LangSvg',
					{
						start: {line: 417, column: 5},
						end: {line: 417, column: 16}
					})('addIdPoints');
			}
		}
	});
var _user$project$LangSvg_ops = _user$project$LangSvg_ops || {};
_user$project$LangSvg_ops['+++'] = F2(
	function (x, _p84) {
		var _p85 = _p84;
		return {
			ctor: '_Tuple2',
			_0: {ctor: '::', _0: x, _1: _p85._0},
			_1: _p85._1
		};
	});
var _user$project$LangSvg$strRgba_ = function (rgba) {
	return A2(
		_elm_lang$core$Basics_ops['++'],
		'rgba',
		_user$project$Utils$parens(
			_user$project$Utils$commas(
				A2(_elm_lang$core$List$map, _elm_lang$core$Basics$toString, rgba))));
};
var _user$project$LangSvg$strRgba = function (_p86) {
	var _p87 = _p86;
	return _user$project$LangSvg$strRgba_(
		A2(
			_elm_lang$core$List$map,
			_elm_lang$core$Tuple$first,
			{
				ctor: '::',
				_0: _p87._0,
				_1: {
					ctor: '::',
					_0: _p87._1,
					_1: {
						ctor: '::',
						_0: _p87._2,
						_1: {
							ctor: '::',
							_0: _p87._3,
							_1: {ctor: '[]'}
						}
					}
				}
			}));
};
var _user$project$LangSvg$strPoint = function (_p88) {
	var _p89 = _p88;
	var _p90 = _user$project$Utils$unwrap2(
		A2(
			_elm_lang$core$List$map,
			_elm_lang$core$Tuple$first,
			{
				ctor: '::',
				_0: _p89._0,
				_1: {
					ctor: '::',
					_0: _p89._1,
					_1: {ctor: '[]'}
				}
			}));
	var x = _p90._0;
	var y = _p90._1;
	return A2(
		_elm_lang$core$Basics_ops['++'],
		_elm_lang$core$Basics$toString(x),
		A2(
			_elm_lang$core$Basics_ops['++'],
			',',
			_elm_lang$core$Basics$toString(y)));
};
var _user$project$LangSvg$strPoints = function (l) {
	return _user$project$Utils$spaces(
		A2(_elm_lang$core$List$map, _user$project$LangSvg$strPoint, l));
};
var _user$project$LangSvg$isSvg = function (v) {
	var _p91 = v.v_;
	if (_p91.ctor === 'VList') {
		var _p92 = A2(
			_elm_lang$core$List$map,
			function (_) {
				return _.v_;
			},
			_p91._0);
		if (((((((((_p92.ctor === '::') && (_p92._0.ctor === 'VBase')) && (_p92._0._0.ctor === 'VString')) && (_p92._0._0._0 === 'svg')) && (_p92._1.ctor === '::')) && (_p92._1._0.ctor === 'VList')) && (_p92._1._1.ctor === '::')) && (_p92._1._1._0.ctor === 'VList')) && (_p92._1._1._1.ctor === '[]')) {
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
var _user$project$LangSvg$maxStrokeWidthNum = 20;
var _user$project$LangSvg$maxColorNum = 500;
var _user$project$LangSvg$strAVal = function (a) {
	var _p93 = a.interpreted;
	switch (_p93.ctor) {
		case 'AString':
			return _p93._0;
		case 'ANum':
			return _elm_lang$core$Basics$toString(
				_elm_lang$core$Tuple$first(_p93._0));
		case 'APoints':
			return _user$project$LangSvg$strPoints(_p93._0);
		case 'ARgba':
			return _user$project$LangSvg$strRgba(_p93._0);
		case 'APath2':
			return _user$project$LangSvg$strAPathCmds(
				_elm_lang$core$Tuple$first(_p93._0));
		case 'ATransform':
			return _user$project$Utils$spaces(
				A2(_elm_lang$core$List$map, _user$project$LangSvg$strTransformCmd, _p93._0));
		case 'ABounds':
			return _user$project$LangSvg$strBounds(_p93._0);
		case 'AColorNum':
			if (_p93._0._1.ctor === 'Nothing') {
				return _user$project$LangSvg$strRgba_(
					_user$project$ColorNum$convert(
						_elm_lang$core$Tuple$first(_p93._0._0)));
			} else {
				var _p94 = A2(
					_user$project$Utils$numToColor,
					_user$project$LangSvg$maxColorNum,
					_elm_lang$core$Tuple$first(_p93._0._0));
				var r = _p94._0;
				var g = _p94._1;
				var b = _p94._2;
				return _user$project$LangSvg$strRgba_(
					{
						ctor: '::',
						_0: _elm_lang$core$Basics$toFloat(r),
						_1: {
							ctor: '::',
							_0: _elm_lang$core$Basics$toFloat(g),
							_1: {
								ctor: '::',
								_0: _elm_lang$core$Basics$toFloat(b),
								_1: {
									ctor: '::',
									_0: _p93._0._1._0._0,
									_1: {ctor: '[]'}
								}
							}
						}
					});
			}
		default:
			return _user$project$LangSvg$strStyle(_p93._0);
	}
};
var _user$project$LangSvg$strStyle = function (styles) {
	return A2(
		_elm_lang$core$String$join,
		';',
		A2(
			_elm_lang$core$List$map,
			function (_p95) {
				var _p96 = _p95;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					_p96._0,
					A2(
						_elm_lang$core$Basics_ops['++'],
						':',
						_user$project$LangSvg$strAVal(_p96._1)));
			},
			styles));
};
var _user$project$LangSvg$printAttr = F2(
	function (prettyPrint, _p97) {
		var _p98 = _p97;
		return A2(
			_user$project$LangSvg$printAttrRaw,
			prettyPrint,
			{
				ctor: '_Tuple2',
				_0: _p98._0,
				_1: _user$project$LangSvg$strAVal(_p98._1)
			});
	});
var _user$project$LangSvg$printAttrs = F2(
	function (prettyPrint, l) {
		var _p99 = l;
		if (_p99.ctor === '[]') {
			return '';
		} else {
			return _elm_lang$core$String$concat(
				A2(
					_elm_lang$core$List$map,
					_user$project$LangSvg$printAttr(prettyPrint),
					l));
		}
	});
var _user$project$LangSvg$replaceAv_ = F2(
	function (av, av_) {
		return {interpreted: av_, val: av.val};
	});
var _user$project$LangSvg$expectedButGotStr = F2(
	function (x, s) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			'expected ',
			A2(
				_elm_lang$core$Basics_ops['++'],
				x,
				A2(_elm_lang$core$Basics_ops['++'], ', but got: ', s)));
	});
var _user$project$LangSvg$expectedButGotCrash = F2(
	function (x, s) {
		return _elm_lang$core$Native_Utils.crash(
			'LangSvg',
			{
				start: {line: 73, column: 27},
				end: {line: 73, column: 38}
			})(
			A2(_user$project$LangSvg$expectedButGotStr, x, s));
	});
var _user$project$LangSvg$toNum = function (a) {
	var _p100 = a.interpreted;
	switch (_p100.ctor) {
		case 'ANum':
			return _p100._0;
		case 'AString':
			var _p101 = _elm_lang$core$String$toFloat(_p100._0);
			if (_p101.ctor === 'Ok') {
				return {ctor: '_Tuple2', _0: _p101._0, _1: _user$project$Lang$dummyTrace};
			} else {
				return A2(
					_user$project$LangSvg$expectedButGotCrash,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'a number (got parse error ',
						A2(_elm_lang$core$Basics_ops['++'], _p101._0, ')')),
					_user$project$LangSvg$strAVal(a));
			}
		default:
			return A2(
				_user$project$LangSvg$expectedButGotCrash,
				'a number',
				_user$project$LangSvg$strAVal(a));
	}
};
var _user$project$LangSvg$toColorNum = function (a) {
	var _p102 = a.interpreted;
	if (_p102.ctor === 'AColorNum') {
		return _p102._0;
	} else {
		return A2(
			_user$project$LangSvg$expectedButGotCrash,
			'a color number',
			_user$project$LangSvg$strAVal(a));
	}
};
var _user$project$LangSvg$toNumIsh = function (a) {
	var _p103 = a.interpreted;
	_v62_3:
	do {
		switch (_p103.ctor) {
			case 'ANum':
				return _p103._0;
			case 'AString':
				var _p104 = _elm_lang$core$String$toFloat(_p103._0);
				if (_p104.ctor === 'Ok') {
					return {ctor: '_Tuple2', _0: _p104._0, _1: _user$project$Lang$dummyTrace};
				} else {
					return A2(
						_user$project$LangSvg$expectedButGotCrash,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'a number (got parse error ',
							A2(_elm_lang$core$Basics_ops['++'], _p104._0, ')')),
						_user$project$LangSvg$strAVal(a));
				}
			case 'AColorNum':
				if (_p103._0.ctor === '_Tuple2') {
					return _p103._0._0;
				} else {
					break _v62_3;
				}
			default:
				break _v62_3;
		}
	} while(false);
	return A2(
		_user$project$LangSvg$expectedButGotCrash,
		'a number or color number',
		_user$project$LangSvg$strAVal(a));
};
var _user$project$LangSvg$findNumishAttr = F2(
	function (attr, attrs) {
		return _user$project$LangSvg$toNumIsh(
			A2(_user$project$LangSvg$findAVal, attr, attrs));
	});
var _user$project$LangSvg$toPoints = function (a) {
	var _p105 = a.interpreted;
	if (_p105.ctor === 'APoints') {
		return _p105._0;
	} else {
		return A2(
			_user$project$LangSvg$expectedButGotCrash,
			'a list of points',
			_user$project$LangSvg$strAVal(a));
	}
};
var _user$project$LangSvg$getPolyPoints = function (attrs) {
	var _p106 = A2(_user$project$Utils$maybeFind, 'points', attrs);
	if (_p106.ctor === 'Just') {
		return _user$project$LangSvg$toPoints(_p106._0);
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangSvg',
			{
				start: {line: 857, column: 3},
				end: {line: 859, column: 45}
			},
			_p106)('getPolyPoints');
	}
};
var _user$project$LangSvg$getPtCount = function (attrs) {
	return _elm_lang$core$List$length(
		_user$project$LangSvg$getPolyPoints(attrs));
};
var _user$project$LangSvg$getPolyPoint = F2(
	function (attrs, i) {
		return A2(
			_user$project$Utils$geti,
			i,
			_user$project$LangSvg$getPolyPoints(attrs));
	});
var _user$project$LangSvg$toPath = function (a) {
	var _p108 = a.interpreted;
	switch (_p108.ctor) {
		case 'APath2':
			return _elm_lang$core$Maybe$Just(_p108._0);
		case 'AString':
			return _elm_lang$core$Maybe$Nothing;
		default:
			return A2(
				_user$project$LangSvg$expectedButGotCrash,
				'path commands',
				_user$project$LangSvg$strAVal(a));
	}
};
var _user$project$LangSvg$pathIndexPoints = function (nodeAttrs) {
	var cmds = A2(
		_elm_lang$core$Maybe$withDefault,
		{ctor: '[]'},
		A2(
			_elm_lang$core$Maybe$map,
			_elm_lang$core$Tuple$first,
			_user$project$LangSvg$toPath(
				A3(
					_user$project$Utils$find,
					A2(
						_elm_lang$core$Basics_ops['++'],
						'pathPoints nodeAttrs looking for \"d\" in ',
						_elm_lang$core$Basics$toString(nodeAttrs)),
					nodeAttrs,
					'd'))));
	var pts = A2(
		_elm_lang$core$List$filterMap,
		function (_p109) {
			var _p110 = _p109;
			var _p111 = _p110._0;
			if (_p111.ctor === 'Nothing') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				return _elm_lang$core$Maybe$Just(
					{ctor: '_Tuple2', _0: _p111._0, _1: _p110._1});
			}
		},
		A2(
			_elm_lang$core$List$concatMap,
			function (cmd) {
				var _p112 = cmd;
				switch (_p112.ctor) {
					case 'CmdZ':
						return {ctor: '[]'};
					case 'CmdMLT':
						return {
							ctor: '::',
							_0: _p112._1,
							_1: {ctor: '[]'}
						};
					case 'CmdHV':
						return {ctor: '[]'};
					case 'CmdC':
						return {
							ctor: '::',
							_0: _p112._1,
							_1: {
								ctor: '::',
								_0: _p112._2,
								_1: {
									ctor: '::',
									_0: _p112._3,
									_1: {ctor: '[]'}
								}
							}
						};
					case 'CmdSQ':
						return {
							ctor: '::',
							_0: _p112._1,
							_1: {
								ctor: '::',
								_0: _p112._2,
								_1: {ctor: '[]'}
							}
						};
					default:
						return {
							ctor: '::',
							_0: _p112._6,
							_1: {ctor: '[]'}
						};
				}
			},
			cmds));
	return pts;
};
var _user$project$LangSvg$getPathPoint = F2(
	function (attrs, i) {
		var _p113 = A2(
			_user$project$Utils$maybeFind,
			i,
			_user$project$LangSvg$pathIndexPoints(attrs));
		if (_p113.ctor === 'Just') {
			return _p113._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'LangSvg',
				{
					start: {line: 863, column: 3},
					end: {line: 865, column: 42}
				},
				_p113)('getPathPoint');
		}
	});
var _user$project$LangSvg$toTransformRot = function (a) {
	var _p115 = a.interpreted;
	if ((((_p115.ctor === 'ATransform') && (_p115._0.ctor === '::')) && (_p115._0._0.ctor === 'Rot')) && (_p115._0._1.ctor === '[]')) {
		return {ctor: '_Tuple3', _0: _p115._0._0._0, _1: _p115._0._0._1, _2: _p115._0._0._2};
	} else {
		return A2(
			_user$project$LangSvg$expectedButGotCrash,
			'a rotation transform',
			_user$project$LangSvg$strAVal(a));
	}
};
var _user$project$LangSvg$expectedButGot = F2(
	function (x, s) {
		return _elm_lang$core$Result$Err(
			A2(_user$project$LangSvg$expectedButGotStr, x, s));
	});
var _user$project$LangSvg$valToPoint = function (v) {
	var _p116 = v.v_;
	if (_p116.ctor === 'VList') {
		var _p117 = A2(
			_elm_lang$core$List$map,
			function (_) {
				return _.v_;
			},
			_p116._0);
		if (((((_p117.ctor === '::') && (_p117._0.ctor === 'VConst')) && (_p117._1.ctor === '::')) && (_p117._1._0.ctor === 'VConst')) && (_p117._1._1.ctor === '[]')) {
			return _elm_lang$core$Result$Ok(
				{ctor: '_Tuple2', _0: _p117._0._1, _1: _p117._1._0._1});
		} else {
			return A2(
				_user$project$LangSvg$expectedButGot,
				'a point',
				_user$project$ValUnparser$strVal(v));
		}
	} else {
		return A2(
			_user$project$LangSvg$expectedButGot,
			'a point',
			_user$project$ValUnparser$strVal(v));
	}
};
var _user$project$LangSvg$valsToRgba = function (vs) {
	var _p118 = A2(
		_elm_lang$core$List$map,
		function (_) {
			return _.v_;
		},
		vs);
	if (((((((((_p118.ctor === '::') && (_p118._0.ctor === 'VConst')) && (_p118._1.ctor === '::')) && (_p118._1._0.ctor === 'VConst')) && (_p118._1._1.ctor === '::')) && (_p118._1._1._0.ctor === 'VConst')) && (_p118._1._1._1.ctor === '::')) && (_p118._1._1._1._0.ctor === 'VConst')) && (_p118._1._1._1._1.ctor === '[]')) {
		return _elm_lang$core$Result$Ok(
			{ctor: '_Tuple4', _0: _p118._0._1, _1: _p118._1._0._1, _2: _p118._1._1._0._1, _3: _p118._1._1._1._0._1});
	} else {
		return A2(
			_user$project$LangSvg$expectedButGot,
			'rgba',
			A2(
				_elm_lang$core$Basics_ops['++'],
				'[',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$String$join,
						', ',
						A2(_elm_lang$core$List$map, _user$project$ValUnparser$strVal, vs)),
					']')));
	}
};
var _user$project$LangSvg$valToBounds = function (vs) {
	var _p119 = A2(
		_elm_lang$core$List$map,
		function (_) {
			return _.v_;
		},
		vs);
	if (((((((((_p119.ctor === '::') && (_p119._0.ctor === 'VConst')) && (_p119._1.ctor === '::')) && (_p119._1._0.ctor === 'VConst')) && (_p119._1._1.ctor === '::')) && (_p119._1._1._0.ctor === 'VConst')) && (_p119._1._1._1.ctor === '::')) && (_p119._1._1._1._0.ctor === 'VConst')) && (_p119._1._1._1._1.ctor === '[]')) {
		return _elm_lang$core$Result$Ok(
			{ctor: '_Tuple4', _0: _p119._0._1, _1: _p119._1._0._1, _2: _p119._1._1._0._1, _3: _p119._1._1._1._0._1});
	} else {
		return A2(
			_user$project$LangSvg$expectedButGot,
			'bounds',
			A2(
				_elm_lang$core$Basics_ops['++'],
				'[',
				A2(
					_elm_lang$core$Basics_ops['++'],
					A2(
						_elm_lang$core$String$join,
						', ',
						A2(_elm_lang$core$List$map, _user$project$ValUnparser$strVal, vs)),
					']')));
	}
};
var _user$project$LangSvg$attr = _elm_lang$virtual_dom$VirtualDom$attribute;
var _user$project$LangSvg$compileAttr = F2(
	function (k, v) {
		var _p120 = A2(
			_elm_lang$core$List$any,
			_elm_lang$core$Char$isUpper,
			_elm_lang$core$String$toList(k)) ? A2(_elm_lang$core$Debug$log, 'WARN: uppercase letter in attribute name may not be handled correctly by DOM listener', k) : k;
		return A2(
			_user$project$LangSvg$attr,
			k,
			_user$project$LangSvg$strAVal(v));
	});
var _user$project$LangSvg$compileAttrs = _elm_lang$core$List$map(
	_elm_lang$core$Basics$uncurry(_user$project$LangSvg$compileAttr));
var _user$project$LangSvg$WithVal = F2(
	function (a, b) {
		return {interpreted: a, val: b};
	});
var _user$project$LangSvg$PathCounts = function (a) {
	return {numPoints: a};
};
var _user$project$LangSvg$AStyle = function (a) {
	return {ctor: 'AStyle', _0: a};
};
var _user$project$LangSvg$ABounds = function (a) {
	return {ctor: 'ABounds', _0: a};
};
var _user$project$LangSvg$ATransform = function (a) {
	return {ctor: 'ATransform', _0: a};
};
var _user$project$LangSvg$aTransform = function (_p121) {
	return _user$project$LangSvg$aVal(
		_user$project$LangSvg$ATransform(_p121));
};
var _user$project$LangSvg$APath2 = function (a) {
	return {ctor: 'APath2', _0: a};
};
var _user$project$LangSvg$AColorNum = function (a) {
	return {ctor: 'AColorNum', _0: a};
};
var _user$project$LangSvg$ARgba = function (a) {
	return {ctor: 'ARgba', _0: a};
};
var _user$project$LangSvg$APoints = function (a) {
	return {ctor: 'APoints', _0: a};
};
var _user$project$LangSvg$aPoints = function (_p122) {
	return _user$project$LangSvg$aVal(
		_user$project$LangSvg$APoints(_p122));
};
var _user$project$LangSvg$AString = function (a) {
	return {ctor: 'AString', _0: a};
};
var _user$project$LangSvg$desugarFixedPosition = F4(
	function (xCanvas, yCanvas, shape0, attrs0) {
		return A2(
			_elm_lang$core$Maybe$andThen,
			function (_p123) {
				var _p124 = _p123;
				var _p133 = _p124._0;
				var _p125 = _p133.interpreted;
				if (_p125.ctor === 'AStyle') {
					return A2(
						_elm_lang$core$Maybe$andThen,
						function (_p126) {
							var _p127 = _p126;
							var _p132 = _p127._0;
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (_p128) {
									var _p129 = _p128;
									var _p131 = _p129._0;
									var _p130 = {ctor: '_Tuple2', _0: _p132.interpreted, _1: _p131.interpreted};
									if (((_p130.ctor === '_Tuple2') && (_p130._0.ctor === 'ANum')) && (_p130._1.ctor === 'ANum')) {
										var newTop = A2(
											_user$project$Lang$plusNumTr,
											_p130._1._0,
											{
												ctor: '_Tuple2',
												_0: _elm_lang$core$Basics$toFloat(yCanvas),
												_1: _user$project$Lang$TrLoc(
													_user$project$Lang$dummyLoc_(_user$project$Lang$frozen))
											});
										var newLeft = A2(
											_user$project$Lang$plusNumTr,
											_p130._0._0,
											{
												ctor: '_Tuple2',
												_0: _elm_lang$core$Basics$toFloat(xCanvas),
												_1: _user$project$Lang$TrLoc(
													_user$project$Lang$dummyLoc_(_user$project$Lang$frozen))
											});
										var newStyle = A2(
											_user$project$LangSvg$replaceAv_,
											_p133,
											_user$project$LangSvg$AStyle(
												{
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: 'left',
														_1: A2(
															_user$project$LangSvg$replaceAv_,
															_p132,
															_user$project$LangSvg$AString(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_elm_lang$core$Basics$toString(
																		_elm_lang$core$Tuple$first(newLeft)),
																	'px')))
													},
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: 'top',
															_1: A2(
																_user$project$LangSvg$replaceAv_,
																_p131,
																_user$project$LangSvg$AString(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_elm_lang$core$Basics$toString(
																			_elm_lang$core$Tuple$first(newTop)),
																		'px')))
														},
														_1: _p129._1
													}
												}));
										return _elm_lang$core$Maybe$Just(
											{
												ctor: '_Tuple2',
												_0: shape0,
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 'style', _1: newStyle},
													_1: _p124._1
												}
											});
									} else {
										return _elm_lang$core$Maybe$Nothing;
									}
								},
								A2(_user$project$Utils$maybeRemoveFirst, 'FIXED_TOP', _p127._1));
						},
						A2(_user$project$Utils$maybeRemoveFirst, 'FIXED_LEFT', _p125._0));
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			A2(_user$project$Utils$maybeRemoveFirst, 'style', attrs0));
	});
var _user$project$LangSvg$aString = function (_p134) {
	return _user$project$LangSvg$aVal(
		_user$project$LangSvg$AString(_p134));
};
var _user$project$LangSvg$addAttrs = F2(
	function (kind, attrs) {
		return _elm_lang$core$Native_Utils.eq(kind, 'svg') ? {
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: 'xmlns',
				_1: _user$project$LangSvg$aString('http://www.w3.org/2000/svg')
			},
			_1: attrs
		} : attrs;
	});
var _user$project$LangSvg$ANum = function (a) {
	return {ctor: 'ANum', _0: a};
};
var _user$project$LangSvg$aNum = function (_p135) {
	return _user$project$LangSvg$aVal(
		_user$project$LangSvg$ANum(_p135));
};
var _user$project$LangSvg$desugarBoundedShapes = F2(
	function (shape0, attrs0) {
		var mkNum = function (n) {
			return _user$project$LangSvg$aNum(
				{ctor: '_Tuple2', _0: n, _1: _user$project$Lang$dummyTrace});
		};
		var _p136 = shape0;
		switch (_p136) {
			case 'BOX':
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p137) {
						var _p138 = _p137;
						var _p140 = _p138._1;
						var _p139 = _p138._0;
						var newAttrs = {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'x',
								_1: mkNum(_p139)
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'y',
									_1: mkNum(_p140)
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'width',
										_1: mkNum(_p138._2 - _p139)
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'height',
											_1: mkNum(_p138._3 - _p140)
										},
										_1: {ctor: '[]'}
									}
								}
							}
						};
						return {
							ctor: '_Tuple2',
							_0: 'rect',
							_1: A2(_elm_lang$core$Basics_ops['++'], newAttrs, _p138._4)
						};
					},
					_user$project$LangSvg$getBoundsAttrs(attrs0));
			case 'OVAL':
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p141) {
						var _p142 = _p141;
						var _p146 = _p142._1;
						var _p145 = _p142._2;
						var _p144 = _p142._0;
						var _p143 = _p142._3;
						var newAttrs = {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: 'cx',
								_1: mkNum(_p144 + ((_p145 - _p144) / 2))
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: 'cy',
									_1: mkNum(_p146 + ((_p143 - _p146) / 2))
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'rx',
										_1: mkNum((_p145 - _p144) / 2)
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'ry',
											_1: mkNum((_p143 - _p146) / 2)
										},
										_1: {ctor: '[]'}
									}
								}
							}
						};
						return {
							ctor: '_Tuple2',
							_0: 'ellipse',
							_1: A2(_elm_lang$core$Basics_ops['++'], newAttrs, _p142._4)
						};
					},
					_user$project$LangSvg$getBoundsAttrs(attrs0));
			default:
				return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$LangSvg$desugarShapeAttrs = F4(
	function (xCanvas, yCanvas, shape0, attrs0) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			{ctor: '_Tuple2', _0: shape0, _1: attrs0},
			A2(
				_user$project$Utils$plusMaybe,
				A4(_user$project$LangSvg$desugarFixedPosition, xCanvas, yCanvas, shape0, attrs0),
				A2(_user$project$LangSvg$desugarBoundedShapes, shape0, attrs0)));
	});
var _user$project$LangSvg$printNode = F6(
	function (namespace, showGhosts, prettyPrint, indent, slate, i) {
		var _p147 = function (_) {
			return _.interpreted;
		}(
			A2(_user$project$Utils$justGet, i, slate));
		if (_p147.ctor === 'TextNode') {
			var content = _user$project$ImpureGoodies$htmlescape(_p147._0);
			return prettyPrint ? content : A4(
				_elm_lang$core$Regex$replace,
				_elm_lang$core$Regex$All,
				_elm_lang$core$Regex$regex('&gt;'),
				function (_p148) {
					return '>';
				},
				content);
		} else {
			var _p152 = _p147._2;
			var _p149 = A4(_user$project$LangSvg$desugarShapeAttrs, 0, 0, _p147._0, _p147._1);
			var kind = _p149._0;
			var l1 = _p149._1;
			var _p150 = {
				ctor: '_Tuple2',
				_0: showGhosts,
				_1: A2(_user$project$Utils$maybeRemoveFirst, 'HIDDEN', l1)
			};
			if (((_p150.ctor === '_Tuple2') && (_p150._0 === false)) && (_p150._1.ctor === 'Just')) {
				return '';
			} else {
				var ending = function () {
					var _p151 = namespace;
					if (_p151.ctor === 'HTML') {
						return _user$project$HTMLParser$isVoidElement(kind) ? '' : A3(_user$project$Utils$delimit, '</', '>', kind);
					} else {
						return A3(_user$project$Utils$delimit, '</', '>', kind);
					}
				}();
				var newKind = _user$project$HTMLParser$isForeignElement(kind) ? _user$project$HTMLParser$Foreign : namespace;
				if (_elm_lang$core$Native_Utils.eq(
					_p152,
					{ctor: '[]'})) {
					var l1_ = A2(
						_user$project$LangSvg$addAttrs,
						kind,
						_user$project$LangSvg$removeSpecialAttrs(l1));
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A3(
							_user$project$Utils$delimit,
							'<',
							'>',
							A2(
								_elm_lang$core$Basics_ops['++'],
								kind,
								A2(_user$project$LangSvg$printAttrs, prettyPrint, l1_))),
						ending);
				} else {
					var l1_ = A2(
						_user$project$LangSvg$addAttrs,
						kind,
						_user$project$LangSvg$removeSpecialAttrs(l1));
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A3(
							_user$project$Utils$delimit,
							'<',
							'>',
							A2(
								_elm_lang$core$Basics_ops['++'],
								kind,
								A2(_user$project$LangSvg$printAttrs, prettyPrint, l1_))),
						A2(
							_elm_lang$core$Basics_ops['++'],
							prettyPrint ? '\n' : '',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_user$project$LangSvg$unescapeStyleScript,
									kind,
									A6(_user$project$LangSvg$printNodes, newKind, showGhosts, prettyPrint, indent + 1, slate, _p152)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									prettyPrint ? '\n' : '',
									A2(
										_elm_lang$core$Basics_ops['++'],
										prettyPrint ? _user$project$Lang$tab(indent) : '',
										ending)))));
				}
			}
		}
	});
var _user$project$LangSvg$printNodes = F5(
	function (namespace, showGhosts, prettyPrint, indent, slate) {
		return function (_p153) {
			return (prettyPrint ? _user$project$Utils$lines : _elm_lang$core$String$join(''))(
				A2(
					_elm_lang$core$List$map,
					function (_p154) {
						return (prettyPrint ? F2(
							function (x, y) {
								return A2(_elm_lang$core$Basics_ops['++'], x, y);
							})(
							_user$project$Lang$tab(indent)) : _elm_lang$core$Basics$identity)(
							A6(_user$project$LangSvg$printNode, namespace, showGhosts, prettyPrint, indent, slate, _p154));
					},
					_p153));
		};
	});
var _user$project$LangSvg$printRawHTML = F2(
	function (showGhosts, _p155) {
		var _p156 = _p155;
		return A6(_user$project$LangSvg$printNode, _user$project$HTMLParser$HTML, showGhosts, false, 0, _p156._1, _p156._0);
	});
var _user$project$LangSvg$printHTML = F2(
	function (showGhosts, _p157) {
		var _p158 = _p157;
		return A6(_user$project$LangSvg$printNode, _user$project$HTMLParser$HTML, showGhosts, true, 0, _p158._1, _p158._0);
	});
var _user$project$LangSvg$buildSvgSimple_ = F2(
	function (tree, i) {
		var _p159 = function (_) {
			return _.interpreted;
		}(
			A3(
				_user$project$Utils$justGet_,
				A2(
					_elm_lang$core$Basics_ops['++'],
					'LangSvg.buildSvgSimple_ ',
					_elm_lang$core$Basics$toString(i)),
				i,
				tree));
		if (_p159.ctor === 'TextNode') {
			return _elm_lang$virtual_dom$VirtualDom$text(_p159._0);
		} else {
			var _p163 = _p159._1;
			var _p160 = A2(_user$project$Utils$maybeRemoveFirst, 'HIDDEN', _p163);
			if (_p160.ctor === 'Just') {
				return A2(
					_elm_lang$svg$Svg$svg,
					{ctor: '[]'},
					{ctor: '[]'});
			} else {
				var attrs_ = function () {
					var _p161 = A2(_user$project$Utils$maybeRemoveFirst, 'ZONES', _p163);
					if (_p161.ctor === 'Nothing') {
						return _p163;
					} else {
						return _p161._0._1;
					}
				}();
				var children = A2(
					_elm_lang$core$List$map,
					_user$project$LangSvg$buildSvgSimple_(tree),
					_p159._2);
				var _p162 = A4(_user$project$LangSvg$desugarShapeAttrs, 0, 0, _p159._0, attrs_);
				var rawKind = _p162._0;
				var rawAttrs = _p162._1;
				return A3(
					_elm_lang$svg$Svg$node,
					rawKind,
					_user$project$LangSvg$compileAttrs(rawAttrs),
					children);
			}
		}
	});
var _user$project$LangSvg$buildSvgSimple = function (_p164) {
	var _p165 = _p164;
	return A2(_user$project$LangSvg$buildSvgSimple_, _p165._1, _p165._0);
};
var _user$project$LangSvg$CmdA = F7(
	function (a, b, c, d, e, f, g) {
		return {ctor: 'CmdA', _0: a, _1: b, _2: c, _3: d, _4: e, _5: f, _6: g};
	});
var _user$project$LangSvg$CmdSQ = F3(
	function (a, b, c) {
		return {ctor: 'CmdSQ', _0: a, _1: b, _2: c};
	});
var _user$project$LangSvg$CmdC = F4(
	function (a, b, c, d) {
		return {ctor: 'CmdC', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$LangSvg$CmdHV = F2(
	function (a, b) {
		return {ctor: 'CmdHV', _0: a, _1: b};
	});
var _user$project$LangSvg$CmdMLT = F2(
	function (a, b) {
		return {ctor: 'CmdMLT', _0: a, _1: b};
	});
var _user$project$LangSvg$CmdZ = function (a) {
	return {ctor: 'CmdZ', _0: a};
};
var _user$project$LangSvg$valsToPath2_ = F2(
	function (counts, vs) {
		var _p166 = vs;
		if (_p166.ctor === '[]') {
			return _elm_lang$core$Result$Ok(
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: counts
				});
		} else {
			var _p178 = _p166._1;
			var _p167 = _p166._0.v_;
			if ((_p167.ctor === 'VBase') && (_p167._0.ctor === 'VString')) {
				var _p177 = _p167._0._0;
				if (A2(_user$project$LangSvg$matchCmd, _p177, 'Z')) {
					return A2(
						_elm_lang$core$Result$map,
						function (rest) {
							return A2(
								_user$project$LangSvg_ops['+++'],
								_user$project$LangSvg$CmdZ(_p177),
								rest);
						},
						A2(_user$project$LangSvg$valsToPath2_, counts, _p178));
				} else {
					if (A2(_user$project$LangSvg$matchCmd, _p177, 'MLT')) {
						var _p168 = A2(
							_elm_lang$core$Tuple$mapFirst,
							_user$project$Utils$unwrap2,
							A2(_user$project$LangSvg$projConsts, 2, _p178));
						var x = _p168._0._0;
						var y = _p168._0._1;
						var vs__ = _p168._1;
						var _p169 = A2(
							_elm_lang$core$Tuple$mapSecond,
							_user$project$Utils$unwrap1,
							A3(
								_user$project$LangSvg$addIdPoints,
								_p177,
								counts,
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: x, _1: y},
									_1: {ctor: '[]'}
								}));
						var counts_ = _p169._0;
						var pt = _p169._1;
						return A2(
							_elm_lang$core$Result$map,
							function (rest) {
								return A2(
									_user$project$LangSvg_ops['+++'],
									A2(_user$project$LangSvg$CmdMLT, _p177, pt),
									rest);
							},
							A2(_user$project$LangSvg$valsToPath2_, counts_, vs__));
					} else {
						if (A2(_user$project$LangSvg$matchCmd, _p177, 'HV')) {
							var _p170 = A2(
								_elm_lang$core$Tuple$mapFirst,
								_user$project$Utils$unwrap1,
								A2(_user$project$LangSvg$projConsts, 1, _p178));
							var i = _p170._0;
							var vs__ = _p170._1;
							return A2(
								_elm_lang$core$Result$map,
								function (rest) {
									return A2(
										_user$project$LangSvg_ops['+++'],
										A2(_user$project$LangSvg$CmdHV, _p177, i),
										rest);
								},
								A2(_user$project$LangSvg$valsToPath2_, counts, vs__));
						} else {
							if (A2(_user$project$LangSvg$matchCmd, _p177, 'C')) {
								var _p171 = A2(
									_elm_lang$core$Tuple$mapFirst,
									_user$project$Utils$unwrap6,
									A2(_user$project$LangSvg$projConsts, 6, _p178));
								var x1 = _p171._0._0;
								var y1 = _p171._0._1;
								var x2 = _p171._0._2;
								var y2 = _p171._0._3;
								var x = _p171._0._4;
								var y = _p171._0._5;
								var vs__ = _p171._1;
								var _p172 = A2(
									_elm_lang$core$Tuple$mapSecond,
									_user$project$Utils$unwrap3,
									A3(
										_user$project$LangSvg$addIdPoints,
										_p177,
										counts,
										{
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: x1, _1: y1},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: x2, _1: y2},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: x, _1: y},
													_1: {ctor: '[]'}
												}
											}
										}));
								var counts_ = _p172._0;
								var pt1 = _p172._1._0;
								var pt2 = _p172._1._1;
								var pt3 = _p172._1._2;
								return A2(
									_elm_lang$core$Result$map,
									function (rest) {
										return A2(
											_user$project$LangSvg_ops['+++'],
											A4(_user$project$LangSvg$CmdC, _p177, pt1, pt2, pt3),
											rest);
									},
									A2(_user$project$LangSvg$valsToPath2_, counts_, vs__));
							} else {
								if (A2(_user$project$LangSvg$matchCmd, _p177, 'SQ')) {
									var _p173 = A2(
										_elm_lang$core$Tuple$mapFirst,
										_user$project$Utils$unwrap4,
										A2(_user$project$LangSvg$projConsts, 4, _p178));
									var x1 = _p173._0._0;
									var y1 = _p173._0._1;
									var x = _p173._0._2;
									var y = _p173._0._3;
									var vs__ = _p173._1;
									var _p174 = A2(
										_elm_lang$core$Tuple$mapSecond,
										_user$project$Utils$unwrap2,
										A3(
											_user$project$LangSvg$addIdPoints,
											_p177,
											counts,
											{
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: x1, _1: y1},
												_1: {
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: x, _1: y},
													_1: {ctor: '[]'}
												}
											}));
									var counts_ = _p174._0;
									var pt1 = _p174._1._0;
									var pt2 = _p174._1._1;
									return A2(
										_elm_lang$core$Result$map,
										function (rest) {
											return A2(
												_user$project$LangSvg_ops['+++'],
												A3(_user$project$LangSvg$CmdSQ, _p177, pt1, pt2),
												rest);
										},
										A2(_user$project$LangSvg$valsToPath2_, counts_, vs__));
								} else {
									if (A2(_user$project$LangSvg$matchCmd, _p177, 'A')) {
										var _p175 = A2(
											_elm_lang$core$Tuple$mapFirst,
											_user$project$Utils$unwrap7,
											A2(_user$project$LangSvg$projConsts, 7, _p178));
										var rx = _p175._0._0;
										var ry = _p175._0._1;
										var axis = _p175._0._2;
										var flag = _p175._0._3;
										var sweep = _p175._0._4;
										var x = _p175._0._5;
										var y = _p175._0._6;
										var vs__ = _p175._1;
										var _p176 = A2(
											_elm_lang$core$Tuple$mapSecond,
											_user$project$Utils$unwrap1,
											A3(
												_user$project$LangSvg$addIdPoints,
												_p177,
												counts,
												{
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: x, _1: y},
													_1: {ctor: '[]'}
												}));
										var counts_ = _p176._0;
										var pt = _p176._1;
										return A2(
											_elm_lang$core$Result$map,
											function (rest) {
												return A2(
													_user$project$LangSvg_ops['+++'],
													A7(_user$project$LangSvg$CmdA, _p177, rx, ry, axis, flag, sweep, pt),
													rest);
											},
											A2(_user$project$LangSvg$valsToPath2_, counts_, vs__));
									} else {
										return _elm_lang$core$Result$Err('valsToPath2_');
									}
								}
							}
						}
					}
				}
			} else {
				return _elm_lang$core$Result$Err('valsToPath2_');
			}
		}
	});
var _user$project$LangSvg$valsToPath2 = _user$project$LangSvg$valsToPath2_(
	{numPoints: 0});
var _user$project$LangSvg$Trans = F2(
	function (a, b) {
		return {ctor: 'Trans', _0: a, _1: b};
	});
var _user$project$LangSvg$Scale = F2(
	function (a, b) {
		return {ctor: 'Scale', _0: a, _1: b};
	});
var _user$project$LangSvg$Rot = F3(
	function (a, b, c) {
		return {ctor: 'Rot', _0: a, _1: b, _2: c};
	});
var _user$project$LangSvg$valToTransformCmd = function (v) {
	var _p179 = v.v_;
	if (_p179.ctor === 'VList') {
		var _p180 = A2(
			_elm_lang$core$List$map,
			function (_) {
				return _.v_;
			},
			_p179._0);
		if (((_p180.ctor === '::') && (_p180._0.ctor === 'VBase')) && (_p180._0._0.ctor === 'VString')) {
			var _p181 = {ctor: '_Tuple2', _0: _p180._0._0._0, _1: _p180._1};
			_v97_3:
			do {
				if (((((_p181.ctor === '_Tuple2') && (_p181._1.ctor === '::')) && (_p181._1._0.ctor === 'VConst')) && (_p181._1._1.ctor === '::')) && (_p181._1._1._0.ctor === 'VConst')) {
					if (_p181._1._1._1.ctor === '::') {
						if (((_p181._0 === 'rotate') && (_p181._1._1._1._0.ctor === 'VConst')) && (_p181._1._1._1._1.ctor === '[]')) {
							return _elm_lang$core$Result$Ok(
								A3(_user$project$LangSvg$Rot, _p181._1._0._1, _p181._1._1._0._1, _p181._1._1._1._0._1));
						} else {
							break _v97_3;
						}
					} else {
						switch (_p181._0) {
							case 'scale':
								return _elm_lang$core$Result$Ok(
									A2(_user$project$LangSvg$Scale, _p181._1._0._1, _p181._1._1._0._1));
							case 'translate':
								return _elm_lang$core$Result$Ok(
									A2(_user$project$LangSvg$Trans, _p181._1._0._1, _p181._1._1._0._1));
							default:
								break _v97_3;
						}
					}
				} else {
					break _v97_3;
				}
			} while(false);
			return A2(
				_user$project$LangSvg$expectedButGot,
				'a transform command',
				_user$project$ValUnparser$strVal(v));
		} else {
			return A2(
				_user$project$LangSvg$expectedButGot,
				'a transform command',
				_user$project$ValUnparser$strVal(v));
		}
	} else {
		return A2(
			_user$project$LangSvg$expectedButGot,
			'a transform command',
			_user$project$ValUnparser$strVal(v));
	}
};
var _user$project$LangSvg$valsToTransform = function (_p182) {
	return _user$project$Utils$projOk(
		A2(_elm_lang$core$List$map, _user$project$LangSvg$valToTransformCmd, _p182));
};
var _user$project$LangSvg$valToAttr = function (v) {
	var _p183 = v.v_;
	if ((((_p183.ctor === 'VList') && (_p183._0.ctor === '::')) && (_p183._0._1.ctor === '::')) && (_p183._0._1._1.ctor === '[]')) {
		var _p195 = _p183._0._1._0;
		var _p184 = {ctor: '_Tuple2', _0: _p183._0._0.v_, _1: _p195.v_};
		if (((_p184.ctor === '_Tuple2') && (_p184._0.ctor === 'VBase')) && (_p184._0._0.ctor === 'VString')) {
			var _p194 = _p184._0._0._0;
			var avRes = function () {
				var _p185 = {ctor: '_Tuple2', _0: _p194, _1: _p184._1};
				_v100_19:
				do {
					if (_p185.ctor === '_Tuple2') {
						switch (_p185._1.ctor) {
							case 'VList':
								switch (_p185._0) {
									case 'points':
										return A2(
											_elm_lang$core$Result$map,
											_user$project$LangSvg$APoints,
											_user$project$Utils$projOk(
												A2(_elm_lang$core$List$map, _user$project$LangSvg$valToPoint, _p185._1._0)));
									case 'fill':
										if ((_p185._1._0.ctor === '::') && (_p185._1._0._1.ctor === '::')) {
											if (_p185._1._0._1._1.ctor === '::') {
												if ((_p185._1._0._1._1._1.ctor === '::') && (_p185._1._0._1._1._1._1.ctor === '[]')) {
													return A2(
														_elm_lang$core$Result$map,
														_user$project$LangSvg$ARgba,
														_user$project$LangSvg$valsToRgba(
															{
																ctor: '::',
																_0: _p185._1._0._0,
																_1: {
																	ctor: '::',
																	_0: _p185._1._0._1._0,
																	_1: {
																		ctor: '::',
																		_0: _p185._1._0._1._1._0,
																		_1: {
																			ctor: '::',
																			_0: _p185._1._0._1._1._1._0,
																			_1: {ctor: '[]'}
																		}
																	}
																}
															}));
												} else {
													break _v100_19;
												}
											} else {
												var _p187 = _p185._1._0._1._0;
												var _p186 = {ctor: '_Tuple2', _0: _p185._1._0._0.v_, _1: _p187.v_};
												if (((_p186.ctor === '_Tuple2') && (_p186._0.ctor === 'VConst')) && (_p186._1.ctor === 'VConst')) {
													return _elm_lang$core$Result$Ok(
														_user$project$LangSvg$AColorNum(
															{
																ctor: '_Tuple2',
																_0: _p186._0._1,
																_1: _elm_lang$core$Maybe$Just(_p186._1._1)
															}));
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'bad fill: ',
															_user$project$ValUnparser$strVal(_p187)));
												}
											}
										} else {
											break _v100_19;
										}
									case 'stroke':
										if ((_p185._1._0.ctor === '::') && (_p185._1._0._1.ctor === '::')) {
											if (_p185._1._0._1._1.ctor === '::') {
												if ((_p185._1._0._1._1._1.ctor === '::') && (_p185._1._0._1._1._1._1.ctor === '[]')) {
													return A2(
														_elm_lang$core$Result$map,
														_user$project$LangSvg$ARgba,
														_user$project$LangSvg$valsToRgba(
															{
																ctor: '::',
																_0: _p185._1._0._0,
																_1: {
																	ctor: '::',
																	_0: _p185._1._0._1._0,
																	_1: {
																		ctor: '::',
																		_0: _p185._1._0._1._1._0,
																		_1: {
																			ctor: '::',
																			_0: _p185._1._0._1._1._1._0,
																			_1: {ctor: '[]'}
																		}
																	}
																}
															}));
												} else {
													break _v100_19;
												}
											} else {
												var _p189 = _p185._1._0._1._0;
												var _p188 = {ctor: '_Tuple2', _0: _p185._1._0._0.v_, _1: _p189.v_};
												if (((_p188.ctor === '_Tuple2') && (_p188._0.ctor === 'VConst')) && (_p188._1.ctor === 'VConst')) {
													return _elm_lang$core$Result$Ok(
														_user$project$LangSvg$AColorNum(
															{
																ctor: '_Tuple2',
																_0: _p188._0._1,
																_1: _elm_lang$core$Maybe$Just(_p188._1._1)
															}));
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'bad stroke: ',
															_user$project$ValUnparser$strVal(_p189)));
												}
											}
										} else {
											break _v100_19;
										}
									case 'color':
										if ((_p185._1._0.ctor === '::') && (_p185._1._0._1.ctor === '::')) {
											if (_p185._1._0._1._1.ctor === '::') {
												if ((_p185._1._0._1._1._1.ctor === '::') && (_p185._1._0._1._1._1._1.ctor === '[]')) {
													return A2(
														_elm_lang$core$Result$map,
														_user$project$LangSvg$ARgba,
														_user$project$LangSvg$valsToRgba(
															{
																ctor: '::',
																_0: _p185._1._0._0,
																_1: {
																	ctor: '::',
																	_0: _p185._1._0._1._0,
																	_1: {
																		ctor: '::',
																		_0: _p185._1._0._1._1._0,
																		_1: {
																			ctor: '::',
																			_0: _p185._1._0._1._1._1._0,
																			_1: {ctor: '[]'}
																		}
																	}
																}
															}));
												} else {
													break _v100_19;
												}
											} else {
												var _p191 = _p185._1._0._1._0;
												var _p190 = {ctor: '_Tuple2', _0: _p185._1._0._0.v_, _1: _p191.v_};
												if (((_p190.ctor === '_Tuple2') && (_p190._0.ctor === 'VConst')) && (_p190._1.ctor === 'VConst')) {
													return _elm_lang$core$Result$Ok(
														_user$project$LangSvg$AColorNum(
															{
																ctor: '_Tuple2',
																_0: _p190._0._1,
																_1: _elm_lang$core$Maybe$Just(_p190._1._1)
															}));
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'bad color: ',
															_user$project$ValUnparser$strVal(_p191)));
												}
											}
										} else {
											break _v100_19;
										}
									case 'background-color':
										if ((_p185._1._0.ctor === '::') && (_p185._1._0._1.ctor === '::')) {
											if (_p185._1._0._1._1.ctor === '::') {
												if ((_p185._1._0._1._1._1.ctor === '::') && (_p185._1._0._1._1._1._1.ctor === '[]')) {
													return A2(
														_elm_lang$core$Result$map,
														_user$project$LangSvg$ARgba,
														_user$project$LangSvg$valsToRgba(
															{
																ctor: '::',
																_0: _p185._1._0._0,
																_1: {
																	ctor: '::',
																	_0: _p185._1._0._1._0,
																	_1: {
																		ctor: '::',
																		_0: _p185._1._0._1._1._0,
																		_1: {
																			ctor: '::',
																			_0: _p185._1._0._1._1._1._0,
																			_1: {ctor: '[]'}
																		}
																	}
																}
															}));
												} else {
													break _v100_19;
												}
											} else {
												var _p193 = _p185._1._0._1._0;
												var _p192 = {ctor: '_Tuple2', _0: _p185._1._0._0.v_, _1: _p193.v_};
												if (((_p192.ctor === '_Tuple2') && (_p192._0.ctor === 'VConst')) && (_p192._1.ctor === 'VConst')) {
													return _elm_lang$core$Result$Ok(
														_user$project$LangSvg$AColorNum(
															{
																ctor: '_Tuple2',
																_0: _p192._0._1,
																_1: _elm_lang$core$Maybe$Just(_p192._1._1)
															}));
												} else {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'bad background-color: ',
															_user$project$ValUnparser$strVal(_p193)));
												}
											}
										} else {
											break _v100_19;
										}
									case 'd':
										return A2(
											_elm_lang$core$Result$map,
											_user$project$LangSvg$APath2,
											_user$project$LangSvg$valsToPath2(_p185._1._0));
									case 'transform':
										return A2(
											_elm_lang$core$Result$map,
											_user$project$LangSvg$ATransform,
											_user$project$LangSvg$valsToTransform(_p185._1._0));
									case 'BOUNDS':
										return A2(
											_elm_lang$core$Result$map,
											_user$project$LangSvg$ABounds,
											_user$project$LangSvg$valToBounds(_p185._1._0));
									case 'style':
										return A2(
											_elm_lang$core$Result$map,
											_user$project$LangSvg$AStyle,
											_user$project$LangSvg$valToStyle(_p185._1._0));
									default:
										break _v100_19;
								}
							case 'VConst':
								switch (_p185._0) {
									case 'fill':
										return _elm_lang$core$Result$Ok(
											_user$project$LangSvg$AColorNum(
												{ctor: '_Tuple2', _0: _p185._1._1, _1: _elm_lang$core$Maybe$Nothing}));
									case 'stroke':
										return _elm_lang$core$Result$Ok(
											_user$project$LangSvg$AColorNum(
												{ctor: '_Tuple2', _0: _p185._1._1, _1: _elm_lang$core$Maybe$Nothing}));
									case 'color':
										return _elm_lang$core$Result$Ok(
											_user$project$LangSvg$AColorNum(
												{ctor: '_Tuple2', _0: _p185._1._1, _1: _elm_lang$core$Maybe$Nothing}));
									case 'background-color':
										return _elm_lang$core$Result$Ok(
											_user$project$LangSvg$AColorNum(
												{ctor: '_Tuple2', _0: _p185._1._1, _1: _elm_lang$core$Maybe$Nothing}));
									default:
										return _elm_lang$core$Result$Ok(
											_user$project$LangSvg$ANum(_p185._1._1));
								}
							case 'VBase':
								if (_p185._1._0.ctor === 'VString') {
									return _elm_lang$core$Result$Ok(
										_user$project$LangSvg$AString(_p185._1._0._0));
								} else {
									break _v100_19;
								}
							default:
								break _v100_19;
						}
					} else {
						break _v100_19;
					}
				} while(false);
				return _elm_lang$core$Result$Err(
					A2(
						_elm_lang$core$Basics_ops['++'],
						'bad SVG attribute value for ',
						A2(
							_elm_lang$core$Basics_ops['++'],
							_p194,
							A2(
								_elm_lang$core$Basics_ops['++'],
								': ',
								_user$project$ValUnparser$strVal(_p195)))));
			}();
			return A2(
				_elm_lang$core$Result$map,
				function (av) {
					return {
						ctor: '_Tuple2',
						_0: _p194,
						_1: {interpreted: av, val: _p195}
					};
				},
				avRes);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'malformed attribute pair: ',
					_user$project$ValUnparser$strVal(v)));
		}
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'malformed attribute list, bad element: ',
				_user$project$ValUnparser$strVal(v)));
	}
};
var _user$project$LangSvg$valToStyle = function (vs) {
	return A3(
		_elm_lang$core$List$foldr,
		F2(
			function (v, acc) {
				return A2(
					_elm_lang$core$Result$andThen,
					function (styles) {
						return A2(
							_elm_lang$core$Result$andThen,
							function (attr) {
								return _elm_lang$core$Result$Ok(
									{ctor: '::', _0: attr, _1: styles});
							},
							_user$project$LangSvg$valToCssAttr(v));
					},
					acc);
			}),
		_elm_lang$core$Result$Ok(
			{ctor: '[]'}),
		vs);
};
var _user$project$LangSvg$valToCssAttr = _user$project$LangSvg$valToAttr;
var _user$project$LangSvg$SvgNode = F3(
	function (a, b, c) {
		return {ctor: 'SvgNode', _0: a, _1: b, _2: c};
	});
var _user$project$LangSvg$dummySvgNode = function () {
	var zero = _user$project$LangSvg$aNum(
		{ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$dummyTrace});
	return A3(
		_user$project$LangSvg$SvgNode,
		'circle',
		A2(
			_elm_lang$core$List$map,
			function (k) {
				return {ctor: '_Tuple2', _0: k, _1: zero};
			},
			{
				ctor: '::',
				_0: 'cx',
				_1: {
					ctor: '::',
					_0: 'cy',
					_1: {
						ctor: '::',
						_0: 'r',
						_1: {ctor: '[]'}
					}
				}
			}),
		{ctor: '[]'});
}();
var _user$project$LangSvg$TextNode = function (a) {
	return {ctor: 'TextNode', _0: a};
};
var _user$project$LangSvg$valToIndexedTree_ = F2(
	function (v, _p196) {
		var _p197 = _p196;
		var _p210 = _p197._0;
		var _p209 = _p197._1;
		var thunk = function (_p198) {
			var _p199 = _p198;
			var _p200 = v.v_;
			if (_p200.ctor === 'VList') {
				var _p201 = A2(
					_elm_lang$core$List$map,
					function (_) {
						return _.v_;
					},
					_p200._0);
				_v108_3:
				do {
					if ((((_p201.ctor === '::') && (_p201._0.ctor === 'VBase')) && (_p201._0._0.ctor === 'VString')) && (_p201._1.ctor === '::')) {
						if (_p201._1._1.ctor === '[]') {
							if ((_p201._1._0.ctor === 'VBase') && (_p201._1._0._0.ctor === 'VString')) {
								switch (_p201._0._0._0) {
									case 'TEXT':
										var node = {
											interpreted: _user$project$LangSvg$TextNode(_p201._1._0._0._0),
											val: v
										};
										return _elm_lang$core$Result$Ok(
											{
												ctor: '_Tuple2',
												_0: 1 + _p210,
												_1: A3(_elm_lang$core$Dict$insert, _p210, node, _p209)
											});
									case 'COMMENT':
										return A2(
											_elm_lang$core$Result$map,
											function (attrs) {
												var node = {
													interpreted: A3(
														_user$project$LangSvg$SvgNode,
														'comment',
														attrs,
														{ctor: '[]'}),
													val: v
												};
												return {
													ctor: '_Tuple2',
													_0: 1 + _p210,
													_1: A3(_elm_lang$core$Dict$insert, _p210, node, _p209)
												};
											},
											_user$project$Utils$projOk(
												A2(
													_elm_lang$core$List$map,
													_user$project$LangSvg$valToAttr,
													{
														ctor: '::',
														_0: A4(
															_user$project$ValBuilder$viewtuple2,
															_user$project$ValBuilder$string,
															_user$project$ValBuilder$string,
															_user$project$ValBuilder$fromVal(v),
															{ctor: '_Tuple2', _0: 'title', _1: _p201._1._0._0._0}),
														_1: {
															ctor: '::',
															_0: A4(
																_user$project$ValBuilder$viewtuple2,
																_user$project$ValBuilder$string,
																_user$project$ValBuilder$list(
																	A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$string)),
																_user$project$ValBuilder$fromVal(v),
																{
																	ctor: '_Tuple2',
																	_0: 'style',
																	_1: {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: 'display', _1: 'none'},
																		_1: {ctor: '[]'}
																	}
																}),
															_1: {ctor: '[]'}
														}
													})));
									default:
										break _v108_3;
								}
							} else {
								break _v108_3;
							}
						} else {
							if (((_p201._1._0.ctor === 'VList') && (_p201._1._1._0.ctor === 'VList')) && (_p201._1._1._1.ctor === '[]')) {
								var processChild = F2(
									function (vi, acc) {
										var _p202 = acc;
										if (_p202.ctor === 'Err') {
											return acc;
										} else {
											return A2(
												_elm_lang$core$Result$map,
												function (_p203) {
													var _p204 = _p203;
													var _p205 = _p204._0;
													var a_children_ = {ctor: '::', _0: _p205 - 1, _1: _p202._0._2};
													return {ctor: '_Tuple3', _0: _p205, _1: _p204._1, _2: a_children_};
												},
												A2(
													_user$project$LangSvg$valToIndexedTree_,
													vi,
													{ctor: '_Tuple2', _0: _p202._0._0, _1: _p202._0._1}));
										}
									});
								return A2(
									_elm_lang$core$Result$andThen,
									function (_p206) {
										var _p207 = _p206;
										var _p208 = _p207._0;
										return A2(
											_elm_lang$core$Result$map,
											function (attrs) {
												var node = {
													interpreted: A3(
														_user$project$LangSvg$SvgNode,
														_p201._0._0._0,
														attrs,
														_elm_lang$core$List$reverse(_p207._2)),
													val: v
												};
												return {
													ctor: '_Tuple2',
													_0: 1 + _p208,
													_1: A3(_elm_lang$core$Dict$insert, _p208, node, _p207._1)
												};
											},
											_user$project$Utils$projOk(
												A2(_elm_lang$core$List$map, _user$project$LangSvg$valToAttr, _p201._1._0._0)));
									},
									A3(
										_elm_lang$core$List$foldl,
										processChild,
										_elm_lang$core$Result$Ok(
											{
												ctor: '_Tuple3',
												_0: _p210,
												_1: _p209,
												_2: {ctor: '[]'}
											}),
										_p201._1._1._0._0));
							} else {
								break _v108_3;
							}
						}
					} else {
						break _v108_3;
					}
				} while(false);
				return A2(
					_user$project$LangSvg$expectedButGot,
					'an SVG node',
					_user$project$LangUtils$valToString(v));
			} else {
				return A2(
					_user$project$LangSvg$expectedButGot,
					'an SVG node',
					_user$project$LangUtils$valToString(v));
			}
		};
		return _user$project$Utils$unwrapNestedResult(
			_user$project$ImpureGoodies$crashToError(thunk));
	});
var _user$project$LangSvg$valToIndexedTree = function (v) {
	var thunk = function (_p211) {
		var _p212 = _p211;
		return A2(
			_elm_lang$core$Result$map,
			function (_p213) {
				var _p214 = _p213;
				var rootId = _p214._0 - 1;
				return {ctor: '_Tuple2', _0: rootId, _1: _p214._1};
			},
			A2(
				_user$project$LangSvg$valToIndexedTree_,
				v,
				{ctor: '_Tuple2', _0: 1, _1: _elm_lang$core$Dict$empty}));
	};
	return thunk(
		{ctor: '_Tuple0'});
};
var _user$project$LangSvg$fetchEverything = F5(
	function (syntax, slideNumber, movieNumber, movieTime, val) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (_p215) {
				var _p216 = _p215;
				return A2(
					_elm_lang$core$Result$map,
					function (indexedTree) {
						return {ctor: '_Tuple5', _0: _p216._0, _1: _p216._1, _2: _p216._2, _3: _p216._3, _4: indexedTree};
					},
					_user$project$LangSvg$valToIndexedTree(_p216._4));
			},
			A5(_user$project$LangSvg$fetchEverything_, syntax, slideNumber, movieNumber, movieTime, val));
	});
var _user$project$LangSvg$resolveToRootedIndexedTree = F5(
	function (syntax, slideNumber, movieNumber, movieTime, val) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p217) {
				var _p218 = _p217;
				return _p218._4;
			},
			A5(_user$project$LangSvg$fetchEverything, syntax, slideNumber, movieNumber, movieTime, val));
	});

var _user$project$ExpUnbuilder$identity = function (e) {
	return _elm_lang$core$Result$Ok(e);
};
var _user$project$ExpUnbuilder$int = function (e) {
	var _p0 = _user$project$Lang$unwrapExp(e);
	if (_p0.ctor === 'EConst') {
		return _elm_lang$core$Result$Ok(
			_elm_lang$core$Basics$floor(_p0._1));
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a constant, got ',
				A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
	}
};
var _user$project$ExpUnbuilder$string = function (e) {
	var _p1 = _user$project$Lang$unwrapExp(e);
	if ((_p1.ctor === 'EBase') && (_p1._1.ctor === 'EString')) {
		return _elm_lang$core$Result$Ok(_p1._1._1);
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Expected a string, got ',
				A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
	}
};
var _user$project$ExpUnbuilder$viewtuple2 = F3(
	function (sub1, sub2, e) {
		var _p2 = _user$project$Lang$unwrapExp(e);
		if (((((((_p2.ctor === 'EList') && (_p2._1.ctor === '::')) && (_p2._1._0.ctor === '_Tuple2')) && (_p2._1._1.ctor === '::')) && (_p2._1._1._0.ctor === '_Tuple2')) && (_p2._1._1._1.ctor === '[]')) && (_p2._3.ctor === 'Nothing')) {
			return A3(
				_elm_lang$core$Result$map2,
				F2(
					function (a, b) {
						return {ctor: '_Tuple2', _0: a, _1: b};
					}),
				sub1(_p2._1._0._1),
				sub2(_p2._1._1._0._1));
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a 2-element list, got ',
					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
		}
	});
var _user$project$ExpUnbuilder$list = F2(
	function (sub, e) {
		var _p3 = _user$project$Lang$unwrapExp(e);
		if ((_p3.ctor === 'EList') && (_p3._3.ctor === 'Nothing')) {
			return _user$project$Utils$projOk(
				A2(
					_elm_lang$core$List$map,
					sub,
					_user$project$Utils$listValues(_p3._1)));
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a list, got ',
					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
		}
	});

var _user$project$Update$buildUpdatedValueFromHtmlString = function (htmlEditorString) {
	return A2(
		_elm_lang$core$Result$andThen,
		function (nodes) {
			var _p0 = nodes;
			if (_p0.ctor === '[]') {
				return _elm_lang$core$Result$Err('No nodes');
			} else {
				return _elm_lang$core$Result$Ok(
					A2(
						_user$project$HTMLValParser$htmlNodeToElmViewInLeo,
						_user$project$ValBuilder$fromVal(
							A2(
								_user$project$Lang$builtinVal,
								'buildUpdatedValueFromHtmlString',
								_user$project$Lang$VBase(
									_user$project$Lang$VString('')))),
						_p0._0));
			}
		},
		A2(
			_elm_lang$core$Result$mapError,
			_user$project$ParserUtils$showError,
			_user$project$HTMLParser$parseHTMLString(htmlEditorString)));
};
var _user$project$Update$doEvalwUpdate = F3(
	function (env, exp, callback) {
		var _p1 = A4(_user$project$Eval$doEval, _user$project$Eval$withoutParentsProvenanceWidgets, _user$project$Syntax$Leo, env, exp);
		if (_p1.ctor === 'Err') {
			return _user$project$UpdateStack$UpdateCriticalError(_p1._0);
		} else {
			return callback(_p1._0);
		}
	});
var _user$project$Update$doEvalw = A2(_user$project$Eval$doEval, _user$project$Eval$withoutParentsProvenanceWidgets, _user$project$Syntax$Leo);
var _user$project$Update$buildUpdatedValueFromEditorString = F2(
	function (syntax, valueEditorString) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p2) {
				var _p3 = _p2;
				return _p3._0._0;
			},
			A2(
				_elm_lang$core$Result$andThen,
				_user$project$Update$doEvalw(
					{ctor: '[]'}),
				A2(
					_elm_lang$core$Result$mapError,
					function (e) {
						return _user$project$ParserUtils$showError(e);
					},
					A2(_user$project$Syntax$parser, syntax, valueEditorString))));
	});
var _user$project$Update$val = function (v_) {
	return A3(
		_user$project$Lang$Val,
		v_,
		A3(
			_user$project$Lang$Provenance,
			{ctor: '[]'},
			_user$project$Lang$eVar('DUMMYEXP'),
			{ctor: '[]'}),
		_user$project$Lang$Parents(
			{ctor: '[]'}));
};
var _user$project$Update$vStr = function (_p4) {
	return _user$project$Update$val(
		_user$project$Lang$VBase(
			_user$project$Lang$VString(_p4)));
};
var _user$project$Update$vConst = function (_p5) {
	return _user$project$Update$val(
		A2(_user$project$Lang$VConst, _elm_lang$core$Maybe$Nothing, _p5));
};
var _user$project$Update$vList = function (_p6) {
	return _user$project$Update$val(
		_user$project$Lang$VList(_p6));
};
var _user$project$Update$removeCommonPrefix = F2(
	function (l1, l2) {
		removeCommonPrefix:
		while (true) {
			var _p7 = {ctor: '_Tuple2', _0: l1, _1: l2};
			if (_p7._0.ctor === '[]') {
				return {ctor: '_Tuple2', _0: l1, _1: l2};
			} else {
				if (_p7._1.ctor === '[]') {
					return {ctor: '_Tuple2', _0: l1, _1: l2};
				} else {
					if (_elm_lang$core$Native_Utils.eq(_p7._0._0, _p7._1._0)) {
						var _v4 = _p7._0._1,
							_v5 = _p7._1._1;
						l1 = _v4;
						l2 = _v5;
						continue removeCommonPrefix;
					} else {
						return {ctor: '_Tuple2', _0: l1, _1: l2};
					}
				}
			}
		}
	});
var _user$project$Update$eBaseToVBase = function (eBaseVal) {
	var _p8 = eBaseVal;
	switch (_p8.ctor) {
		case 'EBool':
			return _user$project$Lang$VBool(_p8._0);
		case 'EString':
			return _user$project$Lang$VString(_p8._1);
		default:
			return _user$project$Lang$VNull;
	}
};
var _user$project$Update$getNum = function (v) {
	var _p9 = v.v_;
	_v7_2:
	do {
		switch (_p9.ctor) {
			case 'VConst':
				if (_p9._1.ctor === '_Tuple2') {
					return _elm_lang$core$Result$Ok(_p9._1._0);
				} else {
					break _v7_2;
				}
			case 'VBase':
				if (_p9._0.ctor === 'VString') {
					return _elm_lang$core$String$toFloat(_p9._0._0);
				} else {
					break _v7_2;
				}
			default:
				break _v7_2;
		}
	} while(false);
	return _elm_lang$core$Result$Err(
		A2(
			_elm_lang$core$Basics_ops['++'],
			'Cannot replace a number with ',
			_user$project$LangUtils$valToString(v)));
};
var _user$project$Update$consWithInversion = F2(
	function (pv, menv) {
		var _p10 = {
			ctor: '_Tuple2',
			_0: _user$project$Update$matchWithInversion(pv),
			_1: menv
		};
		if (((((_p10.ctor === '_Tuple2') && (_p10._0.ctor === 'Just')) && (_p10._0._0.ctor === '_Tuple2')) && (_p10._1.ctor === 'Just')) && (_p10._1._0.ctor === '_Tuple2')) {
			var _p12 = _p10._0._0._0;
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Basics_ops['++'], _p12, _p10._1._0._0),
					_1: function (newUpdatedEnv) {
						var _p11 = A2(
							_user$project$UpdatedEnv$split,
							_elm_lang$core$List$length(_p12),
							newUpdatedEnv);
						var newUpdatedEnv_ = _p11._0;
						var newUpdatedEnvTail = _p11._1;
						var newpv = _user$project$UpdatedEnv$isUnmodified(newUpdatedEnv_) ? {
							ctor: '_Tuple2',
							_0: _elm_lang$core$Tuple$second(pv),
							_1: _elm_lang$core$Maybe$Nothing
						} : _p10._0._0._1(newUpdatedEnv_);
						return {
							ctor: '_Tuple2',
							_0: newpv,
							_1: _p10._1._0._1(newUpdatedEnvTail)
						};
					}
				});
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Update$matchWithInversion = function (_p13) {
	var _p14 = _p13;
	var _p76 = _p14._1;
	var _p75 = _p14._0;
	var _p15 = {ctor: '_Tuple2', _0: _p75.val.p__, _1: _p76.v_};
	_v10_5:
	do {
		switch (_p15._0.ctor) {
			case 'PWildcard':
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: {ctor: '[]'},
						_1: function (newUpdatedEnv) {
							var _p16 = newUpdatedEnv.val;
							if (_p16.ctor === '[]') {
								return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
							} else {
								return _elm_lang$core$Native_Utils.crashCase(
									'Update',
									{
										start: {line: 1937, column: 6},
										end: {line: 1939, column: 138}
									},
									_p16)(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Not the same shape before/after pattern update: ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$LangUtils$envToString(newUpdatedEnv.val),
											' should have length 0')));
							}
						}
					});
			case 'PVar':
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: {
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _p15._0._1, _1: _p76},
							_1: {ctor: '[]'}
						},
						_1: function (newUpdatedEnv) {
							var _p18 = {ctor: '_Tuple2', _0: newUpdatedEnv.val, _1: newUpdatedEnv.changes};
							_v12_2:
							do {
								if (_p18.ctor === '_Tuple2') {
									if (_p18._1.ctor === '::') {
										if ((((((_p18._0.ctor === '::') && (_p18._0._0.ctor === '_Tuple2')) && (_p18._0._1.ctor === '[]')) && (_p18._1._0.ctor === '_Tuple2')) && (_p18._1._0._0 === 0)) && (_p18._1._1.ctor === '[]')) {
											return {
												ctor: '_Tuple2',
												_0: _p18._0._0._1,
												_1: _elm_lang$core$Maybe$Just(_p18._1._0._1)
											};
										} else {
											break _v12_2;
										}
									} else {
										return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
									}
								} else {
									break _v12_2;
								}
							} while(false);
							return _elm_lang$core$Native_Utils.crashCase(
								'Update',
								{
									start: {line: 1942, column: 6},
									end: {line: 1945, column: 138}
								},
								_p18)(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Not the same shape before/after pattern update: ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$envToString(newUpdatedEnv.val),
										' should have length 1')));
						}
					});
			case 'PAs':
				var _p23 = _p15._0._3;
				var pat2Size = _elm_lang$core$List$length(
					_user$project$Lang$identifiersListInPat(_p23));
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p20) {
						var _p21 = _p20;
						return {
							ctor: '_Tuple2',
							_0: _p21._0,
							_1: function (newUpdatedEnv) {
								if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
									return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
								} else {
									var _p22 = _p21._1(newUpdatedEnv);
									return A5(_user$project$UpdateUtils$mergeValMaybe, _p76, _p22._0._0, _p22._0._1, _p22._1._0, _p22._1._1);
								}
							}
						};
					},
					A2(
						_user$project$Update$consWithInversion,
						{ctor: '_Tuple2', _0: _p23, _1: _p76},
						_user$project$Update$matchWithInversion(
							{ctor: '_Tuple2', _0: _p15._0._1, _1: _p76})));
			case 'PList':
				if (_p15._0._3.ctor === 'Nothing') {
					if (_p15._1.ctor === 'VList') {
						var _p32 = _p15._1._0;
						var _p31 = _p15._0._1;
						return (!_elm_lang$core$Native_Utils.eq(
							_elm_lang$core$List$length(_p31),
							_elm_lang$core$List$length(_p32))) ? _elm_lang$core$Maybe$Nothing : A2(
							_elm_lang$core$Maybe$map,
							function (_p24) {
								var _p25 = _p24;
								return {
									ctor: '_Tuple2',
									_0: _p25._0,
									_1: function (newUpdatedEnv) {
										if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
											return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
										} else {
											var _p26 = _p25._1(newUpdatedEnv);
											var newVals = _p26._0;
											var newValsDiffs = _p26._1;
											var _p27 = function () {
												var _p28 = newValsDiffs;
												if (_p28.ctor === '[]') {
													return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
												} else {
													return {
														ctor: '_Tuple2',
														_0: A2(
															_user$project$Lang$replaceV_,
															_p76,
															_user$project$Lang$VList(newVals)),
														_1: _elm_lang$core$Maybe$Just(
															_user$project$Lang$VListDiffs(
																A2(
																	_elm_lang$core$List$map,
																	function (_p29) {
																		var _p30 = _p29;
																		return {
																			ctor: '_Tuple2',
																			_0: _p30._0,
																			_1: _user$project$Lang$ListElemUpdate(_p30._1)
																		};
																	},
																	newValsDiffs)))
													};
												}
											}();
											var newVal = _p27._0;
											var newValDiff = _p27._1;
											return {ctor: '_Tuple2', _0: newVal, _1: newValDiff};
										}
									}
								};
							},
							_user$project$Update$matchListWithInversion(
								{ctor: '_Tuple2', _0: _p31, _1: _p32}));
					} else {
						break _v10_5;
					}
				} else {
					if (_p15._1.ctor === 'VList') {
						var _p46 = _p15._1._0;
						var _p45 = _p15._0._1;
						var _p33 = {
							ctor: '_Tuple2',
							_0: _elm_lang$core$List$length(_p45),
							_1: _elm_lang$core$List$length(_p46)
						};
						var n = _p33._0;
						var m = _p33._1;
						if (_elm_lang$core$Native_Utils.cmp(n, m) > 0) {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							var _p34 = A2(_user$project$Utils$split, n, _p46);
							var vs1 = _p34._0;
							var oldTailVals = _p34._1;
							var oldTailVal = A2(
								_user$project$Lang$replaceV_,
								_p76,
								_user$project$Lang$VList(oldTailVals));
							return A2(
								_elm_lang$core$Maybe$map,
								function (_p35) {
									var _p36 = _p35;
									return {
										ctor: '_Tuple2',
										_0: _p36._0,
										_1: function (newUpdatedEnv) {
											if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
												return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
											} else {
												var _p37 = _p36._1(newUpdatedEnv);
												var newTailVal = _p37._0._0;
												var mbTailValDiffs = _p37._0._1;
												var newVals = _p37._1._0;
												var mbValsDiffs = _p37._1._1;
												var _p38 = function () {
													var _p39 = {ctor: '_Tuple3', _0: mbValsDiffs, _1: newTailVal.v_, _2: mbTailValDiffs};
													_v19_2:
													do {
														if (_p39.ctor === '_Tuple3') {
															if ((_p39._0.ctor === '[]') && (_p39._2.ctor === 'Nothing')) {
																return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
															} else {
																if (_p39._1.ctor === 'VList') {
																	return {
																		ctor: '_Tuple2',
																		_0: A2(
																			_user$project$Lang$replaceV_,
																			_p76,
																			_user$project$Lang$VList(
																				A2(_elm_lang$core$Basics_ops['++'], newVals, _p39._1._0))),
																		_1: _elm_lang$core$Maybe$Just(
																			_user$project$Lang$VListDiffs(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					A2(
																						_elm_lang$core$List$map,
																						function (_p40) {
																							var _p41 = _p40;
																							return {
																								ctor: '_Tuple2',
																								_0: _p41._0,
																								_1: _user$project$Lang$ListElemUpdate(_p41._1)
																							};
																						},
																						mbValsDiffs),
																					function () {
																						var _p42 = mbTailValDiffs;
																						if (_p42.ctor === 'Nothing') {
																							return {ctor: '[]'};
																						} else {
																							if (_p42._0.ctor === 'VListDiffs') {
																								return A2(
																									_user$project$UpdateUtils$offset,
																									_elm_lang$core$List$length(_p45),
																									_p42._0._0);
																							} else {
																								return _elm_lang$core$Native_Utils.crashCase(
																									'Update',
																									{
																										start: {line: 1992, column: 102},
																										end: {line: 1996, column: 108}
																									},
																									_p42)(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'Expected VListDiffs, got ',
																										_elm_lang$core$Basics$toString(_p42._0)));
																							}
																						}
																					}())))
																	};
																} else {
																	break _v19_2;
																}
															}
														} else {
															break _v19_2;
														}
													} while(false);
													return _elm_lang$core$Native_Utils.crashCase(
														'Update',
														{
															start: {line: 1988, column: 43},
															end: {line: 1998, column: 96}
														},
														_p39)(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'RHS of list pattern is not a list: ',
															_user$project$LangUtils$valToString(newTailVal)));
												}();
												var finalVal = _p38._0;
												var finalValDiffs = _p38._1;
												return {ctor: '_Tuple2', _0: finalVal, _1: finalValDiffs};
											}
										}
									};
								},
								A2(
									_user$project$Update$consWithInversion,
									{ctor: '_Tuple2', _0: _p15._0._3._0, _1: oldTailVal},
									_user$project$Update$matchListWithInversion(
										{ctor: '_Tuple2', _0: _p45, _1: vs1})));
						}
					} else {
						break _v10_5;
					}
				}
			case 'PConst':
				if ((_p15._1.ctor === 'VConst') && (_p15._1._1.ctor === '_Tuple2')) {
					return _elm_lang$core$Native_Utils.eq(_p15._0._1, _p15._1._1._0) ? _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple2',
							_0: {ctor: '[]'},
							_1: function (newEnv) {
								return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
							}
						}) : _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			case 'PBase':
				if (_p15._1.ctor === 'VBase') {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Update$eBaseToVBase(_p15._0._1),
						_p15._1._0) ? _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple2',
							_0: {ctor: '[]'},
							_1: function (newEnv) {
								return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
							}
						}) : _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			case 'PParens':
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p47) {
						var _p48 = _p47;
						return {
							ctor: '_Tuple2',
							_0: _p48._0,
							_1: function (newUpdatedEnv) {
								if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
									return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
								} else {
									var _p49 = _p48._1(newUpdatedEnv);
									return {ctor: '_Tuple2', _0: _p49._0, _1: _p49._1};
								}
							}
						};
					},
					_user$project$Update$matchWithInversion(
						{ctor: '_Tuple2', _0: _p15._0._1, _1: _p76}));
			case 'PRecord':
				if (_p15._1.ctor === 'VRecord') {
					var _p71 = _p15._0._1;
					var _p70 = _p15._1._0;
					return A2(
						_elm_lang$core$Maybe$map,
						function (_p50) {
							var _p51 = _p50;
							return {
								ctor: '_Tuple2',
								_0: _p51._0,
								_1: function (newUpdatedEnv) {
									if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
										return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
									} else {
										var _p52 = _p51._1(newUpdatedEnv);
										var newVals = _p52._0;
										var newValsDiffs = _p52._1;
										var _p53 = function () {
											var _p54 = newValsDiffs;
											if (_p54.ctor === '[]') {
												return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
											} else {
												return {
													ctor: '_Tuple2',
													_0: A2(
														_user$project$Lang$replaceV_,
														_p76,
														_user$project$Lang$VRecord(
															A3(
																_elm_lang$core$List$foldl,
																F2(
																	function (_p55, dTemp) {
																		var _p56 = _p55;
																		var k = _user$project$Utils$recordKey(_p56._0);
																		return A3(_elm_lang$core$Dict$insert, k, _p56._1, dTemp);
																	}),
																_p70,
																A2(_user$project$Utils$zip, _p71, newVals)))),
													_1: _elm_lang$core$Maybe$Just(
														_user$project$Lang$VRecordDiffs(
															function (_p57) {
																var _p58 = _p57;
																return _p58._0;
															}(
																A3(
																	_elm_lang$core$List$foldl,
																	F2(
																		function (_p60, _p59) {
																			var _p61 = _p60;
																			var _p66 = _p61._0;
																			var _p62 = _p59;
																			var _p63 = A2(_user$project$Utils$split, _p66 - _p62._2, _p62._1);
																			var discardedPts = _p63._0;
																			var nextPts = _p63._1;
																			var _p64 = nextPts;
																			if ((_p64.ctor === '::') && (_p64._0.ctor === '_Tuple5')) {
																				return {
																					ctor: '_Tuple3',
																					_0: A3(_elm_lang$core$Dict$insert, _p64._0._2, _p61._1, _p62._0),
																					_1: nextPts,
																					_2: _p66
																				};
																			} else {
																				return _elm_lang$core$Native_Utils.crashCase(
																					'Update',
																					{
																						start: {line: 2036, column: 19},
																						end: {line: 2039, column: 162}
																					},
																					_p64)(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'Expected modification at index ',
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							_elm_lang$core$Basics$toString(_p66),
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								' but the list of patterns is ',
																								A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, _p75)))));
																			}
																		}),
																	{ctor: '_Tuple3', _0: _elm_lang$core$Dict$empty, _1: _p71, _2: 0},
																	newValsDiffs))))
												};
											}
										}();
										var newVal = _p53._0;
										var newValDiff = _p53._1;
										return {ctor: '_Tuple2', _0: newVal, _1: newValDiff};
									}
								}
							};
						},
						A2(
							_elm_lang$core$Maybe$andThen,
							function (_p67) {
								return _user$project$Update$matchListWithInversion(
									_elm_lang$core$List$unzip(_p67));
							},
							_user$project$Utils$projJusts(
								A2(
									_elm_lang$core$List$map,
									function (_p68) {
										var _p69 = _p68;
										return A2(
											_elm_lang$core$Maybe$map,
											function (v) {
												return {ctor: '_Tuple2', _0: _p69._4, _1: v};
											},
											A2(_elm_lang$core$Dict$get, _p69._2, _p70));
									},
									_p71))));
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			default:
				return A2(_user$project$Types$valIsType, _p76, _p15._0._3) ? A2(
					_elm_lang$core$Maybe$map,
					function (_p72) {
						var _p73 = _p72;
						return {
							ctor: '_Tuple2',
							_0: _p73._0,
							_1: function (newUpdatedEnv) {
								if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
									return {ctor: '_Tuple2', _0: _p76, _1: _elm_lang$core$Maybe$Nothing};
								} else {
									var _p74 = _p73._1(newUpdatedEnv);
									return {ctor: '_Tuple2', _0: _p74._0, _1: _p74._1};
								}
							}
						};
					},
					_user$project$Update$matchWithInversion(
						{ctor: '_Tuple2', _0: _p15._0._1, _1: _p76})) : _elm_lang$core$Maybe$Nothing;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$Update$matchListWithInversion = function (_p77) {
	var _p78 = _p77;
	var _p94 = _p78._1;
	var _p93 = _p78._0;
	var l = _elm_lang$core$List$length(_p93);
	var inverse_index = function (i) {
		return (l - 1) - i;
	};
	return A2(
		_elm_lang$core$Maybe$map,
		function (_p79) {
			var _p80 = _p79;
			return {
				ctor: '_Tuple2',
				_0: _p80._0,
				_1: function (newUpdatedEnv) {
					if (_user$project$UpdatedEnv$isUnmodified(newUpdatedEnv)) {
						return {
							ctor: '_Tuple2',
							_0: _p94,
							_1: {ctor: '[]'}
						};
					} else {
						var _p81 = A3(
							_elm_lang$core$List$foldl,
							F2(
								function (_p83, _p82) {
									var _p84 = _p83;
									var _p85 = _p82;
									var _p88 = _p85._1;
									var i = inverse_index(_p84._1);
									var _p86 = _p84._0(_p85._2);
									var v = _p86._0;
									var vDiff = _p86._1;
									var e = _p86._2;
									var newValsDiffs = function () {
										var _p87 = vDiff;
										if (_p87.ctor === 'Nothing') {
											return _p88;
										} else {
											return {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: i, _1: _p87._0},
												_1: _p88
											};
										}
									}();
									return {
										ctor: '_Tuple3',
										_0: {ctor: '::', _0: v, _1: _p85._0},
										_1: newValsDiffs,
										_2: e
									};
								}),
							{
								ctor: '_Tuple3',
								_0: {ctor: '[]'},
								_1: {ctor: '[]'},
								_2: newUpdatedEnv
							},
							_user$project$Utils$zipWithIndex(_p80._1));
						var newVals = _p81._0;
						var newValsDiffs = _p81._1;
						return {ctor: '_Tuple2', _0: newVals, _1: newValsDiffs};
					}
				}
			};
		},
		A3(
			_elm_lang$core$List$foldl,
			F2(
				function (pv, acc) {
					var _p89 = {
						ctor: '_Tuple2',
						_0: acc,
						_1: _user$project$Update$matchWithInversion(pv)
					};
					if (((((_p89.ctor === '_Tuple2') && (_p89._0.ctor === 'Just')) && (_p89._0._0.ctor === '_Tuple2')) && (_p89._1.ctor === 'Just')) && (_p89._1._0.ctor === '_Tuple2')) {
						var _p92 = _p89._1._0._0;
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: A2(_elm_lang$core$Basics_ops['++'], _p92, _p89._0._0._0),
								_1: {
									ctor: '::',
									_0: function (newUpdatedEnv) {
										var _p90 = A2(
											_user$project$UpdatedEnv$split,
											_elm_lang$core$List$length(_p92),
											newUpdatedEnv);
										var headNewUpdatedEnv = _p90._0;
										var tailModifiedNewEnv = _p90._1;
										if (_user$project$UpdatedEnv$isUnmodified(headNewUpdatedEnv)) {
											return {
												ctor: '_Tuple3',
												_0: _elm_lang$core$Tuple$second(pv),
												_1: _elm_lang$core$Maybe$Nothing,
												_2: tailModifiedNewEnv
											};
										} else {
											var _p91 = _p89._1._0._1(headNewUpdatedEnv);
											var newVal = _p91._0;
											var newValDiff = _p91._1;
											return {ctor: '_Tuple3', _0: newVal, _1: newValDiff, _2: tailModifiedNewEnv};
										}
									},
									_1: _p89._0._0._1
								}
							});
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				}),
			_elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: {ctor: '[]'},
					_1: {ctor: '[]'}
				}),
			A2(_user$project$Utils$zip, _p93, _p94)));
};
var _user$project$Update$conssWithInversion = F2(
	function (pvs, menv) {
		var _p95 = {
			ctor: '_Tuple2',
			_0: menv,
			_1: _user$project$Update$matchListWithInversion(pvs)
		};
		if (((((_p95.ctor === '_Tuple2') && (_p95._0.ctor === 'Just')) && (_p95._0._0.ctor === '_Tuple2')) && (_p95._1.ctor === 'Just')) && (_p95._1._0.ctor === '_Tuple2')) {
			var _p97 = _p95._1._0._0;
			return _elm_lang$core$Maybe$Just(
				{
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$Basics_ops['++'], _p97, _p95._0._0._0),
					_1: function (newUpdatedEnv) {
						var _p96 = A2(
							_user$project$UpdatedEnv$split,
							_elm_lang$core$List$length(_p97),
							newUpdatedEnv);
						var newUpdatedEnv_ = _p96._0;
						var newUpdatedEnvTail = _p96._1;
						var newvals = _user$project$UpdatedEnv$isUnmodified(newUpdatedEnv) ? {
							ctor: '_Tuple2',
							_0: _elm_lang$core$Tuple$second(pvs),
							_1: {ctor: '[]'}
						} : _p95._1._0._1(newUpdatedEnv_);
						return {
							ctor: '_Tuple2',
							_0: newvals,
							_1: _p95._0._0._1(newUpdatedEnvTail)
						};
					}
				});
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Update$branchWithInversion = F3(
	function (env, input, branches) {
		var _p98 = branches;
		if (_p98.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p112 = _p98._1;
			var _p111 = _p98._0;
			var _p99 = _p111.val;
			var _p110 = _p99._1;
			var _p100 = A2(
				_user$project$Update$consWithInversion,
				{ctor: '_Tuple2', _0: _p110, _1: input},
				_elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: env,
						_1: function (newUpdatedEnv) {
							return newUpdatedEnv;
						}
					}));
			if (_p100.ctor === 'Nothing') {
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p101) {
						var _p102 = _p101;
						return {
							ctor: '_Tuple2',
							_0: {ctor: '_Tuple2', _0: _p102._0._0, _1: _p102._0._1},
							_1: function (_p103) {
								var _p104 = _p103;
								var _p105 = _p102._1(
									{ctor: '_Tuple2', _0: _p104._0, _1: _p104._1});
								var updatedUpdatedEnv = _p105._0;
								var updatedVal = _p105._1;
								var vdiff = _p105._2;
								var newTailBranches = _p105._3;
								var branchdiffs = _p105._4;
								return {
									ctor: '_Tuple5',
									_0: updatedUpdatedEnv,
									_1: updatedVal,
									_2: vdiff,
									_3: {ctor: '::', _0: _p111, _1: newTailBranches},
									_4: A2(_user$project$UpdateUtils$offset, 1, branchdiffs)
								};
							}
						};
					},
					A3(_user$project$Update$branchWithInversion, env, input, _p112));
			} else {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: {ctor: '_Tuple2', _0: _p100._0._0, _1: _p99._2},
						_1: function (_p106) {
							var _p107 = _p106;
							var _p109 = _p107._1;
							var _p108 = _p100._0._1(_p107._0);
							var updatedVal = _p108._0._0;
							var updatedValDiff = _p108._0._1;
							var newUpdatedEnv = _p108._1;
							var newBranch = A2(
								_user$project$Lang$replaceB__,
								_p111,
								A4(_user$project$Lang$Branch_, _p99._0, _p110, _p109.val, _p99._3));
							var newDiff = {
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: 0, _1: _p109.changes},
								_1: {ctor: '[]'}
							};
							return {
								ctor: '_Tuple5',
								_0: newUpdatedEnv,
								_1: updatedVal,
								_2: updatedValDiff,
								_3: {ctor: '::', _0: newBranch, _1: _p112},
								_4: newDiff
							};
						}
					});
			}
		}
	});
var _user$project$Update$commonPrefix = function () {
	var aux = F3(
		function (prefix, s1, s2) {
			aux:
			while (true) {
				var _p113 = {
					ctor: '_Tuple2',
					_0: _elm_lang$core$String$uncons(s1),
					_1: _elm_lang$core$String$uncons(s2)
				};
				if (_p113._0.ctor === 'Nothing') {
					return prefix;
				} else {
					if (_p113._1.ctor === 'Nothing') {
						return prefix;
					} else {
						var _p114 = _p113._0._0._0;
						if (_elm_lang$core$Native_Utils.eq(_p114, _p113._1._0._0)) {
							var _v48 = A2(
								_elm_lang$core$Basics_ops['++'],
								prefix,
								_elm_lang$core$String$fromChar(_p114)),
								_v49 = _p113._0._0._1,
								_v50 = _p113._1._0._1;
							prefix = _v48;
							s1 = _v49;
							s2 = _v50;
							continue aux;
						} else {
							return prefix;
						}
					}
				}
			}
		});
	return aux('');
}();
var _user$project$Update$commonSuffix = F2(
	function (s1, s2) {
		return _elm_lang$core$String$reverse(
			A2(
				_user$project$Update$commonPrefix,
				_elm_lang$core$String$reverse(s1),
				_elm_lang$core$String$reverse(s2)));
	});
var _user$project$Update$angleUpdate = F3(
	function ($new, old, n) {
		var increment = $new - old;
		return ((_elm_lang$core$Native_Utils.cmp(increment, _elm_lang$core$Basics$pi) < 1) && (_elm_lang$core$Native_Utils.cmp(increment, 0 - _elm_lang$core$Basics$pi) > -1)) ? _user$project$Results$ok1(n + increment) : ((_elm_lang$core$Native_Utils.cmp(increment, _elm_lang$core$Basics$pi) > 0) ? _user$project$Results$ok1((n + increment) - (2 * _elm_lang$core$Basics$pi)) : _user$project$Results$ok1((n + increment) + (2 * _elm_lang$core$Basics$pi)));
	});
var _user$project$Update$maybeUpdateMathOp = F5(
	function (op, operandVals, oldOutVal, newOutVal, diffs) {
		maybeUpdateMathOp:
		while (true) {
			var _p115 = {ctor: '_Tuple3', _0: oldOutVal.v_, _1: newOutVal.v_, _2: op.val};
			_v51_3:
			do {
				if (_p115.ctor === '_Tuple3') {
					switch (_p115._0.ctor) {
						case 'VBase':
							if ((((_p115._0._0.ctor === 'VString') && (_p115._1.ctor === 'VBase')) && (_p115._1._0.ctor === 'VString')) && (_p115._2.ctor === 'Plus')) {
								var operandsStr = _user$project$Utils$projJusts(
									A2(
										_elm_lang$core$List$map,
										function (operand) {
											var _p116 = operand.v_;
											if (_p116.ctor === 'VBase') {
												return _elm_lang$core$Maybe$Just(_p116);
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										},
										operandVals));
								var _p117 = operandsStr;
								if ((((((((_p117.ctor === 'Just') && (_p117._0.ctor === '::')) && (_p117._0._0.ctor === 'VBase')) && (_p117._0._0._0.ctor === 'VString')) && (_p117._0._1.ctor === '::')) && (_p117._0._1._0.ctor === 'VBase')) && (_p117._0._1._0._0.ctor === 'VString')) && (_p117._0._1._1.ctor === '[]')) {
									var _p118 = op.val;
									if (_p118.ctor === 'Plus') {
										return A2(
											_user$project$Results$andThen,
											function (mbvdiff) {
												var _p119 = mbvdiff;
												if (_p119.ctor === 'Just') {
													if (_p119._0.ctor === 'VStringDiffs') {
														return A2(
															_user$project$Results$map,
															function (_p120) {
																var _p121 = _p120;
																var _p123 = _p121._3;
																var _p122 = _p121._1;
																var newA = A2(
																	_user$project$Lang$replaceV_,
																	oldOutVal,
																	_user$project$Lang$VBase(
																		_user$project$Lang$VString(_p121._0)));
																var newB = A2(
																	_user$project$Lang$replaceV_,
																	oldOutVal,
																	_user$project$Lang$VBase(
																		_user$project$Lang$VString(_p121._2)));
																var finalDiffs = A2(
																	_elm_lang$core$Basics_ops['++'],
																	_elm_lang$core$Native_Utils.eq(
																		_p122,
																		{ctor: '[]'}) ? {ctor: '[]'} : {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: 0,
																			_1: _user$project$Lang$VStringDiffs(_p122)
																		},
																		_1: {ctor: '[]'}
																	},
																	_elm_lang$core$Native_Utils.eq(
																		_p123,
																		{ctor: '[]'}) ? {ctor: '[]'} : {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: 1,
																			_1: _user$project$Lang$VStringDiffs(_p123)
																		},
																		_1: {ctor: '[]'}
																	});
																return {
																	ctor: '_Tuple2',
																	_0: {
																		ctor: '::',
																		_0: newA,
																		_1: {
																			ctor: '::',
																			_0: newB,
																			_1: {ctor: '[]'}
																		}
																	},
																	_1: finalDiffs
																};
															},
															A4(_user$project$UpdateUtils$reverseStringConcatenation, _p117._0._0._0._0, _p117._0._1._0._0._0, _p115._1._0._0, _p119._0._0));
													} else {
														return _elm_lang$core$Result$Err(
															A2(
																_elm_lang$core$Basics_ops['++'],
																'Expected VStringDiffs 3, got ',
																_elm_lang$core$Basics$toString(_p119._0)));
													}
												} else {
													return _user$project$Results$ok1(
														{
															ctor: '_Tuple2',
															_0: {
																ctor: '::',
																_0: oldOutVal,
																_1: {
																	ctor: '::',
																	_0: newOutVal,
																	_1: {ctor: '[]'}
																}
															},
															_1: {ctor: '[]'}
														});
												}
											},
											_user$project$Results$ok1(
												_elm_lang$core$Maybe$Just(diffs)));
									} else {
										return _elm_lang$core$Result$Err(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'This operation is not supported for strings : ',
												_elm_lang$core$Basics$toString(_p118)));
									}
								} else {
									return _elm_lang$core$Result$Err(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected two strings, got ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(_p117),
												A2(
													_elm_lang$core$Basics_ops['++'],
													' -- actually (to update the operation ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														A2(
															_elm_lang$core$String$join,
															' + ',
															A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, operandVals)),
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$LangUtils$valToString(oldOutVal),
															A2(
																_elm_lang$core$Basics_ops['++'],
																' <- ',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_user$project$LangUtils$valToString(newOutVal),
																	')'))))))));
								}
							} else {
								break _v51_3;
							}
						case 'VConst':
							if (_p115._0._1.ctor === '_Tuple2') {
								switch (_p115._1.ctor) {
									case 'VConst':
										if (_p115._1._1.ctor === '_Tuple2') {
											var _p157 = _p115._0._1._0;
											var _p156 = _p115._1._1._0;
											if (_elm_lang$core$Native_Utils.eq(_p157, _p156)) {
												return _user$project$Results$ok1(
													{
														ctor: '_Tuple2',
														_0: operandVals,
														_1: {ctor: '[]'}
													});
											} else {
												var operands = _user$project$Utils$projJusts(
													A2(
														_elm_lang$core$List$map,
														function (operand) {
															var _p124 = operand.v_;
															if ((_p124.ctor === 'VConst') && (_p124._1.ctor === '_Tuple2')) {
																return _elm_lang$core$Maybe$Just(_p124._1._0);
															} else {
																return _elm_lang$core$Maybe$Nothing;
															}
														},
														operandVals));
												var _p125 = operands;
												if (_p125.ctor === 'Nothing') {
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'Operands do not form a list of numbers: ',
															_elm_lang$core$Basics$toString(operandVals)));
												} else {
													var autoDiff = F3(
														function (l, r, res) {
															return A2(
																_user$project$Results$map,
																function (_p126) {
																	var _p127 = _p126;
																	var _p129 = _p127._1;
																	var _p128 = _p127._0;
																	return {
																		ctor: '_Tuple2',
																		_0: {
																			ctor: '::',
																			_0: _p128,
																			_1: {
																				ctor: '::',
																				_0: _p129,
																				_1: {ctor: '[]'}
																			}
																		},
																		_1: A2(
																			_elm_lang$core$Basics_ops['++'],
																			(!_elm_lang$core$Native_Utils.eq(_p128, l)) ? {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																				_1: {ctor: '[]'}
																			} : {ctor: '[]'},
																			(!_elm_lang$core$Native_Utils.eq(_p129, r)) ? {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																				_1: {ctor: '[]'}
																			} : {ctor: '[]'})
																	};
																},
																res);
														});
													var autoDiff1 = F2(
														function (n, res) {
															return A2(
																_user$project$Results$map,
																function (newN) {
																	return {
																		ctor: '_Tuple2',
																		_0: {
																			ctor: '::',
																			_0: newN,
																			_1: {ctor: '[]'}
																		},
																		_1: (!_elm_lang$core$Native_Utils.eq(newN, n)) ? {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																			_1: {ctor: '[]'}
																		} : {ctor: '[]'}
																	};
																},
																res);
														});
													var result = function () {
														var _p130 = {ctor: '_Tuple2', _0: op.val, _1: _p125._0};
														_v60_16:
														do {
															if (_p130.ctor === '_Tuple2') {
																if (_p130._1.ctor === '::') {
																	if (_p130._1._1.ctor === '::') {
																		if (_p130._1._1._1.ctor === '[]') {
																			switch (_p130._0.ctor) {
																				case 'Plus':
																					var _p132 = _p130._1._1._0;
																					var _p131 = _p130._1._0;
																					return _user$project$Results$oks(
																						{
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: {
																									ctor: '::',
																									_0: _p156 - _p132,
																									_1: {
																										ctor: '::',
																										_0: _p132,
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																									_1: {ctor: '[]'}
																								}
																							},
																							_1: {
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: {
																										ctor: '::',
																										_0: _p131,
																										_1: {
																											ctor: '::',
																											_0: _p156 - _p131,
																											_1: {ctor: '[]'}
																										}
																									},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: {ctor: '[]'}
																							}
																						});
																				case 'Minus':
																					var _p134 = _p130._1._1._0;
																					var _p133 = _p130._1._0;
																					return _user$project$Results$oks(
																						{
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: {
																									ctor: '::',
																									_0: _p134 + _p156,
																									_1: {
																										ctor: '::',
																										_0: _p134,
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																									_1: {ctor: '[]'}
																								}
																							},
																							_1: {
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: {
																										ctor: '::',
																										_0: _p133,
																										_1: {
																											ctor: '::',
																											_0: _p133 - _p156,
																											_1: {ctor: '[]'}
																										}
																									},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: {ctor: '[]'}
																							}
																						});
																				case 'Mult':
																					var _p136 = _p130._1._1._0;
																					var _p135 = _p130._1._0;
																					var newL = _p156 / _p136;
																					var newR = _p156 / _p135;
																					return _user$project$Results$oks(
																						{
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: {
																									ctor: '::',
																									_0: _p135,
																									_1: {
																										ctor: '::',
																										_0: newR,
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: (!_elm_lang$core$Native_Utils.eq(newR, _p136)) ? {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																									_1: {ctor: '[]'}
																								} : {ctor: '[]'}
																							},
																							_1: {
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: {
																										ctor: '::',
																										_0: newL,
																										_1: {
																											ctor: '::',
																											_0: _p136,
																											_1: {ctor: '[]'}
																										}
																									},
																									_1: (!_elm_lang$core$Native_Utils.eq(newL, _p135)) ? {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																										_1: {ctor: '[]'}
																									} : {ctor: '[]'}
																								},
																								_1: {ctor: '[]'}
																							}
																						});
																				case 'Div':
																					var _p138 = _p130._1._1._0;
																					var _p137 = _p130._1._0;
																					if (!_elm_lang$core$Native_Utils.eq(_p156, 0)) {
																						var newR = _p137 / _p156;
																						var newL = _p138 * _p156;
																						return _user$project$Results$oks(
																							{
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: {
																										ctor: '::',
																										_0: newL,
																										_1: {
																											ctor: '::',
																											_0: _p138,
																											_1: {ctor: '[]'}
																										}
																									},
																									_1: (!_elm_lang$core$Native_Utils.eq(newL, _p137)) ? {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																										_1: {ctor: '[]'}
																									} : {ctor: '[]'}
																								},
																								_1: {
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: {
																											ctor: '::',
																											_0: _p137,
																											_1: {
																												ctor: '::',
																												_0: newR,
																												_1: {ctor: '[]'}
																											}
																										},
																										_1: (!_elm_lang$core$Native_Utils.eq(newR, _p138)) ? {
																											ctor: '::',
																											_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																											_1: {ctor: '[]'}
																										} : {ctor: '[]'}
																									},
																									_1: {ctor: '[]'}
																								}
																							});
																					} else {
																						return _user$project$Results$ok1(
																							{
																								ctor: '_Tuple2',
																								_0: {
																									ctor: '::',
																									_0: 0,
																									_1: {
																										ctor: '::',
																										_0: _p138,
																										_1: {ctor: '[]'}
																									}
																								},
																								_1: _elm_lang$core$Native_Utils.eq(_p137, 0) ? {ctor: '[]'} : {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																									_1: {ctor: '[]'}
																								}
																							});
																					}
																				case 'Pow':
																					var _p140 = _p130._1._1._0;
																					var _p139 = _p130._1._0;
																					return A3(
																						autoDiff,
																						_p139,
																						_p140,
																						((_elm_lang$core$Native_Utils.cmp(_p139, 0) < 0) && ((_elm_lang$core$Native_Utils.cmp(_p140, 0) > -1) && _elm_lang$core$Native_Utils.eq(
																							_elm_lang$core$Basics$floor(_p140),
																							_elm_lang$core$Basics$ceiling(_p140)))) ? (_elm_lang$core$Native_Utils.eq(
																							A2(
																								_elm_lang$core$Basics_ops['%'],
																								_elm_lang$core$Basics$floor(_p140),
																								2),
																							0) ? ((_elm_lang$core$Native_Utils.cmp(_p156, 0) > -1) ? _user$project$Results$ok1(
																							{
																								ctor: '_Tuple2',
																								_0: 0 - A2(_user$project$MissingNumberMethods_ops['**'], _p156, 1 / _p140),
																								_1: _p140
																							}) : ((_elm_lang$core$Native_Utils.eq(_p156, -1) && _elm_lang$core$Native_Utils.eq(_p139, -1)) ? ((_elm_lang$core$Native_Utils.cmp(_p140, 0) > 0) ? _user$project$Results$oks(
																							{
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: _p139, _1: _p140 - 1},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: _p139, _1: _p140 + 1},
																									_1: {ctor: '[]'}
																								}
																							}) : _user$project$Results$ok1(
																							{ctor: '_Tuple2', _0: _p139, _1: _p140 + 1})) : _elm_lang$core$Result$Err('No way to invert l^r <-- out where l < 0, r is even, out < 0 and out /= -1'))) : ((_elm_lang$core$Native_Utils.cmp(_p156, 0) > -1) ? _user$project$Results$ok1(
																							{
																								ctor: '_Tuple2',
																								_0: A2(_user$project$MissingNumberMethods_ops['**'], _p156, 1 / _p140),
																								_1: _p140
																							}) : _user$project$Results$ok1(
																							{
																								ctor: '_Tuple2',
																								_0: 0 - A2(_user$project$MissingNumberMethods_ops['**'], 0 - _p156, 1 / _p140),
																								_1: _p140
																							}))) : ((_elm_lang$core$Native_Utils.cmp(_p139, 0) > -1) ? ((_elm_lang$core$Native_Utils.cmp(_p156, 0) > 0) ? _user$project$Results$oks(
																							{
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: A2(_user$project$MissingNumberMethods_ops['**'], _p156, 1 / _p140),
																									_1: _p140
																								},
																								_1: {
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: _p139,
																										_1: A2(_elm_lang$core$Basics$logBase, _p139, _p156)
																									},
																									_1: {ctor: '[]'}
																								}
																							}) : ((_elm_lang$core$Native_Utils.eq(
																							_elm_lang$core$Basics$floor(1 / _p140),
																							_elm_lang$core$Basics$ceiling(1 / _p140)) && (_elm_lang$core$Native_Utils.cmp(1 / _p140, 0) < 0)) ? _user$project$Results$ok1(
																							{
																								ctor: '_Tuple2',
																								_0: 0 - A2(_user$project$MissingNumberMethods_ops['**'], 0 - _p156, 1 / _p140),
																								_1: _p140
																							}) : _elm_lang$core$Result$Err('No way to invert l^r <-- out where l >= 0, out < 0 and 1/r not an integer or not < 0'))) : _elm_lang$core$Result$Err('No way to invert l^r <-- out where l < 0 and r < 0 or r is not an integer')));
																				case 'Mod':
																					var _p141 = _p130._1._0;
																					var newL = (_p141 + _p156) - _p157;
																					return _user$project$Results$ok1(
																						{
																							ctor: '_Tuple2',
																							_0: {
																								ctor: '::',
																								_0: newL,
																								_1: {
																									ctor: '::',
																									_0: _p130._1._1._0,
																									_1: {ctor: '[]'}
																								}
																							},
																							_1: (!_elm_lang$core$Native_Utils.eq(newL, _p141)) ? {
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																								_1: {ctor: '[]'}
																							} : {ctor: '[]'}
																						});
																				case 'ArcTan2':
																					var _p146 = _p130._1._1._0;
																					var _p145 = _p130._1._0;
																					return A3(
																						autoDiff,
																						_p145,
																						_p146,
																						function () {
																							var _p142 = _elm_lang$core$Basics$toPolar(
																								{ctor: '_Tuple2', _0: _p146, _1: _p145});
																							var radius = _p142._0;
																							var theta = _p142._1;
																							return _user$project$Results$ok1(
																								function (_p143) {
																									var _p144 = _p143;
																									return {ctor: '_Tuple2', _0: _p144._1, _1: _p144._0};
																								}(
																									_elm_lang$core$Basics$fromPolar(
																										{ctor: '_Tuple2', _0: radius, _1: (theta + _p156) - _p157})));
																						}());
																				default:
																					break _v60_16;
																			}
																		} else {
																			break _v60_16;
																		}
																	} else {
																		switch (_p130._0.ctor) {
																			case 'Cos':
																				var _p147 = _p130._1._0;
																				return A2(
																					autoDiff1,
																					_p147,
																					function () {
																						var newOutClamped = A3(_elm_lang$core$Basics$clamp, -1, 1, _p156);
																						var moved = _elm_lang$core$Basics$acos(newOutClamped);
																						var movedAbsolute = (_elm_lang$core$Native_Utils.cmp(
																							A2(
																								_user$project$MissingNumberMethods_ops['%%'],
																								A2(_user$project$MissingNumberMethods_ops['%%'], _p147, 2 * _elm_lang$core$Basics$pi) + (3 * _elm_lang$core$Basics$pi),
																								2 * _elm_lang$core$Basics$pi) - _elm_lang$core$Basics$pi,
																							0) > -1) ? moved : ((2 * _elm_lang$core$Basics$pi) - moved);
																						var original = A2(
																							_user$project$MissingNumberMethods_ops['%%'],
																							A2(_user$project$MissingNumberMethods_ops['%%'], _p147, 2 * _elm_lang$core$Basics$pi) + (2 * _elm_lang$core$Basics$pi),
																							2 * _elm_lang$core$Basics$pi);
																						return A3(_user$project$Update$angleUpdate, movedAbsolute, original, _p147);
																					}());
																			case 'Sin':
																				var _p148 = _p130._1._0;
																				return A2(
																					autoDiff1,
																					_p148,
																					function () {
																						var newOutClamped = A3(_elm_lang$core$Basics$clamp, -1, 1, _p156);
																						var moved = _elm_lang$core$Basics$asin(newOutClamped);
																						var movedAbsolute = (_elm_lang$core$Native_Utils.cmp(
																							A2(
																								_user$project$MissingNumberMethods_ops['%%'],
																								(A2(_user$project$MissingNumberMethods_ops['%%'], _p148, 2 * _elm_lang$core$Basics$pi) + (2 * _elm_lang$core$Basics$pi)) + (_elm_lang$core$Basics$pi / 2),
																								2 * _elm_lang$core$Basics$pi) - _elm_lang$core$Basics$pi,
																							0) < 1) ? moved : ((_elm_lang$core$Native_Utils.cmp(moved, 0) > 0) ? (_elm_lang$core$Basics$pi - moved) : ((0 - _elm_lang$core$Basics$pi) - moved));
																						var original = A2(
																							_user$project$MissingNumberMethods_ops['%%'],
																							A2(_user$project$MissingNumberMethods_ops['%%'], _p148, 2 * _elm_lang$core$Basics$pi) + (3 * _elm_lang$core$Basics$pi),
																							2 * _elm_lang$core$Basics$pi) - _elm_lang$core$Basics$pi;
																						return A3(_user$project$Update$angleUpdate, movedAbsolute, original, _p148);
																					}());
																			case 'ArcCos':
																				return A2(
																					autoDiff1,
																					_p130._1._0,
																					_user$project$Results$ok1(
																						_elm_lang$core$Basics$cos(_p156)));
																			case 'ArcSin':
																				return A2(
																					autoDiff1,
																					_p130._1._0,
																					_user$project$Results$ok1(
																						_elm_lang$core$Basics$sin(_p156)));
																			case 'Floor':
																				var _p149 = _p130._1._0;
																				return A2(
																					autoDiff1,
																					_p149,
																					_user$project$Results$ok1((_p149 + _p156) - _p157));
																			case 'Ceil':
																				var _p150 = _p130._1._0;
																				return A2(
																					autoDiff1,
																					_p150,
																					_user$project$Results$ok1((_p150 + _p156) - _p157));
																			case 'Round':
																				var _p151 = _p130._1._0;
																				return A2(
																					autoDiff1,
																					_p151,
																					_user$project$Results$ok1((_p151 + _p156) - _p157));
																			case 'Sqrt':
																				return A2(
																					autoDiff1,
																					_p130._1._0,
																					_user$project$Results$ok1(_p156 * _p156));
																			default:
																				break _v60_16;
																		}
																	}
																} else {
																	if (_p130._0.ctor === 'Pi') {
																		return _elm_lang$core$Native_Utils.eq(_p156, _elm_lang$core$Basics$pi) ? _user$project$Results$ok1(
																			{
																				ctor: '_Tuple2',
																				_0: {ctor: '[]'},
																				_1: {ctor: '[]'}
																			}) : _elm_lang$core$Result$Err('Pi\'s value is 3.14159... and cannot be changed');
																	} else {
																		break _v60_16;
																	}
																}
															} else {
																break _v60_16;
															}
														} while(false);
														return _elm_lang$core$Result$Err(
															A2(
																_elm_lang$core$Basics_ops['++'],
																'Not the correct number of arguments for ',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_elm_lang$core$Basics$toString(op),
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'(',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_elm_lang$core$Basics$toString(operandVals),
																			')')))));
													}();
													return A2(
														_user$project$Results$map,
														function (_p152) {
															var _p153 = _p152;
															return {
																ctor: '_Tuple2',
																_0: A3(
																	_elm_lang$core$List$map2,
																	F2(
																		function (original, newNumber) {
																			var _p154 = original.v_;
																			if ((_p154.ctor === 'VConst') && (_p154._1.ctor === '_Tuple2')) {
																				return A2(
																					_user$project$Lang$replaceV_,
																					original,
																					A2(
																						_user$project$Lang$VConst,
																						_p154._0,
																						{ctor: '_Tuple2', _0: newNumber, _1: _p154._1._1}));
																			} else {
																				return _elm_lang$core$Native_Utils.crashCase(
																					'Update',
																					{
																						start: {line: 1852, column: 15},
																						end: {line: 1854, column: 92}
																					},
																					_p154)(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'[internal error] Did not get a VConst: ',
																						_elm_lang$core$Basics$toString(_p154)));
																			}
																		}),
																	operandVals,
																	_p153._0),
																_1: _p153._1
															};
														},
														result);
												}
											}
										} else {
											break _v51_3;
										}
									case 'VBase':
										if (_p115._1._0.ctor === 'VString') {
											var _p158 = _elm_lang$core$String$toFloat(_p115._1._0._0);
											if (_p158.ctor === 'Err') {
												return _elm_lang$core$Result$Ok(_user$project$LazyList$Nil);
											} else {
												var _v65 = op,
													_v66 = operandVals,
													_v67 = oldOutVal,
													_v68 = A2(
													_user$project$Lang$replaceV_,
													oldOutVal,
													A2(
														_user$project$Lang$VConst,
														_p115._0._0,
														{ctor: '_Tuple2', _0: _p158._0, _1: _p115._0._1._1})),
													_v69 = _user$project$Lang$VConstDiffs;
												op = _v65;
												operandVals = _v66;
												oldOutVal = _v67;
												newOutVal = _v68;
												diffs = _v69;
												continue maybeUpdateMathOp;
											}
										} else {
											break _v51_3;
										}
									default:
										break _v51_3;
								}
							} else {
								break _v51_3;
							}
						default:
							break _v51_3;
					}
				} else {
					break _v51_3;
				}
			} while(false);
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Do not know how to revert computation ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(op),
						A2(
							_elm_lang$core$Basics_ops['++'],
							'(',
							A2(
								_elm_lang$core$Basics_ops['++'],
								A2(
									_elm_lang$core$String$join,
									', ',
									A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, operandVals)),
								A2(
									_elm_lang$core$Basics_ops['++'],
									') <-- ',
									_user$project$LangUtils$valToString(newOutVal)))))));
		}
	});
var _user$project$Update$interpreterMaybeToMaybe = F2(
	function (msg, v) {
		var _p159 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, v);
		_v70_3:
		do {
			if (_p159.ctor === 'Ok') {
				if (_p159._0.ctor === '_Tuple2') {
					if (_p159._0._1.ctor === '::') {
						if ((_p159._0._0 === 'Just') && (_p159._0._1._1.ctor === '[]')) {
							return _elm_lang$core$Result$Ok(
								_elm_lang$core$Maybe$Just(_p159._0._1._0));
						} else {
							break _v70_3;
						}
					} else {
						if (_p159._0._0 === 'Nothing') {
							return _elm_lang$core$Result$Ok(_elm_lang$core$Maybe$Nothing);
						} else {
							break _v70_3;
						}
					}
				} else {
					break _v70_3;
				}
			} else {
				return _elm_lang$core$Result$Err(_p159._0);
			}
		} while(false);
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Not a maybe : ',
				_user$project$LangUtils$valToString(v)));
	});
var _user$project$Update$interpreterListToList = F2(
	function (msg, v) {
		var _p160 = v.v_;
		if (_p160.ctor === 'VList') {
			return _elm_lang$core$Result$Ok(_p160._0);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Expected a list for ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						msg,
						A2(
							_elm_lang$core$Basics_ops['++'],
							', got ',
							_user$project$LangUtils$valToString(v)))));
		}
	});
var _user$project$Update$opFlip = F9(
	function (env, e, sp1, spo, initOp, opArgs, sp2, oldVal, newVal) {
		if (A2(_user$project$LangUtils$valEqual, oldVal, newVal)) {
			return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
		} else {
			var _p161 = opArgs;
			if (((_p161.ctor === '::') && (_p161._1.ctor === '::')) && (_p161._1._1.ctor === '[]')) {
				var _p165 = _p161._1._0;
				var _p164 = _p161._0;
				var newE = function () {
					var _p162 = initOp;
					switch (_p162) {
						case '<':
							return A5(
								_user$project$Lang$EApp,
								sp1,
								_user$project$Lang$withDummyExpInfo(
									A2(_user$project$Lang$EVar, spo, '>=')),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								sp2);
						case '>':
							return A5(
								_user$project$Lang$EApp,
								sp1,
								_user$project$Lang$withDummyExpInfo(
									A2(_user$project$Lang$EVar, spo, '<=')),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								sp2);
						case '>=':
							return A5(
								_user$project$Lang$EOp,
								sp1,
								spo,
								_user$project$Lang$withDummyRange(_user$project$Lang$Lt),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								sp2);
						case '<=':
							return A5(
								_user$project$Lang$EApp,
								sp1,
								_user$project$Lang$withDummyExpInfo(
									A2(_user$project$Lang$EVar, spo, '>')),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								sp2);
						case '==':
							return A5(
								_user$project$Lang$EApp,
								sp1,
								_user$project$Lang$withDummyExpInfo(
									A2(_user$project$Lang$EVar, spo, '/=')),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								_user$project$Lang$InfixApp,
								sp2);
						case '/=':
							return A5(
								_user$project$Lang$EOp,
								sp1,
								spo,
								_user$project$Lang$withDummyRange(_user$project$Lang$Eq),
								{
									ctor: '::',
									_0: _p164,
									_1: {
										ctor: '::',
										_0: _p165,
										_1: {ctor: '[]'}
									}
								},
								sp2);
						default:
							return _elm_lang$core$Native_Utils.crashCase(
								'Update',
								{
									start: {line: 1678, column: 18},
									end: {line: 1685, column: 69}
								},
								_p162)(
								A2(_elm_lang$core$Basics_ops['++'], 'Unexpected operator to flip: ', initOp));
					}
				}();
				return A2(
					_user$project$UpdateStack$updateResultSameEnv,
					env,
					A2(_user$project$Lang$replaceE__, e, newE));
			} else {
				return _user$project$UpdateStack$UpdateCriticalError(
					A2(
						_elm_lang$core$Basics_ops['++'],
						initOp,
						A2(
							_elm_lang$core$Basics_ops['++'],
							' requires , 2 arguments, got ',
							_elm_lang$core$Basics$toString(
								_elm_lang$core$List$length(opArgs)))));
			}
		}
	});
var _user$project$Update$getFromPrevLetsOrEval = F5(
	function (vb, prevLets, p, env, e1) {
		return A2(
			_user$project$Utils$maybeWithLazyDefault,
			A2(
				_elm_lang$core$Maybe$map,
				_elm_lang$core$Result$Ok,
				A3(
					_user$project$UpdateStack$prevLetsFind,
					_user$project$Lang$builtinVal('Update.prevLet'),
					prevLets,
					p)),
			function (_p166) {
				var _p167 = _p166;
				return A2(
					_elm_lang$core$Result$map,
					function (_p168) {
						var _p169 = _p168;
						return {
							ctor: '_Tuple2',
							_0: _p169._0._0,
							_1: {ctor: '[]'}
						};
					},
					A2(_user$project$Update$doEvalw, env, e1));
			});
	});
var _user$project$Update$updateLetExps = F4(
	function (env, prevLets, letExps, $continue) {
		updateLetExps:
		while (true) {
			var _p170 = letExps;
			if (_p170.ctor === '[]') {
				return A3(
					$continue,
					env,
					prevLets,
					F2(
						function (updatedEnv, $return) {
							return A3(
								$return,
								updatedEnv,
								{ctor: '[]'},
								{ctor: '[]'});
						}));
			} else {
				var _p202 = _p170._1;
				var _p201 = _p170._0._0;
				var _p200 = _p170._0._1;
				var resAcc = A3(
					_user$project$Utils$foldLeft,
					_elm_lang$core$Result$Ok(
						{
							ctor: '_Tuple3',
							_0: prevLets,
							_1: {ctor: '[]'},
							_2: {ctor: '[]'}
						}),
					_p200,
					F2(
						function (resAcc, _p171) {
							var _p172 = _p171;
							var _p176 = _p172._2;
							return A3(
								_elm_lang$core$Basics$flip,
								_elm_lang$core$Result$andThen,
								resAcc,
								function (_p173) {
									var _p174 = _p173;
									var _p175 = A5(
										_user$project$Update$getFromPrevLetsOrEval,
										_user$project$Lang$builtinVal('updateLetExps'),
										_p174._0,
										_p176,
										env,
										_p172._5);
									if (_p175.ctor === 'Err') {
										return _elm_lang$core$Result$Err(_p175._0);
									} else {
										return _elm_lang$core$Result$Ok(
											{
												ctor: '_Tuple3',
												_0: _p175._0._1,
												_1: {ctor: '::', _0: _p176, _1: _p174._1},
												_2: {ctor: '::', _0: _p175._0._0, _1: _p174._2}
											});
									}
								});
						}));
				var _p177 = resAcc;
				if (_p177.ctor === 'Err') {
					return _user$project$UpdateStack$UpdateCriticalError(_p177._0);
				} else {
					var _p199 = _p177._0._2;
					var _p198 = _p177._0._1;
					var _p197 = _p177._0._0;
					var groupPatterns = _elm_lang$core$List$reverse(_p198);
					var groupOldValues_ = _elm_lang$core$List$reverse(_p199);
					var groupOldValues = _p201 ? A2(
						_elm_lang$core$List$map,
						function (v) {
							var _p178 = v.v_;
							if ((_p178.ctor === 'VClosure') && (_p178._0.ctor === '[]')) {
								var recIdentifiers = _user$project$Lang$identifiersListInPats(groupPatterns);
								return A2(
									_user$project$Lang$replaceV_,
									v,
									A4(
										_user$project$Lang$VClosure,
										recIdentifiers,
										_p178._1,
										_p178._2,
										A2(
											_elm_lang$core$Basics_ops['++'],
											A2(_user$project$Utils$zip, recIdentifiers, groupOldValues_),
											_p178._3)));
							} else {
								return v;
							}
						},
						groupOldValues_) : groupOldValues_;
					var _p179 = A2(
						_user$project$Update$conssWithInversion,
						{ctor: '_Tuple2', _0: groupPatterns, _1: groupOldValues},
						_elm_lang$core$Maybe$Just(
							{ctor: '_Tuple2', _0: env, _1: _elm_lang$core$Basics$identity}));
					if (_p179.ctor === 'Just') {
						var _p195 = _p179._0._0;
						var _v89 = _p195,
							_v90 = _p197,
							_v91 = _p202,
							_v92 = function (env) {
							return function (prevLets) {
								return function (letExps) {
									return function ($continue) {
										return function (letexpGroup) {
											return function (tailGroups) {
												return function (newPrevLets) {
													return function (revPatList) {
														return function (revValList) {
															return function (groupPatterns) {
																return function (recursion) {
																	return function (groupOldValues_) {
																		return function (groupOldValues) {
																			return function (envWithE1s) {
																				return function (conssBuilder) {
																					return function (envWithAllLetExps) {
																						return function (prevLetsWithoutLetExps) {
																							return function (afterUpdatedEnv) {
																								return A3(
																									$continue,
																									envWithAllLetExps,
																									prevLetsWithoutLetExps,
																									F2(
																										function (updatedEnvWithAllLetExps, $return) {
																											return A2(
																												afterUpdatedEnv,
																												updatedEnvWithAllLetExps,
																												F3(
																													function (updatedEnvWithE1s, newTailGroups, newTailGroupsDiffs) {
																														var _p180 = conssBuilder(updatedEnvWithE1s);
																														var newGroupValues_ = _p180._0._0;
																														var newValDiffs_ = _p180._0._1;
																														var updatedEnv = _p180._1;
																														var _p181 = function () {
																															if (recursion) {
																																var _p182 = A3(
																																	_elm_lang$core$Basics$flip,
																																	_user$project$UpdateUtils$mapDiffs,
																																	{ctor: '_Tuple2', _0: newGroupValues_, _1: newValDiffs_},
																																	F2(
																																		function (v, mbDiff) {
																																			var _p183 = v.v_;
																																			if (_p183.ctor === 'VClosure') {
																																				var _p187 = _p183._3;
																																				var updatedClosureEnv = function () {
																																					var _p184 = mbDiff;
																																					if ((_p184.ctor === 'Just') && (_p184._0.ctor === 'VClosureDiffs')) {
																																						return A2(_user$project$Lang$UpdatedEnv, _p187, _p184._0._0);
																																					} else {
																																						return _user$project$UpdatedEnv$original(_p187);
																																					}
																																				}();
																																				var _p185 = A2(
																																					_user$project$UpdatedEnv$split,
																																					_elm_lang$core$List$length(_p183._0),
																																					updatedClosureEnv);
																																				var recUpdatedEnv = _p185._0;
																																				var originalUpdatedEnv = _p185._1;
																																				var nonrecClosure = A2(
																																					_user$project$Lang$replaceV_,
																																					v,
																																					A4(
																																						_user$project$Lang$VClosure,
																																						{ctor: '[]'},
																																						_p183._1,
																																						_p183._2,
																																						originalUpdatedEnv.val));
																																				var nonrecDiffs = function () {
																																					var _p186 = mbDiff;
																																					if ((_p186.ctor === 'Just') && (_p186._0.ctor === 'VClosureDiffs')) {
																																						return _elm_lang$core$Maybe$Just(
																																							A2(_user$project$Lang$VClosureDiffs, originalUpdatedEnv.changes, _p186._0._1));
																																					} else {
																																						return _elm_lang$core$Maybe$Nothing;
																																					}
																																				}();
																																				return {
																																					ctor: '_Tuple2',
																																					_0: {
																																						ctor: '_Tuple2',
																																						_0: nonrecClosure,
																																						_1: _elm_lang$core$Maybe$Just(recUpdatedEnv)
																																					},
																																					_1: nonrecDiffs
																																				};
																																			} else {
																																				return {
																																					ctor: '_Tuple2',
																																					_0: {ctor: '_Tuple2', _0: v, _1: _elm_lang$core$Maybe$Nothing},
																																					_1: mbDiff
																																				};
																																			}
																																		}));
																																var newGroupValuesAndRecs = _p182._0;
																																var newValDiffs = _p182._1;
																																var _p188 = _elm_lang$core$List$unzip(newGroupValuesAndRecs);
																																var newGroupValues = _p188._0;
																																var newMbRecDiffs = _p188._1;
																																var newRecDiffs = A2(_elm_lang$core$List$filterMap, _elm_lang$core$Basics$identity, newMbRecDiffs);
																																var mergeRecDiffs = A2(_user$project$UpdatedEnv$recursiveMerge, env, newRecDiffs);
																																return A2(
																																	_user$project$UpdateUtils$mapDiffs,
																																	F2(
																																		function (_p189, mbV2Diffs) {
																																			var _p190 = _p189;
																																			return A5(_user$project$UpdateUtils$mergeValMaybe, _p190._0, _p190._1._0._0, _p190._1._0._1, _p190._1._1, mbV2Diffs);
																																		}),
																																	{
																																		ctor: '_Tuple2',
																																		_0: A2(
																																			_user$project$Utils$zip,
																																			groupOldValues_,
																																			A2(
																																				_user$project$Utils$zip,
																																				A2(_user$project$UpdateUtils$zipDiffs, newGroupValues, newValDiffs),
																																				_elm_lang$core$Tuple$second(
																																					_elm_lang$core$List$unzip(mergeRecDiffs.val)))),
																																		_1: mergeRecDiffs.changes
																																	});
																															} else {
																																return {ctor: '_Tuple2', _0: newGroupValues_, _1: newValDiffs_};
																															}
																														}();
																														var newGroupValues = _p181._0;
																														var newValDiffs = _p181._1;
																														var totalExpValOut = A4(
																															_elm_lang$core$List$map3,
																															F3(
																																function (_p191, oldVal, newVal) {
																																	var _p192 = _p191;
																																	return {ctor: '_Tuple3', _0: _p192._5, _1: oldVal, _2: newVal};
																																}),
																															letexpGroup,
																															groupOldValues,
																															newGroupValues);
																														return A6(
																															_user$project$UpdateStack$updateContinueMultiple,
																															'letexp-group',
																															env,
																															{ctor: '[]'},
																															totalExpValOut,
																															newValDiffs,
																															F2(
																																function (updatedEnvTuple, updatedExpTuple) {
																																	var newGroup = A3(
																																		_elm_lang$core$List$map2,
																																		F2(
																																			function (_p193, newE) {
																																				var _p194 = _p193;
																																				return A6(_user$project$Lang$LetExp, _p194._0, _p194._1, _p194._2, _p194._3, _p194._4, newE);
																																			}),
																																		letexpGroup,
																																		updatedExpTuple.val);
																																	var newGroupDiffs = A2(
																																		_elm_lang$core$Maybe$withDefault,
																																		{ctor: '[]'},
																																		updatedExpTuple.changes);
																																	var newUpdatedEnv = A3(_user$project$UpdatedEnv$merge, env, updatedEnv, updatedEnvTuple);
																																	return A3(
																																		$return,
																																		newUpdatedEnv,
																																		{
																																			ctor: '::',
																																			_0: {ctor: '_Tuple2', _0: recursion, _1: newGroup},
																																			_1: newTailGroups
																																		},
																																		A2(
																																			_elm_lang$core$Basics_ops['++'],
																																			newGroupDiffs,
																																			A2(
																																				_user$project$UpdateUtils$offset,
																																				_elm_lang$core$List$length(letexpGroup),
																																				newTailGroupsDiffs)));
																																}));
																													}));
																										}));
																							};
																						};
																					};
																				};
																			};
																		};
																	};
																};
															};
														};
													};
												};
											};
										};
									};
								};
							};
						}(env)(prevLets)(letExps)($continue)(_p200)(_p202)(_p197)(_p198)(_p199)(groupPatterns)(_p201)(groupOldValues_)(groupOldValues)(_p195)(_p179._0._1);
						env = _v89;
						prevLets = _v90;
						letExps = _v91;
						$continue = _v92;
						continue updateLetExps;
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								_user$project$Lang$strPos(
									function (_) {
										return _.start;
									}(
										A2(_user$project$Utils$head, 'update letexps', groupPatterns))),
								A2(
									_elm_lang$core$Basics_ops['++'],
									' could not match pattern ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										A2(
											_elm_lang$core$String$join,
											',',
											A2(
												_elm_lang$core$List$map,
												function (_p196) {
													return _user$project$Utils$squish(
														A2(_user$project$Syntax$patternUnparser, _user$project$Syntax$Leo, _p196));
												},
												groupPatterns)),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' with ',
											A2(
												_elm_lang$core$String$join,
												',',
												A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, groupOldValues)))))));
					}
				}
			}
		}
	});
var _user$project$Update$updateDeclarations = F4(
	function (env, prevLets, _p203, doUpdateBody) {
		var _p204 = _p203;
		return A4(
			_user$project$Update$updateLetExps,
			env,
			prevLets,
			_p204._3,
			F3(
				function (newBodyEnv, remainingPrevLets, afterUpdatedEnv) {
					return A3(
						doUpdateBody,
						newBodyEnv,
						remainingPrevLets,
						F2(
							function (updatedBodyEnv, regroupExp) {
								return A2(
									afterUpdatedEnv,
									updatedBodyEnv,
									F3(
										function (updatedEnv, newLetExps, newLetExpDiffs) {
											var updatedDeclarations = A2(
												_user$project$Lang$UpdatedDeclarations,
												A4(_user$project$Lang$Declarations, _p204._0, _p204._1, _p204._2, newLetExps),
												_elm_lang$core$Native_Utils.eq(
													newLetExpDiffs,
													{ctor: '[]'}) ? _elm_lang$core$Maybe$Nothing : _elm_lang$core$Maybe$Just(newLetExpDiffs));
											return A2(regroupExp, updatedEnv, updatedDeclarations);
										}));
							}));
				}));
	});
var _user$project$Update$updateEnv = F4(
	function (env, k, newValue, modif) {
		var aux = F3(
			function (i, acc, env) {
				aux:
				while (true) {
					var _p205 = env;
					if (_p205.ctor === '[]') {
						return _elm_lang$core$Native_Utils.crashCase(
							'Update',
							{
								start: {line: 56, column: 6},
								end: {line: 59, column: 126}
							},
							_p205)(
							A2(_elm_lang$core$Basics_ops['++'], k, ' not found in environment '));
					} else {
						var _p208 = _p205._1;
						var _p207 = _p205._0._0;
						if (_elm_lang$core$Native_Utils.eq(_p207, k)) {
							return A2(
								_user$project$Lang$UpdatedEnv,
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$List$reverse(acc),
									{
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: _p207, _1: newValue},
										_1: _p208
									}),
								{
									ctor: '::',
									_0: {ctor: '_Tuple2', _0: i, _1: modif},
									_1: {ctor: '[]'}
								});
						} else {
							var _v95 = i + 1,
								_v96 = {ctor: '::', _0: _p205._0, _1: acc},
								_v97 = _p208;
							i = _v95;
							acc = _v96;
							env = _v97;
							continue aux;
						}
					}
				}
			});
		return A3(
			aux,
			0,
			{ctor: '[]'},
			env);
	});
var _user$project$Update$unparsePattern = _user$project$Syntax$patternUnparser(_user$project$Syntax$Leo);
var _user$project$Update$unparse = _user$project$Syntax$unparser(_user$project$Syntax$Leo);
var _user$project$Update$getUpdateStackOp = F6(
	function (env, _p209, prevLets, oldVal, newVal, diffs) {
		var _p210 = _p209;
		var _p654 = _p210._0;
		var e = _user$project$Lang$Expr(_p654);
		var ret = _user$project$Lang$replaceE__(e);
		var _p211 = _user$project$Lang$unwrapExp(e);
		switch (_p211.ctor) {
			case 'EHole':
				return A2(
					_user$project$UpdateStack$updateResultSameEnv,
					env,
					A3(
						_user$project$LangUtils$valToExp,
						_p211._0,
						_user$project$LangUtils$IndentSpace(''),
						newVal));
			case 'EConst':
				var _p212 = _user$project$Update$getNum(newVal);
				if (_p212.ctor === 'Err') {
					return _user$project$UpdateStack$UpdateCriticalError(_p212._0);
				} else {
					return A2(
						_user$project$UpdateStack$updateResultSameEnv,
						env,
						ret(
							A4(_user$project$Lang$EConst, _p211._0, _p212._0, _p211._2, _p211._3)));
				}
			case 'EBase':
				var _p216 = _p211._0;
				var _p213 = _p211._1;
				if (_p213.ctor === 'EString') {
					var _p214 = newVal.v_;
					if ((_p214.ctor === 'VBase') && (_p214._0.ctor === 'VString')) {
						var _p215 = diffs;
						if (_p215.ctor === 'VStringDiffs') {
							return A3(
								_user$project$UpdateStack$updateResultSameEnvDiffs,
								env,
								ret(
									A2(
										_user$project$Lang$EBase,
										_p216,
										A2(_user$project$Lang$EString, _p213._0, _p214._0._0))),
								_user$project$Lang$EStringDiffs(_p215._0));
						} else {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Expected VStringDiffs 2, got ',
									_elm_lang$core$Basics$toString(diffs)));
						}
					} else {
						return A2(
							_user$project$UpdateStack$updateResultSameEnv,
							env,
							A3(
								_user$project$LangUtils$valToExp,
								_p216,
								_user$project$LangUtils$IndentSpace(''),
								newVal));
					}
				} else {
					return A2(
						_user$project$UpdateStack$updateResultSameEnv,
						env,
						A3(
							_user$project$LangUtils$valToExp,
							_p216,
							_user$project$LangUtils$IndentSpace(''),
							newVal));
				}
			case 'EFun':
				var _p217 = newVal.v_;
				if ((_p217.ctor === 'VClosure') && (_p217._0.ctor === '[]')) {
					var _p218 = diffs;
					if (_p218.ctor === 'VClosureDiffs') {
						var _p220 = _p218._1;
						var updatedE = function () {
							var _p219 = _p220;
							if (_p219.ctor === 'Nothing') {
								return A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing);
							} else {
								return A2(
									_user$project$Lang$UpdatedExp,
									ret(
										A4(_user$project$Lang$EFun, _p211._0, _p217._1, _p217._2, _p211._3)),
									A2(_user$project$UpdateUtils$wrap, 0, _p220));
							}
						}();
						return A2(
							_user$project$UpdateStack$updateResult,
							A2(_user$project$Lang$UpdatedEnv, _p217._3, _p218._0),
							updatedE);
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'[internal error] Unexpected modifications to a function: ',
								_elm_lang$core$Basics$toString(_p218)));
					}
				} else {
					return _user$project$UpdateStack$UpdateCriticalError(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'[internal error] Trying to update a function with non-closure ',
							_user$project$LangUtils$valToString(newVal)));
				}
			case 'EVar':
				var newUpdatedEnv = A4(_user$project$Update$updateEnv, env, _p211._1, newVal, diffs);
				return A2(
					_user$project$UpdateStack$updateResult,
					newUpdatedEnv,
					A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing));
			case 'EList':
				if (_p211._3.ctor === 'Nothing') {
					var _p261 = _p211._1;
					var _p221 = {ctor: '_Tuple2', _0: oldVal.v_, _1: newVal.v_};
					if (((_p221.ctor === '_Tuple2') && (_p221._0.ctor === 'VList')) && (_p221._1.ctor === 'VList')) {
						var _p260 = _p221._0._0;
						var _p259 = _p221._1._0;
						var _p222 = diffs;
						if (_p222.ctor === 'VListDiffs') {
							var _p258 = _p222._0;
							var updateDiffs = F9(
								function (i, collectedUpdatedEnv, revElems, revEDiffs, elemsToCollect, changeWhitespaceNext, originalValues, newValues, ldiffs) {
									updateDiffs:
									while (true) {
										var _p223 = ldiffs;
										if (_p223.ctor === '[]') {
											var finalElemsToCollect = function () {
												var _p224 = changeWhitespaceNext;
												if (_p224.ctor === 'Nothing') {
													return elemsToCollect;
												} else {
													var _p225 = elemsToCollect;
													if (_p225.ctor === '::') {
														return {
															ctor: '::',
															_0: A2(_p224._0, _p225._0._0, _p225._0._1),
															_1: _p225._1
														};
													} else {
														return {ctor: '[]'};
													}
												}
											}();
											var finalElems = _elm_lang$core$List$reverse(
												A2(_user$project$Utils$reverseInsert, finalElemsToCollect, revElems));
											var updatedE = function () {
												var _p226 = _elm_lang$core$List$reverse(revEDiffs);
												if (_p226.ctor === '[]') {
													return A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing);
												} else {
													return A2(
														_user$project$Lang$UpdatedExp,
														ret(
															A5(_user$project$Lang$EList, _p211._0, finalElems, _p211._2, _elm_lang$core$Maybe$Nothing, _p211._4)),
														_elm_lang$core$Maybe$Just(
															_user$project$Lang$EListDiffs(_p226)));
												}
											}();
											return A2(_user$project$UpdateStack$updateResult, collectedUpdatedEnv, updatedE);
										} else {
											var _p257 = _p223._1;
											var _p256 = _p223._0._0;
											if (_elm_lang$core$Native_Utils.eq(i, _p256)) {
												var _p227 = _p223._0._1;
												switch (_p227.ctor) {
													case 'ListElemDelete':
														var _p228 = _p227._0;
														var _v114 = i + _p228,
															_v115 = collectedUpdatedEnv,
															_v116 = revElems,
															_v117 = {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: i,
																_1: _user$project$Lang$ListElemDelete(_p228)
															},
															_1: revEDiffs
														},
															_v118 = A2(_elm_lang$core$List$drop, _p228, elemsToCollect),
															_v119 = changeWhitespaceNext,
															_v120 = A2(_elm_lang$core$List$drop, _p228, originalValues),
															_v121 = newValues,
															_v122 = _p257;
														i = _v114;
														collectedUpdatedEnv = _v115;
														revElems = _v116;
														revEDiffs = _v117;
														elemsToCollect = _v118;
														changeWhitespaceNext = _v119;
														originalValues = _v120;
														newValues = _v121;
														ldiffs = _v122;
														continue updateDiffs;
													case 'ListElemUpdate':
														var _p229 = {ctor: '_Tuple3', _0: elemsToCollect, _1: originalValues, _2: newValues};
														if (((((_p229.ctor === '_Tuple3') && (_p229._0.ctor === '::')) && (_p229._0._0.ctor === '_Tuple2')) && (_p229._1.ctor === '::')) && (_p229._2.ctor === '::')) {
															return A8(
																_user$project$UpdateStack$updateContinue,
																'List',
																env,
																_p229._0._0._1,
																{ctor: '[]'},
																_p229._1._0,
																_p229._2._0,
																_p227._0,
																A6(
																	F8(
																		function (sp, i, revElems, tlToCollect, origTail, newValuesTail, newUpdatedEnv, newRawElem) {
																			var finalEnv = A3(_user$project$UpdatedEnv$merge, env, collectedUpdatedEnv, newUpdatedEnv);
																			var newRevEDiffs = function () {
																				var _p230 = newRawElem.changes;
																				if (_p230.ctor === 'Nothing') {
																					var _p231 = changeWhitespaceNext;
																					if (_p231.ctor === 'Nothing') {
																						return revEDiffs;
																					} else {
																						return {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: _p256,
																								_1: _user$project$Lang$ListElemUpdate(
																									_user$project$Lang$EConstDiffs(_user$project$Lang$EOnlyWhitespaceDiffs))
																							},
																							_1: revEDiffs
																						};
																					}
																				} else {
																					return {
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: _p256,
																							_1: _user$project$Lang$ListElemUpdate(_p230._0)
																						},
																						_1: revEDiffs
																					};
																				}
																			}();
																			var newSpRawElem = A2(
																				_elm_lang$core$Maybe$withDefault,
																				{ctor: '_Tuple2', _0: sp, _1: newRawElem.val},
																				A2(
																					_elm_lang$core$Maybe$map,
																					function (f) {
																						return A2(f, sp, newRawElem.val);
																					},
																					changeWhitespaceNext));
																			return A9(
																				updateDiffs,
																				i + 1,
																				finalEnv,
																				{ctor: '::', _0: newSpRawElem, _1: revElems},
																				newRevEDiffs,
																				tlToCollect,
																				_elm_lang$core$Maybe$Nothing,
																				origTail,
																				newValuesTail,
																				_p257);
																		}),
																	_p229._0._0._0,
																	i,
																	revElems,
																	_p229._0._1,
																	_p229._1._1,
																	_p229._2._1));
														} else {
															return _user$project$UpdateStack$UpdateCriticalError(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'[internal error] Unexpected missing elements to update from:\n',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'diffs = ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_elm_lang$core$Basics$toString(diffs),
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'\nelems = ',
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					A2(
																						_elm_lang$core$String$join,
																						',',
																						A2(
																							_elm_lang$core$List$map,
																							function (_p232) {
																								var _p233 = _p232;
																								return A2(
																									_elm_lang$core$Basics_ops['++'],
																									_p233._0.val,
																									A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p233._1));
																							},
																							_p261)),
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'\noriginalValues = ',
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							A2(
																								_elm_lang$core$String$join,
																								',',
																								A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, _p260)),
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								'\nnewValues = ',
																								A2(
																									_elm_lang$core$String$join,
																									',',
																									A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, _p259)))))))))));
														}
													default:
														var _p250 = _p227._0;
														var _p234 = A2(_user$project$Utils$split, _p250, newValues);
														var inserted = _p234._0;
														var remainingNewVals = _p234._1;
														var insertionIndex = _elm_lang$core$List$length(revElems);
														var _p235 = function () {
															var me = _elm_lang$core$Maybe$Just(e);
															if (_elm_lang$core$Native_Utils.cmp(insertionIndex, 0) > 0) {
																if (_elm_lang$core$Native_Utils.cmp(
																	_elm_lang$core$List$length(_p261),
																	1) > 0) {
																	var _p236 = A2(
																		_elm_lang$core$List$take,
																		1,
																		A2(
																			_elm_lang$core$List$drop,
																			A2(
																				_elm_lang$core$Basics$min,
																				insertionIndex,
																				_elm_lang$core$List$length(_p261) - 1),
																			_p261));
																	if (((_p236.ctor === '::') && (_p236._0.ctor === '_Tuple2')) && (_p236._1.ctor === '[]')) {
																		var _p238 = _p236._0._1._0;
																		var elemToCopy = _user$project$Lang$Expr(_p238);
																		var psWs = _user$project$Lang$ws(
																			_user$project$Lang$precedingWhitespace(elemToCopy));
																		var indentation = _elm_lang$core$Native_Utils.eq(_p238.start.line, _p238.end.line) ? _user$project$LangUtils$InlineSpace : _user$project$LangUtils$IndentSpace(
																			A2(_elm_lang$core$String$repeat, _p238.start.col - 1, ' '));
																		var policy = {
																			ctor: '_Tuple2',
																			_0: _p236._0._0,
																			_1: function (_p237) {
																				return A2(
																					_user$project$Lang$copyPrecedingWhitespace,
																					elemToCopy,
																					A4(
																						_user$project$LangUtils$valToExpFull,
																						_elm_lang$core$Maybe$Just(elemToCopy),
																						psWs,
																						indentation,
																						_p237));
																			}
																		};
																		return {ctor: '_Tuple3', _0: policy, _1: policy, _2: _elm_lang$core$Maybe$Nothing};
																	} else {
																		return _elm_lang$core$Native_Utils.crashCase(
																			'Update',
																			{
																				start: {line: 267, column: 39},
																				end: {line: 277, column: 132}
																			},
																			_p236)('[internal error] There should be an element in this list\'s position');
																	}
																} else {
																	var _p240 = _p261;
																	if (_p240.ctor === '::') {
																		if ((_p240._0.ctor === '_Tuple2') && (_p240._1.ctor === '[]')) {
																			var _p242 = _p240._0._1._0;
																			var _p241 = _elm_lang$core$Native_Utils.eq(_p654.start.line, _p654.end.line) ? {
																				ctor: '_Tuple3',
																				_0: _user$project$Lang$ws(''),
																				_1: _user$project$Lang$ws(' '),
																				_2: _user$project$LangUtils$InlineSpace
																			} : ((_elm_lang$core$Native_Utils.cmp(_p654.end.col - 1, _p242.start.col) > 0) ? {
																				ctor: '_Tuple3',
																				_0: _user$project$Lang$ws(''),
																				_1: _user$project$Lang$ws(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'\n',
																						A2(_elm_lang$core$String$repeat, _p242.start.col - 1, ' '))),
																				_2: _user$project$LangUtils$IndentSpace(
																					A2(_elm_lang$core$String$repeat, _p242.start.col - 1, ' '))
																			} : {
																				ctor: '_Tuple3',
																				_0: _user$project$Lang$ws(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'\n',
																						A2(_elm_lang$core$String$repeat, _p654.end.col - 2, ' '))),
																				_1: _user$project$Lang$ws(
																					A2(
																						_elm_lang$core$String$repeat,
																						A2(_elm_lang$core$Basics$max, (_p242.start.col - _p654.end.col) - 1, 1),
																						' ')),
																				_2: _user$project$LangUtils$IndentSpace(
																					A2(_elm_lang$core$String$repeat, _p654.end.col - 2, ' '))
																			});
																			var wsComma = _p241._0;
																			var wsElem = _p241._1;
																			var indentation = _p241._2;
																			var policy = {
																				ctor: '_Tuple2',
																				_0: wsComma,
																				_1: A3(_user$project$LangUtils$valToExpFull, _elm_lang$core$Maybe$Nothing, wsElem, indentation)
																			};
																			return {ctor: '_Tuple3', _0: policy, _1: policy, _2: _elm_lang$core$Maybe$Nothing};
																		} else {
																			return _elm_lang$core$Native_Utils.crashCase(
																				'Update',
																				{
																					start: {line: 279, column: 39},
																					end: {line: 300, column: 144}
																				},
																				_p240)('[internal error] There should be not more than 1 element in this list\'s position');
																		}
																	} else {
																		var _p243 = {
																			ctor: '_Tuple3',
																			_0: _user$project$Lang$ws(''),
																			_1: _user$project$Lang$ws(' '),
																			_2: _user$project$LangUtils$InlineSpace
																		};
																		var wsComma = _p243._0;
																		var wsElem = _p243._1;
																		var indentation = _p243._2;
																		var policy = {
																			ctor: '_Tuple2',
																			_0: wsComma,
																			_1: A3(_user$project$LangUtils$valToExpFull, _elm_lang$core$Maybe$Nothing, wsElem, indentation)
																		};
																		return {ctor: '_Tuple3', _0: policy, _1: policy, _2: _elm_lang$core$Maybe$Nothing};
																	}
																}
															} else {
																var _p245 = _p261;
																if (_p245.ctor === '[]') {
																	if (_elm_lang$core$Native_Utils.eq(_p654.start.line, _p654.end.line)) {
																		return {
																			ctor: '_Tuple3',
																			_0: {
																				ctor: '_Tuple2',
																				_0: _user$project$Lang$ws(''),
																				_1: A3(
																					_user$project$LangUtils$valToExpFull,
																					_elm_lang$core$Maybe$Nothing,
																					_user$project$Lang$ws(''),
																					_user$project$LangUtils$InlineSpace)
																			},
																			_1: {
																				ctor: '_Tuple2',
																				_0: _user$project$Lang$ws(' '),
																				_1: A3(
																					_user$project$LangUtils$valToExpFull,
																					_elm_lang$core$Maybe$Nothing,
																					_user$project$Lang$ws(' '),
																					_user$project$LangUtils$InlineSpace)
																			},
																			_2: _elm_lang$core$Maybe$Nothing
																		};
																	} else {
																		var indentationSquareBracket = A2(_elm_lang$core$String$repeat, _p654.end.col - 2, ' ');
																		var indentation = A2(_elm_lang$core$Basics_ops['++'], indentationSquareBracket, '  ');
																		return {
																			ctor: '_Tuple3',
																			_0: {
																				ctor: '_Tuple2',
																				_0: _user$project$Lang$ws(''),
																				_1: A3(
																					_user$project$LangUtils$valToExpFull,
																					_elm_lang$core$Maybe$Nothing,
																					_user$project$Lang$ws(' '),
																					_user$project$LangUtils$IndentSpace(indentation))
																			},
																			_1: {
																				ctor: '_Tuple2',
																				_0: _user$project$Lang$ws(
																					A2(_elm_lang$core$Basics_ops['++'], '\n', indentationSquareBracket)),
																				_1: A3(
																					_user$project$LangUtils$valToExpFull,
																					_elm_lang$core$Maybe$Nothing,
																					_user$project$Lang$ws(' '),
																					_user$project$LangUtils$IndentSpace(indentation))
																			},
																			_2: _elm_lang$core$Maybe$Nothing
																		};
																	}
																} else {
																	var _p249 = _p245._0._1._0;
																	var head = _user$project$Lang$Expr(_p249);
																	var _p246 = function () {
																		var _p247 = _p245._1;
																		if (_p247.ctor === '[]') {
																			if (_elm_lang$core$Native_Utils.eq(_p654.start.line, _p654.end.line)) {
																				return {
																					ctor: '_Tuple4',
																					_0: _user$project$Lang$ws(''),
																					_1: ' ',
																					_2: head,
																					_3: _user$project$LangUtils$InlineSpace
																				};
																			} else {
																				if (_elm_lang$core$Native_Utils.cmp(_p654.end.col - 1, _p249.start.col) > 0) {
																					var indentation = A2(_elm_lang$core$String$repeat, _p249.start.col - 1, ' ');
																					return {
																						ctor: '_Tuple4',
																						_0: _user$project$Lang$ws(''),
																						_1: A2(_elm_lang$core$Basics_ops['++'], '\n', indentation),
																						_2: head,
																						_3: _user$project$LangUtils$IndentSpace(indentation)
																					};
																				} else {
																					var indentation = A2(_elm_lang$core$String$repeat, _p654.end.col - 2, ' ');
																					return {
																						ctor: '_Tuple4',
																						_0: _user$project$Lang$ws(
																							A2(_elm_lang$core$Basics_ops['++'], '\n', indentation)),
																						_1: ' ',
																						_2: head,
																						_3: _user$project$LangUtils$IndentSpace(indentation)
																					};
																				}
																			}
																		} else {
																			var _p248 = _p247._0._1._0;
																			var indentationSquareBracket = A2(_elm_lang$core$String$repeat, _p654.end.col - 2, ' ');
																			var indentation = _elm_lang$core$Native_Utils.eq(_p248.start.line, _p248.end.line) ? _user$project$LangUtils$InlineSpace : _user$project$LangUtils$IndentSpace(
																				A2(_elm_lang$core$Basics_ops['++'], indentationSquareBracket, '  '));
																			return {
																				ctor: '_Tuple4',
																				_0: _p247._0._0,
																				_1: _user$project$Lang$precedingWhitespace(
																					_user$project$Lang$Expr(_p248)),
																				_2: _user$project$Lang$Expr(_p248),
																				_3: indentation
																			};
																		}
																	}();
																	var wsSecondBeforeComma = _p246._0;
																	var wsSecondBeforeValue = _p246._1;
																	var secondOrHead = _p246._2;
																	var indent = _p246._3;
																	return {
																		ctor: '_Tuple3',
																		_0: {
																			ctor: '_Tuple2',
																			_0: _user$project$Lang$ws(''),
																			_1: A3(
																				_user$project$LangUtils$valToExpFull,
																				_elm_lang$core$Maybe$Just(head),
																				_user$project$Lang$ws(' '),
																				indent)
																		},
																		_1: {
																			ctor: '_Tuple2',
																			_0: wsSecondBeforeComma,
																			_1: A3(
																				_user$project$LangUtils$valToExpFull,
																				_elm_lang$core$Maybe$Just(secondOrHead),
																				_user$project$Lang$ws(wsSecondBeforeValue),
																				indent)
																		},
																		_2: _elm_lang$core$Maybe$Just(
																			F2(
																				function (nextWsBeforeComma, nextElem) {
																					return {
																						ctor: '_Tuple2',
																						_0: wsSecondBeforeComma,
																						_1: A2(_user$project$Lang$replacePrecedingWhitespace, wsSecondBeforeValue, nextElem)
																					};
																				}))
																	};
																}
															}
														}();
														var wsBeforeCommaHead = _p235._0._0;
														var valToWSExpHead = _p235._0._1;
														var wsBeforeCommaTail = _p235._1._0;
														var valToWSExpTail = _p235._1._1;
														var changeElementAfterInsert = _p235._2;
														var insertedExp = A2(
															_elm_lang$core$List$indexedMap,
															F2(
																function (index, inserted) {
																	return {
																		ctor: '_Tuple2',
																		_0: _elm_lang$core$Native_Utils.eq(index + insertionIndex, 0) ? wsBeforeCommaHead : wsBeforeCommaTail,
																		_1: (_elm_lang$core$Native_Utils.eq(index + insertionIndex, 0) ? valToWSExpHead : valToWSExpTail)(inserted)
																	};
																}),
															inserted);
														var elemsToAdd = insertedExp;
														var _v131 = i,
															_v132 = collectedUpdatedEnv,
															_v133 = A2(_user$project$Utils$reverseInsert, elemsToAdd, revElems),
															_v134 = {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: i,
																_1: _user$project$Lang$ListElemInsert(_p250)
															},
															_1: revEDiffs
														},
															_v135 = elemsToCollect,
															_v136 = changeElementAfterInsert,
															_v137 = originalValues,
															_v138 = remainingNewVals,
															_v139 = _p257;
														i = _v131;
														collectedUpdatedEnv = _v132;
														revElems = _v133;
														revEDiffs = _v134;
														elemsToCollect = _v135;
														changeWhitespaceNext = _v136;
														originalValues = _v137;
														newValues = _v138;
														ldiffs = _v139;
														continue updateDiffs;
												}
											} else {
												var _p251 = changeWhitespaceNext;
												if (_p251.ctor === 'Nothing') {
													var count = _p256 - i;
													var _p252 = A2(_user$project$Utils$split, count, elemsToCollect);
													var skipped = _p252._0;
													var remaining = _p252._1;
													var _v141 = _p256,
														_v142 = collectedUpdatedEnv,
														_v143 = A2(_user$project$Utils$reverseInsert, skipped, revElems),
														_v144 = revEDiffs,
														_v145 = remaining,
														_v146 = _elm_lang$core$Maybe$Nothing,
														_v147 = A2(_elm_lang$core$List$drop, count, originalValues),
														_v148 = A2(_elm_lang$core$List$drop, count, newValues),
														_v149 = ldiffs;
													i = _v141;
													collectedUpdatedEnv = _v142;
													revElems = _v143;
													revEDiffs = _v144;
													elemsToCollect = _v145;
													changeWhitespaceNext = _v146;
													originalValues = _v147;
													newValues = _v148;
													ldiffs = _v149;
													continue updateDiffs;
												} else {
													var _p253 = {ctor: '_Tuple3', _0: elemsToCollect, _1: originalValues, _2: newValues};
													if (((((_p253.ctor === '_Tuple3') && (_p253._0.ctor === '::')) && (_p253._0._0.ctor === '_Tuple2')) && (_p253._1.ctor === '::')) && (_p253._2.ctor === '::')) {
														var _v151 = i + 1,
															_v152 = collectedUpdatedEnv,
															_v153 = {
															ctor: '::',
															_0: A2(_p251._0, _p253._0._0._0, _p253._0._0._1),
															_1: revElems
														},
															_v154 = {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: i,
																_1: _user$project$Lang$ListElemUpdate(
																	_user$project$Lang$EConstDiffs(_user$project$Lang$EOnlyWhitespaceDiffs))
															},
															_1: revEDiffs
														},
															_v155 = _p253._0._1,
															_v156 = _elm_lang$core$Maybe$Nothing,
															_v157 = _p253._1._1,
															_v158 = _p253._2._1,
															_v159 = ldiffs;
														i = _v151;
														collectedUpdatedEnv = _v152;
														revElems = _v153;
														revEDiffs = _v154;
														elemsToCollect = _v155;
														changeWhitespaceNext = _v156;
														originalValues = _v157;
														newValues = _v158;
														ldiffs = _v159;
														continue updateDiffs;
													} else {
														return _user$project$UpdateStack$UpdateCriticalError(
															A2(
																_elm_lang$core$Basics_ops['++'],
																'[internal error] Unexpected missing elements to update from (whitespace only):\n',
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'ldiffs = ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_elm_lang$core$Basics$toString(_p258),
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'\nelems = [',
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				A2(
																					_elm_lang$core$String$join,
																					',',
																					A2(
																						_elm_lang$core$List$map,
																						function (_p254) {
																							var _p255 = _p254;
																							return A2(
																								_elm_lang$core$Basics_ops['++'],
																								_p255._0.val,
																								A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p255._1));
																						},
																						_p261)),
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					']\noriginalValues = [',
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						A2(
																							_elm_lang$core$String$join,
																							',',
																							A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, _p260)),
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							']\nnewValues = [',
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								A2(
																									_elm_lang$core$String$join,
																									',',
																									A2(_elm_lang$core$List$map, _user$project$LangUtils$valToString, _p259)),
																								']'))))))))));
													}
												}
											}
										}
									}
								});
							return A9(
								updateDiffs,
								0,
								_user$project$UpdatedEnv$original(env),
								{ctor: '[]'},
								{ctor: '[]'},
								_p261,
								_elm_lang$core$Maybe$Nothing,
								_p260,
								_p259,
								_p258);
						} else {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Expected VListDiffs, got ',
									_elm_lang$core$Basics$toString(diffs)));
						}
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Cannot update a list ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_user$project$Update$unparse(e),
									A2(
										_elm_lang$core$Basics_ops['++'],
										' with non-list ',
										_user$project$LangUtils$valToString(newVal)))));
					}
				} else {
					var _p289 = _p211._3._0;
					var _p288 = _p211._4;
					var _p287 = _p211._2;
					var _p286 = _p211._0;
					var _p285 = _p211._1;
					var _p262 = {ctor: '_Tuple2', _0: oldVal.v_, _1: newVal.v_};
					if (((_p262.ctor === '_Tuple2') && (_p262._0.ctor === 'VList')) && (_p262._1.ctor === 'VList')) {
						var _p263 = diffs;
						if (_p263.ctor === 'VListDiffs') {
							var updateDiffs = F9(
								function (i, elemSize, collectedEnv, revElems, revEDiffs, elemsToCollect, origVals, newOutVals, ldiffs) {
									updateDiffs:
									while (true) {
										var _p264 = ldiffs;
										if (_p264.ctor === '[]') {
											var updatedList = function () {
												var _p265 = _elm_lang$core$List$reverse(revEDiffs);
												if (_p265.ctor === '[]') {
													return A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing);
												} else {
													var finalElems = _elm_lang$core$List$reverse(
														A2(_user$project$Utils$reverseInsert, elemsToCollect, revElems));
													return A2(
														_user$project$Lang$UpdatedExp,
														ret(
															A5(
																_user$project$Lang$EList,
																_p286,
																finalElems,
																_p287,
																_elm_lang$core$Maybe$Just(_p289),
																_p288)),
														_elm_lang$core$Maybe$Just(
															_user$project$Lang$EChildDiffs(_p265)));
												}
											}();
											return A2(_user$project$UpdateStack$updateResult, collectedEnv, updatedList);
										} else {
											var _p284 = _p264._1;
											var _p283 = _p264._0._0;
											if (_elm_lang$core$Native_Utils.cmp(_p283, elemSize) > -1) {
												var _p266 = function () {
													var _p267 = _elm_lang$core$List$reverse(revEDiffs);
													if (_p267.ctor === '[]') {
														return {
															ctor: '_Tuple2',
															_0: _p285,
															_1: {ctor: '[]'}
														};
													} else {
														return {
															ctor: '_Tuple2',
															_0: _elm_lang$core$List$reverse(
																A2(_user$project$Utils$reverseInsert, elemsToCollect, revElems)),
															_1: _p267
														};
													}
												}();
												var finalElems = _p266._0;
												var changesInOrder = _p266._1;
												var valsToRemove = _elm_lang$core$List$length(elemsToCollect);
												var tailOldVal = A2(_elm_lang$core$List$drop, valsToRemove, origVals);
												var tailNewOutVal = A2(_elm_lang$core$List$drop, valsToRemove, newOutVals);
												return A8(
													_user$project$UpdateStack$updateContinue,
													'EList tail',
													env,
													_p289,
													{ctor: '[]'},
													A2(
														_user$project$Lang$replaceV_,
														oldVal,
														_user$project$Lang$VList(tailOldVal)),
													A2(
														_user$project$Lang$replaceV_,
														newVal,
														_user$project$Lang$VList(tailNewOutVal)),
													_user$project$Lang$VListDiffs(
														A2(_user$project$UpdateUtils$offset, 0 - elemSize, ldiffs)),
													F2(
														function (newTailUpdatedEnv, newUpdatedTailExp) {
															var finalUpdatedEnv = A3(_user$project$UpdatedEnv$merge, env, collectedEnv, newTailUpdatedEnv);
															var finalChanges = function () {
																var _p268 = newUpdatedTailExp.changes;
																if (_p268.ctor === 'Nothing') {
																	var _p269 = changesInOrder;
																	if (_p269.ctor === '[]') {
																		return _elm_lang$core$Maybe$Nothing;
																	} else {
																		return _elm_lang$core$Maybe$Just(
																			_user$project$Lang$EChildDiffs(_p269));
																	}
																} else {
																	return _elm_lang$core$Maybe$Just(
																		_user$project$Lang$EChildDiffs(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				changesInOrder,
																				{
																					ctor: '::',
																					_0: {
																						ctor: '_Tuple2',
																						_0: _elm_lang$core$List$length(_p285),
																						_1: _p268._0
																					},
																					_1: {ctor: '[]'}
																				})));
																}
															}();
															return A2(
																_user$project$UpdateStack$updateResult,
																finalUpdatedEnv,
																A2(
																	_user$project$Lang$UpdatedExp,
																	ret(
																		A5(
																			_user$project$Lang$EList,
																			_p286,
																			finalElems,
																			_p287,
																			_elm_lang$core$Maybe$Just(newUpdatedTailExp.val),
																			_p288)),
																	finalChanges));
														}));
											} else {
												var _p270 = _p264._0._1;
												switch (_p270.ctor) {
													case 'ListElemDelete':
														var _p275 = _p270._0;
														var _p271 = {ctor: '_Tuple2', _0: origVals, _1: elemsToCollect};
														if (((_p271.ctor === '_Tuple2') && (_p271._0.ctor === '::')) && (_p271._1.ctor === '::')) {
															var _p274 = _p271._0._1;
															var _p273 = _p271._0._0;
															var _p272 = newOutVals;
															if (_p272.ctor === '::') {
																if (A2(
																	_elm_lang$core$List$all,
																	_user$project$LangUtils$valEqual(_p273),
																	A2(_elm_lang$core$List$take, _p275, _p274)) && A2(_user$project$LangUtils$valEqual, _p272._0, _p273)) {
																	var _v171 = _p283 + 1,
																		_v172 = elemSize,
																		_v173 = collectedEnv,
																		_v174 = {ctor: '::', _0: _p271._1._0, _1: revElems},
																		_v175 = revEDiffs,
																		_v176 = _p271._1._1,
																		_v177 = _p274,
																		_v178 = _p272._1,
																		_v179 = {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: _p283 + 1,
																			_1: _user$project$Lang$ListElemDelete(_p275)
																		},
																		_1: _p284
																	};
																	i = _v171;
																	elemSize = _v172;
																	collectedEnv = _v173;
																	revElems = _v174;
																	revEDiffs = _v175;
																	elemsToCollect = _v176;
																	origVals = _v177;
																	newOutVals = _v178;
																	ldiffs = _v179;
																	continue updateDiffs;
																} else {
																	return _user$project$UpdateStack$UpdateFails('Cannot delete elements appended to the left of a ::.');
																}
															} else {
																return _user$project$UpdateStack$UpdateFails('Cannot delete elements appended to the left of a ::.');
															}
														} else {
															return _user$project$UpdateStack$UpdateCriticalError('ListElemDelete: deleted element not found in original output');
														}
													case 'ListElemInsert':
														var _p280 = _p270._0;
														var _p276 = newOutVals;
														if (_p276.ctor === '::') {
															var _p279 = _p276._1;
															var _p278 = _p276._0;
															var _p277 = {ctor: '_Tuple2', _0: origVals, _1: elemsToCollect};
															if ((_p277._0.ctor === '::') && (_p277._1.ctor === '::')) {
																if (A2(
																	_elm_lang$core$List$all,
																	_user$project$LangUtils$valEqual(_p278),
																	A2(_elm_lang$core$List$take, _p280, _p279)) && A2(_user$project$LangUtils$valEqual, _p278, _p277._0._0)) {
																	var _v182 = _p283 + 1,
																		_v183 = elemSize,
																		_v184 = collectedEnv,
																		_v185 = {ctor: '::', _0: _p277._1._0, _1: revElems},
																		_v186 = revEDiffs,
																		_v187 = _p277._1._1,
																		_v188 = _p277._0._1,
																		_v189 = _p279,
																		_v190 = {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: _p283 + 1,
																			_1: _user$project$Lang$ListElemInsert(_p280)
																		},
																		_1: _p284
																	};
																	i = _v182;
																	elemSize = _v183;
																	collectedEnv = _v184;
																	revElems = _v185;
																	revEDiffs = _v186;
																	elemsToCollect = _v187;
																	origVals = _v188;
																	newOutVals = _v189;
																	ldiffs = _v190;
																	continue updateDiffs;
																} else {
																	return _user$project$UpdateStack$UpdateFails('Cannot insert before elements appended to the left of a ::');
																}
															} else {
																return _user$project$UpdateStack$UpdateFails('Cannot insert before elements appended to the left of a ::');
															}
														} else {
															return _user$project$UpdateStack$UpdateCriticalError('ListElemInsert: inserted element not found in new output');
														}
													default:
														var _p281 = {ctor: '_Tuple3', _0: origVals, _1: elemsToCollect, _2: newOutVals};
														if (((((_p281.ctor === '_Tuple3') && (_p281._0.ctor === '::')) && (_p281._1.ctor === '::')) && (_p281._1._0.ctor === '_Tuple2')) && (_p281._2.ctor === '::')) {
															return A8(
																_user$project$UpdateStack$updateContinue,
																'EList ::',
																env,
																_p281._1._0._1,
																{ctor: '[]'},
																_p281._0._0,
																_p281._2._0,
																_p270._0,
																A9(
																	function (elemSize) {
																		return function (env) {
																			return function (collectedEnv) {
																				return function (revElems) {
																					return function (sp1) {
																						return function (tlCollect) {
																							return function (tailOrigVal) {
																								return function (tlOut) {
																									return function (tailmodif) {
																										return function (newUpdatedEnv) {
																											return function (newhdCollect) {
																												var updatedEnv = A3(_user$project$UpdatedEnv$merge, env, collectedEnv, newUpdatedEnv);
																												var newRevEDiffs = function () {
																													var _p282 = newhdCollect.changes;
																													if (_p282.ctor === 'Nothing') {
																														return revEDiffs;
																													} else {
																														return {
																															ctor: '::',
																															_0: {ctor: '_Tuple2', _0: _p283, _1: _p282._0},
																															_1: revEDiffs
																														};
																													}
																												}();
																												return A9(
																													updateDiffs,
																													_p283 + 1,
																													elemSize,
																													updatedEnv,
																													{
																														ctor: '::',
																														_0: {ctor: '_Tuple2', _0: sp1, _1: newhdCollect.val},
																														_1: revElems
																													},
																													newRevEDiffs,
																													tlCollect,
																													tailOrigVal,
																													tlOut,
																													tailmodif);
																											};
																										};
																									};
																								};
																							};
																						};
																					};
																				};
																			};
																		};
																	},
																	elemSize,
																	env,
																	collectedEnv,
																	revElems,
																	_p281._1._0._0,
																	_p281._1._1,
																	_p281._0._1,
																	_p281._2._1,
																	_p284));
														} else {
															return _user$project$UpdateStack$UpdateCriticalError('ListElemupdate: updated element not found in original output or new output.');
														}
												}
											}
										}
									}
								});
							return A9(
								updateDiffs,
								0,
								_elm_lang$core$List$length(_p285),
								_user$project$UpdatedEnv$original(env),
								{ctor: '[]'},
								{ctor: '[]'},
								_p285,
								_p262._0._0,
								_p262._1._0,
								_p263._0);
						} else {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Expected  a List diff, got ',
									_elm_lang$core$Basics$toString(_p263)));
						}
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected a list to update, got ',
								_user$project$LangUtils$valToString(newVal)));
					}
				}
			case 'ERecord':
				var _p319 = _p211._3;
				var _p318 = _p211._0;
				var _p317 = _p211._1;
				var _p290 = newVal.v_;
				if (_p290.ctor === 'VRecord') {
					var _p316 = _p290._0;
					var _p291 = oldVal.v_;
					if (_p291.ctor === 'VRecord') {
						var _p315 = _p291._0;
						var errors = A6(
							_elm_lang$core$Dict$merge,
							F3(
								function (keyOld, valOld, errs) {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										errs,
										{
											ctor: '::',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												'Deleting key \'',
												A2(_elm_lang$core$Basics_ops['++'], keyOld, '\' from a record not allowed')),
											_1: {ctor: '[]'}
										});
								}),
							F4(
								function (key, valOld, valOut, errs) {
									return errs;
								}),
							F3(
								function (keyOut, valOut, errs) {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										errs,
										{
											ctor: '::',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												'Inserting key \'',
												A2(_elm_lang$core$Basics_ops['++'], keyOut, '\' to a record not allowed')),
											_1: {ctor: '[]'}
										});
								}),
							_p315,
							_p316,
							{ctor: '[]'});
						if (!_elm_lang$core$List$isEmpty(errors)) {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									A2(_elm_lang$core$String$join, ', ', errors),
									'is not allowed. Maybe you wanted to use dictionaries?'));
						} else {
							var declsIdentifiersList = A2(
								_elm_lang$core$List$concatMap,
								function (_p292) {
									var _p293 = _p292;
									return _user$project$Lang$publicIdentifiersListIntPat(_p293._2);
								},
								_user$project$Lang$elemsOf(_p211._2._3));
							var declsIdentifiers = _elm_lang$core$Set$fromList(declsIdentifiersList);
							var isDeclarationIdentifier = A2(_elm_lang$core$Basics$flip, _elm_lang$core$Set$member, declsIdentifiers);
							var prevLetsDecls = function () {
								var aux = F2(
									function (declsIdentifiersList, revAcc) {
										aux:
										while (true) {
											var _p294 = declsIdentifiersList;
											if (_p294.ctor === '[]') {
												return _elm_lang$core$List$reverse(revAcc);
											} else {
												var _p296 = _p294._1;
												var _p295 = _p294._0;
												if (A2(_elm_lang$core$List$member, _p295, _p296)) {
													return _elm_lang$core$List$reverse(revAcc);
												} else {
													var _v197 = _p296,
														_v198 = {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: _p295,
															_1: A2(
																_user$project$Utils$fromJust_,
																'Update.ERecord.prevLetsDecls',
																A2(_elm_lang$core$Dict$get, _p295, _p315))
														},
														_1: revAcc
													};
													declsIdentifiersList = _v197;
													revAcc = _v198;
													continue aux;
												}
											}
										}
									});
								return A2(
									aux,
									declsIdentifiersList,
									{ctor: '[]'});
							}();
							var _p297 = diffs;
							switch (_p297.ctor) {
								case 'VRecordDiffs':
									return A4(
										_user$project$Update$updateDeclarations,
										env,
										prevLetsDecls,
										_p211._2,
										F3(
											function (envRecord, _p298, finishUpdateDeclarations) {
												var resMiVal = function () {
													var _p301 = A2(
														_elm_lang$core$Maybe$map,
														function (_p299) {
															var _p300 = _p299;
															return A2(_user$project$Update$doEvalw, env, _p300._0);
														},
														_p317);
													if (_p301.ctor === 'Nothing') {
														return _elm_lang$core$Result$Ok(_elm_lang$core$Maybe$Nothing);
													} else {
														if (_p301._0.ctor === 'Err') {
															return _elm_lang$core$Result$Err(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Line ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_elm_lang$core$Basics$toString(_p654.start.line),
																		A2(_elm_lang$core$Basics_ops['++'], ', while evaluating {...|, got', _p301._0._0))));
														} else {
															var _p303 = _p301._0._0._0._0;
															var _p302 = _p303.v_;
															if (_p302.ctor === 'VRecord') {
																return _elm_lang$core$Result$Ok(
																	_elm_lang$core$Maybe$Just(_p302._0));
															} else {
																return _elm_lang$core$Result$Err(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'Line ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_elm_lang$core$Basics$toString(_p654.start.line),
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				', while evaluating {...|, got not a record but ',
																				_user$project$LangUtils$valToString(_p303)))));
															}
														}
													}
												}();
												var _p304 = resMiVal;
												if (_p304.ctor === 'Err') {
													return _user$project$UpdateStack$UpdateCriticalError(_p304._0);
												} else {
													var _p314 = _p304._0;
													var _p305 = A3(
														_elm_lang$core$Dict$foldl,
														F3(
															function (key, diff, _p306) {
																var _p307 = _p306;
																var _p311 = _p307._1;
																var _p310 = _p307._0;
																var newValue = A2(
																	_user$project$Utils$fromJust_,
																	'ERecord.newValue',
																	A2(_elm_lang$core$Dict$get, key, _p316));
																if (isDeclarationIdentifier(key)) {
																	return {
																		ctor: '_Tuple2',
																		_0: _p310,
																		_1: A4(_user$project$UpdatedEnv$set, key, newValue, diff, _p311)
																	};
																} else {
																	var _p308 = _p310;
																	if (_p308.ctor === 'Just') {
																		return {
																			ctor: '_Tuple2',
																			_0: _elm_lang$core$Maybe$Just(
																				{
																					ctor: '_Tuple2',
																					_0: A3(_elm_lang$core$Dict$insert, key, newValue, _p308._0._0),
																					_1: A3(_elm_lang$core$Dict$insert, key, diff, _p308._0._1)
																				}),
																			_1: _p311
																		};
																	} else {
																		return _elm_lang$core$Native_Utils.crashCase(
																			'Update',
																			{
																				start: {line: 496, column: 30},
																				end: {line: 499, column: 140}
																			},
																			_p308)(
																			A2(_elm_lang$core$Basics_ops['++'], '[Internal error] Cannot modify a key which is not a field of the record: ', key));
																	}
																}
															}),
														{
															ctor: '_Tuple2',
															_0: A2(
																_elm_lang$core$Maybe$map,
																function (miRecord) {
																	return {ctor: '_Tuple2', _0: miRecord, _1: _elm_lang$core$Dict$empty};
																},
																_p314),
															_1: _user$project$UpdatedEnv$original(envRecord)
														},
														_p297._0);
													var mbMiAcc = _p305._0;
													var updatedEnvRecord = _p305._1;
													return A2(
														finishUpdateDeclarations,
														updatedEnvRecord,
														F2(
															function (updatedEnvBeforeRecord, updatedDecls) {
																var _p312 = {ctor: '_Tuple3', _0: _p317, _1: _p314, _2: mbMiAcc};
																if ((((((_p312.ctor === '_Tuple3') && (_p312._0.ctor === 'Just')) && (_p312._0._0.ctor === '_Tuple2')) && (_p312._1.ctor === 'Just')) && (_p312._2.ctor === 'Just')) && (_p312._2._0.ctor === '_Tuple2')) {
																	return A8(
																		_user$project$UpdateStack$updateContinue,
																		'ERecord.init',
																		env,
																		_p312._0._0._0,
																		{ctor: '[]'},
																		A2(
																			_user$project$Lang$replaceV_,
																			newVal,
																			_user$project$Lang$VRecord(_p312._1._0)),
																		A2(
																			_user$project$Lang$replaceV_,
																			newVal,
																			_user$project$Lang$VRecord(_p312._2._0._0)),
																		_user$project$Lang$VRecordDiffs(_p312._2._0._1),
																		F2(
																			function (updatedEnvInit, updatedInit) {
																				var finalEnv = A3(_user$project$UpdatedEnv$merge, env, updatedEnvBeforeRecord, updatedEnvInit);
																				var finalExpDiffs = function () {
																					var miDiffsAsChild = A2(
																						_elm_lang$core$Maybe$withDefault,
																						{ctor: '[]'},
																						A2(
																							_elm_lang$core$Maybe$map,
																							function (d) {
																								return {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 0, _1: d},
																									_1: {ctor: '[]'}
																								};
																							},
																							updatedInit.changes));
																					var _p313 = A2(
																						_elm_lang$core$Basics_ops['++'],
																						miDiffsAsChild,
																						A2(
																							_elm_lang$core$Maybe$withDefault,
																							{ctor: '[]'},
																							A2(
																								_elm_lang$core$Maybe$map,
																								function (changes) {
																									return A2(_user$project$UpdateUtils$offset, 1, changes);
																								},
																								updatedDecls.changes)));
																					if (_p313.ctor === '[]') {
																						return _elm_lang$core$Maybe$Nothing;
																					} else {
																						return _elm_lang$core$Maybe$Just(
																							_user$project$Lang$EChildDiffs(_p313));
																					}
																				}();
																				var finalExp = A2(
																					_user$project$Lang$UpdatedExp,
																					ret(
																						A4(
																							_user$project$Lang$ERecord,
																							_p318,
																							_elm_lang$core$Maybe$Just(
																								{ctor: '_Tuple2', _0: updatedInit.val, _1: _p312._0._0._1}),
																							updatedDecls.val,
																							_p319)),
																					finalExpDiffs);
																				return A2(_user$project$UpdateStack$updateResult, finalEnv, finalExp);
																			}));
																} else {
																	var finalExpDiffs = _user$project$Lang$eChildDiffs(updatedDecls.changes);
																	var finalExp = ret(
																		A4(_user$project$Lang$ERecord, _p318, _elm_lang$core$Maybe$Nothing, updatedDecls.val, _p319));
																	return A2(
																		_user$project$UpdateStack$updateResult,
																		updatedEnvBeforeRecord,
																		A2(_user$project$Lang$UpdatedExp, finalExp, finalExpDiffs));
																}
															}));
												}
											}));
								case 'VConstDiffs':
									return A2(
										_user$project$UpdateStack$updateResultSameEnv,
										env,
										A4(
											_user$project$LangUtils$valToExpFull,
											_elm_lang$core$Maybe$Just(e),
											_p318,
											_user$project$LangUtils$InlineSpace,
											newVal));
								default:
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected a Record diff, got ',
											_elm_lang$core$Basics$toString(_p297)));
							}
						}
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected Record as original value, got ',
								_user$project$LangUtils$valToString(oldVal)));
					}
				} else {
					return _user$project$UpdateStack$UpdateCriticalError(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Expected Record as value to update from, got ',
							_user$project$LangUtils$valToString(newVal)));
				}
			case 'ESelect':
				var _p340 = _p211._4;
				var _p339 = _p211._1;
				var _p320 = A2(_user$project$Update$doEvalw, env, _p339);
				if (_p320.ctor === 'Err') {
					return _user$project$UpdateStack$UpdateCriticalError(_p320._0);
				} else {
					var _p338 = _p320._0._0._0;
					var _p337 = _p320._0._1;
					var _p321 = _p338.v_;
					if (_p321.ctor === 'VRecord') {
						var _p336 = _p321._0;
						var _p322 = A2(_elm_lang$core$Dict$get, _p340, _p336);
						if (_p322.ctor === 'Nothing') {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Could not find ',
									A2(_elm_lang$core$Basics_ops['++'], _p340, ' in record.')));
						} else {
							var _p335 = _p322._0;
							var withNewE1 = F2(
								function (newE1UpdatedEnv, newE1) {
									var finalExp = ret(
										A5(_user$project$Lang$ESelect, _p211._0, newE1.val, _p211._2, _p211._3, _p340));
									var finalChanges = A2(
										_elm_lang$core$Maybe$map,
										function (d) {
											return _user$project$Lang$EChildDiffs(
												{
													ctor: '::',
													_0: {ctor: '_Tuple2', _0: 0, _1: d},
													_1: {ctor: '[]'}
												});
										},
										newE1.changes);
									return A2(
										_user$project$UpdateStack$updateResult,
										newE1UpdatedEnv,
										A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
								});
							var $default = function (_p323) {
								var _p324 = _p323;
								var newE1Value = A2(
									_user$project$Lang$replaceV_,
									_p338,
									_user$project$Lang$VRecord(
										A3(_elm_lang$core$Dict$insert, _p340, newVal, _p336)));
								var propagatedDiff = _user$project$Lang$VRecordDiffs(
									_elm_lang$core$Dict$fromList(
										{
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: _p340, _1: diffs},
											_1: {ctor: '[]'}
										}));
								return A8(
									_user$project$UpdateStack$updateContinue,
									'ESelect',
									env,
									_p339,
									A2(_user$project$UpdateStack$keepLets, env, _p337),
									_p338,
									newE1Value,
									propagatedDiff,
									withNewE1);
							};
							var _p325 = _p335.v_;
							if ((_p325.ctor === 'VClosure') && (_p325._1.ctor === '::')) {
								var _p326 = _user$project$Lang$pVarUnapply(_p325._1._0);
								if ((_p326.ctor === 'Just') && (_p326._0 === 'this')) {
									return A8(
										_user$project$UpdateStack$updateContinue,
										'ESelect recursive',
										{
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: 'this', _1: _p338},
											_1: {
												ctor: '::',
												_0: {ctor: '_Tuple2', _0: 'recRecordMethod', _1: _p335},
												_1: {ctor: '[]'}
											}
										},
										A2(
											_user$project$Lang$eApp,
											_user$project$Lang$eVar('recRecordMethod'),
											{
												ctor: '::',
												_0: _user$project$Lang$eVar('this'),
												_1: {ctor: '[]'}
											}),
										{ctor: '[]'},
										oldVal,
										newVal,
										diffs,
										F2(
											function (newRecRecordMethodThis, newApp) {
												if (_elm_lang$core$Native_Utils.eq(newApp.changes, _elm_lang$core$Maybe$Nothing)) {
													var _p327 = newRecRecordMethodThis.val;
													if (((((((_p327.ctor === '::') && (_p327._0.ctor === '_Tuple2')) && (_p327._0._0 === 'this')) && (_p327._1.ctor === '::')) && (_p327._1._0.ctor === '_Tuple2')) && (_p327._1._0._0 === 'recRecordMethod')) && (_p327._1._1.ctor === '[]')) {
														var _p334 = _p327._0._1;
														var _p328 = function () {
															var _p329 = newRecRecordMethodThis.changes;
															if (((_p329.ctor === '::') && (_p329._0.ctor === '_Tuple2')) && (_p329._0._0 === 0)) {
																return {
																	ctor: '_Tuple2',
																	_0: _elm_lang$core$Maybe$Just(_p329._0._1),
																	_1: _p329._1
																};
															} else {
																return {ctor: '_Tuple2', _0: _elm_lang$core$Maybe$Nothing, _1: _p329};
															}
														}();
														var thisChange = _p328._0;
														var otherChanges = _p328._1;
														var recMethodChange = function () {
															var _p330 = otherChanges;
															if (((_p330.ctor === '::') && (_p330._0.ctor === '_Tuple2')) && (_p330._0._0 === 1)) {
																return _elm_lang$core$Maybe$Just(_p330._0._1);
															} else {
																return _elm_lang$core$Maybe$Nothing;
															}
														}();
														var _p331 = function () {
															var _p332 = recMethodChange;
															if (_p332.ctor === 'Nothing') {
																return {ctor: '_Tuple2', _0: _p334, _1: thisChange};
															} else {
																var newE1Value = A2(
																	_user$project$Lang$replaceV_,
																	_p338,
																	_user$project$Lang$VRecord(
																		A3(_elm_lang$core$Dict$insert, _p340, _p327._1._0._1, _p336)));
																var propagatedDiff = _user$project$Lang$VRecordDiffs(
																	_elm_lang$core$Dict$fromList(
																		{
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: _p340, _1: diffs},
																			_1: {ctor: '[]'}
																		}));
																return A5(
																	_user$project$UpdateUtils$mergeValMaybe,
																	_p338,
																	_p334,
																	thisChange,
																	newE1Value,
																	_elm_lang$core$Maybe$Just(propagatedDiff));
															}
														}();
														var finalThis = _p331._0;
														var finalThisChange = _p331._1;
														var _p333 = finalThisChange;
														if (_p333.ctor === 'Just') {
															return A8(
																_user$project$UpdateStack$updateContinue,
																'ESelect',
																env,
																_p339,
																A2(_user$project$UpdateStack$keepLets, env, _p337),
																_p338,
																finalThis,
																_p333._0,
																withNewE1);
														} else {
															return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
														}
													} else {
														return _user$project$UpdateStack$UpdateCriticalError('[Internal error] environment should contain 2 elements');
													}
												} else {
													return _user$project$UpdateStack$UpdateFails('Not allowed to modify rewritten expression (recRecordMethod this)');
												}
											}));
								} else {
									return $default(
										{ctor: '_Tuple0'});
								}
							} else {
								return $default(
									{ctor: '_Tuple0'});
							}
						}
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected Record, got ',
								_user$project$LangUtils$valToString(_p338)));
					}
				}
			case 'EApp':
				var _p489 = _p211._4;
				var _p488 = _p211._0;
				var _p487 = _p211._2;
				var _p486 = _p211._1._0;
				var _p485 = _p211._1;
				var _p484 = _p211._3;
				var isFreezing = function (e1) {
					var _p341 = _user$project$Lang$unwrapExp(e1);
					_v219_2:
					do {
						switch (_p341.ctor) {
							case 'EVar':
								if (_p341._1 === 'freeze') {
									return true;
								} else {
									break _v219_2;
								}
							case 'ESelect':
								if (_p341._4 === 'freeze') {
									var _p342 = _user$project$Lang$unwrapExp(_p341._1);
									if ((_p342.ctor === 'EVar') && (_p342._1 === 'Update')) {
										return true;
									} else {
										return false;
									}
								} else {
									break _v219_2;
								}
							default:
								break _v219_2;
						}
					} while(false);
					return false;
				};
				var isFreezingExpression = function (e1) {
					var _p343 = _user$project$Lang$unwrapExp(e1);
					_v221_2:
					do {
						switch (_p343.ctor) {
							case 'EVar':
								if (_p343._1 === 'expressionFreeze') {
									return true;
								} else {
									break _v221_2;
								}
							case 'ESelect':
								if (_p343._4 === 'expressionFreeze') {
									var _p344 = _user$project$Lang$unwrapExp(_p343._1);
									if ((_p344.ctor === 'EVar') && (_p344._1 === 'Update')) {
										return true;
									} else {
										return false;
									}
								} else {
									break _v221_2;
								}
							default:
								break _v221_2;
						}
					} while(false);
					return false;
				};
				var continueIfNotFrozen = isFreezing(_p485) ? function (continuation) {
					return _user$project$UpdateStack$UpdateFails(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'Hit a freeze (line ',
							A2(
								_elm_lang$core$Basics_ops['++'],
								_elm_lang$core$Basics$toString(_p654.start.line),
								')')));
				} : function (continuation) {
					return continuation(
						{ctor: '_Tuple0'});
				};
				return continueIfNotFrozen(
					function (_p345) {
						var maybeUpdateStack = function () {
							var _p346 = _user$project$Lang$unwrapExp(_p485);
							if ((_p346.ctor === 'ESelect') && (_p346._4 === 'apply')) {
								var _p383 = _p346._3;
								var _p382 = _p346._2;
								var _p381 = _p346._0;
								var _p380 = _p346._1;
								var _p347 = A2(_user$project$Update$doEvalw, env, _p380);
								if (_p347.ctor === 'Err') {
									return _elm_lang$core$Maybe$Just(
										{
											ctor: '_Tuple2',
											_0: _user$project$UpdateStack$UpdateCriticalError(_p347._0),
											_1: false
										});
								} else {
									var _p379 = _p347._0._0._0;
									var _p348 = _p379.v_;
									if (_p348.ctor === 'VRecord') {
										var _p378 = _p348._0;
										if (A2(_elm_lang$core$Dict$member, 'apply', _p378) && (A2(_elm_lang$core$Dict$member, 'unapply', _p378) || A2(_elm_lang$core$Dict$member, 'update', _p378))) {
											var isApplyFrozen = true;
											var _p349 = _p487;
											if (_p349.ctor === '[]') {
												return _elm_lang$core$Maybe$Nothing;
											} else {
												if (_p349._1.ctor === '[]') {
													var _p377 = _p349._0;
													var mbUpdateField = function () {
														var _p350 = A2(_elm_lang$core$Dict$get, 'update', _p378);
														if (_p350.ctor === 'Nothing') {
															return _elm_lang$core$Maybe$Nothing;
														} else {
															var _p367 = _p350._0;
															return _elm_lang$core$Maybe$Just(
																function () {
																	var _p351 = A2(_user$project$Update$doEvalw, env, _p377);
																	if (_p351.ctor === 'Err') {
																		return _user$project$UpdateStack$UpdateCriticalError(_p351._0);
																	} else {
																		var _p366 = _p351._0._0._0;
																		var x = _user$project$Lang$eVar('x');
																		var y = _user$project$Lang$eVar('y');
																		var customArgumentList = function () {
																			var getDiffs = function (_p352) {
																				var _p353 = _p352;
																				var diffsVal = A2(
																					_user$project$UpdateUtils$vDiffsToVal,
																					_user$project$ValBuilder$fromVal(_p379),
																					diffs);
																				return {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 'diffs', _1: diffsVal},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: 'diff', _1: diffsVal},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple2', _0: 'outDiff', _1: diffsVal},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: 'diffOut', _1: diffsVal},
																								_1: {ctor: '[]'}
																							}
																						}
																					}
																				};
																			};
																			var base = {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'input', _1: _p366},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 'output', _1: newVal},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: 'outputNew', _1: newVal},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple2', _0: 'newOutput', _1: newVal},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: 'outputOld', _1: oldVal},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 'outputOriginal', _1: oldVal},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 'oldOutput', _1: oldVal},
																										_1: {ctor: '[]'}
																									}
																								}
																							}
																						}
																					}
																				}
																			};
																			var _p354 = _p367.v_;
																			if (((_p354.ctor === 'VClosure') && (_p354._1.ctor === '::')) && (_p354._1._1.ctor === '[]')) {
																				return A2(
																					_user$project$LangUtils$patternExtractsField,
																					function (f) {
																						return _elm_lang$core$Native_Utils.eq(f, 'diffs') || (_elm_lang$core$Native_Utils.eq(f, 'diff') || (_elm_lang$core$Native_Utils.eq(f, 'outDiff') || _elm_lang$core$Native_Utils.eq(f, 'diffOut')));
																					},
																					_p354._1._0) ? A2(
																					_elm_lang$core$Basics_ops['++'],
																					base,
																					getDiffs(
																						{ctor: '_Tuple0'})) : base;
																			} else {
																				return A2(
																					_elm_lang$core$Basics_ops['++'],
																					base,
																					getDiffs(
																						{ctor: '_Tuple0'}));
																			}
																		}();
																		var customArgument = A3(
																			_user$project$ValBuilder$record,
																			_user$project$ValBuilder$identity,
																			_user$project$ValBuilder$fromVal(_p366),
																			_elm_lang$core$Dict$fromList(customArgumentList));
																		var xyApplication = ret(
																			A5(
																				_user$project$Lang$EApp,
																				_user$project$Lang$space0,
																				x,
																				{
																					ctor: '::',
																					_0: y,
																					_1: {ctor: '[]'}
																				},
																				_user$project$Lang$SpaceApp,
																				_user$project$Lang$space0));
																		var xyEnv = {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 'x', _1: _p367},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'y', _1: customArgument},
																				_1: {ctor: '[]'}
																			}
																		};
																		var _p355 = A2(_user$project$Update$doEvalw, xyEnv, xyApplication);
																		if (_p355.ctor === 'Err') {
																			return _user$project$UpdateStack$UpdateCriticalError(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'Line ',
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						_elm_lang$core$Basics$toString(_p654.start.line),
																						A2(_elm_lang$core$Basics_ops['++'], ', while evaluating a lens, ', _p355._0))));
																		} else {
																			var _p365 = _p355._0._0._0;
																			var _p358 = A2(
																				_user$project$Utils$resultOrElseLazy,
																				function (_p356) {
																					return A2(
																						_elm_lang$core$Result$map,
																						function (_p357) {
																							return _elm_lang$core$Result$Ok(
																								A2(
																									_elm_lang$core$Debug$log,
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'/!\\ The lens line ',
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											_elm_lang$core$Basics$toString(_p654.start.line),
																											' had this returned. Please wrap it in Ok')),
																									_p357));
																						},
																						_user$project$UpdateUtils$valToUpdateReturn(_p365));
																				},
																				A2(_user$project$ValUnbuilder$result, _user$project$UpdateUtils$valToUpdateReturn, _p365));
																			if (_p358.ctor === 'Err') {
																				return _user$project$UpdateStack$UpdateCriticalError(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'The update closure should return either Ok (Inputs [list of values]), Ok (InputsWithDiffs [list of (values, Just diffs | Nothing)]) or Err msg. Got ',
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							_user$project$LangUtils$valToString(_p365),
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								'. (error was ',
																								A2(_elm_lang$core$Basics_ops['++'], _p358._0, ')')))));
																			} else {
																				var _p359 = _p358._0;
																				if (_p359.ctor === 'Err') {
																					return _user$project$UpdateStack$UpdateFails(
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							'Line ',
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								_elm_lang$core$Basics$toString(_p654.start.line),
																								A2(_elm_lang$core$Basics_ops['++'], ': ', _p359._0))));
																				} else {
																					var diffListRes = function () {
																						var _p360 = _p359._0;
																						if (_p360.ctor === 'Inputs') {
																							var vArgStr = _user$project$LangUtils$valToString(_p366);
																							return A2(
																								_user$project$Results$andThen,
																								function (v) {
																									return A2(
																										_user$project$Results$map,
																										function (mbDiffs) {
																											return {ctor: '_Tuple2', _0: v, _1: mbDiffs};
																										},
																										A2(_user$project$UpdateUtils$defaultVDiffs, _p366, v));
																								},
																								_elm_lang$core$Result$Ok(
																									_user$project$LazyList$fromList(_p360._0)));
																						} else {
																							return _elm_lang$core$Result$Ok(
																								_user$project$LazyList$fromList(_p360._0));
																						}
																					}();
																					return A2(
																						_user$project$UpdateStack$updateManys,
																						diffListRes,
																						function (_p361) {
																							var _p362 = _p361;
																							var continuation = function () {
																								var _p363 = _p362._1;
																								if (_p363.ctor === 'Just') {
																									return A7(
																										_user$project$UpdateStack$updateContinue,
																										'.update',
																										env,
																										_p377,
																										{ctor: '[]'},
																										_p366,
																										_p362._0,
																										_p363._0);
																								} else {
																									return function (_p364) {
																										return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
																									};
																								}
																							}();
																							return continuation(
																								F2(
																									function (newUpdatedEnvArg, newUpdatedArg) {
																										var newExp = ret(
																											A5(
																												_user$project$Lang$EApp,
																												_p488,
																												ret(
																													A5(_user$project$Lang$ESelect, _p381, _p380, _p382, _p383, 'apply')),
																												{
																													ctor: '::',
																													_0: newUpdatedArg.val,
																													_1: {ctor: '[]'}
																												},
																												_p484,
																												_p489));
																										var newChanges = A2(
																											_elm_lang$core$Maybe$map,
																											function (changes) {
																												return _user$project$Lang$EChildDiffs(
																													{
																														ctor: '::',
																														_0: {ctor: '_Tuple2', _0: 1, _1: changes},
																														_1: {ctor: '[]'}
																													});
																											},
																											newUpdatedArg.changes);
																										return A2(
																											_user$project$UpdateStack$updateResult,
																											newUpdatedEnvArg,
																											A2(_user$project$Lang$UpdatedExp, newExp, newChanges));
																									}));
																						});
																				}
																			}
																		}
																	}
																}());
														}
													}();
													return A4(
														_user$project$UpdateStack$updateMaybeFirst2,
														'after testing update, testing unapply',
														!isApplyFrozen,
														mbUpdateField,
														function (_p368) {
															var _p369 = A2(_elm_lang$core$Dict$get, 'unapply', _p378);
															if (_p369.ctor === 'Just') {
																var _p370 = A2(_user$project$Update$doEvalw, env, _p377);
																if (_p370.ctor === 'Err') {
																	return _elm_lang$core$Maybe$Just(
																		_user$project$UpdateStack$UpdateCriticalError(_p370._0));
																} else {
																	var _p376 = _p370._0._0._0;
																	var x = _user$project$Lang$eVar('x');
																	var y = _user$project$Lang$eVar('y');
																	var customArgument = newVal;
																	var customExpr = ret(
																		A5(
																			_user$project$Lang$EApp,
																			_user$project$Lang$space0,
																			x,
																			{
																				ctor: '::',
																				_0: y,
																				_1: {ctor: '[]'}
																			},
																			_user$project$Lang$SpaceApp,
																			_user$project$Lang$space0));
																	var _p371 = A2(
																		_user$project$Update$doEvalw,
																		{
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 'x', _1: _p369._0},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'y', _1: customArgument},
																				_1: env
																			}
																		},
																		customExpr);
																	if (_p371.ctor === 'Err') {
																		return _elm_lang$core$Maybe$Just(
																			_user$project$UpdateStack$UpdateCriticalError(
																				A2(_elm_lang$core$Basics_ops['++'], 'while evaluating the .unapply of a lens, ', _p371._0)));
																	} else {
																		var _p372 = A2(_user$project$Update$interpreterMaybeToMaybe, 'the result of executing \'unapply\'', _p371._0._0._0);
																		if (_p372.ctor === 'Err') {
																			return _elm_lang$core$Maybe$Just(
																				_user$project$UpdateStack$UpdateCriticalError(_p372._0));
																		} else {
																			if (_p372._0.ctor === 'Nothing') {
																				return _elm_lang$core$Maybe$Nothing;
																			} else {
																				var _p375 = _p372._0._0;
																				return _elm_lang$core$Maybe$Just(
																					A3(
																						_user$project$UpdateStack$updateMany,
																						A2(_user$project$UpdateUtils$defaultVDiffs, _p376, _p375),
																						function (_p373) {
																							var _p374 = _p373;
																							return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
																						},
																						function (newDiff) {
																							return A8(
																								_user$project$UpdateStack$updateContinue,
																								'.unapply',
																								env,
																								_p377,
																								A2(_user$project$UpdateStack$keepLets, env, _p370._0._1),
																								_p376,
																								_p375,
																								newDiff,
																								F2(
																									function (newUpdatedEnvArg, newUpdatedArg) {
																										var newExp = ret(
																											A5(
																												_user$project$Lang$EApp,
																												_p488,
																												ret(
																													A5(_user$project$Lang$ESelect, _p381, _p380, _p382, _p383, 'apply')),
																												{
																													ctor: '::',
																													_0: newUpdatedArg.val,
																													_1: {ctor: '[]'}
																												},
																												_p484,
																												_p489));
																										var newChanges = A2(
																											_elm_lang$core$Maybe$map,
																											function (changes) {
																												return _user$project$Lang$EChildDiffs(
																													{
																														ctor: '::',
																														_0: {ctor: '_Tuple2', _0: 1, _1: changes},
																														_1: {ctor: '[]'}
																													});
																											},
																											newUpdatedArg.changes);
																										return A2(
																											_user$project$UpdateStack$updateResult,
																											newUpdatedEnvArg,
																											A2(_user$project$Lang$UpdatedExp, newExp, newChanges));
																									}));
																						}));
																			}
																		}
																	}
																}
															} else {
																return _elm_lang$core$Maybe$Nothing;
															}
														});
												} else {
													return _elm_lang$core$Maybe$Nothing;
												}
											}
										} else {
											return _elm_lang$core$Maybe$Nothing;
										}
									} else {
										return _elm_lang$core$Maybe$Nothing;
									}
								}
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						}();
						return A3(
							_user$project$UpdateStack$updateMaybeFirst,
							A2(
								_elm_lang$core$Basics_ops['++'],
								'after testing update/unapply, testing apply (line ',
								A2(
									_elm_lang$core$Basics_ops['++'],
									_elm_lang$core$Basics$toString(_p654.start.line),
									')')),
							maybeUpdateStack,
							function (_p384) {
								if (_elm_lang$core$Native_Utils.eq(_p484, _user$project$Lang$InfixApp) && _elm_lang$core$Native_Utils.eq(
									_user$project$Lang$eVarUnapply(_p485),
									_elm_lang$core$Maybe$Just('++'))) {
									var _p385 = _p487;
									if (((_p385.ctor === '::') && (_p385._1.ctor === '::')) && (_p385._1._1.ctor === '[]')) {
										var _p397 = _p385._1._0;
										var _p396 = _p385._0;
										var _p386 = {
											ctor: '_Tuple2',
											_0: A2(_user$project$Update$doEvalw, env, _p396),
											_1: A2(_user$project$Update$doEvalw, env, _p397)
										};
										if (_p386._0.ctor === 'Err') {
											return _user$project$UpdateStack$UpdateCriticalError(_p386._0._0);
										} else {
											if (_p386._1.ctor === 'Err') {
												return _user$project$UpdateStack$UpdateCriticalError(_p386._1._0);
											} else {
												var _p395 = _p386._1._0._0._0;
												var _p394 = _p386._0._0._0._0;
												var rewrite2 = function (exp2Builder) {
													return A8(
														_user$project$UpdateStack$updateContinue,
														'Rewriting ++ to +',
														{
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: 'x', _1: _p394},
															_1: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: 'y', _1: _p395},
																_1: env
															}
														},
														A2(
															exp2Builder,
															A2(
																_user$project$Lang$replaceE__,
																_p396,
																A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'x')),
															A2(
																_user$project$Lang$replaceE__,
																_p397,
																A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'y'))),
														{ctor: '[]'},
														oldVal,
														newVal,
														diffs,
														F2(
															function (newAugEnv, newUpdatedE1) {
																var _p387 = newAugEnv.val;
																if ((((((_p387.ctor === '::') && (_p387._0.ctor === '_Tuple2')) && (_p387._0._0 === 'x')) && (_p387._1.ctor === '::')) && (_p387._1._0.ctor === '_Tuple2')) && (_p387._1._0._0 === 'y')) {
																	var eLeft_continue = function () {
																		var _p388 = A2(_user$project$UpdateUtils$diffsAt, 0, newAugEnv.changes);
																		if (_p388.ctor === 'Nothing') {
																			return function (continuation) {
																				return A2(
																					continuation,
																					_user$project$UpdatedEnv$original(env),
																					A2(_user$project$Lang$UpdatedExp, _p396, _elm_lang$core$Maybe$Nothing));
																			};
																		} else {
																			return A7(
																				_user$project$UpdateStack$updateContinue,
																				'left of ++',
																				env,
																				_p396,
																				{ctor: '[]'},
																				_p394,
																				_p387._0._1,
																				_p388._0);
																		}
																	}();
																	var eRight_continue = function () {
																		var _p389 = A2(_user$project$UpdateUtils$diffsAt, 1, newAugEnv.changes);
																		if (_p389.ctor === 'Nothing') {
																			return function (continuation) {
																				return A2(
																					continuation,
																					_user$project$UpdatedEnv$original(env),
																					A2(_user$project$Lang$UpdatedExp, _p397, _elm_lang$core$Maybe$Nothing));
																			};
																		} else {
																			return A7(
																				_user$project$UpdateStack$updateContinue,
																				'right of ++',
																				env,
																				_p397,
																				{ctor: '[]'},
																				_p395,
																				_p387._1._0._1,
																				_p389._0);
																		}
																	}();
																	var finalEnv = A2(_user$project$UpdateUtils$dropDiffs, 2, newAugEnv.changes);
																	return eLeft_continue(
																		F2(
																			function (newELeftEnv, newELeft) {
																				return eRight_continue(
																					F2(
																						function (newERightEnv, newERight) {
																							var _p390 = function () {
																								var _p391 = {ctor: '_Tuple2', _0: newELeft.changes, _1: newERight.changes};
																								if ((_p391._0.ctor === 'Nothing') && (_p391._1.ctor === 'Nothing')) {
																									return {ctor: '_Tuple2', _0: e, _1: _elm_lang$core$Maybe$Nothing};
																								} else {
																									return {
																										ctor: '_Tuple2',
																										_0: A2(
																											_user$project$Lang$replaceE__,
																											e,
																											A5(
																												_user$project$Lang$EApp,
																												_p488,
																												_p485,
																												{
																													ctor: '::',
																													_0: newELeft.val,
																													_1: {
																														ctor: '::',
																														_0: newERight.val,
																														_1: {ctor: '[]'}
																													}
																												},
																												_p484,
																												_p489)),
																										_1: _user$project$UpdateUtils$combineEChildDiffs(
																											{
																												ctor: '::',
																												_0: {ctor: '_Tuple2', _0: 1, _1: _p391._0},
																												_1: {
																													ctor: '::',
																													_0: {ctor: '_Tuple2', _0: 2, _1: _p391._1},
																													_1: {ctor: '[]'}
																												}
																											})
																									};
																								}
																							}();
																							var newE = _p390._0;
																							var newEChanges = _p390._1;
																							var finalEnv = A3(_user$project$UpdatedEnv$merge, env, newELeftEnv, newERightEnv);
																							return A2(
																								_user$project$UpdateStack$updateResult,
																								finalEnv,
																								A2(_user$project$Lang$UpdatedExp, newE, newEChanges));
																						}));
																			}));
																} else {
																	return _user$project$UpdateStack$UpdateCriticalError(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'[Internal error] Expected at least 2 values in the environment, got ',
																			_user$project$LangUtils$envToString(newAugEnv.val)));
																}
															}));
												};
												var _p392 = {ctor: '_Tuple2', _0: _p394.v_, _1: _p395.v_};
												if (((((_p392.ctor === '_Tuple2') && (_p392._0.ctor === 'VBase')) && (_p392._0._0.ctor === 'VString')) && (_p392._1.ctor === 'VBase')) && (_p392._1._0.ctor === 'VString')) {
													var _p393 = _elm_lang$core$Debug$log(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'It\'s a string update !',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$LangUtils$valToString(_p394),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	' , ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_user$project$LangUtils$valToString(_p395),
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			' <-- ',
																			_user$project$LangUtils$valToString(newVal)))))));
													return rewrite2(
														F2(
															function (ex, ey) {
																return A2(
																	_user$project$Lang$replaceE__,
																	e,
																	A5(
																		_user$project$Lang$EOp,
																		_user$project$Lang$space1,
																		_user$project$Lang$space1,
																		_user$project$Lang$withDummyRange(_user$project$Lang$Plus),
																		{
																			ctor: '::',
																			_0: ex,
																			_1: {
																				ctor: '::',
																				_0: ey,
																				_1: {ctor: '[]'}
																			}
																		},
																		_user$project$Lang$space0));
															}));
												} else {
													return rewrite2(
														F2(
															function (ex, ey) {
																return A2(
																	_user$project$Lang$replaceE__,
																	e,
																	A5(
																		_user$project$Lang$EApp,
																		_user$project$Lang$space1,
																		A2(
																			_user$project$Lang$replaceE__,
																			_p485,
																			A2(_user$project$Lang$EVar, _user$project$Lang$space0, 'append')),
																		{
																			ctor: '::',
																			_0: ex,
																			_1: {
																				ctor: '::',
																				_0: ey,
																				_1: {ctor: '[]'}
																			}
																		},
																		_user$project$Lang$SpaceApp,
																		_user$project$Lang$space0));
															}));
												}
											}
										}
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'++ should be called with two arguments, was called on ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_elm_lang$core$Basics$toString(
														_elm_lang$core$List$length(_p487)),
													'. ')));
									}
								} else {
									if ((!_elm_lang$core$Native_Utils.eq(_p484, _user$project$Lang$SpaceApp)) && ((!_elm_lang$core$Native_Utils.eq(_p484, _user$project$Lang$InfixApp)) && (_elm_lang$core$Native_Utils.eq(
										_elm_lang$core$List$length(_p487),
										1) && function () {
										var e2 = A2(_user$project$Utils$geti, 0, _p487);
										var _p398 = _user$project$Lang$unwrapExp(e2);
										switch (_p398.ctor) {
											case 'EVar':
												return false;
											case 'EFun':
												return false;
											case 'EBase':
												return false;
											case 'EConst':
												return false;
											default:
												return true;
										}
									}()))) {
										var tmpVarName = A2(
											_elm_lang$core$Basics_ops['++'],
											'tmp',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_elm_lang$core$Basics$toString(
													_user$project$ImpureGoodies$getCurrentTime(
														{ctor: '_Tuple0'})),
												'_'));
										var mbInsertTmpVar = F2(
											function (i, e) {
												var _p399 = _user$project$Lang$unwrapExp(e);
												if (((_p399.ctor === 'EApp') && (_p399._2.ctor === '::')) && (_p399._2._1.ctor === '[]')) {
													var _p403 = _p399._2._0;
													var _p402 = _p399._3;
													if ((!_elm_lang$core$Native_Utils.eq(_p402, _user$project$Lang$SpaceApp)) && ((!_elm_lang$core$Native_Utils.eq(_p402, _user$project$Lang$InfixApp)) && function () {
														var _p400 = _user$project$Lang$unwrapExp(_p403);
														switch (_p400.ctor) {
															case 'EVar':
																return false;
															case 'EFun':
																return false;
															case 'EBase':
																return false;
															case 'EConst':
																return false;
															default:
																return true;
														}
													}())) {
														var _p401 = A2(mbInsertTmpVar, i + 1, _p403);
														var assignments = _p401._0;
														var newSubE2 = _p401._1;
														var tmpVar = A2(
															_elm_lang$core$Basics_ops['++'],
															tmpVarName,
															_elm_lang$core$Basics$toString(i));
														return {
															ctor: '_Tuple2',
															_0: {
																ctor: '::',
																_0: {ctor: '_Tuple2', _0: tmpVar, _1: newSubE2},
																_1: assignments
															},
															_1: A2(
																_user$project$Lang$replaceE__,
																e,
																A5(
																	_user$project$Lang$EApp,
																	_p399._0,
																	_p399._1,
																	{
																		ctor: '::',
																		_0: _user$project$Lang$eVar(tmpVar),
																		_1: {ctor: '[]'}
																	},
																	_p402,
																	_p399._4))
														};
													} else {
														return {
															ctor: '_Tuple2',
															_0: {ctor: '[]'},
															_1: e
														};
													}
												} else {
													return {
														ctor: '_Tuple2',
														_0: {ctor: '[]'},
														_1: e
													};
												}
											});
										var propagateChanges = F2(
											function (updatedEnv, updatedExp) {
												var resFinalExpChanges = function () {
													var _p404 = {
														ctor: '_Tuple2',
														_0: _user$project$Lang$unwrapExp(updatedExp.val),
														_1: updatedExp.changes
													};
													_v252_2:
													do {
														if (_p404.ctor === '_Tuple2') {
															if (_p404._1.ctor === 'Just') {
																if ((_p404._0.ctor === 'ELet') && (_p404._1._0.ctor === 'EChildDiffs')) {
																	var _p422 = _p404._0._4;
																	var argumentRemDiffs = A3(
																		_elm_lang$core$List$foldl,
																		F2(
																			function (group, acc) {
																				var _p405 = group;
																				if (((_p405.ctor === '_Tuple2') && (_p405._1.ctor === '::')) && (_p405._1._1.ctor === '[]')) {
																					var _p416 = _p405._1._0._5;
																					var _p406 = acc;
																					if (_p406.ctor === 'Err') {
																						return _elm_lang$core$Result$Err(_p406._0);
																					} else {
																						if (_p406._0._2.ctor === 'Nothing') {
																							var _p409 = _p406._0._0;
																							var _p408 = _p406._0._1;
																							var _p407 = _p408;
																							if (((_p407.ctor === '::') && (_p407._0.ctor === '_Tuple2')) && (_p407._0._0 === 0)) {
																								return _elm_lang$core$Result$Ok(
																									{
																										ctor: '_Tuple3',
																										_0: _p409 + 1,
																										_1: _p407._1,
																										_2: _elm_lang$core$Maybe$Just(
																											{
																												ctor: '_Tuple2',
																												_0: _p416,
																												_1: _elm_lang$core$Maybe$Just(_p407._0._1)
																											})
																									});
																							} else {
																								return _elm_lang$core$Result$Ok(
																									{
																										ctor: '_Tuple3',
																										_0: _p409 + 1,
																										_1: _p408,
																										_2: _elm_lang$core$Maybe$Just(
																											{ctor: '_Tuple2', _0: _p416, _1: _elm_lang$core$Maybe$Nothing})
																									});
																							}
																						} else {
																							var _p415 = _p406._0._2._0._1;
																							var _p414 = _p406._0._0;
																							var _p413 = _p406._0._1;
																							var _p410 = _user$project$Lang$unwrapExp(_p416);
																							if (((_p410.ctor === 'EApp') && (_p410._2.ctor === '::')) && (_p410._2._1.ctor === '[]')) {
																								var _p411 = function () {
																									var _p412 = _p413;
																									if (((((((_p412.ctor === '::') && (_p412._0.ctor === '_Tuple2')) && (_p412._0._1.ctor === 'EChildDiffs')) && (_p412._0._1._0.ctor === '::')) && (_p412._0._1._0._0.ctor === '_Tuple2')) && (_p412._0._1._0._0._0 === 0)) && (_p412._0._1._0._1.ctor === '[]')) {
																										return _elm_lang$core$Native_Utils.eq(_p412._0._0, _p414) ? {
																											ctor: '_Tuple2',
																											_0: _p412._1,
																											_1: _user$project$UpdateUtils$combineEChildDiffs(
																												{
																													ctor: '::',
																													_0: {
																														ctor: '_Tuple2',
																														_0: 0,
																														_1: _elm_lang$core$Maybe$Just(_p412._0._1._0._0._1)
																													},
																													_1: {
																														ctor: '::',
																														_0: {ctor: '_Tuple2', _0: 1, _1: _p415},
																														_1: {ctor: '[]'}
																													}
																												})
																										} : {
																											ctor: '_Tuple2',
																											_0: _p413,
																											_1: _user$project$UpdateUtils$combineEChildDiffs(
																												{
																													ctor: '::',
																													_0: {ctor: '_Tuple2', _0: 1, _1: _p415},
																													_1: {ctor: '[]'}
																												})
																										};
																									} else {
																										return {
																											ctor: '_Tuple2',
																											_0: _p413,
																											_1: _user$project$UpdateUtils$combineEChildDiffs(
																												{
																													ctor: '::',
																													_0: {ctor: '_Tuple2', _0: 1, _1: _p415},
																													_1: {ctor: '[]'}
																												})
																										};
																									}
																								}();
																								var remDiffList = _p411._0;
																								var thisChange = _p411._1;
																								return _elm_lang$core$Result$Ok(
																									A3(
																										F3(
																											function (v0, v1, v2) {
																												return {ctor: '_Tuple3', _0: v0, _1: v1, _2: v2};
																											}),
																										_p414 + 1,
																										remDiffList,
																										_elm_lang$core$Maybe$Just(
																											{
																												ctor: '_Tuple2',
																												_0: A2(
																													_user$project$Lang$replaceE__,
																													_p416,
																													A5(
																														_user$project$Lang$EApp,
																														_p410._0,
																														_p410._1,
																														{
																															ctor: '::',
																															_0: _p406._0._2._0._0,
																															_1: {ctor: '[]'}
																														},
																														_p410._3,
																														_p410._4)),
																												_1: thisChange
																											})));
																							} else {
																								return _elm_lang$core$Result$Err(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'[Internal error] Assignment was not an EApp after updating the rewrite',
																										_user$project$Update$unparse(_p416)));
																							}
																						}
																					}
																				} else {
																					return _elm_lang$core$Result$Err(
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							'[Internal error] Found not just one LetExp',
																							_elm_lang$core$Basics$toString(group)));
																				}
																			}),
																		_elm_lang$core$Result$Ok(
																			{ctor: '_Tuple3', _0: 0, _1: _p404._1._0._0, _2: _elm_lang$core$Maybe$Nothing}),
																		_p404._0._2._3);
																	return A2(
																		_elm_lang$core$Result$andThen,
																		function (_p417) {
																			var _p418 = _p417;
																			var _p419 = {
																				ctor: '_Tuple2',
																				_0: _user$project$Lang$unwrapExp(_p422),
																				_1: _p418._2
																			};
																			if (((((_p419._0.ctor === 'EApp') && (_p419._0._2.ctor === '::')) && (_p419._0._2._1.ctor === '[]')) && (_p419._1.ctor === 'Just')) && (_p419._1._0.ctor === '_Tuple2')) {
																				var _p421 = _p419._1._0._1;
																				var thisChange = function () {
																					var _p420 = _p418._1;
																					if (((((((_p420.ctor === '::') && (_p420._0.ctor === '_Tuple2')) && (_p420._0._1.ctor === 'EChildDiffs')) && (_p420._0._1._0.ctor === '::')) && (_p420._0._1._0._0.ctor === '_Tuple2')) && (_p420._0._1._0._0._0 === 0)) && (_p420._0._1._0._1.ctor === '[]')) {
																						return _user$project$UpdateUtils$combineEChildDiffs(
																							{
																								ctor: '::',
																								_0: {
																									ctor: '_Tuple2',
																									_0: 0,
																									_1: _elm_lang$core$Maybe$Just(_p420._0._1._0._0._1)
																								},
																								_1: {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 1, _1: _p421},
																									_1: {ctor: '[]'}
																								}
																							});
																					} else {
																						return _user$project$UpdateUtils$combineEChildDiffs(
																							{
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: 1, _1: _p421},
																								_1: {ctor: '[]'}
																							});
																					}
																				}();
																				return _elm_lang$core$Result$Ok(
																					{
																						ctor: '_Tuple2',
																						_0: A2(
																							_user$project$Lang$replaceE__,
																							e,
																							A5(
																								_user$project$Lang$EApp,
																								_p419._0._0,
																								_p419._0._1,
																								{
																									ctor: '::',
																									_0: _p419._1._0._0,
																									_1: {ctor: '[]'}
																								},
																								_p419._0._3,
																								_p419._0._4)),
																						_1: thisChange
																					});
																			} else {
																				return _elm_lang$core$Result$Err(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'[Internal error]: Updated body is not an EApp ',
																						_user$project$Update$unparse(_p422)));
																			}
																		},
																		argumentRemDiffs);
																} else {
																	break _v252_2;
																}
															} else {
																return _elm_lang$core$Result$Ok(
																	{ctor: '_Tuple2', _0: e, _1: _elm_lang$core$Maybe$Nothing});
															}
														} else {
															break _v252_2;
														}
													} while(false);
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'[Internal error]: Updated expression is not an ELet ',
															_user$project$Update$unparse(updatedExp.val)));
												}();
												var _p423 = resFinalExpChanges;
												if (_p423.ctor === 'Err') {
													return _user$project$UpdateStack$UpdateCriticalError(_p423._0);
												} else {
													return A2(
														_user$project$UpdateStack$updateResult,
														updatedEnv,
														A2(_user$project$Lang$UpdatedExp, _p423._0._0, _p423._0._1));
												}
											});
										var _p424 = A2(mbInsertTmpVar, 1, e);
										var assignments = _p424._0;
										var rewritingBody = _p424._1;
										var rewriting = A2(
											_user$project$Lang$replaceE__,
											e,
											A5(
												_user$project$Lang$ELet,
												_user$project$Lang$space0,
												_user$project$Lang$Let,
												A4(
													_user$project$Lang$Declarations,
													A2(
														_elm_lang$core$List$range,
														0,
														_elm_lang$core$List$length(assignments) - 1),
													{ctor: '[]'},
													{ctor: '[]'},
													A2(
														_elm_lang$core$List$map,
														function (_p425) {
															var _p426 = _p425;
															return {
																ctor: '_Tuple2',
																_0: false,
																_1: {
																	ctor: '::',
																	_0: A6(
																		_user$project$Lang$LetExp,
																		_elm_lang$core$Maybe$Nothing,
																		_user$project$Lang$space1,
																		_user$project$Lang$pVar(_p426._0),
																		_user$project$Lang$FunArgAsPats,
																		_user$project$Lang$space1,
																		_p426._1),
																	_1: {ctor: '[]'}
																}
															};
														},
														_elm_lang$core$List$reverse(assignments))),
												_user$project$Lang$space0,
												rewritingBody));
										return A8(
											_user$project$UpdateStack$updateContinue,
											'Rewriting to temporary assignments',
											env,
											rewriting,
											{ctor: '[]'},
											oldVal,
											newVal,
											diffs,
											propagateChanges);
									} else {
										var updateAppResult = F4(
											function (newE1UpdatedEnv, newUpdatedE1, newE2sUpdatedEnv, newUpdatedE2s) {
												var finalUpdatedEnv = A3(_user$project$UpdatedEnv$merge, env, newE1UpdatedEnv, newE2sUpdatedEnv);
												var finalExp = ret(
													A5(_user$project$Lang$EApp, _p488, newUpdatedE1.val, newUpdatedE2s.val, _p484, _p489));
												var finalChanges = A2(_user$project$UpdateUtils$combineAppChanges, newUpdatedE1.changes, newUpdatedE2s.changes);
												return A2(
													_user$project$UpdateStack$updateResult,
													finalUpdatedEnv,
													A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
											});
										var _p427 = A2(_user$project$Update$doEvalw, env, _p485);
										if (_p427.ctor === 'Err') {
											return _user$project$UpdateStack$UpdateCriticalError(_p427._0);
										} else {
											var _p483 = _p427._0._0._0;
											var _p428 = _p483.v_;
											switch (_p428.ctor) {
												case 'VClosure':
													var _p444 = _p428._0;
													var _p443 = _p428._3;
													var _p442 = _p428._1;
													var ne1ps = _elm_lang$core$List$length(_p442);
													var _p429 = A2(_user$project$Utils$split, ne1ps, _p487);
													var es2ToEval = _p429._0;
													var es2ForLater = _p429._1;
													if (_elm_lang$core$Native_Utils.cmp(
														_elm_lang$core$List$length(es2ForLater),
														0) > 0) {
														var rewriting = ret(
															A5(
																_user$project$Lang$EApp,
																_p488,
																ret(
																	A5(_user$project$Lang$EApp, _p488, _p485, es2ToEval, _user$project$Lang$SpaceApp, _p489)),
																es2ForLater,
																_user$project$Lang$SpaceApp,
																_p489));
														return A8(
															_user$project$UpdateStack$updateContinue,
															'evaluating app with correct number of arguments',
															env,
															rewriting,
															{ctor: '[]'},
															oldVal,
															newVal,
															diffs,
															F2(
																function (newUpdatedEnv, newRewriting) {
																	var _p430 = _user$project$Lang$unwrapExp(newRewriting.val);
																	if (_p430.ctor === 'EApp') {
																		var _p431 = _user$project$Lang$unwrapExp(_p430._1);
																		if (_p431.ctor === 'EApp') {
																			var newChanges = A2(
																				_elm_lang$core$Maybe$map,
																				_user$project$UpdateUtils$flattenFirstEChildDiffs(ne1ps),
																				newRewriting.changes);
																			var newExp = ret(
																				A5(
																					_user$project$Lang$EApp,
																					_p488,
																					_p431._1,
																					A2(_elm_lang$core$Basics_ops['++'], _p431._2, _p430._2),
																					_p484,
																					_p489));
																			return A2(
																				_user$project$UpdateStack$updateResult,
																				newUpdatedEnv,
																				A2(_user$project$Lang$UpdatedExp, newExp, newChanges));
																		} else {
																			return _user$project$UpdateStack$UpdateCriticalError(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'[internal error] expected EApp, got ',
																					_elm_lang$core$Basics$toString(_p431)));
																		}
																	} else {
																		return _user$project$UpdateStack$UpdateCriticalError(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'[internal error] expected EApp, got ',
																				_elm_lang$core$Basics$toString(_p430)));
																	}
																}));
													} else {
														var _p432 = _user$project$Utils$projOk(
															A3(
																_elm_lang$core$List$map2,
																F2(
																	function (p, e2) {
																		return A2(_user$project$Update$doEvalw, env, e2);
																	}),
																_p442,
																es2ToEval));
														if (_p432.ctor === 'Err') {
															return _user$project$UpdateStack$UpdateCriticalError(_p432._0);
														} else {
															var v2s = A2(
																_elm_lang$core$List$map,
																function (_p433) {
																	var _p434 = _p433;
																	return _p434._0._0;
																},
																_p432._0);
															var ne2 = _elm_lang$core$List$length(_p487);
															var closureEnv = _elm_lang$core$Native_Utils.eq(
																_p444,
																{ctor: '[]'}) ? _p443 : A2(_user$project$Lang$expandRecEnv, _p444, _p443);
															var _p435 = (_elm_lang$core$Native_Utils.cmp(ne1ps, ne2) > 0) ? A2(_user$project$Utils$split, ne2, _p442) : {
																ctor: '_Tuple2',
																_0: _p442,
																_1: {ctor: '[]'}
															};
															var e1psUsed = _p435._0;
															var e1psNotUsed = _p435._1;
															var propagateAppFunArguments = F3(
																function (consBuilder, updatedInsideEnv, updatedBody) {
																	var _p436 = consBuilder(updatedInsideEnv);
																	var newV2s = _p436._0._0;
																	var newV2sDiffs = _p436._0._1;
																	var updatedExpandedEnv_ = _p436._1;
																	var updatedEnv_ = _elm_lang$core$Native_Utils.eq(
																		_p444,
																		{ctor: '[]'}) ? updatedExpandedEnv_ : A3(_user$project$UpdatedEnv$expandRecEnvReverse, _p444, _p443, updatedExpandedEnv_);
																	var _p437 = _user$project$Lang$updatedVal.unapply(
																		A5(
																			_user$project$Lang$updated.vClosure,
																			_user$project$Lang$replaceV_(_p483),
																			_p444,
																			_p442,
																			updatedBody,
																			updatedEnv_));
																	var newV1 = _p437._0;
																	var newV1Diffs = _p437._1;
																	var e1_updater = function () {
																		var _p438 = newV1Diffs;
																		if (_p438.ctor === 'Nothing') {
																			return function (continuation) {
																				return A2(
																					continuation,
																					_user$project$UpdatedEnv$original(env),
																					A2(_user$project$Lang$UpdatedExp, _p485, _elm_lang$core$Maybe$Nothing));
																			};
																		} else {
																			return A7(
																				_user$project$UpdateStack$updateContinue,
																				'VClosure1 partial app',
																				env,
																				_p485,
																				A2(_user$project$UpdateStack$keepLets, env, _p427._0._1),
																				_p483,
																				newV1,
																				_p438._0);
																		}
																	}();
																	var e2s_updater = function () {
																		var _p439 = newV2sDiffs;
																		if (_p439.ctor === '[]') {
																			return function (continuation) {
																				return A2(
																					continuation,
																					_user$project$UpdatedEnv$original(env),
																					A2(_user$project$Lang$UpdatedExpTuple, _p487, _elm_lang$core$Maybe$Nothing));
																			};
																		} else {
																			return A5(
																				_user$project$UpdateStack$updateContinueMultiple,
																				'args of partial app',
																				env,
																				{ctor: '[]'},
																				A3(_user$project$Utils$zip3, _p487, v2s, newV2s),
																				_p439);
																		}
																	}();
																	return e1_updater(
																		F2(
																			function (newE1UpdatedEnv, newUpdatedE1) {
																				return e2s_updater(
																					F2(
																						function (newE2sUpdatedEnv, newUpdatedE2s) {
																							return (isFreezingExpression(_p485) && (!_elm_lang$core$Native_Utils.eq(newUpdatedE2s.changes, _elm_lang$core$Maybe$Nothing))) ? _user$project$UpdateStack$UpdateFails(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'Hit an expressionFreeze on line ',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_elm_lang$core$Basics$toString(_p486.start.line),
																										' (cannot modify expression, only variables\' values)'))) : A4(updateAppResult, newE1UpdatedEnv, newUpdatedE1, newE2sUpdatedEnv, newUpdatedE2s);
																						}));
																			}));
																});
															var _p440 = A2(
																_user$project$Update$conssWithInversion,
																{ctor: '_Tuple2', _0: e1psUsed, _1: v2s},
																_elm_lang$core$Maybe$Just(
																	{ctor: '_Tuple2', _0: closureEnv, _1: _elm_lang$core$Basics$identity}));
															if ((_p440.ctor === 'Just') && (_p440._0.ctor === '_Tuple2')) {
																var withUpdatedInsideEnvAndBody = function (continuation) {
																	if (_elm_lang$core$Native_Utils.cmp(ne1ps, ne2) > 0) {
																		var _p441 = {ctor: '_Tuple2', _0: newVal.v_, _1: diffs};
																		if (((_p441.ctor === '_Tuple2') && (_p441._0.ctor === 'VClosure')) && (_p441._1.ctor === 'VClosureDiffs')) {
																			return A2(
																				continuation,
																				A2(_user$project$Lang$UpdatedEnv, _p441._0._3, _p441._1._0),
																				A2(_user$project$Lang$UpdatedExp, _p441._0._2, _p441._1._1));
																		} else {
																			return _user$project$UpdateStack$UpdateCriticalError(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					_user$project$Lang$strPos(_p486.start),
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'Expected a closure in output, got ',
																						A2(
																							_elm_lang$core$Basics_ops['++'],
																							_user$project$LangUtils$valToString(newVal),
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								' and diffs ',
																								_elm_lang$core$Basics$toString(diffs))))));
																		}
																	} else {
																		return A8(
																			_user$project$UpdateStack$updateContinue,
																			'VClosure3',
																			_p440._0._0,
																			_p428._2,
																			{ctor: '[]'},
																			oldVal,
																			newVal,
																			diffs,
																			continuation);
																	}
																};
																return withUpdatedInsideEnvAndBody(
																	propagateAppFunArguments(_p440._0._1));
															} else {
																return _user$project$UpdateStack$UpdateCriticalError(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'[internal error] ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_user$project$Lang$strPos(_p486.start),
																			' bad environment, internal error in update')));
															}
														}
													}
												case 'VFun':
													var _p459 = _p428._0;
													var _p458 = _p428._1;
													var _p445 = _p428._3;
													if (_p445.ctor === 'Nothing') {
														return (_elm_lang$core$Native_Utils.eq(_p459, '>=') || (_elm_lang$core$Native_Utils.eq(_p459, '>') || (_elm_lang$core$Native_Utils.eq(_p459, '<=') || _elm_lang$core$Native_Utils.eq(_p459, '/=')))) ? A9(
															_user$project$Update$opFlip,
															env,
															e,
															_p488,
															_user$project$Lang$precedingWhitespaceWithInfoExp(_p485),
															_p459,
															_p487,
															_p489,
															oldVal,
															newVal) : _user$project$UpdateStack$UpdateFails(
															A2(_elm_lang$core$Basics_ops['++'], 'No built-in definition to update ', _p459));
													} else {
														var arity = _elm_lang$core$List$length(_p458);
														var nAvailableArgs = _elm_lang$core$List$length(_p487);
														if (_elm_lang$core$Native_Utils.cmp(arity, nAvailableArgs) < 0) {
															var _p446 = A2(_user$project$Utils$split, arity, _p487);
															var es2ToEval = _p446._0;
															var es2ForLater = _p446._1;
															var rewriting = ret(
																A5(
																	_user$project$Lang$EApp,
																	_p488,
																	ret(
																		A5(_user$project$Lang$EApp, _p488, _p485, es2ToEval, _user$project$Lang$SpaceApp, _p489)),
																	es2ForLater,
																	_user$project$Lang$SpaceApp,
																	_p489));
															return A8(
																_user$project$UpdateStack$updateContinue,
																'EApp VFun',
																env,
																rewriting,
																{ctor: '[]'},
																oldVal,
																newVal,
																diffs,
																F2(
																	function (newUpdatedEnv, newRewriting) {
																		var _p447 = _user$project$Lang$unwrapExp(newRewriting.val);
																		if (_p447.ctor === 'EApp') {
																			var _p449 = _p447._1;
																			var _p448 = _user$project$Lang$unwrapExp(_p449);
																			if (_p448.ctor === 'EApp') {
																				var finalChanges = A2(
																					_elm_lang$core$Maybe$map,
																					_user$project$UpdateUtils$flattenFirstEChildDiffs(arity),
																					newRewriting.changes);
																				var finalExp = ret(
																					A5(
																						_user$project$Lang$EApp,
																						_p488,
																						_p448._1,
																						A2(_elm_lang$core$Basics_ops['++'], _p448._2, _p447._2),
																						_p484,
																						_p489));
																				return A2(
																					_user$project$UpdateStack$updateResult,
																					newUpdatedEnv,
																					A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
																			} else {
																				return _user$project$UpdateStack$UpdateCriticalError(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'[internal error] expected EApp, got ',
																						A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p449)));
																			}
																		} else {
																			return _user$project$UpdateStack$UpdateCriticalError(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'[internal error] expected EApp, got ',
																					A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, newRewriting.val)));
																		}
																	}));
														} else {
															if (_elm_lang$core$Native_Utils.cmp(arity, nAvailableArgs) > 0) {
																var convertedBody = A2(
																	_user$project$Lang$replaceE__,
																	_p485,
																	A5(
																		_user$project$Lang$EApp,
																		_p488,
																		ret(
																			A2(_user$project$Lang$EVar, _user$project$Lang$space1, _p459)),
																		A2(
																			_elm_lang$core$List$map,
																			function (_p450) {
																				return _user$project$Lang$withDummyExpInfo(
																					A2(_user$project$Lang$EVar, _user$project$Lang$space1, _p450));
																			},
																			_p458),
																		_user$project$Lang$SpaceApp,
																		_p488));
																var funconverted = A2(
																	_user$project$Lang$replaceE__,
																	_p485,
																	A4(
																		_user$project$Lang$EFun,
																		_user$project$Lang$space0,
																		A2(
																			_elm_lang$core$List$map,
																			function (n) {
																				return _user$project$Lang$withDummyPatInfo(
																					A3(_user$project$Lang$PVar, _user$project$Lang$space1, n, _user$project$Lang$noWidgetDecl));
																			},
																			_p458),
																		convertedBody,
																		_user$project$Lang$space0));
																return A8(
																	_user$project$UpdateStack$updateContinue,
																	'EApp VFun eta',
																	env,
																	ret(
																		A5(_user$project$Lang$EApp, _user$project$Lang$space0, funconverted, _p487, _user$project$Lang$SpaceApp, _user$project$Lang$space0)),
																	{ctor: '[]'},
																	oldVal,
																	newVal,
																	diffs,
																	F2(
																		function (newUpdatedEnv, newUpdatedBody) {
																			var _p451 = _user$project$Lang$unwrapExp(newUpdatedBody.val);
																			if (_p451.ctor === 'EApp') {
																				if (A2(_user$project$LangUtils$expEqual, _p451._1, funconverted)) {
																					var finalExp = ret(
																						A5(_user$project$Lang$EApp, _p488, _p485, _p451._2, _p484, _p489));
																					var finalChanges = newUpdatedBody.changes;
																					return A2(
																						_user$project$UpdateStack$updateResult,
																						newUpdatedEnv,
																						A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
																				} else {
																					return _user$project$UpdateStack$UpdateFails('Cannot modify the definition of a built-in function');
																				}
																			} else {
																				return _user$project$UpdateStack$UpdateCriticalError(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'[internal error] expected EApp, got',
																						A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)));
																			}
																		}));
															} else {
																var _p452 = _user$project$Utils$projOk(
																	A2(
																		_elm_lang$core$List$map,
																		_user$project$Update$doEvalw(env),
																		_p487));
																if (_p452.ctor === 'Err') {
																	return _user$project$UpdateStack$UpdateCriticalError(_p452._0);
																} else {
																	var v2s = A2(
																		_elm_lang$core$List$map,
																		function (_p453) {
																			var _p454 = _p453;
																			return _p454._0._0;
																		},
																		_p452._0);
																	var _p455 = A4(_p445._0, v2s, oldVal, newVal, diffs);
																	if (_p455.ctor === 'Err') {
																		return _user$project$UpdateStack$UpdateCriticalError(_p455._0);
																	} else {
																		if (_p455._0.ctor === 'Nil') {
																			return _user$project$UpdateStack$UpdateFails(
																				A2(_elm_lang$core$Basics_ops['++'], 'not solution for updating ', _p459));
																		} else {
																			var llWithDiffResult = A2(
																				_user$project$LazyList$map,
																				function (_p456) {
																					var _p457 = _p456;
																					var resMaybeDiffsOffsetted = A2(_user$project$UpdateUtils$offset, 1, _p457._1);
																					return {
																						ctor: '_Tuple2',
																						_0: {ctor: '::', _0: _p483, _1: _p457._0},
																						_1: _user$project$Results$ok1(
																							_elm_lang$core$Maybe$Just(resMaybeDiffsOffsetted))
																					};
																				},
																				_p455._0);
																			return A7(
																				_user$project$UpdateStack$updateOpMultiple,
																				'vfun',
																				env,
																				{ctor: '::', _0: _p485, _1: _p487},
																				function (funAndNewE2s) {
																					return ret(
																						A5(
																							_user$project$Lang$EApp,
																							_p488,
																							_p485,
																							A2(_user$project$Utils$tail, 'vfun', funAndNewE2s),
																							_p484,
																							_p489));
																				},
																				{ctor: '[]'},
																				{ctor: '::', _0: _p483, _1: v2s},
																				llWithDiffResult);
																		}
																	}
																}
															}
														}
													}
												case 'VRecord':
													var _p460 = {
														ctor: '_Tuple6',
														_0: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vStringUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorDataType, _p483)),
														_1: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vRecordUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorArgs, _p483)),
														_2: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vStringUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorDataType, oldVal)),
														_3: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vRecordUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorArgs, oldVal)),
														_4: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vStringUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorDataType, newVal)),
														_5: A2(
															_elm_lang$core$Maybe$andThen,
															_user$project$Lang$vRecordUnapply,
															A2(_user$project$Lang$vRecordUnapplyField, _user$project$Lang$ctorArgs, newVal))
													};
													if (((((((_p460.ctor === '_Tuple6') && (_p460._0.ctor === 'Just')) && (_p460._1.ctor === 'Just')) && (_p460._2.ctor === 'Just')) && (_p460._3.ctor === 'Just')) && (_p460._4.ctor === 'Just')) && (_p460._5.ctor === 'Just')) {
														var _p482 = _p460._3._0;
														var _p481 = _p460._4._0;
														var _p480 = _p460._5._0;
														var _p479 = _p460._0._0;
														if (!_elm_lang$core$Native_Utils.eq(_p479, _p481)) {
															return _user$project$UpdateStack$UpdateCriticalError(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	_user$project$Lang$strPos(_p486.start),
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		' cannot push back a ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_p481,
																			A2(_elm_lang$core$Basics_ops['++'], ' to replace a partiall call to ', _p479)))));
														} else {
															if (!_elm_lang$core$Native_Utils.eq(_p460._2._0, _p481)) {
																return _user$project$UpdateStack$UpdateCriticalError(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_user$project$Lang$strPos(_p486.start),
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			' cannot push back a ',
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_p481,
																				A2(_elm_lang$core$Basics_ops['++'], ' to replace a partiall call to ', _p479)))));
															} else {
																var existingArgsSize = _elm_lang$core$Dict$size(_p460._1._0);
																var _p461 = diffs;
																if (_p461.ctor === 'VRecordDiffs') {
																	var _p478 = _p461._0;
																	var _p462 = A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorArgs, _p478);
																	if (_p462.ctor === 'Nothing') {
																		return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
																	} else {
																		if (_p462._0.ctor === 'VRecordDiffs') {
																			var _p477 = _p462._0._0;
																			var newE1Diffs = A2(
																				_elm_lang$core$Dict$filter,
																				F2(
																					function (name, _p463) {
																						return A2(
																							_elm_lang$core$Result$withDefault,
																							false,
																							A2(
																								_elm_lang$core$Result$map,
																								function (x) {
																									return _elm_lang$core$Native_Utils.cmp(x, existingArgsSize) < 1;
																								},
																								_user$project$Lang$nameToArg(name)));
																					}),
																				_p477);
																			var newE2sDiffs = A2(
																				_elm_lang$core$Dict$filter,
																				F2(
																					function (name, _p464) {
																						return A2(
																							_elm_lang$core$Result$withDefault,
																							false,
																							A2(
																								_elm_lang$core$Result$map,
																								function (x) {
																									return _elm_lang$core$Native_Utils.cmp(x, existingArgsSize) > 0;
																								},
																								_user$project$Lang$nameToArg(name)));
																					}),
																				_p477);
																			var e1_updater = function () {
																				if (_elm_lang$core$Dict$isEmpty(newE1Diffs)) {
																					return function (continuation) {
																						return A2(
																							continuation,
																							_user$project$UpdatedEnv$original(env),
																							A2(_user$project$Lang$UpdatedExp, _p485, _elm_lang$core$Maybe$Nothing));
																					};
																				} else {
																					var newDatatypeDict = A2(
																						_user$project$Utils$maybeWithDefaultLazy,
																						function (_p465) {
																							return _elm_lang$core$Dict$fromList(
																								{
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: _user$project$Lang$ctorDataType,
																										_1: _user$project$Update$vStr(_p479)
																									},
																									_1: {ctor: '[]'}
																								});
																						},
																						_user$project$Lang$vRecordUnapply(newVal));
																					var oldDatatypeDict = A2(
																						_user$project$Utils$maybeWithDefaultLazy,
																						function (_p466) {
																							return _elm_lang$core$Dict$fromList(
																								{
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: _user$project$Lang$ctorDataType,
																										_1: _user$project$Update$vStr(_p479)
																									},
																									_1: {ctor: '[]'}
																								});
																						},
																						_user$project$Lang$vRecordUnapply(oldVal));
																					var oldValE1 = A2(
																						_user$project$Lang$replaceV_,
																						_p483,
																						_user$project$Lang$VRecord(
																							A3(
																								_elm_lang$core$Dict$insert,
																								_user$project$Lang$ctorArgs,
																								A2(
																									_user$project$Lang$replaceV_,
																									_p483,
																									_user$project$Lang$VRecord(
																										A2(
																											_elm_lang$core$Dict$filter,
																											F2(
																												function (name, _p467) {
																													return A2(
																														_elm_lang$core$Result$withDefault,
																														false,
																														A2(
																															_elm_lang$core$Result$map,
																															function (x) {
																																return _elm_lang$core$Native_Utils.cmp(x, existingArgsSize) < 1;
																															},
																															_user$project$Lang$nameToArg(name)));
																												}),
																											_p482))),
																								oldDatatypeDict)));
																					var newValE1 = A2(
																						_user$project$Lang$replaceV_,
																						_p483,
																						_user$project$Lang$VRecord(
																							A3(
																								_elm_lang$core$Dict$insert,
																								_user$project$Lang$ctorArgs,
																								A2(
																									_user$project$Lang$replaceV_,
																									_p483,
																									_user$project$Lang$VRecord(
																										A2(
																											_elm_lang$core$Dict$filter,
																											F2(
																												function (name, _p468) {
																													return A2(
																														_elm_lang$core$Result$withDefault,
																														false,
																														A2(
																															_elm_lang$core$Result$map,
																															function (x) {
																																return _elm_lang$core$Native_Utils.cmp(x, existingArgsSize) < 1;
																															},
																															_user$project$Lang$nameToArg(name)));
																												}),
																											_p480))),
																								newDatatypeDict)));
																					var v1pdiffs = _user$project$Lang$VRecordDiffs(
																						A3(
																							_elm_lang$core$Dict$insert,
																							_user$project$Lang$ctorArgs,
																							_user$project$Lang$VRecordDiffs(newE1Diffs),
																							_p478));
																					return A7(
																						_user$project$UpdateStack$updateContinue,
																						'EApp-Datatype-1',
																						env,
																						_p485,
																						{ctor: '[]'},
																						oldValE1,
																						newValE1,
																						v1pdiffs);
																				}
																			}();
																			var e2s_updater = function () {
																				if (_elm_lang$core$Dict$isEmpty(newE2sDiffs)) {
																					return function (continuation) {
																						return A2(
																							continuation,
																							_user$project$UpdatedEnv$original(env),
																							A2(_user$project$Lang$UpdatedExpTuple, _p487, _elm_lang$core$Maybe$Nothing));
																					};
																				} else {
																					var diffIndexToArgName = function (diffIndex) {
																						return _user$project$Lang$argName((diffIndex + existingArgsSize) + 1);
																					};
																					var aux = F3(
																						function (diffIndex, $arguments, _p469) {
																							aux:
																							while (true) {
																								var _p470 = _p469;
																								var _p475 = _p470._0;
																								var _p474 = _p470._1;
																								var _p471 = $arguments;
																								if (_p471.ctor === '::') {
																									var name = diffIndexToArgName(diffIndex);
																									var newRevAccDiffs = function () {
																										var _p472 = A2(_elm_lang$core$Dict$get, name, newE2sDiffs);
																										if (_p472.ctor === 'Nothing') {
																											return _p474;
																										} else {
																											return {
																												ctor: '::',
																												_0: {ctor: '_Tuple2', _0: diffIndex, _1: _p472._0},
																												_1: _p474
																											};
																										}
																									}();
																									var _p473 = {
																										ctor: '_Tuple2',
																										_0: A2(_elm_lang$core$Dict$get, name, _p482),
																										_1: A2(_elm_lang$core$Dict$get, name, _p480)
																									};
																									if (_p473._0.ctor === 'Just') {
																										if (_p473._1.ctor === 'Just') {
																											var _v288 = diffIndex + 1,
																												_v289 = _p471._1,
																												_v290 = {
																												ctor: '_Tuple2',
																												_0: {
																													ctor: '::',
																													_0: {ctor: '_Tuple3', _0: _p471._0, _1: _p473._0._0, _2: _p473._1._0},
																													_1: _p475
																												},
																												_1: newRevAccDiffs
																											};
																											diffIndex = _v288;
																											$arguments = _v289;
																											_p469 = _v290;
																											continue aux;
																										} else {
																											return _elm_lang$core$Result$Err(
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													_user$project$Lang$strPos(_p486.start),
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														'Wrong number of arguments when updating, missing ',
																														A2(_elm_lang$core$Basics_ops['++'], name, ' in the new value'))));
																										}
																									} else {
																										return _elm_lang$core$Result$Err(
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												_user$project$Lang$strPos(_p486.start),
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'Wrong number of arguments when updating, missing ',
																													A2(_elm_lang$core$Basics_ops['++'], name, ' in the old value'))));
																									}
																								} else {
																									return _elm_lang$core$Result$Ok(
																										{
																											ctor: '_Tuple2',
																											_0: _elm_lang$core$List$reverse(_p475),
																											_1: _elm_lang$core$List$reverse(_p474)
																										});
																								}
																							}
																						});
																					var _p476 = A3(
																						aux,
																						0,
																						_p487,
																						{
																							ctor: '_Tuple2',
																							_0: {ctor: '[]'},
																							_1: {ctor: '[]'}
																						});
																					if (_p476.ctor === 'Ok') {
																						return A5(
																							_user$project$UpdateStack$updateContinueMultiple,
																							'EApp-Datatype-2',
																							env,
																							{ctor: '[]'},
																							_p476._0._0,
																							_p476._0._1);
																					} else {
																						return function (continuation) {
																							return _user$project$UpdateStack$UpdateCriticalError(_p476._0);
																						};
																					}
																				}
																			}();
																			return e1_updater(
																				F2(
																					function (newE1UpdatedEnv, newUpdatedE1) {
																						return e2s_updater(
																							F2(
																								function (newE2sUpdatedEnv, newUpdatedE2s) {
																									return A4(updateAppResult, newE1UpdatedEnv, newUpdatedE1, newE2sUpdatedEnv, newUpdatedE2s);
																								}));
																					}));
																		} else {
																			return _user$project$UpdateStack$UpdateFails(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					_user$project$Lang$strPos(_p486.start),
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'The diffs for the args of a datatype has to be a VRecordDiffs, got ',
																						_elm_lang$core$Basics$toString(_p462._0))));
																		}
																	}
																} else {
																	return _user$project$UpdateStack$UpdateFails(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_user$project$Lang$strPos(_p486.start),
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'When partially applying a datatype, cannot accept something other than VRecordDiffs as diffs. Got ',
																				_elm_lang$core$Basics$toString(diffs))));
																}
															}
														}
													} else {
														return _user$project$UpdateStack$UpdateCriticalError(
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$Lang$strPos(_p486.start),
																' not a function or a partially applied datatype'));
													}
												default:
													return _user$project$UpdateStack$UpdateCriticalError(
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$Lang$strPos(_p486.start),
															' not a function or a partially applied datatype'));
											}
										}
									}
								}
							});
					});
			case 'EIf':
				var _p499 = _p211._3;
				var _p498 = _p211._6;
				var _p497 = _p211._4;
				var _p496 = _p211._2;
				var _p495 = _p211._0;
				var _p494 = _p211._5;
				var _p493 = _p211._1;
				var _p490 = A2(_user$project$Update$doEvalw, env, _p493);
				if (_p490.ctor === 'Ok') {
					var _p492 = _p490._0._0._0;
					var _p491 = _p492.v_;
					if ((_p491.ctor === 'VBase') && (_p491._0.ctor === 'VBool')) {
						return _p491._0._0 ? A8(
							_user$project$UpdateStack$updateContinue,
							'IfThen',
							env,
							_p499,
							prevLets,
							oldVal,
							newVal,
							diffs,
							F2(
								function (newUpdatedEnv, newUpdatedThn) {
									var finalExp = ret(
										A7(_user$project$Lang$EIf, _p495, _p493, _p496, newUpdatedThn.val, _p497, _p494, _p498));
									var finalChanges = A2(_user$project$UpdateUtils$wrap, 1, newUpdatedThn.changes);
									return A2(
										_user$project$UpdateStack$updateResult,
										newUpdatedEnv,
										A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
								})) : A8(
							_user$project$UpdateStack$updateContinue,
							'IfElse',
							env,
							_p494,
							prevLets,
							oldVal,
							newVal,
							diffs,
							F2(
								function (newUpdatedEnv, newUpdatedEls) {
									var finalExp = ret(
										A7(_user$project$Lang$EIf, _p495, _p493, _p496, _p499, _p497, newUpdatedEls.val, _p498));
									var finalChanges = A2(_user$project$UpdateUtils$wrap, 2, newUpdatedEls.changes);
									return A2(
										_user$project$UpdateStack$updateResult,
										newUpdatedEnv,
										A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
								}));
					} else {
						return _user$project$UpdateStack$UpdateCriticalError(
							A2(
								_elm_lang$core$Basics_ops['++'],
								'Expected boolean condition, got ',
								_user$project$LangUtils$valToString(_p492)));
					}
				} else {
					return _user$project$UpdateStack$UpdateCriticalError(_p490._0);
				}
			case 'EOp':
				var _p633 = _p211._1;
				var _p632 = _p211._4;
				var _p631 = _p211._0;
				var _p630 = _p211._3;
				var _p629 = _p211._2;
				var _p500 = {ctor: '_Tuple2', _0: _p629.val, _1: _p630};
				_v294_2:
				do {
					if (((_p500.ctor === '_Tuple2') && (_p500._1.ctor === '::')) && (_p500._1._1.ctor === '[]')) {
						switch (_p500._0.ctor) {
							case 'NoWidgets':
								return A8(
									_user$project$UpdateStack$updateContinue,
									'NoWidgets',
									env,
									_p500._1._0,
									{ctor: '[]'},
									oldVal,
									newVal,
									diffs,
									F2(
										function (newUpdatedEnv, newUpdatedArg) {
											var finalExp = ret(
												A5(
													_user$project$Lang$EOp,
													_p631,
													_p633,
													_p629,
													{
														ctor: '::',
														_0: newUpdatedArg.val,
														_1: {ctor: '[]'}
													},
													_p632));
											return A2(
												_user$project$UpdateStack$updateResult,
												newUpdatedEnv,
												A2(
													_user$project$Lang$UpdatedExp,
													finalExp,
													A2(_user$project$UpdateUtils$wrap, 0, newUpdatedArg.changes)));
										}));
							case 'DebugLog':
								return A8(
									_user$project$UpdateStack$updateContinue,
									'DebugLog',
									env,
									_p500._1._0,
									{ctor: '[]'},
									oldVal,
									newVal,
									diffs,
									F2(
										function (newUpdatedEnv, newUpdatedArg) {
											var finalExp = ret(
												A5(
													_user$project$Lang$EOp,
													_p631,
													_p633,
													_p629,
													{
														ctor: '::',
														_0: newUpdatedArg.val,
														_1: {ctor: '[]'}
													},
													_p632));
											return A2(
												_user$project$UpdateStack$updateResult,
												newUpdatedEnv,
												A2(
													_user$project$Lang$UpdatedExp,
													finalExp,
													A2(_user$project$UpdateUtils$wrap, 0, newUpdatedArg.changes)));
										}));
							default:
								break _v294_2;
						}
					} else {
						break _v294_2;
					}
				} while(false);
				var _p501 = _user$project$Utils$projOk(
					A2(
						_elm_lang$core$List$map,
						_user$project$Update$doEvalw(env),
						_p630));
				if (_p501.ctor === 'Err') {
					return _user$project$UpdateStack$UpdateCriticalError(_p501._0);
				} else {
					var _p502 = A2(
						_elm_lang$core$Tuple$mapFirst,
						_elm_lang$core$List$unzip,
						_elm_lang$core$List$unzip(_p501._0));
					var vs = _p502._0._0;
					var wss = _p502._0._1;
					var envs = _p502._1;
					var args = A2(
						_elm_lang$core$List$map,
						function (_) {
							return _.v_;
						},
						vs);
					var _p503 = _p629.val;
					switch (_p503.ctor) {
						case 'CurrentEnv':
							var resNewEnv = A2(
								_user$project$ValUnbuilder$list,
								A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity),
								newVal);
							var resNewEnvDiffs = A2(
								_elm_lang$core$Result$map,
								_elm_lang$core$List$concatMap(_elm_lang$core$Basics$identity),
								A2(
									_elm_lang$core$Result$andThen,
									function (_p504) {
										return _user$project$Utils$projOk(
											A2(
												_elm_lang$core$List$map,
												function (_p505) {
													var _p506 = _p505;
													var _p510 = _p506._1;
													var _p507 = _p510;
													if (_p507.ctor === 'VRecordDiffs') {
														var _p509 = _p507._0;
														var _p508 = {
															ctor: '_Tuple3',
															_0: A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorTuple, _p509),
															_1: A2(_elm_lang$core$Dict$get, '_1', _p509),
															_2: A2(_elm_lang$core$Dict$get, '_2', _p509)
														};
														_v299_3:
														do {
															if (_p508.ctor === '_Tuple3') {
																if (_p508._0.ctor === 'Just') {
																	return _elm_lang$core$Result$Err('Unexpected change to the tuple constructor\'s name');
																} else {
																	if (_p508._1.ctor === 'Just') {
																		return _elm_lang$core$Result$Err('Cannot change the name of a variable');
																	} else {
																		if (_p508._2.ctor === 'Just') {
																			return _elm_lang$core$Result$Ok(
																				{
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: _p506._0, _1: _p508._2._0},
																					_1: {ctor: '[]'}
																				});
																		} else {
																			break _v299_3;
																		}
																	}
																}
															} else {
																break _v299_3;
															}
														} while(false);
														return _elm_lang$core$Result$Ok(
															{ctor: '[]'});
													} else {
														return _elm_lang$core$Result$Err(
															A2(
																_elm_lang$core$Basics_ops['++'],
																'Expected VRecordDiffs, got ',
																_elm_lang$core$Basics$toString(_p510)));
													}
												},
												_p504));
									},
									A2(
										_elm_lang$core$Result$fromMaybe,
										'Insertions and deletions not authorized in environments',
										function () {
											var _p511 = diffs;
											if (_p511.ctor === 'VListDiffs') {
												return _user$project$UpdateUtils$toTupleDiffs(_p511._0);
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										}())));
							var _p512 = {ctor: '_Tuple2', _0: resNewEnv, _1: resNewEnvDiffs};
							_v301_1:
							do {
								if (_p512._0.ctor === 'Ok') {
									if (_p512._1.ctor === 'Ok') {
										return A2(
											_user$project$UpdateStack$updateResult,
											A2(_user$project$Lang$UpdatedEnv, _p512._0._0, _p512._1._0),
											A2(_user$project$Lang$UpdatedExp, e, _elm_lang$core$Maybe$Nothing));
									} else {
										break _v301_1;
									}
								} else {
									if (_p512._1.ctor === 'Err') {
										break _v301_1;
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(_p512._0._0);
									}
								}
							} while(false);
							return _user$project$UpdateStack$UpdateFails(_p512._1._0);
						case 'Explode':
							var _p513 = {ctor: '_Tuple2', _0: vs, _1: _p630};
							if ((((_p513._0.ctor === '::') && (_p513._0._1.ctor === '[]')) && (_p513._1.ctor === '::')) && (_p513._1._1.ctor === '[]')) {
								var _p532 = _p513._0._0;
								var _p514 = {
									ctor: '_Tuple3',
									_0: A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$string, oldVal),
									_1: A2(_user$project$ValUnbuilder$list, _user$project$ValUnbuilder$string, newVal),
									_2: diffs
								};
								if (_p514._0.ctor === 'Ok') {
									if (_p514._1.ctor === 'Ok') {
										if (_p514._2.ctor === 'VListDiffs') {
											var _p531 = _p514._1._0;
											var newResult = A2(
												_user$project$ValBuilder$string,
												_user$project$ValBuilder$fromVal(_p532),
												A2(_elm_lang$core$String$join, '', _p531));
											var resNewResultDiffs = function () {
												var aux = F4(
													function (d, oldStrings, newStrings, _p515) {
														aux:
														while (true) {
															var _p516 = _p515;
															var _p529 = _p516._1;
															var _p528 = _p516._2;
															var _p517 = d;
															if (_p517.ctor === '[]') {
																return _elm_lang$core$Result$Ok(
																	_user$project$Lang$VStringDiffs(
																		_elm_lang$core$List$reverse(_p528)));
															} else {
																var _p527 = _p517._1;
																var _p526 = _p517._0._0;
																var notModified = _p526 - _p516._0;
																if (_elm_lang$core$Native_Utils.cmp(notModified, 0) > 0) {
																	var _p518 = A2(_user$project$Utils$split, notModified, oldStrings);
																	var sameOld = _p518._0;
																	var remainingOld = _p518._1;
																	var _p519 = A2(_user$project$Utils$split, notModified, newStrings);
																	var remainingNew = _p519._1;
																	var sameStringLength = _elm_lang$core$List$sum(
																		A2(_elm_lang$core$List$map, _elm_lang$core$String$length, sameOld));
																	var _v306 = d,
																		_v307 = remainingOld,
																		_v308 = remainingNew,
																		_v309 = {ctor: '_Tuple3', _0: _p526, _1: _p529 + sameStringLength, _2: _p528};
																	d = _v306;
																	oldStrings = _v307;
																	newStrings = _v308;
																	_p515 = _v309;
																	continue aux;
																} else {
																	var _p520 = _p517._0._1;
																	switch (_p520.ctor) {
																		case 'ListElemInsert':
																			var _p521 = A2(_user$project$Utils$split, _p520._0, newStrings);
																			var inserted = _p521._0;
																			var remainingNew = _p521._1;
																			var insertedStringLength = _elm_lang$core$List$sum(
																				A2(_elm_lang$core$List$map, _elm_lang$core$String$length, inserted));
																			var _v311 = _p527,
																				_v312 = oldStrings,
																				_v313 = remainingNew,
																				_v314 = {
																				ctor: '_Tuple3',
																				_0: _p526,
																				_1: _p529,
																				_2: {
																					ctor: '::',
																					_0: A3(_user$project$Lang$StringUpdate, _p529, _p529, insertedStringLength),
																					_1: _p528
																				}
																			};
																			d = _v311;
																			oldStrings = _v312;
																			newStrings = _v313;
																			_p515 = _v314;
																			continue aux;
																		case 'ListElemDelete':
																			var _p523 = _p520._0;
																			var _p522 = A2(_user$project$Utils$split, _p523, oldStrings);
																			var deleted = _p522._0;
																			var remainingOld = _p522._1;
																			var deletedStringLength = _elm_lang$core$List$sum(
																				A2(_elm_lang$core$List$map, _elm_lang$core$String$length, deleted));
																			var _v315 = _p527,
																				_v316 = remainingOld,
																				_v317 = newStrings,
																				_v318 = {
																				ctor: '_Tuple3',
																				_0: _p526 + _p523,
																				_1: _p529 + deletedStringLength,
																				_2: {
																					ctor: '::',
																					_0: A3(_user$project$Lang$StringUpdate, _p529, _p529 + deletedStringLength, 0),
																					_1: _p528
																				}
																			};
																			d = _v315;
																			oldStrings = _v316;
																			newStrings = _v317;
																			_p515 = _v318;
																			continue aux;
																		default:
																			var _p525 = _p520._0;
																			var _p524 = {ctor: '_Tuple3', _0: oldStrings, _1: newStrings, _2: _p525};
																			_v319_3:
																			do {
																				if (_p524.ctor === '_Tuple3') {
																					if (_p524._0.ctor === '::') {
																						if (_p524._1.ctor === '::') {
																							if (_p524._2.ctor === 'VStringDiffs') {
																								var _v320 = _p527,
																									_v321 = _p524._0._1,
																									_v322 = _p524._1._1,
																									_v323 = {
																									ctor: '_Tuple3',
																									_0: _p526 + 1,
																									_1: _p529 + _elm_lang$core$String$length(_p524._0._0),
																									_2: A2(
																										_user$project$Utils$reverseInsert,
																										A2(_user$project$Lang$offsetStr, _p529, _p524._2._0),
																										_p528)
																								};
																								d = _v320;
																								oldStrings = _v321;
																								newStrings = _v322;
																								_p515 = _v323;
																								continue aux;
																							} else {
																								break _v319_3;
																							}
																						} else {
																							return _elm_lang$core$Result$Err(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'Diff and values are not coherent for explode: ',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_elm_lang$core$Basics$toString(diffs),
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											'\n',
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												_user$project$LangUtils$valToString(oldVal),
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'\n',
																													_user$project$LangUtils$valToString(newVal)))))));
																						}
																					} else {
																						return _elm_lang$core$Result$Err(
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								'Diff and values are not coherent for explode: ',
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									_elm_lang$core$Basics$toString(diffs),
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'\n',
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											_user$project$LangUtils$valToString(oldVal),
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												'\n',
																												_user$project$LangUtils$valToString(newVal)))))));
																					}
																				} else {
																					break _v319_3;
																				}
																			} while(false);
																			return _elm_lang$core$Result$Err(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'expected a VStringDiffs in the diffs of explode\'s output\'s elements, got ',
																					_elm_lang$core$Basics$toString(_p525)));
																	}
																}
															}
														}
													});
												return A4(
													aux,
													_p514._2._0,
													_p514._0._0,
													_p531,
													{
														ctor: '_Tuple3',
														_0: 0,
														_1: 0,
														_2: {ctor: '[]'}
													});
											}();
											var _p530 = resNewResultDiffs;
											if (_p530.ctor === 'Err') {
												return _user$project$UpdateStack$UpdateCriticalError(_p530._0);
											} else {
												return A8(
													_user$project$UpdateStack$updateContinue,
													'argument of explode',
													env,
													_p513._1._0,
													{ctor: '[]'},
													_p532,
													newResult,
													_p530._0,
													F2(
														function (newUpdatedEnv, newUpdatedOpArg) {
															var finalExp = ret(
																A5(
																	_user$project$Lang$EOp,
																	_p631,
																	_p633,
																	_p629,
																	{
																		ctor: '::',
																		_0: newUpdatedOpArg.val,
																		_1: {ctor: '[]'}
																	},
																	_p632));
															return A2(
																_user$project$UpdateStack$updateResult,
																newUpdatedEnv,
																A2(
																	_user$project$Lang$UpdatedExp,
																	finalExp,
																	A2(_user$project$UpdateUtils$wrap, 0, newUpdatedOpArg.changes)));
														}));
											}
										} else {
											return _user$project$UpdateStack$UpdateCriticalError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Expected a VListDiffs for explode, got ',
													_elm_lang$core$Basics$toString(diffs)));
										}
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Expected a list of string as new output for explode, got ',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p514._1._0,
													A2(
														_elm_lang$core$Basics_ops['++'],
														' for ',
														_user$project$LangUtils$valToString(newVal)))));
									}
								} else {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected a list of string as previous output for explode, got ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p514._0._0,
												A2(
													_elm_lang$core$Basics_ops['++'],
													' for ',
													_user$project$LangUtils$valToString(oldVal)))));
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Wrong number of arguments for explode, expected 1, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(vs))));
							}
						case 'DictFromList':
							var _p533 = {ctor: '_Tuple2', _0: vs, _1: _p630};
							if (((((_p533.ctor === '_Tuple2') && (_p533._0.ctor === '::')) && (_p533._0._1.ctor === '[]')) && (_p533._1.ctor === '::')) && (_p533._1._1.ctor === '[]')) {
								var _p561 = _p533._0._0;
								var _p534 = A2(
									_user$project$ValUnbuilder$list,
									A2(
										_user$project$ValUnbuilder$tuple2,
										A2(
											_user$project$ValUnbuilder$dup,
											_user$project$ValUnbuilder$identity,
											_user$project$LangUtils$valToDictKey(_user$project$Syntax$Leo)),
										_user$project$ValUnbuilder$identity),
									_p561);
								if (_p534.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected a list of key/values, got ',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p534._0,
												A2(
													_elm_lang$core$Basics_ops['++'],
													' for ',
													_user$project$LangUtils$valToString(_p561)))));
								} else {
									var _p560 = _p534._0;
									var _p535 = {ctor: '_Tuple2', _0: newVal.v_, _1: diffs};
									if ((_p535._0.ctor === 'VDict') && (_p535._1.ctor === 'VDictDiffs')) {
										var _p559 = _p535._0._0;
										var _p558 = _p535._1._0;
										var _p536 = A3(
											_elm_lang$core$List$foldl,
											F2(
												function (_p538, _p537) {
													var _p539 = _p538;
													var _p547 = _p539._0._0._0;
													var _p546 = _p539._1;
													var _p545 = _p539._0._0._1;
													var _p540 = _p537;
													var _p544 = _p540._0;
													var _p543 = _p540._1;
													var _p541 = {
														ctor: '_Tuple2',
														_0: A2(_elm_lang$core$Dict$get, _p545, _p558),
														_1: A2(_elm_lang$core$Dict$get, _p545, _p559)
													};
													_v330_3:
													do {
														if (_p541._0.ctor === 'Just') {
															switch (_p541._0._0.ctor) {
																case 'VDictElemDelete':
																	return {
																		ctor: '_Tuple2',
																		_0: _p544,
																		_1: {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: _p546,
																				_1: _user$project$Lang$ListElemDelete(1)
																			},
																			_1: _p543
																		}
																	};
																case 'VDictElemUpdate':
																	if (_p541._1.ctor === 'Just') {
																		return {
																			ctor: '_Tuple2',
																			_0: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: _p547, _1: _p541._1._0},
																				_1: _p544
																			},
																			_1: {
																				ctor: '::',
																				_0: {
																					ctor: '_Tuple2',
																					_0: _p546,
																					_1: _user$project$Lang$ListElemUpdate(
																						_user$project$Lang$VRecordDiffs(
																							_elm_lang$core$Dict$fromList(
																								{
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: '_2', _1: _p541._0._0._0},
																									_1: {ctor: '[]'}
																								})))
																				},
																				_1: _p543
																			}
																		};
																	} else {
																		break _v330_3;
																	}
																default:
																	break _v330_3;
															}
														} else {
															return {
																ctor: '_Tuple2',
																_0: {
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: _p547, _1: _p539._0._1},
																	_1: _p544
																},
																_1: _p543
															};
														}
													} while(false);
													return _elm_lang$core$Native_Utils.crashCase(
														'Update',
														{
															start: {line: 1212, column: 37},
															end: {line: 1216, column: 260}
														},
														_p541)(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'Unexpected diff: ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_elm_lang$core$Basics$toString(_p541._0),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	' on val ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		A2(
																			_elm_lang$core$Maybe$withDefault,
																			'Nothing',
																			A2(_elm_lang$core$Maybe$map, _user$project$LangUtils$valToString, _p541._1)),
																		' when updating DictFromList -- if it was a VDictElemInsert, the key already existed')))));
												}),
											{
												ctor: '_Tuple2',
												_0: {ctor: '[]'},
												_1: {ctor: '[]'}
											},
											_user$project$Utils$zipWithIndex(_p560));
										var newListRev = _p536._0;
										var newDiffsRev = _p536._1;
										var _p548 = A3(
											_elm_lang$core$Dict$foldl,
											F3(
												function (k, v, _p549) {
													var _p550 = _p549;
													var _p557 = _p550._1;
													var _p556 = _p550._0;
													var _p551 = v;
													if (_p551.ctor === 'VDictElemInsert') {
														var _p552 = A2(_elm_lang$core$Dict$get, k, _p559);
														if (_p552.ctor === 'Just') {
															var _p553 = A2(_user$project$LangUtils$dictKeyToVal, _user$project$Syntax$Leo, k);
															if (_p553.ctor === 'Ok') {
																return {
																	ctor: '_Tuple2',
																	_0: {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: _p553._0, _1: _p552._0},
																		_1: _p556
																	},
																	_1: _p557 + 1
																};
															} else {
																return _elm_lang$core$Native_Utils.crashCase(
																	'Update',
																	{
																		start: {line: 1222, column: 56},
																		end: {line: 1224, column: 136}
																	},
																	_p553)(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'Could not get a key out of ',
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			_elm_lang$core$Basics$toString(k),
																			A2(_elm_lang$core$Basics_ops['++'], ' because ', _p553._0))));
															}
														} else {
															return _elm_lang$core$Native_Utils.crashCase(
																'Update',
																{
																	start: {line: 1221, column: 60},
																	end: {line: 1225, column: 191}
																},
																_p552)(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'Unexpected VictElemInsert of ',
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		_elm_lang$core$Basics$toString(k),
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			' but this key was not found in the updating dictionary ',
																			_user$project$LangUtils$valToString(newVal)))));
														}
													} else {
														return {ctor: '_Tuple2', _0: _p556, _1: _p557};
													}
												}),
											{ctor: '_Tuple2', _0: newListRev, _1: 0},
											_p558);
										var finalListRev = _p548._0;
										var numberAdded = _p548._1;
										var finalDiffsRev = (_elm_lang$core$Native_Utils.cmp(numberAdded, 0) > 0) ? {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: _elm_lang$core$List$length(_p560),
												_1: _user$project$Lang$ListElemInsert(numberAdded)
											},
											_1: newDiffsRev
										} : newDiffsRev;
										var finalValuesList = A3(
											_user$project$ValBuilder$list,
											A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$identity, _user$project$ValBuilder$identity),
											_user$project$ValBuilder$fromVal(_p561),
											_elm_lang$core$List$reverse(finalListRev));
										var finalDiffsList = _user$project$Lang$VListDiffs(
											_elm_lang$core$List$reverse(finalDiffsRev));
										return A8(
											_user$project$UpdateStack$updateContinue,
											'DictFromList',
											env,
											_p533._1._0,
											{ctor: '[]'},
											_p561,
											finalValuesList,
											finalDiffsList,
											F2(
												function (newEnv, newKeyValuesListE) {
													var finalExp = ret(
														A5(
															_user$project$Lang$EOp,
															_p631,
															_p633,
															_p629,
															{
																ctor: '::',
																_0: newKeyValuesListE.val,
																_1: {ctor: '[]'}
															},
															_p632));
													return A2(
														_user$project$UpdateStack$updateResult,
														newEnv,
														A2(
															_user$project$Lang$UpdatedExp,
															finalExp,
															A2(_user$project$UpdateUtils$wrap, 0, newKeyValuesListE.changes)));
												}));
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Expected a VDictDiffs, got ',
												_elm_lang$core$Basics$toString(_p535._1)));
									}
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										' DictFromList expects one argument, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(vs))));
							}
						case 'DictGet':
							var _p562 = vs;
							if (((_p562.ctor === '::') && (_p562._1.ctor === '::')) && (_p562._1._1.ctor === '[]')) {
								var _p576 = _p562._0;
								var _p575 = _p562._1._0;
								var _p563 = A2(_user$project$LangUtils$valToDictKey, _user$project$Syntax$Leo, _p576);
								if (_p563.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Could not convert this to a dictionary key: ',
											_user$project$LangUtils$valToString(_p576)));
								} else {
									var _p574 = _p563._0;
									var _p564 = _p575.v_;
									if (_p564.ctor === 'VDict') {
										var _p573 = _p564._0;
										var continuation = F2(
											function (newDict, newDiff) {
												var _p565 = _p630;
												if (((_p565.ctor === '::') && (_p565._1.ctor === '::')) && (_p565._1._1.ctor === '[]')) {
													return A8(
														_user$project$UpdateStack$updateContinue,
														'DictGet',
														env,
														_p565._1._0,
														{ctor: '[]'},
														_p575,
														newDict,
														newDiff,
														F2(
															function (newEnv, newDictE) {
																return A2(
																	_user$project$UpdateStack$updateResult,
																	newEnv,
																	A2(
																		_user$project$Lang$UpdatedExp,
																		ret(
																			A5(
																				_user$project$Lang$EOp,
																				_p631,
																				_p633,
																				_p629,
																				{
																					ctor: '::',
																					_0: _p565._0,
																					_1: {
																						ctor: '::',
																						_0: newDictE.val,
																						_1: {ctor: '[]'}
																					}
																				},
																				_p632)),
																		A2(_user$project$UpdateUtils$wrap, 1, newDictE.changes)));
															}));
												} else {
													return _user$project$UpdateStack$UpdateCriticalError(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'DictGet requires two arguments, got ',
															_elm_lang$core$Basics$toString(
																_elm_lang$core$List$length(vs))));
												}
											});
										var _p566 = A2(_elm_lang$core$Dict$get, _p574, _p573);
										if (_p566.ctor === 'Nothing') {
											var _p567 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, newVal);
											_v340_2:
											do {
												if ((_p567.ctor === 'Ok') && (_p567._0.ctor === '_Tuple2')) {
													if (_p567._0._1.ctor === '[]') {
														if (_p567._0._0 === 'Nothing') {
															return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
														} else {
															break _v340_2;
														}
													} else {
														if ((_p567._0._0 === 'Just') && (_p567._0._1._1.ctor === '[]')) {
															var newDiff = _user$project$Lang$VDictDiffs(
																_elm_lang$core$Dict$fromList(
																	{
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: _p574, _1: _user$project$Lang$VDictElemInsert},
																		_1: {ctor: '[]'}
																	}));
															var newDict = A2(
																_user$project$Lang$replaceV_,
																_p575,
																_user$project$Lang$VDict(
																	A3(_elm_lang$core$Dict$insert, _p574, _p567._0._1._0, _p573)));
															return A2(continuation, newDict, newDiff);
														} else {
															break _v340_2;
														}
													}
												} else {
													break _v340_2;
												}
											} while(false);
											return _user$project$UpdateStack$UpdateCriticalError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Expected Nothing or Just x, got ',
													_user$project$LangUtils$valToString(newVal)));
										} else {
											var _p568 = A2(_user$project$ValUnbuilder$constructor, _elm_lang$core$Result$Ok, newVal);
											_v341_2:
											do {
												if ((_p568.ctor === 'Ok') && (_p568._0.ctor === '_Tuple2')) {
													if (_p568._0._1.ctor === '[]') {
														if (_p568._0._0 === 'Nothing') {
															var newDiff = _user$project$Lang$VDictDiffs(
																_elm_lang$core$Dict$fromList(
																	{
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: _p574, _1: _user$project$Lang$VDictElemDelete},
																		_1: {ctor: '[]'}
																	}));
															var newDict = A2(
																_user$project$Lang$replaceV_,
																_p575,
																_user$project$Lang$VDict(
																	A2(_elm_lang$core$Dict$remove, _p574, _p573)));
															return A2(continuation, newDict, newDiff);
														} else {
															break _v341_2;
														}
													} else {
														if ((_p568._0._0 === 'Just') && (_p568._0._1._1.ctor === '[]')) {
															var _p569 = diffs;
															if (_p569.ctor === 'VRecordDiffs') {
																var _p570 = A2(_elm_lang$core$Dict$get, _user$project$Lang$ctorArgs, _p569._0);
																if (_p570.ctor === 'Nothing') {
																	return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
																} else {
																	var _p571 = _p570._0;
																	if (_p571.ctor === 'VRecordDiffs') {
																		var _p572 = A2(_elm_lang$core$Dict$get, '_1', _p571._0);
																		if (_p572.ctor === 'Just') {
																			var newDiff = _user$project$Lang$VDictDiffs(
																				_elm_lang$core$Dict$fromList(
																					{
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: _p574,
																							_1: _user$project$Lang$VDictElemUpdate(_p572._0)
																						},
																						_1: {ctor: '[]'}
																					}));
																			var newDict = A2(
																				_user$project$Lang$replaceV_,
																				_p575,
																				_user$project$Lang$VDict(
																					A3(_elm_lang$core$Dict$insert, _p574, _p568._0._1._0, _p573)));
																			return A2(continuation, newDict, newDiff);
																		} else {
																			return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
																		}
																	} else {
																		return _user$project$UpdateStack$UpdateCriticalError(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'Expected VRecordDiffs, got ',
																				_elm_lang$core$Basics$toString(_p571)));
																	}
																}
															} else {
																return _user$project$UpdateStack$UpdateCriticalError(
																	A2(
																		_elm_lang$core$Basics_ops['++'],
																		'Expected VRecordDiffs, got ',
																		_elm_lang$core$Basics$toString(_p569)));
															}
														} else {
															break _v341_2;
														}
													}
												} else {
													break _v341_2;
												}
											} while(false);
											return _user$project$UpdateStack$UpdateCriticalError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'Expected Nothing or Just x, got ',
													_user$project$LangUtils$valToString(newVal)));
										}
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'DictGet requires the second argument to be a dictionary, got ',
												_user$project$LangUtils$valToString(_p575)));
									}
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'DictGet requires two arguments, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(vs))));
							}
						case 'DictRemove':
							var _p577 = vs;
							if (((_p577.ctor === '::') && (_p577._1.ctor === '::')) && (_p577._1._1.ctor === '[]')) {
								var _p589 = _p577._0;
								var _p588 = _p577._1._0;
								var _p578 = A2(_user$project$LangUtils$valToDictKey, _user$project$Syntax$Leo, _p589);
								if (_p578.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Could not convert this to a dictionary key: ',
											_user$project$LangUtils$valToString(_p589)));
								} else {
									var _p587 = _p578._0;
									var _p579 = _p588.v_;
									if (_p579.ctor === 'VDict') {
										var _p580 = A2(_elm_lang$core$Dict$get, _p587, _p579._0);
										if (_p580.ctor === 'Nothing') {
											var _p581 = _p630;
											if (((_p581.ctor === '::') && (_p581._1.ctor === '::')) && (_p581._1._1.ctor === '[]')) {
												return A8(
													_user$project$UpdateStack$updateContinue,
													'DictRemove',
													env,
													_p581._1._0,
													{ctor: '[]'},
													oldVal,
													newVal,
													diffs,
													F2(
														function (newEnv, newDictE) {
															return A2(
																_user$project$UpdateStack$updateResult,
																newEnv,
																A2(
																	_user$project$Lang$UpdatedExp,
																	ret(
																		A5(
																			_user$project$Lang$EOp,
																			_p631,
																			_p633,
																			_p629,
																			{
																				ctor: '::',
																				_0: _p581._0,
																				_1: {
																					ctor: '::',
																					_0: newDictE.val,
																					_1: {ctor: '[]'}
																				}
																			},
																			_p632)),
																	A2(_user$project$UpdateUtils$wrap, 1, newDictE.changes)));
														}));
											} else {
												return _user$project$UpdateStack$UpdateCriticalError('[internal error] DictRemove requires two arguments');
											}
										} else {
											var _p582 = diffs;
											if (_p582.ctor === 'VDictDiffs') {
												var potentialErrors = A3(
													_elm_lang$core$Dict$foldl,
													F3(
														function (k, v, acc) {
															return A2(
																_elm_lang$core$Result$andThen,
																function (_p583) {
																	return _elm_lang$core$Native_Utils.eq(k, _p587) ? _elm_lang$core$Result$Err(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'Cannot insert/update the key ',
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				_user$project$LangUtils$valToString(_p589),
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					' to dictionary because it is removed (line ',
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						_elm_lang$core$Basics$toString(_p654.start.line),
																						')'))))) : _elm_lang$core$Result$Ok(
																		{ctor: '_Tuple0'});
																},
																acc);
														}),
													_elm_lang$core$Result$Ok(
														{ctor: '_Tuple0'}),
													_p582._0);
												var _p584 = potentialErrors;
												if (_p584.ctor === 'Err') {
													return _user$project$UpdateStack$UpdateFails(_p584._0);
												} else {
													var _p585 = _p630;
													if (((_p585.ctor === '::') && (_p585._1.ctor === '::')) && (_p585._1._1.ctor === '[]')) {
														var _p586 = newVal.v_;
														if (_p586.ctor === 'VDict') {
															var argNewvalDict = A2(
																_user$project$Lang$replaceV_,
																newVal,
																_user$project$Lang$VDict(
																	A3(_elm_lang$core$Dict$insert, _p587, _p580._0, _p586._0)));
															return A8(
																_user$project$UpdateStack$updateContinue,
																'DictRemove',
																env,
																_p585._1._0,
																{ctor: '[]'},
																_p588,
																argNewvalDict,
																diffs,
																F2(
																	function (newEnv, newDictE) {
																		return A2(
																			_user$project$UpdateStack$updateResult,
																			newEnv,
																			A2(
																				_user$project$Lang$UpdatedExp,
																				ret(
																					A5(
																						_user$project$Lang$EOp,
																						_p631,
																						_p633,
																						_p629,
																						{
																							ctor: '::',
																							_0: _p585._0,
																							_1: {
																								ctor: '::',
																								_0: newDictE.val,
																								_1: {ctor: '[]'}
																							}
																						},
																						_p632)),
																				A2(_user$project$UpdateUtils$wrap, 1, newDictE.changes)));
																	}));
														} else {
															return _user$project$UpdateStack$UpdateCriticalError(
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	'[internal error] DictRemove was updated with a non-dict: ',
																	_user$project$LangUtils$valToString(newVal)));
														}
													} else {
														return _user$project$UpdateStack$UpdateCriticalError('[internal error] DictRemove requires two arguments');
													}
												}
											} else {
												return _user$project$UpdateStack$UpdateFails(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'DictRemove: Expected VDictDiffs, got ',
														_elm_lang$core$Basics$toString(_p582)));
											}
										}
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'DictRemove requires the second argument to be a dictionary, got ',
												_user$project$LangUtils$valToString(_p588)));
									}
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'DictRemove requires two arguments, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(vs))));
							}
						case 'DictInsert':
							var _p590 = {ctor: '_Tuple2', _0: vs, _1: _p630};
							if (((((((((_p590.ctor === '_Tuple2') && (_p590._0.ctor === '::')) && (_p590._0._1.ctor === '::')) && (_p590._0._1._1.ctor === '::')) && (_p590._0._1._1._1.ctor === '[]')) && (_p590._1.ctor === '::')) && (_p590._1._1.ctor === '::')) && (_p590._1._1._1.ctor === '::')) && (_p590._1._1._1._1.ctor === '[]')) {
								var _p602 = _p590._0._0;
								var _p601 = _p590._1._1._0;
								var _p600 = _p590._1._1._1._0;
								var _p599 = _p590._0._1._1._0;
								var _p591 = A2(_user$project$LangUtils$valToDictKey, _user$project$Syntax$Leo, _p602);
								if (_p591.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Could not convert this to a dictionary key: ',
											_user$project$LangUtils$valToString(_p602)));
								} else {
									var _p598 = _p591._0;
									var _p592 = _p599.v_;
									if (_p592.ctor === 'VDict') {
										var _p593 = newVal.v_;
										if (_p593.ctor === 'VDict') {
											var _p597 = _p593._0;
											var valWIthoutKey = A2(
												_user$project$Lang$replaceV_,
												newVal,
												_user$project$Lang$VDict(
													A2(_elm_lang$core$Dict$remove, _p598, _p597)));
											var _p594 = diffs;
											if (_p594.ctor === 'VDictDiffs') {
												var _p596 = _p594._0;
												var newDictDiff = A2(_elm_lang$core$Dict$remove, _p598, _p596);
												var diffsWithoutKey = _user$project$Lang$VDictDiffs(newDictDiff);
												var continuation = _elm_lang$core$Dict$isEmpty(newDictDiff) ? function (continuation) {
													return A2(
														continuation,
														_user$project$UpdatedEnv$original(env),
														A2(_user$project$Lang$UpdatedExp, _p600, _elm_lang$core$Maybe$Nothing));
												} : function (continuation) {
													return A8(
														_user$project$UpdateStack$updateContinue,
														'DictInsert - dict',
														env,
														_p600,
														{ctor: '[]'},
														oldVal,
														valWIthoutKey,
														diffsWithoutKey,
														continuation);
												};
												var continuationInserted = function () {
													var _p595 = {
														ctor: '_Tuple2',
														_0: A2(_elm_lang$core$Dict$get, _p598, _p596),
														_1: A2(_elm_lang$core$Dict$get, _p598, _p597)
													};
													if (_p595._0.ctor === 'Nothing') {
														return function (continuation) {
															return A2(
																continuation,
																_user$project$UpdatedEnv$original(env),
																A2(_user$project$Lang$UpdatedExp, _p601, _elm_lang$core$Maybe$Nothing));
														};
													} else {
														switch (_p595._0._0.ctor) {
															case 'VDictElemInsert':
																return function (continuation) {
																	return _user$project$UpdateStack$UpdateCriticalError(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'Discrepancy, you are trying to insert a key which should already exist ',
																			_user$project$LangUtils$valToString(_p602)));
																};
															case 'VDictElemDelete':
																return function (continuation) {
																	return _user$project$UpdateStack$UpdateFails(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'Cannot delete a key which was added by insertion',
																			_user$project$LangUtils$valToString(_p602)));
																};
															default:
																if (_p595._1.ctor === 'Just') {
																	return function (continuation) {
																		return A8(
																			_user$project$UpdateStack$updateContinue,
																			'DictInsert - value',
																			env,
																			_p601,
																			{ctor: '[]'},
																			_p590._0._1._0,
																			_p595._1._0,
																			_p595._0._0._0,
																			continuation);
																	};
																} else {
																	return function (continuation) {
																		return _user$project$UpdateStack$UpdateFails(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'Incoherency: cannot update a key if it does not appear in the output value: ',
																				_user$project$LangUtils$valToString(_p602)));
																	};
																}
														}
													}
												}();
												return continuation(
													F2(
														function (newEnv, newDictE) {
															return continuationInserted(
																F2(
																	function (newEnv2, newInsertedE) {
																		var finalEnv = A3(_user$project$UpdatedEnv$merge, env, newEnv, newEnv2);
																		var finalChanges = _user$project$UpdateUtils$combineEChildDiffs(
																			{
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 1, _1: newInsertedE.changes},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 2, _1: newDictE.changes},
																					_1: {ctor: '[]'}
																				}
																			});
																		return A2(
																			_user$project$UpdateStack$updateResult,
																			finalEnv,
																			A2(
																				_user$project$Lang$UpdatedExp,
																				ret(
																					A5(
																						_user$project$Lang$EOp,
																						_p631,
																						_p633,
																						_p629,
																						{
																							ctor: '::',
																							_0: _p590._1._0,
																							_1: {
																								ctor: '::',
																								_0: newInsertedE.val,
																								_1: {
																									ctor: '::',
																									_0: newDictE.val,
																									_1: {ctor: '[]'}
																								}
																							}
																						},
																						_p632)),
																				finalChanges));
																	}));
														}));
											} else {
												return _user$project$UpdateStack$UpdateCriticalError(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'[Internal error] Expected a VDictDiffs, got ',
														_elm_lang$core$Basics$toString(_p594)));
											}
										} else {
											return _user$project$UpdateStack$UpdateCriticalError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'DictInsert cannot be updated with something other than a dict, got ',
													_user$project$LangUtils$valToString(newVal)));
										}
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'DictInsert requires the second argument to be a dictionary, got ',
												_user$project$LangUtils$valToString(_p599)));
									}
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'DictInsert requires tnree arguments, got ',
										_elm_lang$core$Basics$toString(
											_elm_lang$core$List$length(vs))));
							}
						case 'ToStrExceptStr':
							var $default = function (original) {
								var _p603 = newVal.v_;
								if ((_p603.ctor === 'VBase') && (_p603._0.ctor === 'VString')) {
									var _p611 = _p603._0._0;
									var _p604 = A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p611);
									if (_p604.ctor === 'Err') {
										return _user$project$UpdateStack$UpdateFails(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'Could not parse new output value \'',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_p611,
													A2(
														_elm_lang$core$Basics_ops['++'],
														'\' for ToStrExceptStr expression ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$ParserUtils$showError(_p604._0),
															A2(
																_elm_lang$core$Basics_ops['++'],
																'\nOriginal value was ',
																_user$project$LangUtils$valToString(original)))))));
									} else {
										var _p605 = A2(
											_user$project$Update$doEvalw,
											{ctor: '[]'},
											_p604._0);
										if (_p605.ctor === 'Err') {
											return _user$project$UpdateStack$UpdateFails(_p605._0);
										} else {
											var _p610 = _p605._0._0._0;
											var _p606 = {ctor: '_Tuple2', _0: _p630, _1: vs};
											if (((((_p606.ctor === '_Tuple2') && (_p606._0.ctor === '::')) && (_p606._0._1.ctor === '[]')) && (_p606._1.ctor === '::')) && (_p606._1._1.ctor === '[]')) {
												var _p609 = _p606._1._0;
												return A3(
													_user$project$UpdateStack$updateMany,
													A2(_user$project$UpdateUtils$defaultVDiffs, _p609, _p610),
													function (_p607) {
														var _p608 = _p607;
														return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
													},
													function (vDiff) {
														return A8(
															_user$project$UpdateStack$updateContinue,
															'EOp ToStrExceptStr default',
															env,
															_p606._0._0,
															{ctor: '[]'},
															_p609,
															_p610,
															vDiff,
															F2(
																function (newUpdatedEnv, newOpArg) {
																	return A2(
																		_user$project$UpdateStack$updateResult,
																		newUpdatedEnv,
																		A2(
																			_user$project$Lang$UpdatedExp,
																			ret(
																				A5(
																					_user$project$Lang$EOp,
																					_p631,
																					_p633,
																					_p629,
																					{
																						ctor: '::',
																						_0: newOpArg.val,
																						_1: {ctor: '[]'}
																					},
																					_p632)),
																			A2(_user$project$UpdateUtils$wrap, 0, newOpArg.changes)));
																}));
													});
											} else {
												return _user$project$UpdateStack$UpdateCriticalError(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'[internal error] Wrong number of arguments in update ToStrExceptStr: ',
														_elm_lang$core$Basics$toString(_p606)));
											}
										}
									}
								} else {
									return _user$project$UpdateStack$UpdateCriticalError(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Expected string, got ',
											_user$project$LangUtils$valToString(newVal)));
								}
							};
							var _p612 = vs;
							if ((_p612.ctor === '::') && (_p612._1.ctor === '[]')) {
								var _p615 = _p612._0;
								var _p613 = _p615.v_;
								if ((_p613.ctor === 'VBase') && (_p613._0.ctor === 'VString')) {
									var _p614 = _p630;
									if ((_p614.ctor === '::') && (_p614._1.ctor === '[]')) {
										return A8(
											_user$project$UpdateStack$updateContinue,
											'EOp ToStrExceptStr',
											env,
											_p614._0,
											{ctor: '[]'},
											_p615,
											newVal,
											diffs,
											F2(
												function (newUpdatedEnv, newOpArg) {
													return A2(
														_user$project$UpdateStack$updateResult,
														newUpdatedEnv,
														A2(
															_user$project$Lang$UpdatedExp,
															ret(
																A5(
																	_user$project$Lang$EOp,
																	_p631,
																	_p633,
																	_p629,
																	{
																		ctor: '::',
																		_0: newOpArg.val,
																		_1: {ctor: '[]'}
																	},
																	_p632)),
															A2(_user$project$UpdateUtils$wrap, 0, newOpArg.changes)));
												}));
									} else {
										return _user$project$UpdateStack$UpdateCriticalError(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'[internal error] Wrong number of argument values in update ToStrExceptStr: ',
												_elm_lang$core$Basics$toString(_p614)));
									}
								} else {
									return $default(_p615);
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'[internale error] Wrong number or arguments in updateToStrExceptStr: ',
										_elm_lang$core$Basics$toString(e)));
							}
						case 'ToStr':
							var _p616 = newVal.v_;
							if ((_p616.ctor === 'VBase') && (_p616._0.ctor === 'VString')) {
								var _p624 = _p616._0._0;
								var _p617 = A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p624);
								if (_p617.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateFails(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'Could not parse new output value \'',
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p624,
												A2(
													_elm_lang$core$Basics_ops['++'],
													'\' for ToStr expression. ',
													_user$project$ParserUtils$showError(_p617._0)))));
								} else {
									var _p618 = A2(
										_user$project$Update$doEvalw,
										{ctor: '[]'},
										_p617._0);
									if (_p618.ctor === 'Err') {
										return _user$project$UpdateStack$UpdateFails(_p618._0);
									} else {
										var _p623 = _p618._0._0._0;
										var _p619 = {ctor: '_Tuple2', _0: _p630, _1: vs};
										if (((((_p619.ctor === '_Tuple2') && (_p619._0.ctor === '::')) && (_p619._0._1.ctor === '[]')) && (_p619._1.ctor === '::')) && (_p619._1._1.ctor === '[]')) {
											var _p622 = _p619._1._0;
											return A3(
												_user$project$UpdateStack$updateMany,
												A2(_user$project$UpdateUtils$defaultVDiffs, _p622, _p623),
												function (_p620) {
													var _p621 = _p620;
													return A2(_user$project$UpdateStack$updateResultSameEnvExp, env, e);
												},
												function (vDiff) {
													return A8(
														_user$project$UpdateStack$updateContinue,
														'EOp ToStr',
														env,
														_p619._0._0,
														{ctor: '[]'},
														_p622,
														_p623,
														vDiff,
														F2(
															function (newUpdatedEnv, newOpArg) {
																return A2(
																	_user$project$UpdateStack$updateResult,
																	newUpdatedEnv,
																	A2(
																		_user$project$Lang$UpdatedExp,
																		ret(
																			A5(
																				_user$project$Lang$EOp,
																				_p631,
																				_p633,
																				_p629,
																				{
																					ctor: '::',
																					_0: newOpArg.val,
																					_1: {ctor: '[]'}
																				},
																				_p632)),
																		A2(_user$project$UpdateUtils$wrap, 0, newOpArg.changes)));
															}));
												});
										} else {
											return _user$project$UpdateStack$UpdateCriticalError(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'[internal error] Wrong number of arguments in update: ',
													_elm_lang$core$Basics$toString(_p619)));
										}
									}
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Expected string, got ',
										_user$project$LangUtils$valToString(newVal)));
							}
						case 'RegexExtractFirstIn':
							var _p625 = {ctor: '_Tuple2', _0: vs, _1: _p630};
							if (((((((_p625.ctor === '_Tuple2') && (_p625._0.ctor === '::')) && (_p625._0._1.ctor === '::')) && (_p625._0._1._1.ctor === '[]')) && (_p625._1.ctor === '::')) && (_p625._1._1.ctor === '::')) && (_p625._1._1._1.ctor === '[]')) {
								var _p627 = _p625._0._1._0;
								var _p626 = A4(_user$project$UpdateRegex$updateRegexExtractFirstIn, _p625._0._0, _p627, oldVal, newVal);
								if (_p626.ctor === 'Err') {
									return _user$project$UpdateStack$UpdateCriticalError(_p626._0);
								} else {
									var llWithDiffs = A2(
										_user$project$LazyList$map,
										function (newStringV) {
											return {
												ctor: '_Tuple2',
												_0: newStringV,
												_1: A2(_user$project$UpdateUtils$defaultVDiffs, _p627, newStringV)
											};
										},
										_p626._0);
									return A7(
										_user$project$UpdateStack$updateAlternatives,
										'extractFirstIn',
										env,
										_p625._1._1._0,
										{ctor: '[]'},
										_p627,
										llWithDiffs,
										F2(
											function (newUpdatedEnv, newStringE) {
												return A2(
													_user$project$UpdateStack$updateResult,
													newUpdatedEnv,
													A2(
														_user$project$Lang$UpdatedExp,
														ret(
															A5(
																_user$project$Lang$EOp,
																_p631,
																_p633,
																_p629,
																{
																	ctor: '::',
																	_0: _p625._1._0,
																	_1: {
																		ctor: '::',
																		_0: newStringE.val,
																		_1: {ctor: '[]'}
																	}
																},
																_p632)),
														A2(_user$project$UpdateUtils$wrap, 1, newStringE.changes)));
											}));
								}
							} else {
								return _user$project$UpdateStack$UpdateCriticalError('extractFirstIn requires regexp, replacement (fun or string) and the string');
							}
						case 'Lt':
							return A9(_user$project$Update$opFlip, env, e, _p631, _p633, '<', _p630, _p632, oldVal, newVal);
						case 'Eq':
							return A9(_user$project$Update$opFlip, env, e, _p631, _p633, '==', _p630, _p632, oldVal, newVal);
						default:
							var _p628 = A5(_user$project$Update$maybeUpdateMathOp, _p629, vs, oldVal, newVal, diffs);
							if (_p628.ctor === 'Err') {
								return _user$project$UpdateStack$UpdateCriticalError(_p628._0);
							} else {
								if (_p628._0.ctor === 'Nil') {
									return _user$project$UpdateStack$UpdateFails(
										A2(
											_elm_lang$core$Basics_ops['++'],
											'No way to update computation',
											A2(
												_elm_lang$core$Basics_ops['++'],
												A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e),
												A2(
													_elm_lang$core$Basics_ops['++'],
													' with ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUtils$valToString(newVal),
														A2(
															_elm_lang$core$Basics_ops['++'],
															' (was',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$LangUtils$valToString(oldVal),
																')')))))));
								} else {
									return A7(
										_user$project$UpdateStack$updateOpMultiple,
										'op',
										env,
										_p630,
										function (newOpArgs) {
											return ret(
												A5(_user$project$Lang$EOp, _p631, _p633, _p629, newOpArgs, _p632));
										},
										{ctor: '[]'},
										vs,
										A2(
											_user$project$LazyList$map,
											_elm_lang$core$Tuple$mapSecond(_user$project$UpdateUtils$tupleDiffsToDiffs),
											_p628._0));
								}
							}
					}
				}
			case 'ECase':
				var _p640 = _p211._1;
				return A3(
					_user$project$Update$doEvalwUpdate,
					env,
					_p640,
					function (_p634) {
						var _p635 = _p634;
						var _p639 = _p635._0._0;
						var _p636 = A3(_user$project$Update$branchWithInversion, env, _p639, _p211._2);
						if (_p636.ctor === 'Nothing') {
							return _user$project$UpdateStack$UpdateCriticalError(
								A2(
									_elm_lang$core$Basics_ops['++'],
									'Match error: ',
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$LangUtils$valToString(_p639),
										A2(
											_elm_lang$core$Basics_ops['++'],
											' on branches ',
											A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e)))));
						} else {
							return A8(
								_user$project$UpdateStack$updateContinue,
								'ECase',
								_p636._0._0._0,
								_p636._0._0._1,
								{ctor: '[]'},
								oldVal,
								newVal,
								diffs,
								F2(
									function (upUpdatedEnv, upExp) {
										var _p637 = _p636._0._1(
											{ctor: '_Tuple2', _0: upUpdatedEnv, _1: upExp});
										var newBranchUpdatedEnv = _p637._0;
										var newInputVal = _p637._1;
										var newInputValDiffs = _p637._2;
										var nBranches = _p637._3;
										var nBranchesDiffs = _p637._4;
										var input_update = function () {
											var _p638 = newInputValDiffs;
											if (_p638.ctor === 'Nothing') {
												return function (continuation) {
													return A2(
														continuation,
														_user$project$UpdatedEnv$original(env),
														A2(_user$project$Lang$UpdatedExp, _p640, _elm_lang$core$Maybe$Nothing));
												};
											} else {
												return A7(
													_user$project$UpdateStack$updateContinue,
													'ECase 2',
													env,
													_p640,
													A2(_user$project$UpdateStack$keepLets, env, _p635._1),
													_p639,
													newInputVal,
													_p638._0);
											}
										}();
										return input_update(
											F2(
												function (newInputUpdatedEnv, newInputUpdatedExp) {
													var finalUpdatedEnv = A3(_user$project$UpdatedEnv$merge, env, newBranchUpdatedEnv, newInputUpdatedEnv);
													var finalExp = ret(
														A4(_user$project$Lang$ECase, _p211._0, newInputUpdatedExp.val, nBranches, _p211._3));
													var finalChanges = _user$project$UpdateUtils$combineEChildDiffs(
														{
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: 0, _1: newInputUpdatedExp.changes},
															_1: A2(_user$project$UpdateUtils$offset, 1, nBranchesDiffs)
														});
													return A2(
														_user$project$UpdateStack$updateResult,
														finalUpdatedEnv,
														A2(_user$project$Lang$UpdatedExp, finalExp, finalChanges));
												}));
									}));
						}
					});
			case 'ELet':
				return A4(
					_user$project$Update$updateDeclarations,
					env,
					prevLets,
					_p211._2,
					F3(
						function (envBody, remainingPrevLets, finishUpdateDeclarations) {
							return A8(
								_user$project$UpdateStack$updateContinue,
								'ELet',
								envBody,
								_p211._4,
								remainingPrevLets,
								oldVal,
								newVal,
								diffs,
								F2(
									function (updatedEnvBody, updatedBody) {
										return A2(
											finishUpdateDeclarations,
											updatedEnvBody,
											F2(
												function (updatedEnv, updatedDecls) {
													var declsDiffs = function () {
														var _p641 = updatedDecls.changes;
														if (_p641.ctor === 'Nothing') {
															return {ctor: '[]'};
														} else {
															return _p641._0;
														}
													}();
													var bodyDiff = function () {
														var _p642 = updatedBody.changes;
														if (_p642.ctor === 'Nothing') {
															return {ctor: '[]'};
														} else {
															return {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: _elm_lang$core$List$sum(
																		A2(
																			_elm_lang$core$List$map,
																			function (_p643) {
																				var _p644 = _p643;
																				return _elm_lang$core$List$length(_p644._1);
																			},
																			_p211._2._3)),
																	_1: _p642._0
																},
																_1: {ctor: '[]'}
															};
														}
													}();
													var finalDiff = function () {
														var _p645 = A2(_elm_lang$core$Basics_ops['++'], declsDiffs, bodyDiff);
														if (_p645.ctor === '[]') {
															return _elm_lang$core$Maybe$Nothing;
														} else {
															return _elm_lang$core$Maybe$Just(
																_user$project$Lang$EChildDiffs(_p645));
														}
													}();
													return A2(
														_user$project$UpdateStack$updateResult,
														updatedEnv,
														A2(
															_user$project$Lang$UpdatedExp,
															A2(
																_user$project$Lang$replaceE__,
																e,
																A5(_user$project$Lang$ELet, _p211._0, _p211._1, updatedDecls.val, _p211._3, updatedBody.val)),
															finalDiff));
												}));
									}));
						}));
			case 'EColonType':
				return A8(
					_user$project$UpdateStack$updateContinue,
					'EColonType',
					env,
					_p211._1,
					prevLets,
					oldVal,
					newVal,
					diffs,
					F2(
						function (nv, ne) {
							return A2(
								_user$project$UpdateStack$updateResult,
								nv,
								A2(
									_user$project$Lang$UpdatedExp,
									ret(
										A5(_user$project$Lang$EColonType, _p211._0, ne.val, _p211._2, _p211._3, _p211._4)),
									A2(_user$project$UpdateUtils$wrap, 0, ne.changes)));
						}));
			default:
				var _p653 = _p211._2;
				return A8(
					_user$project$UpdateStack$updateContinue,
					'EParens',
					env,
					_p211._1,
					prevLets,
					oldVal,
					newVal,
					diffs,
					F2(
						function (nv, ne) {
							var $continue = function (ne) {
								return A2(
									_user$project$UpdateStack$updateResult,
									nv,
									A2(
										_user$project$Lang$UpdatedExp,
										ret(
											A4(_user$project$Lang$EParens, _p211._0, ne.val, _p653, _p211._3)),
										A2(_user$project$UpdateUtils$wrap, 0, ne.changes)));
							};
							var _p646 = _p653;
							if (_p646.ctor === 'HtmlSyntax') {
								return $continue(
									A2(
										_user$project$UpdateStack$replaceInsertions,
										ne,
										function (inserted) {
											var _p647 = _user$project$Lang$unwrapExp(inserted);
											if (((((((_p647.ctor === 'EList') && (_p647._1.ctor === '::')) && (_p647._1._0.ctor === '_Tuple2')) && (_p647._1._1.ctor === '::')) && (_p647._1._1._0.ctor === '_Tuple2')) && (_p647._1._1._1.ctor === '[]')) && (_p647._3.ctor === 'Nothing')) {
												var _p652 = _p647._1._1._0._1;
												var _p651 = _p647._1._0._1;
												var _p648 = {
													ctor: '_Tuple2',
													_0: _user$project$Lang$eStrUnapply(_p651),
													_1: A2(
														_user$project$ExpUnbuilder$list,
														A2(_user$project$ExpUnbuilder$viewtuple2, _user$project$ExpUnbuilder$string, _user$project$ExpUnbuilder$string),
														_p652)
												};
												if ((((_p648.ctor === '_Tuple2') && (_p648._0.ctor === 'Just')) && (_p648._0._0 === 'style')) && (_p648._1.ctor === 'Ok')) {
													return _elm_lang$core$Maybe$Just(
														A2(
															_user$project$Lang$replaceE__,
															inserted,
															A5(
																_user$project$Lang$EList,
																_p647._0,
																{
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: _p647._1._0._0, _1: _p651},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: _user$project$Lang$space0,
																			_1: A2(
																				_user$project$Lang$replaceE__,
																				_p652,
																				A5(
																					_user$project$Lang$EApp,
																					_user$project$Lang$space0,
																					_user$project$Lang$eVar('__mbstylesplit__'),
																					{
																						ctor: '::',
																						_0: A2(
																							_user$project$Lang$replaceE__,
																							_p652,
																							A2(
																								_user$project$Lang$EBase,
																								_user$project$Lang$space0,
																								A2(
																									_user$project$Lang$EString,
																									'\"',
																									_user$project$LangParserUtils$implodeStyleValue(
																										A2(
																											_elm_lang$core$List$filterMap,
																											function (_p649) {
																												var _p650 = _p649;
																												var trimmedName = _elm_lang$core$String$trim(_p650._0);
																												return (!_elm_lang$core$Native_Utils.eq(trimmedName, '')) ? _elm_lang$core$Maybe$Just(
																													{
																														ctor: '_Tuple2',
																														_0: trimmedName,
																														_1: _elm_lang$core$String$trim(_p650._1)
																													}) : _elm_lang$core$Maybe$Nothing;
																											},
																											_p648._1._0))))),
																						_1: {ctor: '[]'}
																					},
																					_user$project$Lang$SpaceApp,
																					_user$project$Lang$space0))
																		},
																		_1: {ctor: '[]'}
																	}
																},
																_p647._2,
																_elm_lang$core$Maybe$Nothing,
																_p647._4)));
												} else {
													return _elm_lang$core$Maybe$Nothing;
												}
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										}));
							} else {
								return $continue(ne);
							}
						}));
		}
	});
var _user$project$Update$update = F3(
	function (callbacks, forks, updateStack) {
		update:
		while (true) {
			var _p655 = updateStack;
			switch (_p655.ctor) {
				case 'UpdateContextS':
					var _v389 = A2(_user$project$LazyList$maybeCons, _p655._6, callbacks),
						_v390 = forks,
						_v391 = A6(_user$project$Update$getUpdateStackOp, _p655._0, _p655._1, _p655._2, _p655._3, _p655._4, _p655._5);
					callbacks = _v389;
					forks = _v390;
					updateStack = _v391;
					continue update;
				case 'UpdateResultS':
					var _p661 = _p655._0;
					var _p660 = _p655._1;
					var _p656 = A2(_user$project$LazyList$maybeCons, _p655._2, callbacks);
					if (_p656.ctor === 'Nil') {
						var _p657 = forks;
						if (_p657.ctor === 'Nil') {
							return _user$project$Results$ok1(
								{ctor: '_Tuple2', _0: _p661, _1: _p660});
						} else {
							return A2(
								_user$project$Results$okLazy,
								{ctor: '_Tuple2', _0: _p661, _1: _p660},
								A5(
									F6(
										function (lft, m, nus, cb2, fk2, _p658) {
											var _p659 = _p658;
											return A3(
												_user$project$Update$updateRec,
												cb2,
												_elm_lang$lazy$Lazy$force(lft),
												nus);
										}),
									_p657._1,
									_p657._0._0,
									_p657._0._1,
									_p657._0._2,
									_p657._0._3));
						}
					} else {
						var _v395 = _elm_lang$lazy$Lazy$force(_p656._1),
							_v396 = forks,
							_v397 = A2(_p656._0._1, _p661, _p660);
						callbacks = _v395;
						forks = _v396;
						updateStack = _v397;
						continue update;
					}
				case 'UpdateResultAlternative':
					var _v399 = callbacks,
						_v400 = function () {
						var _p662 = _elm_lang$lazy$Lazy$force(_p655._2);
						if (_p662.ctor === 'Nothing') {
							return forks;
						} else {
							return A2(
								_user$project$LazyList$append,
								_user$project$LazyList$fromList(
									{
										ctor: '::',
										_0: A4(_user$project$UpdateStack$Fork, _p655._0, _p662._0, callbacks, _user$project$LazyList$Nil),
										_1: {ctor: '[]'}
									}),
								forks);
						}
					}(),
						_v401 = _p655._1;
					callbacks = _v399;
					forks = _v400;
					updateStack = _v401;
					continue update;
				case 'UpdateFails':
					var _p663 = forks;
					if (_p663.ctor === 'Nil') {
						return _elm_lang$core$Result$Err(_p655._0);
					} else {
						var _v403 = _p663._0._2,
							_v404 = A2(_user$project$LazyList$appendLazy, _p663._0._3, _p663._1),
							_v405 = _p663._0._1;
						callbacks = _v403;
						forks = _v404;
						updateStack = _v405;
						continue update;
					}
				default:
					return _elm_lang$core$Result$Err(_p655._0);
			}
		}
	});
var _user$project$Update$updateRec = F3(
	function (callbacks, forks, updateStack) {
		var _p664 = A3(_user$project$Update$update, callbacks, forks, updateStack);
		if (_p664.ctor === 'Ok') {
			return _p664._0;
		} else {
			return _user$project$LazyList$Nil;
		}
	});

var _user$project$LangTools$visibleIdentifiersAtEIdBindingNumNoPrelude = F2(
	function (program, _p0) {
		var _p1 = _p0;
		var f = _user$project$Lang$foldExpTopDownWithScope;
		return A7(
			f,
			F3(
				function (exp, globalIdents, currentScope) {
					return globalIdents;
				}),
			F6(
				function (exp, isRec, group, bindingNumber, globalIdents, currentScope) {
					var newIdents = A2(
						_elm_lang$core$List$concatMap,
						function (_p2) {
							return _user$project$Lang$identifiersListInPat(
								_user$project$Lang$patOfLetExp(_p2));
						},
						group);
					var newScope = A2(_user$project$Utils$reverseInsert, newIdents, currentScope);
					var newGlobalIdents = (_elm_lang$core$Native_Utils.eq(
						_user$project$Lang$expEId(exp),
						_p1._1._0) && _elm_lang$core$Native_Utils.eq(bindingNumber, _p1._1._1)) ? (_elm_lang$core$Native_Utils.eq(
						_p1._0,
						_user$project$Lang$InsertDeclarationLevel(_user$project$Lang$After)) ? newScope : currentScope) : globalIdents;
					return {ctor: '_Tuple2', _0: newGlobalIdents, _1: newScope};
				}),
			F2(
				function (fun, currentScope) {
					var _p3 = _user$project$Lang$unwrapExp(fun);
					if (_p3.ctor === 'EFun') {
						return A2(
							_user$project$Utils$reverseInsert,
							A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, _p3._1),
							currentScope);
					} else {
						return currentScope;
					}
				}),
			F4(
				function (cs, branch, index, currentScope) {
					var _p4 = branch.val;
					return A2(
						_user$project$Utils$reverseInsert,
						_user$project$Lang$identifiersListInPat(_p4._1),
						currentScope);
				}),
			{ctor: '[]'},
			{ctor: '[]'},
			program);
	});
var _user$project$LangTools$visibleIdentifiersAtPredicate_ = F3(
	function (idents, exp, pred) {
		var ret = function (deeperIdents) {
			return (_elm_lang$core$Native_Utils.eq(
				0,
				_elm_lang$core$Set$size(deeperIdents)) && pred(exp)) ? idents : deeperIdents;
		};
		var recurse = function (e) {
			return A3(_user$project$LangTools$visibleIdentifiersAtPredicate_, idents, e, pred);
		};
		var recurseAllChildren = function (_p5) {
			var _p6 = _p5;
			return _user$project$Utils$unionAll(
				A2(
					_elm_lang$core$List$map,
					recurse,
					_user$project$Lang$childExps(exp)));
		};
		var recurseWithNewIdents = F2(
			function (pats, e) {
				return A3(
					_user$project$LangTools$visibleIdentifiersAtPredicate_,
					A2(
						_elm_lang$core$Set$union,
						_user$project$Lang$identifiersSetInPats(pats),
						idents),
					e,
					pred);
			});
		var _p7 = _user$project$Lang$unwrapExp(exp);
		switch (_p7.ctor) {
			case 'EConst':
				return ret(_elm_lang$core$Set$empty);
			case 'EBase':
				return ret(_elm_lang$core$Set$empty);
			case 'EVar':
				return ret(_elm_lang$core$Set$empty);
			case 'EFun':
				return ret(
					A2(recurseWithNewIdents, _p7._1, _p7._2));
			case 'EOp':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'EList':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'ERecord':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'ESelect':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'EIf':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'ECase':
				var scrutineeResult = recurse(_p7._1);
				var branchResults = A2(
					_elm_lang$core$List$map,
					function (_p8) {
						var _p9 = _p8;
						return A2(
							recurseWithNewIdents,
							{
								ctor: '::',
								_0: _p9._1,
								_1: {ctor: '[]'}
							},
							_p9._2);
					},
					A2(
						_elm_lang$core$List$map,
						function (_) {
							return _.val;
						},
						_p7._2));
				return ret(
					_user$project$Utils$unionAll(
						{ctor: '::', _0: scrutineeResult, _1: branchResults}));
			case 'EApp':
				return ret(
					recurseAllChildren(
						{ctor: '_Tuple0'}));
			case 'ELet':
				var _p10 = A3(
					_user$project$Lang$foldLeftGroup,
					{ctor: '_Tuple2', _0: _elm_lang$core$Set$empty, _1: idents},
					_p7._2._3,
					F3(
						function (_p11, group, isRec) {
							var _p12 = _p11;
							var _p17 = _p12._1;
							var newIdents = A2(
								_elm_lang$core$List$concatMap,
								function (_p13) {
									var _p14 = _p13;
									return _user$project$Lang$identifiersListInPat(_p14._2);
								},
								group);
							var assignResult = A3(
								_user$project$Utils$foldLeft,
								_elm_lang$core$Set$empty,
								group,
								F2(
									function (acc, _p15) {
										var _p16 = _p15;
										return A2(
											_elm_lang$core$Set$union,
											acc,
											A3(
												_user$project$LangTools$visibleIdentifiersAtPredicate_,
												isRec ? A2(
													_elm_lang$core$Set$union,
													_p17,
													_elm_lang$core$Set$fromList(newIdents)) : _p17,
												_p16._5,
												pred));
									}));
							return {
								ctor: '_Tuple2',
								_0: A2(_elm_lang$core$Set$union, _p12._0, assignResult),
								_1: A2(
									_elm_lang$core$Set$union,
									_p17,
									_elm_lang$core$Set$fromList(newIdents))
							};
						}));
				var assignsResults = _p10._0;
				var newIdents = _p10._1;
				var bodyResult = A3(_user$project$LangTools$visibleIdentifiersAtPredicate_, newIdents, _p7._4, pred);
				return ret(
					A2(_elm_lang$core$Set$union, assignsResults, bodyResult));
			case 'EColonType':
				return ret(
					recurse(_p7._1));
			case 'EParens':
				return ret(
					recurse(_p7._1));
			default:
				return ret(_elm_lang$core$Set$empty);
		}
	});
var _user$project$LangTools$visibleIdentifiersAtPredicateNoPrelude = F2(
	function (exp, pred) {
		return A3(_user$project$LangTools$visibleIdentifiersAtPredicate_, _elm_lang$core$Set$empty, exp, pred);
	});
var _user$project$LangTools$removeIntroducedIdents = F2(
	function (introducedIdents, subst) {
		return A3(_elm_lang$core$List$foldl, _elm_lang$core$Dict$remove, subst, introducedIdents);
	});
var _user$project$LangTools$transformVarsUntilBound = F2(
	function (subst, exp) {
		var recurse = function (e) {
			return A2(_user$project$LangTools$transformVarsUntilBound, subst, e);
		};
		var recurseWithout = F2(
			function (introducedIdents, e) {
				var newSubst = A2(_user$project$LangTools$removeIntroducedIdents, introducedIdents, subst);
				return _elm_lang$core$Native_Utils.eq(
					_elm_lang$core$Dict$size(newSubst),
					0) ? e : A2(_user$project$LangTools$transformVarsUntilBound, newSubst, e);
			});
		var _p18 = _user$project$Lang$unwrapExp(exp);
		switch (_p18.ctor) {
			case 'EConst':
				return exp;
			case 'EBase':
				return exp;
			case 'EVar':
				var _p19 = A2(_elm_lang$core$Dict$get, _p18._1, subst);
				if (_p19.ctor === 'Just') {
					return _p19._0(exp);
				} else {
					return exp;
				}
			case 'EFun':
				var _p20 = _p18._1;
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A4(
						_user$project$Lang$EFun,
						_p18._0,
						_p20,
						A2(
							recurseWithout,
							_user$project$Lang$identifiersListInPats(_p20),
							_p18._2),
						_p18._3));
			case 'EOp':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$EOp,
						_p18._0,
						_p18._1,
						_p18._2,
						A2(_elm_lang$core$List$map, recurse, _p18._3),
						_p18._4));
			case 'EList':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$EList,
						_p18._0,
						A2(_user$project$Utils$listValuesMap, recurse, _p18._1),
						_p18._2,
						A2(_elm_lang$core$Maybe$map, recurse, _p18._3),
						_p18._4));
			case 'ERecord':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A4(
						_user$project$Lang$ERecord,
						_p18._0,
						A2(
							_elm_lang$core$Maybe$map,
							function (_p21) {
								var _p22 = _p21;
								return {
									ctor: '_Tuple2',
									_0: recurse(_p22._0),
									_1: _p22._1
								};
							},
							_p18._1),
						_elm_lang$core$Tuple$second(
							A2(_user$project$LangTools$transformVarsUntilBoundDecls, subst, _p18._2)),
						_p18._3));
			case 'ESelect':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$ESelect,
						_p18._0,
						recurse(_p18._1),
						_p18._2,
						_p18._3,
						_p18._4));
			case 'EIf':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A7(
						_user$project$Lang$EIf,
						_p18._0,
						recurse(_p18._1),
						_p18._2,
						recurse(_p18._3),
						_p18._4,
						recurse(_p18._5),
						_p18._6));
			case 'ECase':
				var newScrutinee = recurse(_p18._1);
				var newBranches = A2(
					_elm_lang$core$List$map,
					_user$project$Lang$mapValField(
						function (_p23) {
							var _p24 = _p23;
							var _p25 = _p24._1;
							return A4(
								_user$project$Lang$Branch_,
								_p24._0,
								_p25,
								A2(
									recurseWithout,
									_user$project$Lang$identifiersListInPat(_p25),
									_p24._2),
								_p24._3);
						}),
					_p18._2);
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A4(_user$project$Lang$ECase, _p18._0, newScrutinee, newBranches, _p18._3));
			case 'EApp':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$EApp,
						_p18._0,
						recurse(_p18._1),
						A2(_elm_lang$core$List$map, recurse, _p18._2),
						_p18._3,
						_p18._4));
			case 'ELet':
				var _p26 = A2(_user$project$LangTools$transformVarsUntilBoundDecls, subst, _p18._2);
				var newSubst = _p26._0;
				var newDecls = _p26._1;
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$ELet,
						_p18._0,
						_p18._1,
						newDecls,
						_p18._3,
						A2(_user$project$LangTools$transformVarsUntilBound, newSubst, _p18._4)));
			case 'EColonType':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A5(
						_user$project$Lang$EColonType,
						_p18._0,
						recurse(_p18._1),
						_p18._2,
						_p18._3,
						_p18._4));
			case 'EParens':
				return A2(
					_user$project$Lang$replaceE__,
					exp,
					A4(
						_user$project$Lang$EParens,
						_p18._0,
						recurse(_p18._1),
						_p18._2,
						_p18._3));
			default:
				return exp;
		}
	});
var _user$project$LangTools$transformVarsUntilBoundDecls = F2(
	function (subst, _p27) {
		var _p28 = _p27;
		var _p35 = _p28._3;
		var _p29 = A3(
			_user$project$Lang$foldLeftGroup,
			{
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: subst
			},
			_p35,
			F3(
				function (_p30, group, isRec) {
					var _p31 = _p30;
					var _p34 = _p31._1;
					var idents = _user$project$Lang$groupIdentifiers(group);
					var newSubst = A2(_user$project$LangTools$removeIntroducedIdents, idents, _p34);
					var localSubst = isRec ? newSubst : _p34;
					return {
						ctor: '_Tuple2',
						_0: A3(
							_user$project$Utils$foldLeft,
							_p31._0,
							group,
							F2(
								function (revAcc, _p32) {
									var _p33 = _p32;
									return {
										ctor: '::',
										_0: A6(
											_user$project$Lang$LetExp,
											_p33._0,
											_p33._1,
											_p33._2,
											_p33._3,
											_p33._4,
											A2(_user$project$LangTools$transformVarsUntilBound, localSubst, _p33._5)),
										_1: revAcc
									};
								})),
						_1: newSubst
					};
				}));
		var revLetExps = _p29._0;
		var newSubst = _p29._1;
		var newLetExps = _elm_lang$core$List$reverse(revLetExps);
		return {
			ctor: '_Tuple2',
			_0: newSubst,
			_1: A4(
				_user$project$Lang$Declarations,
				_p28._0,
				_p28._1,
				_p28._2,
				A2(_user$project$Lang$regroup, _p35, newLetExps))
		};
	});
var _user$project$LangTools$renameVarsUntilBound = F2(
	function (renamings, exp) {
		var renamer = F2(
			function (newName, e) {
				var _p36 = _user$project$Lang$unwrapExp(e);
				if (_p36.ctor === 'EVar') {
					return A2(
						_user$project$Lang$replaceE__,
						e,
						A2(_user$project$Lang$EVar, _p36._0, newName));
				} else {
					return _elm_lang$core$Native_Utils.crashCase(
						'LangTools',
						{
							start: {line: 2284, column: 5},
							end: {line: 2286, column: 140}
						},
						_p36)(
						A2(
							_elm_lang$core$Basics_ops['++'],
							'LangTools.renameVarsUntilBound: renamer should only be passed an EVar, but given: ',
							_elm_lang$core$Basics$toString(e)));
				}
			});
		var fnSubst = A2(
			_elm_lang$core$Dict$map,
			F2(
				function (_p38, newName) {
					return renamer(newName);
				}),
			renamings);
		return A2(_user$project$LangTools$transformVarsUntilBound, fnSubst, exp);
	});
var _user$project$LangTools$renameVarUntilBound = F3(
	function (oldName, newName, exp) {
		return A2(
			_user$project$LangTools$renameVarsUntilBound,
			A2(_elm_lang$core$Dict$singleton, oldName, newName),
			exp);
	});
var _user$project$LangTools$allSimplyResolvableThings = F2(
	function (tryThing, program) {
		return A2(
			_elm_lang$core$List$concatMap,
			function (exp) {
				var _p39 = _user$project$Lang$unwrapExp(exp);
				if (_p39.ctor === 'ELet') {
					return A2(
						_elm_lang$core$List$concatMap,
						function (_p40) {
							var _p41 = _p40;
							return A2(tryThing, _p41._2, _p41._5);
						},
						_user$project$Lang$elemsOf(_p39._2._3));
				} else {
					return {ctor: '[]'};
				}
			},
			_user$project$Lang$flattenExpTree(program));
	});
var _user$project$LangTools$varsWithName = F2(
	function (ident, exp) {
		return A2(
			_elm_lang$core$List$filter,
			function (_p42) {
				return A2(
					F2(
						function (x, y) {
							return _elm_lang$core$Native_Utils.eq(x, y);
						}),
					_elm_lang$core$Maybe$Just(ident),
					_user$project$Lang$expToMaybeIdent(_p42));
			},
			_user$project$Lang$flattenExpTree(exp));
	});
var _user$project$LangTools$tryMatchExpPatToSomething = F4(
	function (makeThisMatch, postProcessDescendentWithPath, pat, exp) {
		var recurse = F2(
			function (pat, exp) {
				return A4(_user$project$LangTools$tryMatchExpPatToSomething, makeThisMatch, postProcessDescendentWithPath, pat, exp);
			});
		var thisMatch = A2(makeThisMatch, pat, exp);
		var addThisMatch = function (matchResult) {
			return A2(
				_elm_lang$core$Maybe$map,
				F2(
					function (x, y) {
						return A2(_elm_lang$core$Basics_ops['++'], x, y);
					})(thisMatch),
				matchResult);
		};
		var postProcessDescendentsWithPath = F2(
			function (i, pathAndExps) {
				return A2(
					_elm_lang$core$List$map,
					postProcessDescendentWithPath(i),
					pathAndExps);
			});
		var matchListsAsFarAsPossible = F2(
			function (ps, es) {
				return A2(
					_elm_lang$core$Maybe$map,
					_elm_lang$core$List$concat,
					_user$project$Utils$projJusts(
						A2(
							_user$project$Utils$mapi1,
							function (_p43) {
								var _p44 = _p43;
								return A2(
									_elm_lang$core$Maybe$map,
									postProcessDescendentsWithPath(_p44._0),
									A2(recurse, _p44._1._0, _p44._1._1));
							},
							A2(_user$project$Utils$zip, ps, es))));
			});
		var _p45 = pat.val.p__;
		switch (_p45.ctor) {
			case 'PWildcard':
				return _elm_lang$core$Maybe$Just(thisMatch);
			case 'PVar':
				return _elm_lang$core$Maybe$Just(thisMatch);
			case 'PAs':
				return addThisMatch(
					A2(
						_elm_lang$core$Maybe$map,
						postProcessDescendentsWithPath(1),
						A2(
							_elm_lang$core$Maybe$andThen,
							function (match) {
								return A2(
									_elm_lang$core$Maybe$map,
									F2(
										function (x, y) {
											return A2(_elm_lang$core$Basics_ops['++'], x, y);
										})(match),
									A2(recurse, _p45._3, exp));
							},
							A2(recurse, _p45._1, exp))));
			case 'PList':
				if (_p45._3.ctor === 'Nothing') {
					var _p49 = _p45._1;
					var _p46 = _user$project$Lang$unwrapExp(
						_user$project$Lang$expEffectiveExp(exp));
					if (_p46.ctor === 'EList') {
						if (_p46._3.ctor === 'Nothing') {
							var _p47 = _p46._1;
							return (!_elm_lang$core$Native_Utils.eq(
								_elm_lang$core$List$length(_p49),
								_elm_lang$core$List$length(_p47))) ? _elm_lang$core$Maybe$Nothing : addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									_p49,
									_user$project$Utils$listValues(_p47)));
						} else {
							var _p48 = _p46._1;
							return (_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$List$length(_p48),
								_elm_lang$core$List$length(_p49)) > 0) ? _elm_lang$core$Maybe$Nothing : addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									_p49,
									_user$project$Utils$listValues(_p48)));
						}
					} else {
						return _elm_lang$core$Maybe$Just(thisMatch);
					}
				} else {
					var _p53 = _p45._1;
					var _p50 = function (x) {
						return _user$project$Lang$unwrapExp(x);
					}(
						_user$project$Lang$expEffectiveExp(exp));
					if (_p50.ctor === 'EList') {
						if (_p50._3.ctor === 'Nothing') {
							var _p51 = _p50._1;
							return (_elm_lang$core$Native_Utils.cmp(
								_elm_lang$core$List$length(_p51),
								_elm_lang$core$List$length(_p53)) < 0) ? _elm_lang$core$Maybe$Nothing : addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									_p53,
									_user$project$Utils$listValues(_p51)));
						} else {
							var _p52 = _p50._1;
							return (!_elm_lang$core$Native_Utils.eq(
								_elm_lang$core$List$length(_p52),
								_elm_lang$core$List$length(_p53))) ? addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									_p53,
									_user$project$Utils$listValues(_p52))) : addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									A2(
										_elm_lang$core$Basics_ops['++'],
										_p53,
										{
											ctor: '::',
											_0: _p45._3._0,
											_1: {ctor: '[]'}
										}),
									A2(
										_elm_lang$core$Basics_ops['++'],
										_user$project$Utils$listValues(_p52),
										{
											ctor: '::',
											_0: _p50._3._0,
											_1: {ctor: '[]'}
										})));
						}
					} else {
						return _elm_lang$core$Maybe$Just(thisMatch);
					}
				}
			case 'PRecord':
				var _p54 = _user$project$Lang$unwrapExp(
					_user$project$Lang$expEffectiveExp(exp));
				if ((_p54.ctor === 'ERecord') && (_p54._1.ctor === 'Nothing')) {
					var _p55 = _user$project$Lang$recordEntriesFromDeclarations(_p54._2);
					if (_p55.ctor === 'Just') {
						var psEsMaybes = A4(_user$project$Record$getPatternMatch, _user$project$Utils$recordKey, _user$project$Utils$recordKey, _p45._1, _p55._0);
						var _p56 = psEsMaybes;
						if (_p56.ctor === 'Nothing') {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							var _p57 = _elm_lang$core$List$unzip(_p56._0);
							var pps = _p57._0;
							var ees = _p57._1;
							return addThisMatch(
								A2(
									matchListsAsFarAsPossible,
									_user$project$Utils$recordValues(pps),
									_user$project$Utils$recordValues(ees)));
						}
					} else {
						return _elm_lang$core$Maybe$Just(thisMatch);
					}
				} else {
					return _elm_lang$core$Maybe$Just(thisMatch);
				}
			case 'PConst':
				var _p58 = _user$project$Lang$unwrapExp(
					_user$project$Lang$expEffectiveExp(exp));
				if (_p58.ctor === 'EConst') {
					return _elm_lang$core$Native_Utils.eq(_p45._1, _p58._1) ? _elm_lang$core$Maybe$Just(thisMatch) : _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(thisMatch);
				}
			case 'PBase':
				var _p59 = _user$project$Lang$unwrapExp(
					_user$project$Lang$expEffectiveExp(exp));
				if (_p59.ctor === 'EBase') {
					return A2(_user$project$Lang$eBaseValsEqual, _p45._1, _p59._1) ? _elm_lang$core$Maybe$Just(thisMatch) : _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Just(thisMatch);
				}
			case 'PParens':
				return A2(recurse, _p45._1, exp);
			default:
				return A2(recurse, _p45._1, exp);
		}
	});
var _user$project$LangTools$tryMatchExpPatToPats_ = F2(
	function (pat, exp) {
		return A4(
			_user$project$LangTools$tryMatchExpPatToSomething,
			F2(
				function (pat, exp) {
					return {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: pat, _1: exp},
						_1: {ctor: '[]'}
					};
				}),
			F2(
				function (i, binding) {
					return binding;
				}),
			pat,
			exp);
	});
var _user$project$LangTools$tryMatchExpPatToPaths_ = F2(
	function (pat, exp) {
		return A4(
			_user$project$LangTools$tryMatchExpPatToSomething,
			F2(
				function (pat, exp) {
					return {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: {ctor: '[]'},
							_1: exp
						},
						_1: {ctor: '[]'}
					};
				}),
			F2(
				function (i, _p60) {
					var _p61 = _p60;
					return {
						ctor: '_Tuple2',
						_0: {ctor: '::', _0: i, _1: _p61._0},
						_1: _p61._1
					};
				}),
			pat,
			exp);
	});
var _user$project$LangTools$tryMatchExpPatToPats = F2(
	function (pat, exp) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			{ctor: '[]'},
			A2(_user$project$LangTools$tryMatchExpPatToPats_, pat, exp));
	});
var _user$project$LangTools$findLetAndPatMatchingExp_ = F3(
	function (targetEId, program, letAndPatBoundEFindMap) {
		return A2(
			_user$project$Lang$mapFirstSuccessNode,
			function (exp) {
				var _p62 = _user$project$Lang$unwrapExp(exp);
				if (_p62.ctor === 'ELet') {
					return A2(
						_user$project$Utils$mapFirstSuccess,
						function (_p63) {
							var _p64 = _p63;
							return A2(
								_user$project$Utils$mapFirstSuccess,
								letAndPatBoundEFindMap(exp),
								A2(_user$project$LangTools$tryMatchExpPatToPats, _p64._2, _p64._5));
						},
						_user$project$Lang$elemsOf(_p62._2._3));
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			program);
	});
var _user$project$LangTools$findLetAndPatMatchingExp = F2(
	function (targetEId, program) {
		return A3(
			_user$project$LangTools$findLetAndPatMatchingExp_,
			targetEId,
			program,
			F2(
				function (letExp, _p65) {
					var _p66 = _p65;
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$expEId(_p66._1),
						targetEId) ? _elm_lang$core$Maybe$Just(
						{ctor: '_Tuple2', _0: letExp, _1: _p66._0}) : _elm_lang$core$Maybe$Nothing;
				}));
	});
var _user$project$LangTools$findLetAndPatMatchingExpLoose = F2(
	function (targetEId, program) {
		return A3(
			_user$project$LangTools$findLetAndPatMatchingExp_,
			targetEId,
			program,
			F2(
				function (letExp, _p67) {
					var _p68 = _p67;
					var _p70 = _p68._1;
					var _p69 = A2(_user$project$Lang$findExpByEId, _p70, targetEId);
					if (_p69.ctor === 'Just') {
						return _elm_lang$core$Native_Utils.eq(
							_user$project$Lang$expEId(
								_user$project$Lang$expEffectiveExp(_p69._0)),
							_user$project$Lang$expEId(
								_user$project$Lang$expEffectiveExp(_p70))) ? _elm_lang$core$Maybe$Just(
							{ctor: '_Tuple2', _0: letExp, _1: _p68._0}) : _elm_lang$core$Maybe$Nothing;
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				}));
	});
var _user$project$LangTools$allSimplyResolvableLetPatBindings = _user$project$LangTools$allSimplyResolvableThings(_user$project$LangTools$tryMatchExpPatToPats);
var _user$project$LangTools$tryMatchExpPatToPIds = F2(
	function (pat, exp) {
		return A2(
			_elm_lang$core$List$map,
			function (_p71) {
				var _p72 = _p71;
				return {ctor: '_Tuple2', _0: _p72._0.val.pid, _1: _p72._1};
			},
			A2(_user$project$LangTools$tryMatchExpPatToPats, pat, exp));
	});
var _user$project$LangTools$tryMatchExpPatToPaths = F2(
	function (pat, exp) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			{ctor: '[]'},
			A2(_user$project$LangTools$tryMatchExpPatToPaths_, pat, exp));
	});
var _user$project$LangTools$tryMatchExpsPatsToPathsAtFunctionCall = F2(
	function (pats, exps) {
		return _elm_lang$core$List$concat(
			A2(
				_elm_lang$core$Maybe$withDefault,
				{ctor: '[]'},
				_user$project$Utils$projJusts(
					A2(
						_elm_lang$core$List$indexedMap,
						F2(
							function (i, _p73) {
								var _p74 = _p73;
								return A2(
									_elm_lang$core$Maybe$map,
									function (pathAndExps) {
										return A2(
											_elm_lang$core$List$map,
											function (_p75) {
												var _p76 = _p75;
												return {ctor: '_Tuple3', _0: i, _1: _p76._0, _2: _p76._1};
											},
											pathAndExps);
									},
									A2(_user$project$LangTools$tryMatchExpPatToPaths_, _p74._0, _p74._1));
							}),
						A2(_user$project$Utils$zip, pats, exps)))));
	});
var _user$project$LangTools$expPathsInExpList = function (exps) {
	return _elm_lang$core$List$concat(
		A2(
			_user$project$Utils$mapi1,
			function (_p77) {
				var _p78 = _p77;
				var _p83 = _p78._0;
				var _p82 = _p78._1;
				var _p79 = _user$project$Lang$unwrapExp(_p82);
				if (_p79.ctor === 'EList') {
					return A2(
						_elm_lang$core$Basics_ops['++'],
						{
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: _p82,
								_1: {
									ctor: '::',
									_0: _p83,
									_1: {ctor: '[]'}
								}
							},
							_1: {ctor: '[]'}
						},
						A2(
							_elm_lang$core$List$map,
							function (_p80) {
								var _p81 = _p80;
								return {
									ctor: '_Tuple2',
									_0: _p81._0,
									_1: {ctor: '::', _0: _p83, _1: _p81._1}
								};
							},
							_user$project$LangTools$expPathsInExpList(
								_user$project$Utils$listValues(_p79._1))));
				} else {
					return {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _p82,
							_1: {
								ctor: '::',
								_0: _p83,
								_1: {ctor: '[]'}
							}
						},
						_1: {ctor: '[]'}
					};
				}
			},
			exps));
};
var _user$project$LangTools$eidPathInExpList = F2(
	function (exps, targetEId) {
		return A2(
			_user$project$Utils$mapFirstSuccess,
			function (_p84) {
				var _p85 = _p84;
				return _elm_lang$core$Native_Utils.eq(
					_user$project$Lang$expEId(_p85._0),
					targetEId) ? _elm_lang$core$Maybe$Just(_p85._1) : _elm_lang$core$Maybe$Nothing;
			},
			_user$project$LangTools$expPathsInExpList(exps));
	});
var _user$project$LangTools$followPathInPat = F2(
	function (path, pat) {
		var _p86 = {ctor: '_Tuple2', _0: pat.val.p__, _1: path};
		_v41_7:
		do {
			if (_p86.ctor === '_Tuple2') {
				if (_p86._1.ctor === '[]') {
					return _elm_lang$core$Maybe$Just(pat);
				} else {
					switch (_p86._0.ctor) {
						case 'PAs':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (p) {
									return A2(_user$project$LangTools$followPathInPat, _p86._1._1, p);
								},
								A2(
									_user$project$Utils$maybeGeti1,
									_p86._1._0,
									{
										ctor: '::',
										_0: _p86._0._1,
										_1: {
											ctor: '::',
											_0: _p86._0._3,
											_1: {ctor: '[]'}
										}
									}));
						case 'PList':
							if (_p86._0._3.ctor === 'Nothing') {
								return A2(
									_elm_lang$core$Maybe$andThen,
									function (p) {
										return A2(_user$project$LangTools$followPathInPat, _p86._1._1, p);
									},
									A2(_user$project$Utils$maybeGeti1, _p86._1._0, _p86._0._1));
							} else {
								return A2(
									_elm_lang$core$Maybe$andThen,
									function (p) {
										return A2(_user$project$LangTools$followPathInPat, _p86._1._1, p);
									},
									A2(
										_user$project$Utils$maybeGeti1,
										_p86._1._0,
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p86._0._1,
											{
												ctor: '::',
												_0: _p86._0._3._0,
												_1: {ctor: '[]'}
											})));
							}
						case 'PRecord':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (_p87) {
									var _p88 = _p87;
									return A2(_user$project$LangTools$followPathInPat, _p86._1._1, _p88._4);
								},
								A2(_user$project$Utils$maybeGeti1, _p86._1._0, _p86._0._1));
						case 'PParens':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (p) {
									return A2(_user$project$LangTools$followPathInPat, _p86._1._1, p);
								},
								A2(
									_user$project$Utils$maybeGeti1,
									_p86._1._0,
									{
										ctor: '::',
										_0: _p86._0._1,
										_1: {ctor: '[]'}
									}));
						case 'PColonType':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (p) {
									return A2(_user$project$LangTools$followPathInPat, _p86._1._1, p);
								},
								A2(
									_user$project$Utils$maybeGeti1,
									_p86._1._0,
									{
										ctor: '::',
										_0: _p86._0._1,
										_1: {ctor: '[]'}
									}));
						default:
							break _v41_7;
					}
				}
			} else {
				break _v41_7;
			}
		} while(false);
		return _elm_lang$core$Maybe$Nothing;
	});
var _user$project$LangTools$mapDeclarations = F2(
	function (callback, decls) {
		var _p89 = _user$project$Lang$getDeclarationsExtractors(decls);
		var ds = _p89._0;
		var dBuilder = _p89._1;
		return dBuilder(
			A2(
				_elm_lang$core$List$indexedMap,
				F2(
					function (index, def) {
						return A2(callback, index, def);
					}),
				ds));
	});
var _user$project$LangTools$findDeclaration = F2(
	function (callback, decls) {
		return A2(
			_user$project$Utils$mapFirstSuccess,
			function (_p90) {
				var _p91 = _p90;
				var _p92 = _p91._0;
				return A2(callback, _p91._1, _p92) ? _elm_lang$core$Maybe$Just(_p92) : _elm_lang$core$Maybe$Nothing;
			},
			_user$project$Utils$zipWithIndex(
				_user$project$Lang$getDeclarations(decls)));
	});
var _user$project$LangTools$nthDeclaration = F2(
	function (i, decls) {
		return A2(
			_user$project$LangTools$findDeclaration,
			F2(
				function (index, d) {
					return _elm_lang$core$Native_Utils.eq(index, i);
				}),
			decls);
	});
var _user$project$LangTools$findScopeExpAndPatByPathedPatternId = F2(
	function (_p93, exp) {
		var _p94 = _p93;
		var _p98 = _p94._1;
		var _p97 = _p94._0._1;
		var maybeScopeExp = A2(_user$project$Lang$findExpByEId, exp, _p94._0._0);
		var maybePat = function () {
			var _p95 = A2(_elm_lang$core$Maybe$map, _user$project$Lang$unwrapExp, maybeScopeExp);
			_v45_3:
			do {
				if (_p95.ctor === 'Just') {
					switch (_p95._0.ctor) {
						case 'ELet':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (def) {
									var _p96 = def;
									switch (_p96.ctor) {
										case 'DeclAnnotation':
											return A2(_user$project$LangTools$followPathInPat, _p98, _p96._0._2);
										case 'DeclExp':
											return A2(_user$project$LangTools$followPathInPat, _p98, _p96._0._2);
										default:
											return A2(_user$project$LangTools$followPathInPat, _p98, _p96._0._3);
									}
								},
								A2(_user$project$LangTools$nthDeclaration, _p97, _p95._0._2));
						case 'EFun':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (pat) {
									return A2(_user$project$LangTools$followPathInPat, _p98, pat);
								},
								A2(_user$project$Utils$maybeGeti0, _p97, _p95._0._1));
						case 'ECase':
							return A2(
								_elm_lang$core$Maybe$andThen,
								function (pat) {
									return A2(_user$project$LangTools$followPathInPat, _p98, pat);
								},
								A2(
									_user$project$Utils$maybeGeti0,
									_p97,
									_user$project$Lang$branchPats(_p95._0._2)));
						default:
							break _v45_3;
					}
				} else {
					break _v45_3;
				}
			} while(false);
			return _elm_lang$core$Maybe$Nothing;
		}();
		return A2(
			_elm_lang$core$Maybe$map,
			function (pat) {
				return {
					ctor: '_Tuple2',
					_0: {
						ctor: '_Tuple2',
						_0: A2(_user$project$Utils$fromJust_, 'findScopeExpAndPatByPathedPatternId', maybeScopeExp),
						_1: _p97 - 1
					},
					_1: pat
				};
			},
			maybePat);
	});
var _user$project$LangTools$findPatByPathedPatternId = F2(
	function (pathedPatId, exp) {
		return A2(
			_elm_lang$core$Maybe$map,
			_elm_lang$core$Tuple$second,
			A2(_user$project$LangTools$findScopeExpAndPatByPathedPatternId, pathedPatId, exp));
	});
var _user$project$LangTools$pathedPatternIdToPId = F2(
	function (pathedPatId, exp) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p99) {
				return function (_) {
					return _.pid;
				}(
					function (_) {
						return _.val;
					}(_p99));
			},
			A2(_user$project$LangTools$findPatByPathedPatternId, pathedPatId, exp));
	});
var _user$project$LangTools$declarationsOf = function (e) {
	var _p100 = _user$project$Lang$unwrapExp(e);
	if (_p100.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(_p100._2);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$findScopeAreasByIdent = F2(
	function (ident, exp) {
		return A2(
			_elm_lang$core$List$concatMap,
			function (e) {
				var _p101 = _user$project$Lang$unwrapExp(e);
				switch (_p101.ctor) {
					case 'ELet':
						var _p102 = A3(
							_user$project$Lang$foldLeftGroup,
							{
								ctor: '_Tuple2',
								_0: {ctor: '[]'},
								_1: false
							},
							_p101._2._3,
							F3(
								function (_p103, group, isRec) {
									var _p104 = _p103;
									var _p105 = _p104._0;
									if (_p104._1) {
										return {
											ctor: '_Tuple2',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												_p105,
												_user$project$Lang$groupBoundExps(group)),
											_1: true
										};
									} else {
										var idents = _user$project$Lang$groupIdentifiers(group);
										return A2(_elm_lang$core$List$member, ident, idents) ? (isRec ? {
											ctor: '_Tuple2',
											_0: A2(
												_elm_lang$core$Basics_ops['++'],
												_p105,
												_user$project$Lang$groupBoundExps(group)),
											_1: true
										} : {ctor: '_Tuple2', _0: _p105, _1: true}) : {ctor: '_Tuple2', _0: _p105, _1: false};
									}
								}));
						var res = _p102._0;
						var found = _p102._1;
						return found ? A2(
							_elm_lang$core$Basics_ops['++'],
							res,
							{
								ctor: '::',
								_0: _p101._4,
								_1: {ctor: '[]'}
							}) : res;
					case 'EFun':
						return A2(
							_elm_lang$core$List$member,
							ident,
							_user$project$Lang$identifiersListInPats(_p101._1)) ? {
							ctor: '::',
							_0: _p101._2,
							_1: {ctor: '[]'}
						} : {ctor: '[]'};
					case 'ECase':
						return A2(
							_elm_lang$core$List$concatMap,
							function (_p106) {
								var _p107 = _p106;
								return A2(
									_elm_lang$core$List$member,
									ident,
									_user$project$Lang$identifiersListInPat(_p107._0)) ? {
									ctor: '::',
									_0: _p107._1,
									_1: {ctor: '[]'}
								} : {ctor: '[]'};
							},
							_user$project$Lang$branchPatExps(_p101._2));
					default:
						return {ctor: '[]'};
				}
			},
			_user$project$Lang$flattenExpTree(exp));
	});
var _user$project$LangTools$findScopeAreas = F3(
	function (_p108, exp, oldName) {
		var _p109 = _p108;
		var _p116 = _p109._1;
		var maybeScopeExp = A2(_user$project$Lang$findExpByEId, exp, _p109._0);
		var _p110 = A2(_elm_lang$core$Maybe$map, _user$project$Lang$unwrapExp, maybeScopeExp);
		_v52_3:
		do {
			if (_p110.ctor === 'Just') {
				switch (_p110._0.ctor) {
					case 'ELet':
						var offset = _user$project$Lang$startBindingNumLetExp(_p110._0._2);
						var _p111 = A3(
							_user$project$Lang$foldLeftGroup,
							{
								ctor: '_Tuple3',
								_0: {ctor: '[]'},
								_1: 0,
								_2: false
							},
							_p110._0._2._3,
							F3(
								function (_p112, group, isRec) {
									var _p113 = _p112;
									var _p115 = _p113._1;
									var _p114 = _p113._0;
									var maybeShadowingIdentifiers = _user$project$Lang$groupIdentifiers(group);
									var isShadowing = A2(_elm_lang$core$List$member, oldName, maybeShadowingIdentifiers);
									var newDeclsBefore = _p115 + _elm_lang$core$List$length(group);
									if (_p113._2) {
										return {
											ctor: '_Tuple3',
											_0: ((!isShadowing) || (!isRec)) ? A2(
												_elm_lang$core$Basics_ops['++'],
												_p114,
												_user$project$Lang$groupBoundExps(group)) : _p114,
											_1: newDeclsBefore,
											_2: !isShadowing
										};
									} else {
										var idents = _user$project$Lang$groupIdentifiers(group);
										return ((_elm_lang$core$Native_Utils.cmp(_p115, _p116 - offset) < 1) && (_elm_lang$core$Native_Utils.cmp(_p116 - offset, newDeclsBefore) < 0)) ? (isRec ? {
											ctor: '_Tuple3',
											_0: ((!isShadowing) || (!isRec)) ? A2(
												_elm_lang$core$Basics_ops['++'],
												_p114,
												_user$project$Lang$groupBoundExps(group)) : _p114,
											_1: newDeclsBefore,
											_2: true
										} : {ctor: '_Tuple3', _0: _p114, _1: newDeclsBefore, _2: true}) : {ctor: '_Tuple3', _0: _p114, _1: newDeclsBefore, _2: false};
									}
								}));
						var res = _p111._0;
						var found = _p111._2;
						return A2(
							_elm_lang$core$Basics_ops['++'],
							res,
							{
								ctor: '::',
								_0: _p110._0._4,
								_1: {ctor: '[]'}
							});
					case 'EFun':
						return {
							ctor: '::',
							_0: _p110._0._2,
							_1: {ctor: '[]'}
						};
					case 'ECase':
						return A2(
							_elm_lang$core$Maybe$withDefault,
							{ctor: '[]'},
							A2(
								_elm_lang$core$Maybe$map,
								function (branch) {
									return {
										ctor: '::',
										_0: branch,
										_1: {ctor: '[]'}
									};
								},
								A2(
									_user$project$Utils$maybeGeti0,
									_p116,
									_user$project$Lang$branchExps(_p110._0._2))));
					default:
						break _v52_3;
				}
			} else {
				break _v52_3;
			}
		} while(false);
		return {ctor: '[]'};
	});
var _user$project$LangTools$patToExp = function (pat) {
	return A2(
		_elm_lang$core$Maybe$map,
		_user$project$Lang$withDummyExpInfo,
		function () {
			var _p117 = pat.val.p__;
			switch (_p117.ctor) {
				case 'PVar':
					return _elm_lang$core$Maybe$Just(
						A2(_user$project$Lang$EVar, _user$project$Lang$space1, _p117._1));
				case 'PAs':
					return A2(
						_elm_lang$core$Maybe$map,
						_user$project$Lang$unwrapExp,
						A2(
							_user$project$Utils$maybeOrElseLazy,
							function (_p118) {
								return _user$project$LangTools$patToExp(_p117._3);
							},
							_user$project$LangTools$patToExp(_p117._1)));
				case 'PList':
					var _p125 = _p117._4;
					var _p124 = _p117._2;
					var _p123 = _p117._0;
					var _p119 = _user$project$Utils$projJusts(
						A2(_elm_lang$core$List$map, _user$project$LangTools$patToExp, _p117._1));
					if (_p119.ctor === 'Nothing') {
						return _elm_lang$core$Maybe$Nothing;
					} else {
						var _p122 = _p119._0;
						var _p120 = _p117._3;
						if (_p120.ctor === 'Just') {
							var _p121 = _user$project$LangTools$patToExp(_p120._0);
							if (_p121.ctor === 'Just') {
								return _elm_lang$core$Maybe$Just(
									A5(
										_user$project$Lang$EList,
										_p123,
										A2(
											_elm_lang$core$List$map,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												})(_user$project$Lang$space0),
											_p122),
										_p124,
										_elm_lang$core$Maybe$Just(_p121._0),
										_p125));
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						} else {
							return _elm_lang$core$Maybe$Just(
								A5(
									_user$project$Lang$EList,
									_p123,
									A2(
										_elm_lang$core$List$map,
										F2(
											function (v0, v1) {
												return {ctor: '_Tuple2', _0: v0, _1: v1};
											})(_user$project$Lang$space0),
										_p122),
									_p124,
									_elm_lang$core$Maybe$Nothing,
									_p125));
						}
					}
				case 'PConst':
					return _elm_lang$core$Maybe$Just(
						A4(_user$project$Lang$EConst, _p117._0, _p117._1, _user$project$Lang$dummyLoc, _user$project$Lang$noWidgetDecl));
				case 'PBase':
					return _elm_lang$core$Maybe$Just(
						A2(_user$project$Lang$EBase, _p117._0, _p117._1));
				case 'PParens':
					return A2(
						_elm_lang$core$Maybe$map,
						_user$project$Lang$unwrapExp,
						_user$project$LangTools$patToExp(_p117._1));
				case 'PWildcard':
					return _elm_lang$core$Maybe$Nothing;
				case 'PRecord':
					return _elm_lang$core$Maybe$Nothing;
				default:
					return A2(
						_elm_lang$core$Maybe$map,
						_user$project$Lang$unwrapExp,
						_user$project$LangTools$patToExp(_p117._1));
			}
		}());
};
var _user$project$LangTools$setPatNameInPat = F3(
	function (path, newName, pat) {
		var _p126 = {ctor: '_Tuple2', _0: pat.val.p__, _1: path};
		_v58_7:
		do {
			if (_p126.ctor === '_Tuple2') {
				if (_p126._1.ctor === '[]') {
					switch (_p126._0.ctor) {
						case 'PVar':
							return A2(
								_user$project$Lang$replaceP__,
								pat,
								A3(_user$project$Lang$PVar, _p126._0._0, newName, _p126._0._2));
						case 'PWildcard':
							return A2(
								_user$project$Lang$replaceP__,
								pat,
								A3(
									_user$project$Lang$PVar,
									_p126._0._0,
									newName,
									_user$project$Info$withDummyInfo(_user$project$Lang$NoWidgetDecl)));
						default:
							break _v58_7;
					}
				} else {
					switch (_p126._0.ctor) {
						case 'PAs':
							switch (_p126._1._0) {
								case 1:
									var _p127 = _p126._0._1;
									return A2(
										_user$project$Lang$replaceP__,
										pat,
										A4(
											_user$project$Lang$PAs,
											_p126._0._0,
											A3(_user$project$LangTools$setPatNameInPat, _p126._1._1, newName, _p127),
											_p126._0._2,
											_p127));
								case 2:
									return A2(
										_user$project$Lang$replaceP__,
										pat,
										A4(
											_user$project$Lang$PAs,
											_p126._0._0,
											_p126._0._1,
											_p126._0._2,
											A3(_user$project$LangTools$setPatNameInPat, _p126._1._1, newName, _p126._0._3)));
								default:
									break _v58_7;
							}
						case 'PList':
							if (_p126._0._3.ctor === 'Nothing') {
								var newPs = A3(
									_user$project$Utils$getReplacei1,
									_p126._1._0,
									A2(_user$project$LangTools$setPatNameInPat, _p126._1._1, newName),
									_p126._0._1);
								return A2(
									_user$project$Lang$replaceP__,
									pat,
									A5(_user$project$Lang$PList, _p126._0._0, newPs, _p126._0._2, _elm_lang$core$Maybe$Nothing, _p126._0._4));
							} else {
								var _p134 = _p126._0._4;
								var _p133 = _p126._0._2;
								var _p132 = _p126._0._0;
								var _p131 = _p126._0._3._0;
								var _p130 = _p126._0._1;
								var _p129 = _p126._1._1;
								var _p128 = _p126._1._0;
								if (_elm_lang$core$Native_Utils.cmp(
									_p128,
									_elm_lang$core$List$length(_p130)) < 1) {
									var newPs = A3(
										_user$project$Utils$getReplacei1,
										_p128,
										A2(_user$project$LangTools$setPatNameInPat, _p129, newName),
										_p130);
									return A2(
										_user$project$Lang$replaceP__,
										pat,
										A5(
											_user$project$Lang$PList,
											_p132,
											newPs,
											_p133,
											_elm_lang$core$Maybe$Just(_p131),
											_p134));
								} else {
									if (_elm_lang$core$Native_Utils.eq(
										_p128,
										_elm_lang$core$List$length(_p130) + 1)) {
										return A2(
											_user$project$Lang$replaceP__,
											pat,
											A5(
												_user$project$Lang$PList,
												_p132,
												_p130,
												_p133,
												_elm_lang$core$Maybe$Just(
													A3(_user$project$LangTools$setPatNameInPat, _p129, newName, _p131)),
												_p134));
									} else {
										return pat;
									}
								}
							}
						case 'PRecord':
							var _p138 = _p126._1._0;
							var _p137 = _p126._0._1;
							if (_elm_lang$core$Native_Utils.cmp(
								_p138,
								_elm_lang$core$List$length(_p137)) < 1) {
								var newFields = A3(
									_user$project$Utils$getReplacei1,
									_p138,
									function (_p135) {
										var _p136 = _p135;
										var newFieldPat = A3(_user$project$LangTools$setPatNameInPat, _p126._1._1, newName, _p136._4);
										return {ctor: '_Tuple5', _0: _p136._0, _1: _p136._1, _2: _p136._2, _3: _p136._3, _4: newFieldPat};
									},
									_p137);
								return A2(
									_user$project$Lang$replaceP__,
									pat,
									A3(_user$project$Lang$PRecord, _p126._0._0, newFields, _p126._0._2));
							} else {
								return pat;
							}
						default:
							break _v58_7;
					}
				}
			} else {
				break _v58_7;
			}
		} while(false);
		return pat;
	});
var _user$project$LangTools$setPatName = F3(
	function (_p139, newName, exp) {
		var _p140 = _p139;
		var _p150 = _p140._1;
		var _p149 = _p140._0._1;
		var _p141 = A2(
			_elm_lang$core$Debug$log,
			'setPatName',
			{ctor: '_Tuple0'});
		var maybeScopeExp = A2(_user$project$Lang$findExpByEId, exp, _p140._0._0);
		var maybeNewScopeExp = function () {
			var makeNewScope = function (e__) {
				return A2(
					_user$project$Lang$replaceE__,
					A2(_user$project$Utils$fromJust_, 'setPatName', maybeScopeExp),
					e__);
			};
			var _p142 = A2(_elm_lang$core$Maybe$map, _user$project$Lang$unwrapExp, maybeScopeExp);
			_v61_3:
			do {
				if (_p142.ctor === 'Just') {
					switch (_p142._0.ctor) {
						case 'ELet':
							var newDecls = A2(
								_user$project$LangTools$mapDeclarations,
								F2(
									function (index, def) {
										if (_elm_lang$core$Native_Utils.eq(index, _p149)) {
											var _p143 = def;
											if (_p143.ctor === 'DeclExp') {
												var newPat = A3(_user$project$LangTools$setPatNameInPat, _p150, newName, _p143._0._2);
												return _user$project$Lang$DeclExp(
													A6(_user$project$Lang$LetExp, _p143._0._0, _p143._0._1, newPat, _p143._0._3, _p143._0._4, _p143._0._5));
											} else {
												return def;
											}
										} else {
											return def;
										}
									}),
								_p142._0._2);
							return _elm_lang$core$Maybe$Just(
								makeNewScope(
									A5(_user$project$Lang$ELet, _p142._0._0, _p142._0._1, newDecls, _p142._0._3, _p142._0._4)));
						case 'EFun':
							var _p144 = _p142._0._1;
							return A2(
								_elm_lang$core$Maybe$map,
								function (pat) {
									var newPat = A3(_user$project$LangTools$setPatNameInPat, _p150, newName, pat);
									return makeNewScope(
										A4(
											_user$project$Lang$EFun,
											_p142._0._0,
											A3(_user$project$Utils$replacei0, _p149, newPat, _p144),
											_p142._0._2,
											_p142._0._3));
								},
								A2(_user$project$Utils$maybeGeti0, _p149, _p144));
						case 'ECase':
							var _p146 = _p142._0._2;
							return A2(
								_elm_lang$core$Maybe$map,
								function (branch) {
									var _p145 = branch.val;
									var ws1 = _p145._0;
									var pat = _p145._1;
									var exp = _p145._2;
									var ws2 = _p145._3;
									var newPat = A3(_user$project$LangTools$setPatNameInPat, _p150, newName, pat);
									var newBranch = _elm_lang$core$Native_Utils.update(
										branch,
										{
											val: A4(_user$project$Lang$Branch_, ws1, newPat, exp, ws2)
										});
									return makeNewScope(
										A4(
											_user$project$Lang$ECase,
											_p142._0._0,
											_p142._0._1,
											A3(_user$project$Utils$replacei0, _p149, newBranch, _p146),
											_p142._0._3));
								},
								A2(_user$project$Utils$maybeGeti0, _p149, _p146));
						default:
							break _v61_3;
					}
				} else {
					break _v61_3;
				}
			} while(false);
			return _elm_lang$core$Maybe$Nothing;
		}();
		var _p147 = maybeNewScopeExp;
		if (_p147.ctor === 'Just') {
			var _p148 = _p147._0;
			return A3(
				_user$project$Lang$replaceExpNode,
				_user$project$Lang$expEId(_p148),
				_p148,
				exp);
		} else {
			return exp;
		}
	});
var _user$project$LangTools$renameIdentifiersInPat = F2(
	function (subst, pat) {
		var recurse = _user$project$LangTools$renameIdentifiersInPat(subst);
		var recurseList = _elm_lang$core$List$map(recurse);
		var pat__ = function () {
			var _p151 = pat.val.p__;
			switch (_p151.ctor) {
				case 'PVar':
					var _p152 = A2(_elm_lang$core$Dict$get, _p151._1, subst);
					if (_p152.ctor === 'Just') {
						return A3(_user$project$Lang$PVar, _p151._0, _p152._0, _p151._2);
					} else {
						return pat.val.p__;
					}
				case 'PList':
					if (_p151._3.ctor === 'Nothing') {
						return A5(
							_user$project$Lang$PList,
							_p151._0,
							recurseList(_p151._1),
							_p151._2,
							_elm_lang$core$Maybe$Nothing,
							_p151._4);
					} else {
						return A5(
							_user$project$Lang$PList,
							_p151._0,
							recurseList(_p151._1),
							_p151._2,
							_elm_lang$core$Maybe$Just(
								recurse(_p151._3._0)),
							_p151._4);
					}
				case 'PAs':
					return A4(
						_user$project$Lang$PAs,
						_p151._0,
						recurse(_p151._1),
						_p151._2,
						recurse(_p151._3));
				case 'PColonType':
					return A4(
						_user$project$Lang$PColonType,
						_p151._0,
						recurse(_p151._1),
						_p151._2,
						_p151._3);
				case 'PRecord':
					return A3(
						_user$project$Lang$PRecord,
						_p151._0,
						A2(_user$project$Utils$recordValuesMap, recurse, _p151._1),
						_p151._2);
				case 'PParens':
					return A3(
						_user$project$Lang$PParens,
						_p151._0,
						recurse(_p151._1),
						_p151._2);
				case 'PWildcard':
					return pat.val.p__;
				case 'PBase':
					return pat.val.p__;
				default:
					return pat.val.p__;
			}
		}();
		return A2(_user$project$Lang$replaceP__, pat, pat__);
	});
var _user$project$LangTools$renameIdentifiersInPats = F2(
	function (subst, pats) {
		return A2(
			_elm_lang$core$List$map,
			_user$project$LangTools$renameIdentifiersInPat(subst),
			pats);
	});
var _user$project$LangTools$renameIdentifierInPat = F3(
	function (old, $new, pat) {
		return A2(
			_user$project$LangTools$renameIdentifiersInPat,
			A2(_elm_lang$core$Dict$singleton, old, $new),
			pat);
	});
var _user$project$LangTools$renameIdentifierInPats = F3(
	function (old, $new, pats) {
		return A2(
			_elm_lang$core$List$map,
			A2(_user$project$LangTools$renameIdentifierInPat, old, $new),
			pats);
	});
var _user$project$LangTools$renameIdentifiersInDecls = F2(
	function (subst, _p153) {
		var _p154 = _p153;
		var _p162 = _p154._1;
		var _p161 = _p154._3;
		return A4(
			_user$project$Lang$Declarations,
			_p154._0,
			A2(
				_user$project$Lang$regroup,
				_p162,
				A2(
					_elm_lang$core$List$map,
					function (_p155) {
						var _p156 = _p155;
						return A7(
							_user$project$Lang$LetType,
							_p156._0,
							_p156._1,
							_p156._2,
							A2(_user$project$LangTools$renameIdentifiersInPat, subst, _p156._3),
							_p156._4,
							_p156._5,
							_p156._6);
					},
					_user$project$Lang$elemsOf(_p162))),
			A2(
				_elm_lang$core$List$map,
				function (_p157) {
					var _p158 = _p157;
					return A6(
						_user$project$Lang$LetAnnotation,
						_p158._0,
						_p158._1,
						A2(_user$project$LangTools$renameIdentifiersInPat, subst, _p158._2),
						_p158._3,
						_p158._4,
						_p158._5);
				},
				_p154._2),
			A2(
				_user$project$Lang$regroup,
				_p161,
				A2(
					_elm_lang$core$List$map,
					function (_p159) {
						var _p160 = _p159;
						return A6(
							_user$project$Lang$LetExp,
							_p160._0,
							_p160._1,
							A2(_user$project$LangTools$renameIdentifiersInPat, subst, _p160._2),
							_p160._3,
							_p160._4,
							_p160._5);
					},
					_user$project$Lang$elemsOf(_p161))));
	});
var _user$project$LangTools$renameIdentifiers = F2(
	function (subst, exp) {
		var exp__Renamer = function (e__) {
			var _p163 = e__;
			switch (_p163.ctor) {
				case 'EVar':
					var _p164 = A2(_elm_lang$core$Dict$get, _p163._1, subst);
					if (_p164.ctor === 'Just') {
						return A2(_user$project$Lang$EVar, _p163._0, _p164._0);
					} else {
						return e__;
					}
				case 'EFun':
					return A4(
						_user$project$Lang$EFun,
						_p163._0,
						A2(_user$project$LangTools$renameIdentifiersInPats, subst, _p163._1),
						_p163._2,
						_p163._3);
				case 'ECase':
					var branches_ = A2(
						_elm_lang$core$List$map,
						_user$project$Lang$mapValField(
							function (_p165) {
								var _p166 = _p165;
								return A4(
									_user$project$Lang$Branch_,
									_p166._0,
									A2(_user$project$LangTools$renameIdentifiersInPat, subst, _p166._1),
									_p166._2,
									_p166._3);
							}),
						_p163._2);
					return A4(_user$project$Lang$ECase, _p163._0, _p163._1, branches_, _p163._3);
				case 'ELet':
					return A5(
						_user$project$Lang$ELet,
						_p163._0,
						_p163._1,
						A2(_user$project$LangTools$renameIdentifiersInDecls, subst, _p163._2),
						_p163._3,
						_p163._4);
				default:
					return e__;
			}
		};
		return A2(_user$project$Lang$mapExpViaExp__, exp__Renamer, exp);
	});
var _user$project$LangTools$renameIdentifier = F3(
	function (old, $new, exp) {
		return A2(
			_user$project$LangTools$renameIdentifiers,
			A2(_elm_lang$core$Dict$singleton, old, $new),
			exp);
	});
var _user$project$LangTools$nonCollidingNames = F3(
	function (suggestedNames, i, existingNames) {
		nonCollidingNames:
		while (true) {
			var plainSuggestedNames = A2(
				_elm_lang$core$List$map,
				A2(_user$project$Utils$stringReplace, '{n}', ''),
				suggestedNames);
			if (!A2(_user$project$Utils$anyOverlapListSet, plainSuggestedNames, existingNames)) {
				return plainSuggestedNames;
			} else {
				var newNames = A2(
					_elm_lang$core$List$map,
					function (name) {
						return A2(_elm_lang$core$String$contains, '{n}', name) ? A3(
							_user$project$Utils$stringReplace,
							'{n}',
							_elm_lang$core$Basics$toString(i),
							name) : A2(
							_elm_lang$core$Basics_ops['++'],
							name,
							_elm_lang$core$Basics$toString(i));
					},
					suggestedNames);
				if (!A2(_user$project$Utils$anyOverlapListSet, newNames, existingNames)) {
					return newNames;
				} else {
					var _v73 = suggestedNames,
						_v74 = i + 1,
						_v75 = existingNames;
					suggestedNames = _v73;
					i = _v74;
					existingNames = _v75;
					continue nonCollidingNames;
				}
			}
		}
	});
var _user$project$LangTools$nonCollidingName = F3(
	function (suggestedName, i, existingNames) {
		return A2(
			_user$project$Utils$head,
			'LangTools.nonCollidingNames did not satisfy its invariant',
			A3(
				_user$project$LangTools$nonCollidingNames,
				{
					ctor: '::',
					_0: suggestedName,
					_1: {ctor: '[]'}
				},
				i,
				existingNames));
	});
var _user$project$LangTools$assignUniqueNames_ = F3(
	function (exp, usedNames, oldNameToNewName) {
		var recurse = _user$project$LangTools$assignUniqueNames_;
		var recurseExps = function (es) {
			return A3(
				_elm_lang$core$List$foldl,
				F2(
					function (e, _p167) {
						var _p168 = _p167;
						var _p169 = A3(recurse, e, _p168._1, oldNameToNewName);
						var newE = _p169._0;
						var usedNames_ = _p169._1;
						var newNameToOldName_ = _p169._2;
						return {
							ctor: '_Tuple3',
							_0: A2(
								_elm_lang$core$Basics_ops['++'],
								_p168._0,
								{
									ctor: '::',
									_0: newE,
									_1: {ctor: '[]'}
								}),
							_1: usedNames_,
							_2: A2(_elm_lang$core$Dict$union, newNameToOldName_, _p168._2)
						};
					}),
				{
					ctor: '_Tuple3',
					_0: {ctor: '[]'},
					_1: usedNames,
					_2: _elm_lang$core$Dict$empty
				},
				es);
		};
		var recurseExp = function (e) {
			var _p170 = recurseExps(
				{
					ctor: '::',
					_0: e,
					_1: {ctor: '[]'}
				});
			var newEs = _p170._0;
			var usedNames = _p170._1;
			var newNameToOldName = _p170._2;
			return {
				ctor: '_Tuple3',
				_0: A2(_user$project$Utils$head, 'assignUniqueNames_ head1', newEs),
				_1: usedNames,
				_2: newNameToOldName
			};
		};
		var assignUniqueNamesToPat_ = F2(
			function (pat, usedNames) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (name, _p171) {
							var _p172 = _p171;
							var _p175 = _p172._1;
							var _p174 = _p172._0;
							var _p173 = _p172._2;
							if (A2(_elm_lang$core$Set$member, name, _p175)) {
								var newName = A3(_user$project$LangTools$nonCollidingName, name, 2, _p175);
								return {
									ctor: '_Tuple3',
									_0: A3(_user$project$LangTools$renameIdentifierInPat, name, newName, _p174),
									_1: A2(_elm_lang$core$Set$insert, newName, _p175),
									_2: A3(_elm_lang$core$Dict$insert, name, newName, _p173)
								};
							} else {
								return {
									ctor: '_Tuple3',
									_0: _p174,
									_1: A2(_elm_lang$core$Set$insert, name, _p175),
									_2: _p173
								};
							}
						}),
					{ctor: '_Tuple3', _0: pat, _1: usedNames, _2: _elm_lang$core$Dict$empty},
					_user$project$Lang$identifiersListInPat(pat));
			});
		var assignUniqueNamesToDeclarations_ = F3(
			function (_p176, usedNames, oldNameToNewName) {
				var _p177 = _p176;
				var _p178 = A3(
					_user$project$Lang$foldLeftGroup,
					{
						ctor: '_Tuple4',
						_0: {ctor: '[]'},
						_1: usedNames,
						_2: _elm_lang$core$Dict$empty,
						_3: oldNameToNewName
					},
					_p177._3,
					F3(
						function (_p179, letexps, isRec) {
							var _p180 = _p179;
							var _p196 = _p180._3;
							var _p181 = A3(
								_user$project$Utils$foldLeft,
								{
									ctor: '_Tuple3',
									_0: {ctor: '[]'},
									_1: _p180._1,
									_2: _elm_lang$core$Dict$empty
								},
								letexps,
								F2(
									function (_p183, _p182) {
										var _p184 = _p183;
										var _p185 = _p182;
										var _p187 = _p185._2;
										var _p186 = A2(assignUniqueNamesToPat_, _p187, _p184._1);
										var newPat = _p186._0;
										var usedNames_ = _p186._1;
										var oldNameToNewNameAdditions_ = _p186._2;
										return {
											ctor: '_Tuple3',
											_0: {ctor: '::', _0: _p187, _1: _p184._0},
											_1: usedNames_,
											_2: A2(_elm_lang$core$Dict$union, _p184._2, oldNameToNewNameAdditions_)
										};
									}));
							var newRevPats = _p181._0;
							var usedNames__ = _p181._1;
							var oldNameToNewNameAdditions = _p181._2;
							var newPats = _elm_lang$core$List$reverse(newRevPats);
							var oldNameToNewNameWithAdditions = A2(_elm_lang$core$Dict$union, oldNameToNewNameAdditions, _p196);
							var oldNameToNewNameForBoundExps = isRec ? oldNameToNewNameWithAdditions : _p196;
							var _p188 = A3(
								_user$project$Utils$foldLeft,
								{
									ctor: '_Tuple4',
									_0: usedNames__,
									_1: newPats,
									_2: {ctor: '[]'},
									_3: _user$project$Utils$flipDict(oldNameToNewNameAdditions)
								},
								letexps,
								F2(
									function (_p190, _p189) {
										var _p191 = _p190;
										var _p192 = _p189;
										var _p193 = _p191._1;
										if (_p193.ctor === '::') {
											var _p194 = A3(recurse, _p192._5, _p191._0, oldNameToNewNameForBoundExps);
											var newE1 = _p194._0;
											var usedNames__ = _p194._1;
											var newNameToOldName_ = _p194._2;
											var newLetExp = A6(_user$project$Lang$LetExp, _p192._0, _p192._1, _p193._0, _p192._3, _p192._4, newE1);
											return {
												ctor: '_Tuple4',
												_0: usedNames__,
												_1: _p193._1,
												_2: {ctor: '::', _0: newLetExp, _1: _p191._2},
												_3: A2(_elm_lang$core$Dict$union, _p191._3, newNameToOldName_)
											};
										} else {
											return _elm_lang$core$Native_Utils.crashCase(
												'LangTools',
												{
													start: {line: 2904, column: 17},
													end: {line: 2909, column: 96}
												},
												_p193)('Unexpected missing pattern in EvalUpdate.assignUniqueNames_');
										}
									}));
							var usedNames___ = _p188._0;
							var revNewLetExps = _p188._2;
							var newNameToOldName__ = _p188._3;
							return {
								ctor: '_Tuple4',
								_0: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: isRec,
										_1: _elm_lang$core$List$reverse(revNewLetExps)
									},
									_1: _p180._0
								},
								_1: usedNames___,
								_2: A2(_elm_lang$core$Dict$union, _p180._2, newNameToOldName__),
								_3: oldNameToNewNameWithAdditions
							};
						}));
				var newRevLetexpsGroups = _p178._0;
				var usedNames__ = _p178._1;
				var newNameToOldName__ = _p178._2;
				var oldNameToNewName__ = _p178._3;
				return {
					ctor: '_Tuple4',
					_0: A4(
						_user$project$Lang$Declarations,
						_p177._0,
						_p177._1,
						_p177._2,
						_elm_lang$core$List$reverse(newRevLetexpsGroups)),
					_1: usedNames__,
					_2: newNameToOldName__,
					_3: oldNameToNewName__
				};
			});
		var leafUnchanged = {ctor: '_Tuple3', _0: exp, _1: usedNames, _2: _elm_lang$core$Dict$empty};
		var _p197 = _user$project$Lang$unwrapExp(exp);
		switch (_p197.ctor) {
			case 'EConst':
				return leafUnchanged;
			case 'EBase':
				return leafUnchanged;
			case 'EVar':
				var _p198 = A2(_elm_lang$core$Dict$get, _p197._1, oldNameToNewName);
				if (_p198.ctor === 'Just') {
					return {
						ctor: '_Tuple3',
						_0: A2(
							_user$project$Lang$replaceE__,
							exp,
							A2(_user$project$Lang$EVar, _p197._0, _p198._0)),
						_1: usedNames,
						_2: _elm_lang$core$Dict$empty
					};
				} else {
					return leafUnchanged;
				}
			case 'EFun':
				var _p199 = A3(
					_elm_lang$core$List$foldl,
					F2(
						function (p, _p200) {
							var _p201 = _p200;
							var _p202 = A2(assignUniqueNamesToPat_, p, _p201._1);
							var newPat = _p202._0;
							var usedNames_ = _p202._1;
							var oldNameToNewNameAdditions_ = _p202._2;
							return {
								ctor: '_Tuple3',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p201._0,
									{
										ctor: '::',
										_0: newPat,
										_1: {ctor: '[]'}
									}),
								_1: usedNames_,
								_2: A2(_elm_lang$core$Dict$union, oldNameToNewNameAdditions_, _p201._2)
							};
						}),
					{
						ctor: '_Tuple3',
						_0: {ctor: '[]'},
						_1: usedNames,
						_2: _elm_lang$core$Dict$empty
					},
					_p197._1);
				var newPs = _p199._0;
				var usedNames_ = _p199._1;
				var oldNameToNewNameAdditions = _p199._2;
				var _p203 = A3(
					recurse,
					_p197._2,
					usedNames_,
					A2(_elm_lang$core$Dict$union, oldNameToNewNameAdditions, oldNameToNewName));
				var newBody = _p203._0;
				var usedNames__ = _p203._1;
				var newNameToOldName = _p203._2;
				var newNameToOldName_ = A2(
					_elm_lang$core$Dict$union,
					_user$project$Utils$flipDict(oldNameToNewNameAdditions),
					newNameToOldName);
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A4(_user$project$Lang$EFun, _p197._0, newPs, newBody, _p197._3)),
					_1: usedNames__,
					_2: newNameToOldName_
				};
			case 'EOp':
				var _p204 = recurseExps(_p197._3);
				var newEs = _p204._0;
				var usedNames_ = _p204._1;
				var newNameToOldName = _p204._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A5(_user$project$Lang$EOp, _p197._0, _p197._1, _p197._2, newEs, _p197._4)),
					_1: usedNames_,
					_2: newNameToOldName
				};
			case 'EList':
				if (_p197._3.ctor === 'Nothing') {
					var _p206 = _p197._1;
					var _p205 = recurseExps(
						_user$project$Utils$listValues(_p206));
					var newEs = _p205._0;
					var usedNames_ = _p205._1;
					var newNameToOldName = _p205._2;
					return {
						ctor: '_Tuple3',
						_0: A2(
							_user$project$Lang$replaceE__,
							exp,
							A5(
								_user$project$Lang$EList,
								_p197._0,
								A2(_user$project$Utils$listValuesMake, _p206, newEs),
								_p197._2,
								_elm_lang$core$Maybe$Nothing,
								_p197._4)),
						_1: usedNames_,
						_2: newNameToOldName
					};
				} else {
					var _p209 = _p197._1;
					var _p207 = recurseExps(
						A2(
							_elm_lang$core$Basics_ops['++'],
							_user$project$Utils$listValues(_p209),
							{
								ctor: '::',
								_0: _p197._3._0,
								_1: {ctor: '[]'}
							}));
					var newEs = _p207._0;
					var usedNames_ = _p207._1;
					var newNameToOldName = _p207._2;
					var _p208 = {
						ctor: '_Tuple2',
						_0: _user$project$Utils$removeLastElement(newEs),
						_1: A2(_user$project$Utils$last, 'assignUniqueNames_', newEs)
					};
					var newHeads = _p208._0;
					var newTail = _p208._1;
					return {
						ctor: '_Tuple3',
						_0: A2(
							_user$project$Lang$replaceE__,
							exp,
							A5(
								_user$project$Lang$EList,
								_p197._0,
								A2(_user$project$Utils$listValuesMake, _p209, newHeads),
								_p197._2,
								_elm_lang$core$Maybe$Just(newTail),
								_p197._4)),
						_1: usedNames_,
						_2: newNameToOldName
					};
				}
			case 'ERecord':
				var _p210 = function () {
					var _p211 = _p197._1;
					if (_p211.ctor === 'Nothing') {
						return {ctor: '_Tuple3', _0: _elm_lang$core$Maybe$Nothing, _1: usedNames, _2: _elm_lang$core$Dict$empty};
					} else {
						var _p212 = A3(recurse, _p211._0._0, usedNames, oldNameToNewName);
						var newInit = _p212._0;
						var usedNames_ = _p212._1;
						var newNameToOldName_ = _p212._2;
						return {
							ctor: '_Tuple3',
							_0: _elm_lang$core$Maybe$Just(
								{ctor: '_Tuple2', _0: newInit, _1: _p211._0._1}),
							_1: usedNames_,
							_2: newNameToOldName_
						};
					}
				}();
				var newInit = _p210._0;
				var usedNames__ = _p210._1;
				var newNameToOldName = _p210._2;
				var _p213 = A3(assignUniqueNamesToDeclarations_, _p197._2, usedNames__, oldNameToNewName);
				var newDecls = _p213._0;
				var usedNames___ = _p213._1;
				var newNameToOldName__ = _p213._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A4(_user$project$Lang$ERecord, _p197._0, newInit, newDecls, _p197._3)),
					_1: usedNames___,
					_2: A2(_elm_lang$core$Dict$union, newNameToOldName, newNameToOldName__)
				};
			case 'ESelect':
				var _p214 = recurseExp(_p197._1);
				var newE1 = _p214._0;
				var usedNames_ = _p214._1;
				var newNameToOldName = _p214._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A5(_user$project$Lang$ESelect, _p197._0, newE1, _p197._2, _p197._3, _p197._4)),
					_1: usedNames_,
					_2: newNameToOldName
				};
			case 'EIf':
				var _p215 = recurseExps(
					{
						ctor: '::',
						_0: _p197._1,
						_1: {
							ctor: '::',
							_0: _p197._3,
							_1: {
								ctor: '::',
								_0: _p197._5,
								_1: {ctor: '[]'}
							}
						}
					});
				var newEs = _p215._0;
				var usedNames_ = _p215._1;
				var newNameToOldName = _p215._2;
				var _p216 = newEs;
				if ((((_p216.ctor === '::') && (_p216._1.ctor === '::')) && (_p216._1._1.ctor === '::')) && (_p216._1._1._1.ctor === '[]')) {
					return {
						ctor: '_Tuple3',
						_0: A2(
							_user$project$Lang$replaceE__,
							exp,
							A7(_user$project$Lang$EIf, _p197._0, _p216._0, _p197._2, _p216._1._0, _p197._4, _p216._1._1._0, _p197._6)),
						_1: usedNames_,
						_2: newNameToOldName
					};
				} else {
					return _elm_lang$core$Native_Utils.crashCase(
						'LangTools',
						{
							start: {line: 2993, column: 8},
							end: {line: 3001, column: 48}
						},
						_p216)('assignUniqueNames_ EIf');
				}
			case 'ECase':
				var _p218 = A3(recurse, _p197._1, usedNames, oldNameToNewName);
				var newScrutinee = _p218._0;
				var usedNames_ = _p218._1;
				var newNameToOldName = _p218._2;
				var _p219 = A3(
					_elm_lang$core$List$foldl,
					F2(
						function (branch, _p220) {
							var _p221 = _p220;
							var _p222 = branch.val;
							var bws1 = _p222._0;
							var bPat = _p222._1;
							var bExp = _p222._2;
							var bws2 = _p222._3;
							var _p223 = A2(assignUniqueNamesToPat_, bPat, _p221._1);
							var newPat = _p223._0;
							var usedNames_ = _p223._1;
							var oldNameToNewNameAdditions = _p223._2;
							var _p224 = A3(
								recurse,
								bExp,
								usedNames_,
								A2(_elm_lang$core$Dict$union, oldNameToNewNameAdditions, oldNameToNewName));
							var newBody = _p224._0;
							var usedNames__ = _p224._1;
							var newNameToOldName_ = _p224._2;
							var newBranch = _elm_lang$core$Native_Utils.update(
								branch,
								{
									val: A4(_user$project$Lang$Branch_, bws1, newPat, newBody, bws2)
								});
							return {
								ctor: '_Tuple3',
								_0: A2(
									_elm_lang$core$Basics_ops['++'],
									_p221._0,
									{
										ctor: '::',
										_0: newBranch,
										_1: {ctor: '[]'}
									}),
								_1: usedNames__,
								_2: A2(
									_elm_lang$core$Dict$union,
									_user$project$Utils$flipDict(oldNameToNewNameAdditions),
									A2(_elm_lang$core$Dict$union, newNameToOldName_, _p221._2))
							};
						}),
					{
						ctor: '_Tuple3',
						_0: {ctor: '[]'},
						_1: usedNames_,
						_2: newNameToOldName
					},
					_p197._2);
				var newBranches = _p219._0;
				var usedNames__ = _p219._1;
				var newNameToOldName_ = _p219._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A4(_user$project$Lang$ECase, _p197._0, newScrutinee, newBranches, _p197._3)),
					_1: usedNames__,
					_2: newNameToOldName_
				};
			case 'EApp':
				var _p225 = recurseExps(
					{ctor: '::', _0: _p197._1, _1: _p197._2});
				var newE1AndEs = _p225._0;
				var usedNames_ = _p225._1;
				var newNameToOldName = _p225._2;
				var _p226 = {
					ctor: '_Tuple2',
					_0: A2(_user$project$Utils$head, 'assignUniqueNames_ head', newE1AndEs),
					_1: A2(_user$project$Utils$tail, 'assignUniqueNames_ tail', newE1AndEs)
				};
				var newE1 = _p226._0;
				var newEs = _p226._1;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A5(_user$project$Lang$EApp, _p197._0, newE1, newEs, _p197._3, _p197._4)),
					_1: usedNames_,
					_2: newNameToOldName
				};
			case 'ELet':
				var _p227 = A3(assignUniqueNamesToDeclarations_, _p197._2, usedNames, oldNameToNewName);
				var newDecls = _p227._0;
				var usedNames_ = _p227._1;
				var newNameToOldName = _p227._2;
				var oldNameToNewNameWithAdditions = _p227._3;
				var _p228 = A3(recurse, _p197._4, usedNames_, oldNameToNewNameWithAdditions);
				var newE2 = _p228._0;
				var usedNames__ = _p228._1;
				var newNameToOldName_ = _p228._2;
				var newNameToOldName__ = A2(_elm_lang$core$Dict$union, newNameToOldName, newNameToOldName_);
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A5(_user$project$Lang$ELet, _p197._0, _p197._1, newDecls, _p197._3, newE2)),
					_1: usedNames__,
					_2: newNameToOldName__
				};
			case 'EColonType':
				var _p229 = recurseExp(_p197._1);
				var newE1 = _p229._0;
				var usedNames_ = _p229._1;
				var newNameToOldName = _p229._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A5(_user$project$Lang$EColonType, _p197._0, newE1, _p197._2, _p197._3, _p197._4)),
					_1: usedNames_,
					_2: newNameToOldName
				};
			case 'EParens':
				var _p230 = recurseExp(_p197._1);
				var newE1 = _p230._0;
				var usedNames_ = _p230._1;
				var newNameToOldName = _p230._2;
				return {
					ctor: '_Tuple3',
					_0: A2(
						_user$project$Lang$replaceE__,
						exp,
						A4(_user$project$Lang$EParens, _p197._0, newE1, _p197._2, _p197._3)),
					_1: usedNames_,
					_2: newNameToOldName
				};
			default:
				return leafUnchanged;
		}
	});
var _user$project$LangTools$identifierCounts = function (exp) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (ident, counts) {
				return A3(
					_elm_lang$core$Dict$update,
					ident,
					function (old) {
						var _p231 = old;
						if (_p231.ctor === 'Just') {
							return _elm_lang$core$Maybe$Just(_p231._0 + 1);
						} else {
							return _elm_lang$core$Maybe$Just(1);
						}
					},
					counts);
			}),
		_elm_lang$core$Dict$empty,
		_user$project$Lang$identifiersList(exp));
};
var _user$project$LangTools$declarationsPats = function (_p232) {
	var _p233 = _p232;
	return A2(
		_elm_lang$core$Basics_ops['++'],
		A2(
			_elm_lang$core$List$map,
			function (_p234) {
				var _p235 = _p234;
				return _p235._3;
			},
			_user$project$Lang$elemsOf(_p233._1)),
		A2(
			_elm_lang$core$Basics_ops['++'],
			A2(
				_elm_lang$core$List$map,
				function (_p236) {
					var _p237 = _p236;
					return _p237._2;
				},
				_p233._2),
			A2(
				_elm_lang$core$List$map,
				function (_p238) {
					var _p239 = _p238;
					return _p239._2;
				},
				_user$project$Lang$elemsOf(_p233._3))));
};
var _user$project$LangTools$identifiersListPatsOnly = function (exp) {
	var folder = F2(
		function (e__, acc) {
			var _p240 = e__;
			switch (_p240.ctor) {
				case 'EFun':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, _p240._1),
						acc);
				case 'ECase':
					var pats = _user$project$Lang$branchPats(_p240._2);
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(_elm_lang$core$List$concatMap, _user$project$Lang$identifiersListInPat, pats),
						acc);
				case 'ELet':
					return A2(
						_elm_lang$core$Basics_ops['++'],
						A2(
							_elm_lang$core$List$concatMap,
							_user$project$Lang$identifiersListInPat,
							_user$project$LangTools$declarationsPats(_p240._2)),
						acc);
				default:
					return acc;
			}
		});
	return A3(
		_user$project$Lang$foldExpViaE__,
		folder,
		{ctor: '[]'},
		exp);
};
var _user$project$LangTools$identifiersSetPatsOnly = function (exp) {
	return _elm_lang$core$Set$fromList(
		_user$project$LangTools$identifiersListPatsOnly(exp));
};
var _user$project$LangTools$allPats = function (root) {
	return A2(
		_elm_lang$core$List$concatMap,
		function (exp) {
			var _p241 = _user$project$Lang$unwrapExp(exp);
			switch (_p241.ctor) {
				case 'EFun':
					return _p241._1;
				case 'ECase':
					return _user$project$Lang$branchPats(_p241._2);
				case 'ELet':
					return _user$project$LangTools$declarationsPats(_p241._2);
				default:
					return {ctor: '[]'};
			}
		},
		_user$project$Lang$flattenExpTree(root));
};
var _user$project$LangTools$isLiteral = function (exp) {
	return _elm_lang$core$Native_Utils.eq(
		_elm_lang$core$Set$size(
			_user$project$Lang$freeIdentifiers(exp)),
		0);
};
var _user$project$LangTools$expToMaybeSnapHoleVal = function (exp) {
	var _p242 = _user$project$Lang$unwrapExp(exp);
	if ((_p242.ctor === 'EHole') && (_p242._1.ctor === 'ESnapHole')) {
		return _elm_lang$core$Maybe$Just(_p242._1._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$expToCaseScrutinee = function (exp) {
	var _p243 = _user$project$Lang$unwrapExp(exp);
	if (_p243.ctor === 'ECase') {
		return _p243._1;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1274, column: 3},
				end: {line: 1276, column: 115}
			},
			_p243)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToScrutinee exp is not an ECase: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToFuncPats = function (exp) {
	var _p245 = _user$project$Lang$unwrapExp(exp);
	if (_p245.ctor === 'EFun') {
		return _p245._1;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1267, column: 3},
				end: {line: 1269, column: 107}
			},
			_p245)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToFuncPats exp is not an EFun: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToMaybeLetBody = function (exp) {
	var _p247 = _user$project$Lang$unwrapExp(exp);
	if (_p247.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(_p247._4);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$expToLetBody = function (exp) {
	var _p248 = _user$project$LangTools$expToMaybeLetBody(exp);
	if (_p248.ctor === 'Just') {
		return _p248._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1254, column: 3},
				end: {line: 1256, column: 100}
			},
			_p248)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetBody exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToMaybeLetPatAndBoundExp = function (exp) {
	var _p250 = _user$project$Lang$unwrapExp(exp);
	if (_p250.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(
			A2(
				_elm_lang$core$List$map,
				function (_p251) {
					var _p252 = _p251;
					return {ctor: '_Tuple2', _0: _p252._2, _1: _p252._5};
				},
				_user$project$Lang$elemsOf(_p250._2._3)));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$findBoundExpByPathedPatternId = F2(
	function (_p253, exp) {
		var _p254 = _p253;
		var _p255 = A2(
			_elm_lang$core$Maybe$andThen,
			_user$project$LangTools$expToMaybeLetPatAndBoundExp,
			A2(_user$project$Lang$findExpByEId, exp, _p254._0._0));
		if (_p255.ctor === 'Just') {
			var _p256 = A2(_user$project$Utils$nth, _p255._0, _p254._0._1);
			if (_p256.ctor === 'Err') {
				return _elm_lang$core$Maybe$Nothing;
			} else {
				return A2(
					_user$project$Utils$mapFirstSuccess,
					function (_p257) {
						var _p258 = _p257;
						return _elm_lang$core$Native_Utils.eq(_p258._0, _p254._1) ? _elm_lang$core$Maybe$Just(_p258._1) : _elm_lang$core$Maybe$Nothing;
					},
					A2(_user$project$LangTools$tryMatchExpPatToPaths, _p256._0._0, _p256._0._1));
			}
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$LangTools$expToLetPatAndBoundExp = function (exp) {
	var _p259 = _user$project$LangTools$expToMaybeLetPatAndBoundExp(exp);
	if (_p259.ctor === 'Just') {
		return _p259._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1241, column: 3},
				end: {line: 1243, column: 103}
			},
			_p259)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetPatAndBoundExp exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToMaybeLetBoundExp = function (exp) {
	var _p261 = _user$project$Lang$unwrapExp(exp);
	if (_p261.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(
			A2(
				_elm_lang$core$List$map,
				function (_p262) {
					var _p263 = _p262;
					return _p263._5;
				},
				_user$project$Lang$elemsOf(_p261._2._3)));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$expToLetBoundExp = function (exp) {
	var _p264 = _user$project$LangTools$expToMaybeLetBoundExp(exp);
	if (_p264.ctor === 'Just') {
		return _p264._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1227, column: 3},
				end: {line: 1229, column: 103}
			},
			_p264)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetPat exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToMaybeLetPat = function (exp) {
	var _p266 = _user$project$Lang$unwrapExp(exp);
	if (_p266.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(
			A2(
				_elm_lang$core$List$map,
				function (_p267) {
					var _p268 = _p267;
					return _p268._2;
				},
				_user$project$Lang$elemsOf(_p266._2._3)));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$expToLetPat = function (exp) {
	var _p269 = _user$project$LangTools$expToMaybeLetPat(exp);
	if (_p269.ctor === 'Just') {
		return _p269._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1212, column: 3},
				end: {line: 1214, column: 97}
			},
			_p269)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetPat exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToLetKind = function (exp) {
	var _p271 = _user$project$Lang$unwrapExp(exp);
	if (_p271.ctor === 'ELet') {
		return _p271._1;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1205, column: 3},
				end: {line: 1207, column: 110}
			},
			_p271)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetKind exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToMaybeLetParts = function (exp) {
	var _p273 = _user$project$Lang$unwrapExp(exp);
	if (((((((_p273.ctor === 'ELet') && (_p273._2._3.ctor === '::')) && (_p273._2._3._0.ctor === '_Tuple2')) && (_p273._2._3._0._1.ctor === '::')) && (_p273._2._3._0._1._0._0.ctor === 'Nothing')) && (_p273._2._3._0._1._1.ctor === '[]')) && (_p273._2._3._1.ctor === '[]')) {
		return _elm_lang$core$Maybe$Just(
			{ctor: '_Tuple9', _0: _p273._0, _1: _p273._1, _2: _p273._2._3._0._1._0._1, _3: _p273._2._3._0._1._0._2, _4: _p273._2._3._0._1._0._3, _5: _p273._2._3._0._1._0._4, _6: _p273._2._3._0._1._0._5, _7: _p273._3, _8: _p273._4});
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$expToLetParts = function (exp) {
	var _p274 = _user$project$LangTools$expToMaybeLetParts(exp);
	if (_p274.ctor === 'Just') {
		return _p274._0;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1190, column: 3},
				end: {line: 1192, column: 99}
			},
			_p274)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToLetParts exp is not an ELet: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$expToListParts = function (exp) {
	var _p276 = _user$project$Lang$unwrapExp(exp);
	if (_p276.ctor === 'EList') {
		return {
			ctor: '_Tuple5',
			_0: _p276._0,
			_1: _user$project$Utils$listValues(_p276._1),
			_2: _p276._2,
			_3: _p276._3,
			_4: _p276._4
		};
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1181, column: 3},
				end: {line: 1183, column: 127}
			},
			_p276)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToListParts exp is not an EList: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$patToMaybePVarIdent = function (pat) {
	var _p278 = pat.val.p__;
	if (_p278.ctor === 'PVar') {
		return _elm_lang$core$Maybe$Just(_p278._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$patToMaybeIdent = function (pat) {
	patToMaybeIdent:
	while (true) {
		var _p279 = pat.val.p__;
		switch (_p279.ctor) {
			case 'PVar':
				return _elm_lang$core$Maybe$Just(_p279._1);
			case 'PAs':
				return A2(
					_user$project$Utils$maybeOrElseLazy,
					function (_p280) {
						return _user$project$LangTools$patToMaybeIdent(_p279._3);
					},
					_user$project$LangTools$patToMaybeIdent(_p279._1));
			case 'PParens':
				var _v122 = _p279._1;
				pat = _v122;
				continue patToMaybeIdent;
			case 'PColonType':
				var _v123 = _p279._1;
				pat = _v123;
				continue patToMaybeIdent;
			default:
				return _elm_lang$core$Maybe$Nothing;
		}
	}
};
var _user$project$LangTools$identPathsInPat = function (pat) {
	var childIdentPaths = A2(
		_user$project$Utils$concatMapi1,
		function (_p281) {
			var _p282 = _p281;
			return A2(
				_elm_lang$core$List$map,
				function (_p283) {
					var _p284 = _p283;
					return {
						ctor: '_Tuple2',
						_0: _p284._0,
						_1: {ctor: '::', _0: _p282._0, _1: _p284._1}
					};
				},
				_user$project$LangTools$identPathsInPat(_p282._1));
		},
		_user$project$Lang$childPats(pat));
	var _p285 = _user$project$LangTools$patToMaybeIdent(pat);
	if (_p285.ctor === 'Just') {
		return {
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: _p285._0,
				_1: {ctor: '[]'}
			},
			_1: childIdentPaths
		};
	} else {
		return childIdentPaths;
	}
};
var _user$project$LangTools$pathForIdentInPat = F2(
	function (targetIdent, pat) {
		return A2(
			_user$project$Utils$mapFirstSuccess,
			function (_p286) {
				var _p287 = _p286;
				return _elm_lang$core$Native_Utils.eq(_p287._0, targetIdent) ? _elm_lang$core$Maybe$Just(_p287._1) : _elm_lang$core$Maybe$Nothing;
			},
			_user$project$LangTools$identPathsInPat(pat));
	});
var _user$project$LangTools$bindingPathedPatternIdFor_ = F4(
	function (currentBindingPathedPatternId, targetName, predicateMap, exp) {
		var _p288 = A2(
			_elm_lang$core$Debug$log,
			'bindingPathedPatternIdFor_',
			{
				ctor: '_Tuple3',
				_0: currentBindingPathedPatternId,
				_1: targetName,
				_2: _user$project$Lang$expEId(exp)
			});
		var recurse = F2(
			function (pathedPatternId, e) {
				return A4(_user$project$LangTools$bindingPathedPatternIdFor_, pathedPatternId, targetName, predicateMap, e);
			});
		var maybeNewBindingForRecursion = F3(
			function (pat, branchI, pathPrefix) {
				return A2(
					_elm_lang$core$Maybe$map,
					function (path) {
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: {
									ctor: '_Tuple2',
									_0: _user$project$Lang$expEId(exp),
									_1: branchI
								},
								_1: A2(_elm_lang$core$Basics_ops['++'], pathPrefix, path)
							});
					},
					A2(_user$project$LangTools$pathForIdentInPat, targetName, pat));
			});
		var _p289 = A2(predicateMap, exp, currentBindingPathedPatternId);
		if (_p289.ctor === 'Just') {
			return _elm_lang$core$Maybe$Just(_p289._0);
		} else {
			var _p290 = _user$project$Lang$unwrapExp(exp);
			switch (_p290.ctor) {
				case 'EFun':
					var newBindingPathedPatternId = A2(
						_elm_lang$core$Maybe$withDefault,
						currentBindingPathedPatternId,
						A2(
							_user$project$Utils$mapFirstSuccess,
							function (_p291) {
								var _p292 = _p291;
								return A3(
									maybeNewBindingForRecursion,
									_p292._0,
									_p292._1,
									{ctor: '[]'});
							},
							_user$project$Utils$zipWithIndex(_p290._1)));
					return A2(recurse, newBindingPathedPatternId, _p290._2);
				case 'ELet':
					var aux = F4(
						function (bn, currentBindingPathedPatternId, newBindingPathedPatternId, groups) {
							aux:
							while (true) {
								var _p293 = groups;
								_v131_2:
								do {
									if ((_p293.ctor === '::') && (_p293._0.ctor === '_Tuple2')) {
										if (_p293._0._1.ctor === '[]') {
											if ((_p293._1.ctor === '::') && (_p293._1._0.ctor === '_Tuple2')) {
												var nextBindingPathedPatternId = A3(
													_user$project$Utils$foldLeft,
													newBindingPathedPatternId,
													_p293._1._0._1,
													F2(
														function (currentBindingPathedPatternId, _p294) {
															var _p295 = _p294;
															return A2(
																_elm_lang$core$Maybe$withDefault,
																currentBindingPathedPatternId,
																A3(
																	maybeNewBindingForRecursion,
																	_p295._2,
																	bn,
																	{ctor: '[]'}));
														}));
												var _v133 = bn + 1,
													_v134 = newBindingPathedPatternId,
													_v135 = nextBindingPathedPatternId,
													_v136 = {ctor: '::', _0: _p293._1._0, _1: _p293._1._1};
												bn = _v133;
												currentBindingPathedPatternId = _v134;
												newBindingPathedPatternId = _v135;
												groups = _v136;
												continue aux;
											} else {
												break _v131_2;
											}
										} else {
											var _p298 = _p293._0._0;
											var pathedPatternIdForBoundExp = _p298 ? newBindingPathedPatternId : currentBindingPathedPatternId;
											return A2(
												_user$project$Utils$firstOrLazySecond,
												A2(recurse, pathedPatternIdForBoundExp, _p293._0._1._0._5),
												function (_p296) {
													var _p297 = _p296;
													return A4(
														aux,
														bn + 1,
														currentBindingPathedPatternId,
														newBindingPathedPatternId,
														{
															ctor: '::',
															_0: {ctor: '_Tuple2', _0: _p298, _1: _p293._0._1._1},
															_1: _p293._1
														});
												});
										}
									} else {
										break _v131_2;
									}
								} while(false);
								return A2(recurse, newBindingPathedPatternId, _p290._4);
							}
						});
					return A4(
						aux,
						_user$project$Lang$startBindingNumLetExp(_p290._2),
						currentBindingPathedPatternId,
						currentBindingPathedPatternId,
						{
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: false,
								_1: {ctor: '[]'}
							},
							_1: _p290._2._3
						});
				case 'ECase':
					return A2(
						_user$project$Utils$mapFirstSuccess,
						function (_p299) {
							var _p300 = _p299;
							var newBindingPathedPatternId = A2(
								_elm_lang$core$Maybe$withDefault,
								currentBindingPathedPatternId,
								A3(
									maybeNewBindingForRecursion,
									_p300._0._0,
									_p300._1,
									{ctor: '[]'}));
							return A2(recurse, newBindingPathedPatternId, _p300._0._1);
						},
						_user$project$Utils$zipWithIndex(
							_user$project$Lang$branchPatExps(_p290._2)));
				default:
					return A2(
						_user$project$Utils$mapFirstSuccess,
						recurse(currentBindingPathedPatternId),
						_user$project$Lang$childExps(exp));
			}
		}
	});
var _user$project$LangTools$bindingPathedPatternIdForIdentAtEId = F3(
	function (targetName, targetEId, program) {
		var predMap = F2(
			function (exp, maybeCurrentBindingPathedPatternId) {
				var _p301 = _user$project$Lang$unwrapExp(exp);
				if (_p301.ctor === 'EVar') {
					return _elm_lang$core$Native_Utils.eq(
						_user$project$Lang$expEId(exp),
						targetEId) ? _elm_lang$core$Maybe$Just(maybeCurrentBindingPathedPatternId) : _elm_lang$core$Maybe$Nothing;
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			});
		return A2(
			_elm_lang$core$Maybe$withDefault,
			_elm_lang$core$Maybe$Nothing,
			A4(_user$project$LangTools$bindingPathedPatternIdFor_, _elm_lang$core$Maybe$Nothing, targetName, predMap, program));
	});
var _user$project$LangTools$bindingScopeIdForIdentAtEId = F3(
	function (targetName, targetEId, program) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p302) {
				var _p303 = _p302;
				return _p303._0;
			},
			A3(_user$project$LangTools$bindingPathedPatternIdForIdentAtEId, targetName, targetEId, program));
	});
var _user$project$LangTools$bindingPathedPatternIdForUniqueName = F2(
	function (targetName, program) {
		var predMap = F2(
			function (e, maybeCurrentBindingPathedPatternId) {
				return maybeCurrentBindingPathedPatternId;
			});
		return A4(_user$project$LangTools$bindingPathedPatternIdFor_, _elm_lang$core$Maybe$Nothing, targetName, predMap, program);
	});
var _user$project$LangTools$identPatsInPat = function (pat) {
	return A2(
		_elm_lang$core$List$filterMap,
		function (p) {
			var _p304 = _user$project$LangTools$patToMaybeIdent(p);
			if (_p304.ctor === 'Just') {
				return _elm_lang$core$Maybe$Just(
					{ctor: '_Tuple2', _0: _p304._0, _1: p});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		_user$project$Lang$flattenPatTree(pat));
};
var _user$project$LangTools$identPIdsInPat = function (pat) {
	return A2(
		_elm_lang$core$List$map,
		function (_p305) {
			var _p306 = _p305;
			return {ctor: '_Tuple2', _0: _p306._0, _1: _p306._1.val.pid};
		},
		_user$project$LangTools$identPatsInPat(pat));
};
var _user$project$LangTools$allVarEIdsToBindingPatList = function (program) {
	var handleCaseBranch = F4(
		function (caseExp, branch, branchI, identToPId) {
			return A2(
				_elm_lang$core$Dict$union,
				_elm_lang$core$Dict$fromList(
					_user$project$LangTools$identPatsInPat(
						_user$project$Lang$branchPat(branch))),
				identToPId);
		});
	var handleEFun = F2(
		function (funcExp, identToPId) {
			return A2(
				_elm_lang$core$Dict$union,
				_elm_lang$core$Dict$fromList(
					A2(
						_elm_lang$core$List$concatMap,
						_user$project$LangTools$identPatsInPat,
						_user$project$LangTools$expToFuncPats(funcExp))),
				identToPId);
		});
	var handleELet = F6(
		function (_p308, isRec, letExpGroup, _p307, globalAcc, identToPId) {
			return {
				ctor: '_Tuple2',
				_0: globalAcc,
				_1: A2(
					_elm_lang$core$Dict$union,
					_elm_lang$core$Dict$fromList(
						A2(
							_elm_lang$core$List$concatMap,
							_user$project$LangTools$identPatsInPat,
							A2(_elm_lang$core$List$map, _user$project$Lang$patOfLetExp, letExpGroup))),
					identToPId)
			};
		});
	return A7(
		_user$project$Lang$foldExpTopDownWithScope,
		F3(
			function (exp, eidAndMaybePId, identToPId) {
				var _p309 = _user$project$Lang$expToMaybeIdent(exp);
				if (_p309.ctor === 'Just') {
					return {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: _user$project$Lang$expEId(exp),
							_1: A2(_elm_lang$core$Dict$get, _p309._0, identToPId)
						},
						_1: eidAndMaybePId
					};
				} else {
					return eidAndMaybePId;
				}
			}),
		handleELet,
		handleEFun,
		handleCaseBranch,
		{ctor: '[]'},
		_elm_lang$core$Dict$empty,
		program);
};
var _user$project$LangTools$allVarEIdsToBindingPat = function (program) {
	return _elm_lang$core$Dict$fromList(
		_user$project$LangTools$allVarEIdsToBindingPatList(program));
};
var _user$project$LangTools$allVarEIdsToBindingPId = function (program) {
	return A2(
		_elm_lang$core$Dict$map,
		F2(
			function (_p310, maybePat) {
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p311) {
						return function (_) {
							return _.pid;
						}(
							function (_) {
								return _.val;
							}(_p311));
					},
					maybePat);
			}),
		_user$project$LangTools$allVarEIdsToBindingPat(program));
};
var _user$project$LangTools$allVarEIdsToBindingPIdList = function (program) {
	return A2(
		_elm_lang$core$List$map,
		function (_p312) {
			var _p313 = _p312;
			return {
				ctor: '_Tuple2',
				_0: _p313._0,
				_1: A2(
					_elm_lang$core$Maybe$map,
					function (_p314) {
						return function (_) {
							return _.pid;
						}(
							function (_) {
								return _.val;
							}(_p314));
					},
					_p313._1)
			};
		},
		_user$project$LangTools$allVarEIdsToBindingPatList(program));
};
var _user$project$LangTools$allVarEIdsToBindingPatsBasedOnUniqueName = function (program) {
	var allIdentToPat = _elm_lang$core$Dict$fromList(
		A2(
			_elm_lang$core$List$concatMap,
			function (exp) {
				var _p315 = _user$project$Lang$unwrapExp(exp);
				switch (_p315.ctor) {
					case 'EFun':
						return A2(_elm_lang$core$List$concatMap, _user$project$LangTools$identPatsInPat, _p315._1);
					case 'ELet':
						return A2(
							_elm_lang$core$List$concatMap,
							function (_p316) {
								var _p317 = _p316;
								return _user$project$LangTools$identPatsInPat(_p317._2);
							},
							_user$project$Lang$elemsOf(_p315._2._3));
					case 'ECase':
						return A2(
							_elm_lang$core$List$concatMap,
							_user$project$LangTools$identPatsInPat,
							_user$project$Lang$branchPats(_p315._2));
					default:
						return {ctor: '[]'};
				}
			},
			_user$project$Lang$flattenExpTree(program)));
	return _elm_lang$core$Dict$fromList(
		A2(
			_elm_lang$core$List$filterMap,
			function (exp) {
				var _p318 = _user$project$Lang$expToMaybeIdent(exp);
				if (_p318.ctor === 'Nothing') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					var _p319 = A2(_elm_lang$core$Dict$get, _p318._0, allIdentToPat);
					if (_p319.ctor === 'Nothing') {
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: _user$project$Lang$expEId(exp),
								_1: _elm_lang$core$Maybe$Nothing
							});
					} else {
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: _user$project$Lang$expEId(exp),
								_1: _elm_lang$core$Maybe$Just(_p319._0)
							});
					}
				}
			},
			_user$project$Lang$flattenExpTree(program)));
};
var _user$project$LangTools$allVarEIdsToBindingPIdBasedOnUniqueName = function (program) {
	return A2(
		_elm_lang$core$Dict$map,
		F2(
			function (_p320, maybePat) {
				return A2(
					_elm_lang$core$Maybe$map,
					function (_p321) {
						return function (_) {
							return _.pid;
						}(
							function (_) {
								return _.val;
							}(_p321));
					},
					maybePat);
			}),
		_user$project$LangTools$allVarEIdsToBindingPatsBasedOnUniqueName(program));
};
var _user$project$LangTools$expToIdent = function (exp) {
	var _p322 = _user$project$Lang$unwrapExp(exp);
	if (_p322.ctor === 'EVar') {
		return _p322._1;
	} else {
		return _elm_lang$core$Native_Utils.crashCase(
			'LangTools',
			{
				start: {line: 1157, column: 3},
				end: {line: 1159, column: 101}
			},
			_p322)(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'LangTools.expToIdent exp is not an EVar: ',
				_user$project$LangUnparser$unparseWithIds(exp)));
	}
};
var _user$project$LangTools$identifierUses = F2(
	function (ident, exp) {
		return A2(
			_elm_lang$core$List$filter,
			function (_p324) {
				return A2(
					F2(
						function (x, y) {
							return _elm_lang$core$Native_Utils.eq(x, y);
						}),
					ident,
					_user$project$LangTools$expToIdent(_p324));
			},
			_user$project$Lang$freeVars(exp));
	});
var _user$project$LangTools$identifierUsageEIds = F2(
	function (ident, exp) {
		return A2(
			_elm_lang$core$List$map,
			_user$project$Lang$expEId,
			A2(_user$project$LangTools$identifierUses, ident, exp));
	});
var _user$project$LangTools$identifierUsesAfterDefiningPat = F2(
	function (ident, exp) {
		return A2(
			_elm_lang$core$List$concatMap,
			function (scopeAreaExp) {
				return A2(_user$project$LangTools$identifierUses, ident, scopeAreaExp);
			},
			A2(_user$project$LangTools$findScopeAreasByIdent, ident, exp));
	});
var _user$project$LangTools$identifierSetUses = F2(
	function (identSet, exp) {
		return A2(
			_elm_lang$core$List$filter,
			function (varExp) {
				return A2(
					_elm_lang$core$Set$member,
					_user$project$LangTools$expToIdent(varExp),
					identSet);
			},
			_user$project$Lang$freeVars(exp));
	});
var _user$project$LangTools$bindingPathedPatternIdFor = F2(
	function (varExp, program) {
		var targetName = _user$project$LangTools$expToIdent(varExp);
		var targetEId = _user$project$Lang$expEId(varExp);
		return A3(_user$project$LangTools$bindingPathedPatternIdForIdentAtEId, targetName, targetEId, program);
	});
var _user$project$LangTools$bindingScopeIdFor = F2(
	function (varExp, program) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p325) {
				var _p326 = _p325;
				return _p326._0;
			},
			A2(_user$project$LangTools$bindingPathedPatternIdFor, varExp, program));
	});
var _user$project$LangTools$expToMaybeVar = function (exp) {
	var _p327 = _user$project$Lang$unwrapExp(exp);
	if (_p327.ctor === 'EVar') {
		return _elm_lang$core$Maybe$Just(exp);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$allVars = function (root) {
	return A2(
		_elm_lang$core$List$filterMap,
		_user$project$LangTools$expToMaybeVar,
		_user$project$Lang$flattenExpTree(root));
};
var _user$project$LangTools$expToMaybeNum = function (exp) {
	var _p328 = _user$project$Lang$unwrapExp(exp);
	if (_p328.ctor === 'EConst') {
		return _elm_lang$core$Maybe$Just(_p328._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$performActionIfBody = F5(
	function (root, e, action, actionForRoot, $default) {
		var eId = _user$project$Lang$expEId(e);
		var _p329 = A2(_user$project$Lang$parentByEId, root, eId);
		if (_p329.ctor === 'Just') {
			if (_p329._0.ctor === 'Just') {
				var _p332 = _p329._0._0;
				var $return = F2(
					function (bodies, mbBranch) {
						return A2(
							_elm_lang$core$List$member,
							eId,
							A2(_elm_lang$core$List$map, _user$project$Lang$expEId, bodies)) ? A3(action, e, _p332, mbBranch) : $default;
					});
				var _p330 = _user$project$Lang$unwrapExp(_p332);
				switch (_p330.ctor) {
					case 'EFun':
						return A2(
							$return,
							{
								ctor: '::',
								_0: _p330._2,
								_1: {ctor: '[]'}
							},
							_elm_lang$core$Maybe$Nothing);
					case 'EIf':
						return A2(
							$return,
							{
								ctor: '::',
								_0: _p330._3,
								_1: {
									ctor: '::',
									_0: _p330._5,
									_1: {ctor: '[]'}
								}
							},
							_elm_lang$core$Maybe$Nothing);
					case 'ECase':
						var mbBranch = A2(
							_user$project$Utils$mapFirstSuccess,
							function (branch) {
								return _elm_lang$core$Native_Utils.eq(
									eId,
									_user$project$Lang$expEId(
										_user$project$Lang$branchExp(branch))) ? _elm_lang$core$Maybe$Just(branch) : _elm_lang$core$Maybe$Nothing;
							},
							_p330._2);
						var _p331 = mbBranch;
						if (_p331.ctor === 'Nothing') {
							return $default;
						} else {
							return A3(action, e, _p332, mbBranch);
						}
					case 'ELet':
						return A2(
							$return,
							{
								ctor: '::',
								_0: _p330._4,
								_1: {ctor: '[]'}
							},
							_elm_lang$core$Maybe$Nothing);
					default:
						return $default;
				}
			} else {
				return actionForRoot(root);
			}
		} else {
			return $default;
		}
	});
var _user$project$LangTools$deepestCommonAncestorWithNewlineOrELet = F2(
	function (program, pred) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			program,
			A2(
				_user$project$Utils$findFirst,
				function (e) {
					return A2(
						_elm_lang$core$String$contains,
						'\n',
						_user$project$Lang$precedingWhitespace(e)) || (!_elm_lang$core$Native_Utils.eq(
						_user$project$Lang$eLetUnapply(e),
						_elm_lang$core$Maybe$Nothing));
				},
				_elm_lang$core$List$reverse(
					A2(_user$project$Lang$commonAncestors, pred, program))));
	});
var _user$project$LangTools$scopeNamesLocLiftedThrough_ = F3(
	function (targetLocId, scopeNames, exp) {
		var _p333 = _user$project$Lang$unwrapExp(exp);
		_v156_2:
		do {
			switch (_p333.ctor) {
				case 'ELet':
					if ((((((_p333._2._2.ctor === '[]') && (_p333._2._3.ctor === '::')) && (_p333._2._3._0.ctor === '_Tuple2')) && (_p333._2._3._0._1.ctor === '::')) && (_p333._2._3._0._1._1.ctor === '[]')) && (_p333._2._3._1.ctor === '[]')) {
						var scopeNames__ = function (pat) {
							var _p334 = pat.val.p__;
							switch (_p334.ctor) {
								case 'PVar':
									return {
										ctor: '::',
										_0: _p334._1,
										_1: {ctor: '[]'}
									};
								case 'PAs':
									return A2(
										_elm_lang$core$Basics_ops['++'],
										scopeNames__(_p334._1),
										scopeNames__(_p334._3));
								default:
									return {ctor: '[]'};
							}
						};
						var scopeNames_ = A2(
							_elm_lang$core$Basics_ops['++'],
							scopeNames,
							scopeNames__(_p333._2._3._0._1._0._2));
						return _user$project$Utils$firstMaybe(
							{
								ctor: '::',
								_0: A3(_user$project$LangTools$scopeNamesLocLiftedThrough_, targetLocId, scopeNames_, _p333._2._3._0._1._0._5),
								_1: {
									ctor: '::',
									_0: A3(_user$project$LangTools$scopeNamesLocLiftedThrough_, targetLocId, scopeNames, _p333._4),
									_1: {ctor: '[]'}
								}
							});
					} else {
						break _v156_2;
					}
				case 'EConst':
					if (_p333._2.ctor === '_Tuple3') {
						return _elm_lang$core$Native_Utils.eq(_p333._2._0, targetLocId) ? _elm_lang$core$Maybe$Just(scopeNames) : _elm_lang$core$Maybe$Nothing;
					} else {
						break _v156_2;
					}
				default:
					break _v156_2;
			}
		} while(false);
		var recurse = function (exp) {
			return A3(_user$project$LangTools$scopeNamesLocLiftedThrough_, targetLocId, scopeNames, exp);
		};
		return A2(
			_user$project$Utils$mapFirstSuccess,
			recurse,
			_user$project$Lang$childExps(exp));
	});
var _user$project$LangTools$scopeNamesLocLiftedThrough = F2(
	function (newLetBody, targetLoc) {
		var _p335 = targetLoc;
		var targetLocId = _p335._0;
		var ident = _p335._2;
		var _p336 = A3(
			_user$project$LangTools$scopeNamesLocLiftedThrough_,
			targetLocId,
			{ctor: '[]'},
			newLetBody);
		if (_p336.ctor === 'Nothing') {
			return {ctor: '[]'};
		} else {
			var _p337 = _p336._0;
			return _elm_lang$core$Native_Utils.eq(
				_user$project$Utils$maybeLast(_p337),
				_elm_lang$core$Maybe$Just(ident)) ? _user$project$Utils$removeLastElement(_p337) : _p337;
		}
	});
var _user$project$LangTools$leadingCapitals = _elm_lang$core$Regex$regex('^[A-Z]+');
var _user$project$LangTools$downcaseLeadingCapitals = function (string) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$AtMost(1),
		_user$project$LangTools$leadingCapitals,
		function (_p338) {
			var _p339 = _p338;
			return _elm_lang$core$String$toLower(_p339.match);
		},
		string);
};
var _user$project$LangTools$trailingDigits = _elm_lang$core$Regex$regex('[0-9]+$');
var _user$project$LangTools$removeTrailingDigits = function (string) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$AtMost(1),
		_user$project$LangTools$trailingDigits,
		function (_p340) {
			return '';
		},
		string);
};
var _user$project$LangTools$leadingDigits = _elm_lang$core$Regex$regex('^[0-9]+');
var _user$project$LangTools$removeLeadingDigits = function (string) {
	return A4(
		_elm_lang$core$Regex$replace,
		_elm_lang$core$Regex$AtMost(1),
		_user$project$LangTools$leadingDigits,
		function (_p341) {
			return '';
		},
		string);
};
var _user$project$LangTools$renamePatVar = F3(
	function (oldName, newName, pat) {
		return A2(
			_user$project$Lang$mapPat,
			function (p) {
				var _p342 = p.val.p__;
				if (_p342.ctor === 'PVar') {
					return _elm_lang$core$Native_Utils.eq(_p342._1, oldName) ? A2(
						_user$project$Lang$replaceP__,
						p,
						A3(_user$project$Lang$PVar, _p342._0, newName, _p342._2)) : p;
				} else {
					return p;
				}
			},
			pat);
	});
var _user$project$LangTools$simpleExpNameWithDefault = F2(
	function ($default, exp) {
		var _p343 = _user$project$Lang$unwrapExp(
			_user$project$Lang$expEffectiveExp(exp));
		switch (_p343.ctor) {
			case 'EConst':
				return 'num';
			case 'EVar':
				return _p343._1;
			case 'EApp':
				return A2(
					_elm_lang$core$Maybe$withDefault,
					$default,
					_user$project$Lang$expToMaybeIdent(_p343._1));
			case 'EList':
				return 'list';
			case 'ERecord':
				return 'record';
			case 'EOp':
				return A2(
					_elm_lang$core$Maybe$withDefault,
					$default,
					A2(
						_user$project$Utils$findFirst,
						F2(
							function (x, y) {
								return !_elm_lang$core$Native_Utils.eq(x, y);
							})($default),
						A2(
							_elm_lang$core$List$map,
							_user$project$LangTools$simpleExpNameWithDefault($default),
							_p343._3)));
			case 'EBase':
				switch (_p343._1.ctor) {
					case 'ENull':
						return 'null';
					case 'EString':
						return 'string';
					default:
						return 'bool';
				}
			case 'EFun':
				return 'func';
			case 'EHole':
				return 'hole';
			default:
				return $default;
		}
	});
var _user$project$LangTools$defaultExpName = 'thing';
var _user$project$LangTools$simpleExpName = function (exp) {
	return A2(_user$project$LangTools$simpleExpNameWithDefault, _user$project$LangTools$defaultExpName, exp);
};
var _user$project$LangTools$locDescriptionParts = F2(
	function (program, loc) {
		var _p344 = loc;
		var locId = _p344._0;
		var ident = _p344._2;
		var baseIdent = _elm_lang$core$Native_Utils.eq(ident, '') ? A2(
			_elm_lang$core$Basics_ops['++'],
			'k',
			_elm_lang$core$Basics$toString(locId)) : ident;
		var scopeNamesLiftedThrough = A2(_user$project$LangTools$scopeNamesLocLiftedThrough, program, loc);
		return A2(
			_elm_lang$core$Basics_ops['++'],
			scopeNamesLiftedThrough,
			{
				ctor: '::',
				_0: baseIdent,
				_1: {ctor: '[]'}
			});
	});
var _user$project$LangTools$locDescription = F2(
	function (program, loc) {
		return A2(
			_elm_lang$core$String$join,
			' ',
			A2(_user$project$LangTools$locDescriptionParts, program, loc));
	});
var _user$project$LangTools$getProperIndentationIfBody = F2(
	function (root, e) {
		var indentationAtParent = F3(
			function (e, parent, mbBranch) {
				return _elm_lang$core$Maybe$Just(
					function () {
						var _p345 = {
							ctor: '_Tuple2',
							_0: _user$project$Lang$unwrapExp(parent),
							_1: mbBranch
						};
						_v162_2:
						do {
							if (_p345.ctor === '_Tuple2') {
								if (_p345._0.ctor === 'ELet') {
									return A2(
										_user$project$Lang$indentationAt,
										_user$project$Lang$expEId(parent),
										root);
								} else {
									if (_p345._1.ctor === 'Just') {
										return A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Lang$indentationOfBranch(_p345._1._0),
											'  ');
									} else {
										break _v162_2;
									}
								}
							} else {
								break _v162_2;
							}
						} while(false);
						return A2(
							_elm_lang$core$Basics_ops['++'],
							A2(
								_user$project$Lang$indentationAt,
								_user$project$Lang$expEId(parent),
								root),
							'  ');
					}());
			});
		var eId = _user$project$Lang$expEId(e);
		return A5(
			_user$project$LangTools$performActionIfBody,
			root,
			e,
			indentationAtParent,
			_elm_lang$core$Basics$always(_elm_lang$core$Maybe$Nothing),
			_elm_lang$core$Maybe$Nothing);
	});
var _user$project$LangTools$reflowLetWhitespace = F2(
	function (program, letExp) {
		var _p346 = A2(
			_elm_lang$core$Debug$log,
			'Please update LangTools.reflowLetWhitespace to execute this command',
			{ctor: '_Tuple0'});
		return letExp;
	});
var _user$project$LangTools$longLineLength = 50;
var _user$project$LangTools$copyListWhitespace = F2(
	function (templateList, list) {
		var _p347 = {
			ctor: '_Tuple2',
			_0: _user$project$Lang$unwrapExp(templateList),
			_1: _user$project$Lang$unwrapExp(list)
		};
		if (((_p347.ctor === '_Tuple2') && (_p347._0.ctor === 'EList')) && (_p347._1.ctor === 'EList')) {
			return A2(
				_user$project$Lang$replaceE__,
				list,
				A5(_user$project$Lang$EList, _p347._0._0, _p347._1._1, _p347._0._2, _p347._1._3, _p347._0._4));
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'LangTools',
				{
					start: {line: 400, column: 3},
					end: {line: 405, column: 131}
				},
				_p347)(
				A2(
					_elm_lang$core$Basics_ops['++'],
					'Lang.copyListWs expected lists, but given ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_user$project$LangUnparser$unparseWithIds(templateList),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' and ',
							_user$project$LangUnparser$unparseWithIds(list)))));
		}
	});
var _user$project$LangTools$outerSameValueExp = F2(
	function (program, targetExp) {
		var targetEId = _user$project$Lang$expEId(
			_user$project$Lang$expEffectiveExp(targetExp));
		return A2(
			_elm_lang$core$Maybe$withDefault,
			targetExp,
			A2(
				_user$project$Lang$findFirstNode,
				function (_p349) {
					return function (exp) {
						return _elm_lang$core$Native_Utils.eq(
							_user$project$Lang$expEId(exp),
							targetEId);
					}(
						_user$project$Lang$expEffectiveExp(_p349));
				},
				program));
	});
var _user$project$LangTools$lastExp = function (exp) {
	lastExp:
	while (true) {
		var _p350 = _elm_lang$core$List$reverse(
			_user$project$Lang$childExps(exp));
		if (_p350.ctor === '[]') {
			return exp;
		} else {
			var _v165 = _p350._0;
			exp = _v165;
			continue lastExp;
		}
	}
};
var _user$project$LangTools$maybeTopLevelChild = function (exp) {
	var _p351 = _user$project$Lang$unwrapExp(exp);
	if (_p351.ctor === 'ELet') {
		return _elm_lang$core$Maybe$Just(_p351._4);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _user$project$LangTools$topLevelExps = function (program) {
	var _p352 = _user$project$LangTools$maybeTopLevelChild(program);
	if (_p352.ctor === 'Just') {
		return {
			ctor: '::',
			_0: program,
			_1: _user$project$LangTools$topLevelExps(_p352._0)
		};
	} else {
		return {
			ctor: '::',
			_0: program,
			_1: {ctor: '[]'}
		};
	}
};
var _user$project$LangTools$lastTopLevelExp = function (exp) {
	return A2(
		_elm_lang$core$Maybe$withDefault,
		exp,
		A2(
			_elm_lang$core$Maybe$map,
			_user$project$LangTools$lastTopLevelExp,
			_user$project$LangTools$maybeTopLevelChild(exp)));
};
var _user$project$LangTools$isTopLevelEId = F2(
	function (eid, program) {
		isTopLevelEId:
		while (true) {
			if (_elm_lang$core$Native_Utils.eq(
				eid,
				_user$project$Lang$expEId(program))) {
				return true;
			} else {
				var _p353 = _user$project$LangTools$maybeTopLevelChild(program);
				if (_p353.ctor === 'Just') {
					var _v169 = eid,
						_v170 = _p353._0;
					eid = _v169;
					program = _v170;
					continue isTopLevelEId;
				} else {
					return false;
				}
			}
		}
	});
var _user$project$LangTools$newLetFancyWhitespace = F6(
	function (insertedLetEId, isRec, pat, boundExp, expToWrap, program) {
		var toWrapEId = _user$project$Lang$expEId(expToWrap);
		var isTopLevel = A2(_user$project$LangTools$isTopLevelEId, toWrapEId, program);
		var letOrDef = isTopLevel ? _user$project$Lang$Def : _user$project$Lang$Let;
		var newLetIndentation = A2(
			_elm_lang$core$Maybe$withDefault,
			A2(_user$project$Lang$indentationAt, toWrapEId, program),
			A2(_user$project$LangTools$getProperIndentationIfBody, program, expToWrap));
		var newlineCountAfterLet = function () {
			var newlinesBeforeWrapped = _user$project$Lang$newlineCount(
				_user$project$Lang$precedingWhitespace(expToWrap));
			return (isTopLevel || (_elm_lang$core$Native_Utils.cmp(newlinesBeforeWrapped, 2) > -1)) ? 2 : 1;
		}();
		var newlineCountBeforeLet = _elm_lang$core$Native_Utils.eq(
			toWrapEId,
			_user$project$Lang$expEId(program)) ? 1 : newlineCountAfterLet;
		var expToWrapWithNewWs = function () {
			var wrappedExpIndent = (_user$project$Lang$isLet(expToWrap) || isTopLevel) ? '' : '  ';
			return (_user$project$Lang$patHasNewlines(pat) || _user$project$Lang$expHasNewlines(boundExp)) ? A2(
				_user$project$Lang$replaceIndentation,
				wrappedExpIndent,
				A2(_user$project$Lang$ensureWhitespaceNNewlinesExp, newlineCountAfterLet, expToWrap)) : A3(_user$project$Lang$ensureWhitespaceSmartExp, newlineCountAfterLet, wrappedExpIndent, expToWrap);
		}();
		return A2(
			_user$project$Lang$indentExp,
			newLetIndentation,
			A2(
				_user$project$Lang$replacePrecedingWhitespace,
				A2(_elm_lang$core$String$repeat, newlineCountBeforeLet, '\n'),
				_user$project$Lang$Expr(
					A2(
						_user$project$Lang$withDummyExpInfoEId,
						insertedLetEId,
						A9(
							_user$project$Lang$eLet__,
							_user$project$Lang$space0,
							letOrDef,
							isRec,
							(isTopLevel ? _user$project$Lang$ensureNoWhitespacePat : _user$project$Lang$ensureWhitespacePat)(pat),
							_user$project$Lang$space1,
							_user$project$Lang$ensureWhitespaceExp(
								A2(_user$project$Lang$replaceIndentation, '  ', boundExp)),
							_user$project$Lang$space1,
							expToWrapWithNewWs,
							_user$project$Lang$space0)))));
	});
var _user$project$LangTools$wrapWithLets = F3(
	function (listOfListsOfNamesAndAssigns, eidToWrap, program) {
		var nonEmptyListOfListsOfNamesAndAssigns = A2(
			_elm_lang$core$List$filter,
			function (_p354) {
				return !_elm_lang$core$List$isEmpty(_p354);
			},
			listOfListsOfNamesAndAssigns);
		return A3(
			_elm_lang$core$List$foldr,
			F2(
				function (letNamesAndAssigns, program) {
					var _p355 = _user$project$Lang$patBoundExpOf(letNamesAndAssigns);
					var pat = _p355._0;
					var boundExp = _p355._1;
					return A3(
						_user$project$Lang$mapExpNode,
						eidToWrap,
						function (expToWrap) {
							return A6(_user$project$LangTools$newLetFancyWhitespace, -1, false, pat, boundExp, expToWrap, program);
						},
						program);
				}),
			program,
			nonEmptyListOfListsOfNamesAndAssigns);
	});
var _user$project$LangTools$addFirstDef = F3(
	function (program, pat, boundExp) {
		return A3(
			_user$project$Lang$mapExpNode,
			_user$project$Lang$expEId(program),
			function (nonComment) {
				return A6(_user$project$LangTools$newLetFancyWhitespace, -1, false, pat, boundExp, nonComment, program);
			},
			program);
	});
var _user$project$LangTools$isTopLevel = F2(
	function (exp, program) {
		isTopLevel:
		while (true) {
			if (_elm_lang$core$Native_Utils.eq(exp, program)) {
				return true;
			} else {
				var _p356 = _user$project$LangTools$maybeTopLevelChild(program);
				if (_p356.ctor === 'Just') {
					var _v172 = exp,
						_v173 = _p356._0;
					exp = _v172;
					program = _v173;
					continue isTopLevel;
				} else {
					return false;
				}
			}
		}
	});
var _user$project$LangTools$expToLocation = function (_p357) {
	var _p358 = _p357;
	var _p359 = _p358._0;
	return {ctor: '_Tuple2', _0: _p359.start.line, _1: _p359.start.col};
};
var _user$project$LangTools$justFindExpWithAncestorsByEId = F2(
	function (root, eid) {
		return A2(
			_user$project$Utils$fromJust__,
			function (_p360) {
				var _p361 = _p360;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'justFindExpWithAncestorsByEId: Couldn\'t find eid ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(eid),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' in ',
							_user$project$LangUnparser$unparseWithIds(root))));
			},
			A2(_user$project$Lang$findWithAncestorsByEId, root, eid));
	});
var _user$project$LangTools$deepestAncestorWithNewline = F2(
	function (program, eid) {
		var ancestors = A2(
			_user$project$Utils$dropLast,
			1,
			A2(_user$project$LangTools$justFindExpWithAncestorsByEId, program, eid));
		var ancestorsWithNewlines = A2(
			_elm_lang$core$List$filter,
			function (_p362) {
				return A2(
					_elm_lang$core$String$contains,
					'\n',
					_user$project$Lang$precedingWhitespace(_p362));
			},
			ancestors);
		return _user$project$Utils$last_(
			{ctor: '::', _0: program, _1: ancestorsWithNewlines});
	});
var _user$project$LangTools$justFindExpByEId = F2(
	function (exp, eid) {
		return A2(
			_user$project$Utils$fromJust__,
			function (_p363) {
				var _p364 = _p363;
				return A2(
					_elm_lang$core$Basics_ops['++'],
					'Couldn\'t find eid ',
					A2(
						_elm_lang$core$Basics_ops['++'],
						_elm_lang$core$Basics$toString(eid),
						A2(
							_elm_lang$core$Basics_ops['++'],
							' in ',
							_user$project$LangUnparser$unparseWithIds(exp))));
			},
			A2(_user$project$Lang$findExpByEId, exp, eid));
	});
var _user$project$LangTools$locationInProgram = F2(
	function (program, eid) {
		return _user$project$LangTools$expToLocation(
			A2(_user$project$LangTools$justFindExpByEId, program, eid));
	});
var _user$project$LangTools$outerSameValueExpByEId = F2(
	function (program, targetEId) {
		return A2(
			_user$project$LangTools$outerSameValueExp,
			program,
			A2(_user$project$LangTools$justFindExpByEId, program, targetEId));
	});
var _user$project$LangTools$allLocsAndNumbers = function (exp) {
	return A3(
		_user$project$Lang$foldExpViaE__,
		F2(
			function (e__, acc) {
				var _p365 = e__;
				if (_p365.ctor === 'EConst') {
					return {
						ctor: '::',
						_0: {ctor: '_Tuple2', _0: _p365._2, _1: _p365._1},
						_1: acc
					};
				} else {
					return acc;
				}
			}),
		{ctor: '[]'},
		exp);
};
var _user$project$LangTools$allLocIds = function (exp) {
	return A2(
		_elm_lang$core$List$map,
		function (_p366) {
			var _p367 = _p366;
			return _p367._0._0;
		},
		_user$project$LangTools$allLocsAndNumbers(exp));
};
var _user$project$LangTools$frozenLocIdsAndNumbers = function (exp) {
	return A2(
		_elm_lang$core$List$map,
		function (_p368) {
			var _p369 = _p368;
			return {ctor: '_Tuple2', _0: _p369._0._0, _1: _p369._1};
		},
		A2(
			_elm_lang$core$List$filter,
			function (_p370) {
				var _p371 = _p370;
				return _elm_lang$core$Native_Utils.eq(_p371._0._1, '!') || _user$project$LeoParser$isPreludeLocId(_p371._0._0);
			},
			_user$project$LangTools$allLocsAndNumbers(exp)));
};
var _user$project$LangTools$unfrozenLocIdsAndNumbers = function (exp) {
	return A2(
		_elm_lang$core$List$map,
		function (_p372) {
			var _p373 = _p372;
			return {ctor: '_Tuple2', _0: _p373._0._0, _1: _p373._1};
		},
		A2(
			_elm_lang$core$List$filter,
			function (_p374) {
				var _p375 = _p374;
				return (!_elm_lang$core$Native_Utils.eq(_p375._0._1, '!')) && (!_user$project$LeoParser$isPreludeLocId(_p375._0._0));
			},
			_user$project$LangTools$allLocsAndNumbers(exp)));
};
var _user$project$LangTools$replaceConstsWithVars = F2(
	function (locIdToNewName, exp) {
		var replacer = function (exp__) {
			var _p376 = exp__;
			if ((_p376.ctor === 'EConst') && (_p376._2.ctor === '_Tuple3')) {
				var _p377 = A2(_elm_lang$core$Dict$get, _p376._2._0, locIdToNewName);
				if (_p377.ctor === 'Just') {
					return A2(_user$project$Lang$EVar, _p376._0, _p377._0);
				} else {
					return exp__;
				}
			} else {
				return exp__;
			}
		};
		return A2(_user$project$Lang$mapExpViaExp__, replacer, exp);
	});
var _user$project$LangTools$patternListsEqual = F2(
	function (patsA, patsB) {
		return A2(
			_elm_lang$core$Maybe$withDefault,
			false,
			A2(
				_elm_lang$core$Maybe$map,
				_elm_lang$core$List$all(
					function (_p378) {
						var _p379 = _p378;
						return A2(_user$project$LangTools$patternsEqual, _p379._0, _p379._1);
					}),
				A2(_user$project$Utils$maybeZip, patsA, patsB)));
	});
var _user$project$LangTools$patternsEqual = F2(
	function (patA, patB) {
		var _p380 = {ctor: '_Tuple2', _0: patA.val.p__, _1: patB.val.p__};
		_v186_6:
		do {
			if (_p380.ctor === '_Tuple2') {
				switch (_p380._0.ctor) {
					case 'PVar':
						if (_p380._1.ctor === 'PVar') {
							return _elm_lang$core$Native_Utils.eq(_p380._0._1, _p380._1._1);
						} else {
							break _v186_6;
						}
					case 'PConst':
						if (_p380._1.ctor === 'PConst') {
							return _elm_lang$core$Native_Utils.eq(_p380._0._1, _p380._1._1);
						} else {
							break _v186_6;
						}
					case 'PBase':
						if (_p380._1.ctor === 'PBase') {
							return A2(_user$project$Lang$eBaseValsEqual, _p380._0._1, _p380._1._1);
						} else {
							break _v186_6;
						}
					case 'PList':
						if (_p380._0._3.ctor === 'Nothing') {
							if ((_p380._1.ctor === 'PList') && (_p380._1._3.ctor === 'Nothing')) {
								return A2(_user$project$LangTools$patternListsEqual, _p380._0._1, _p380._1._1);
							} else {
								break _v186_6;
							}
						} else {
							if ((_p380._1.ctor === 'PList') && (_p380._1._3.ctor === 'Just')) {
								return A2(
									_user$project$LangTools$patternListsEqual,
									{ctor: '::', _0: _p380._0._3._0, _1: _p380._0._1},
									{ctor: '::', _0: _p380._1._3._0, _1: _p380._1._1});
							} else {
								break _v186_6;
							}
						}
					case 'PAs':
						if (_p380._1.ctor === 'PAs') {
							return A2(_user$project$LangTools$patternsEqual, _p380._0._1, _p380._1._1) && A2(_user$project$LangTools$patternsEqual, _p380._0._3, _p380._1._3);
						} else {
							break _v186_6;
						}
					default:
						break _v186_6;
				}
			} else {
				break _v186_6;
			}
		} while(false);
		return false;
	});
var _user$project$LangTools$patternDeclsEqual = F2(
	function (_p382, _p381) {
		var _p383 = _p382;
		var _p396 = _p383._1;
		var _p395 = _p383._3;
		var _p394 = _p383._2;
		var _p384 = _p381;
		var _p393 = _p384._1;
		var _p392 = _p384._3;
		var _p391 = _p384._2;
		return _elm_lang$core$Native_Utils.eq(
			_elm_lang$core$List$length(_p396),
			_elm_lang$core$List$length(_p393)) && (_elm_lang$core$Native_Utils.eq(
			_elm_lang$core$List$length(_p394),
			_elm_lang$core$List$length(_p391)) && (_elm_lang$core$Native_Utils.eq(
			_elm_lang$core$List$length(_p395),
			_elm_lang$core$List$length(_p392)) && (A2(
			_elm_lang$core$List$all,
			function (_p385) {
				var _p386 = _p385;
				return A2(_user$project$LangTools$patternsEqual, _p386._0._2, _p386._1._2);
			},
			A2(
				_user$project$Utils$zip,
				_user$project$Lang$elemsOf(_p395),
				_user$project$Lang$elemsOf(_p392))) && (A2(
			_elm_lang$core$List$all,
			function (_p387) {
				var _p388 = _p387;
				return A2(_user$project$LangTools$patternsEqual, _p388._0._3, _p388._1._3);
			},
			A2(
				_user$project$Utils$zip,
				_user$project$Lang$elemsOf(_p396),
				_user$project$Lang$elemsOf(_p393))) && A2(
			_elm_lang$core$List$all,
			function (_p389) {
				var _p390 = _p389;
				return A2(_user$project$LangTools$patternsEqual, _p390._0._2, _p390._1._2);
			},
			A2(_user$project$Utils$zip, _p394, _p391))))));
	});
var _user$project$LangTools$extraExpsDiff = F2(
	function (baseExp, otherExp) {
		extraExpsDiff:
		while (true) {
			var childDiffs = function (_p397) {
				var _p398 = _p397;
				var _p399 = A2(
					_user$project$Utils$maybeZip,
					_user$project$Lang$childExps(baseExp),
					_user$project$Lang$childExps(otherExp));
				if (_p399.ctor === 'Just') {
					return A2(
						_elm_lang$core$List$concatMap,
						function (_p400) {
							var _p401 = _p400;
							return A2(_user$project$LangTools$extraExpsDiff, _p401._0, _p401._1);
						},
						_p399._0);
				} else {
					return {
						ctor: '::',
						_0: otherExp,
						_1: {ctor: '[]'}
					};
				}
			};
			var _p402 = {
				ctor: '_Tuple2',
				_0: _user$project$Lang$unwrapExp(baseExp),
				_1: _user$project$Lang$unwrapExp(otherExp)
			};
			_v195_19:
			do {
				_v195_18:
				do {
					_v195_15:
					do {
						_v195_7:
						do {
							switch (_p402._0.ctor) {
								case 'EConst':
									switch (_p402._1.ctor) {
										case 'EConst':
											return _elm_lang$core$Native_Utils.eq(_p402._0._1, _p402._1._1) ? {ctor: '[]'} : {
												ctor: '::',
												_0: otherExp,
												_1: {ctor: '[]'}
											};
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EBase':
									switch (_p402._1.ctor) {
										case 'EBase':
											return A2(_user$project$Lang$eBaseValsEqual, _p402._0._1, _p402._1._1) ? {ctor: '[]'} : {
												ctor: '::',
												_0: otherExp,
												_1: {ctor: '[]'}
											};
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EVar':
									switch (_p402._1.ctor) {
										case 'EVar':
											return _elm_lang$core$Native_Utils.eq(_p402._0._1, _p402._1._1) ? {ctor: '[]'} : {
												ctor: '::',
												_0: otherExp,
												_1: {ctor: '[]'}
											};
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EFun':
									switch (_p402._1.ctor) {
										case 'EFun':
											if (A2(_user$project$LangTools$patternListsEqual, _p402._0._1, _p402._1._1)) {
												var _v196 = _p402._0._2,
													_v197 = _p402._1._2;
												baseExp = _v196;
												otherExp = _v197;
												continue extraExpsDiff;
											} else {
												return {
													ctor: '::',
													_0: otherExp,
													_1: {ctor: '[]'}
												};
											}
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EOp':
									switch (_p402._1.ctor) {
										case 'EOp':
											return _elm_lang$core$Native_Utils.eq(_p402._0._2.val, _p402._1._2.val) ? childDiffs(
												{ctor: '_Tuple0'}) : {
												ctor: '::',
												_0: otherExp,
												_1: {ctor: '[]'}
											};
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EList':
									switch (_p402._1.ctor) {
										case 'EList':
											if (_p402._0._3.ctor === 'Nothing') {
												if (_p402._1._3.ctor === 'Nothing') {
													return childDiffs(
														{ctor: '_Tuple0'});
												} else {
													break _v195_7;
												}
											} else {
												if (_p402._1._3.ctor === 'Just') {
													return childDiffs(
														{ctor: '_Tuple0'});
												} else {
													break _v195_7;
												}
											}
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EApp':
									switch (_p402._1.ctor) {
										case 'EApp':
											return childDiffs(
												{ctor: '_Tuple0'});
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'ELet':
									switch (_p402._1.ctor) {
										case 'ELet':
											return A2(_user$project$LangTools$patternDeclsEqual, _p402._0._2, _p402._1._2) ? childDiffs(
												{ctor: '_Tuple0'}) : {
												ctor: '::',
												_0: otherExp,
												_1: {ctor: '[]'}
											};
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EIf':
									switch (_p402._1.ctor) {
										case 'EIf':
											return A2(
												_elm_lang$core$Basics_ops['++'],
												A2(_user$project$LangTools$extraExpsDiff, _p402._0._1, _p402._1._1),
												A2(
													_elm_lang$core$Basics_ops['++'],
													A2(_user$project$LangTools$extraExpsDiff, _p402._0._3, _p402._1._3),
													A2(_user$project$LangTools$extraExpsDiff, _p402._0._5, _p402._1._5)));
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'ECase':
									switch (_p402._1.ctor) {
										case 'ECase':
											return A2(
												_elm_lang$core$Maybe$withDefault,
												{
													ctor: '::',
													_0: otherExp,
													_1: {ctor: '[]'}
												},
												A2(
													_elm_lang$core$Maybe$andThen,
													function (branchPairs) {
														var bValPairs = A2(
															_elm_lang$core$List$map,
															function (_p403) {
																var _p404 = _p403;
																return {ctor: '_Tuple2', _0: _p404._0.val, _1: _p404._1.val};
															},
															branchPairs);
														return A2(
															_elm_lang$core$List$all,
															function (_p405) {
																var _p406 = _p405;
																return A2(_user$project$LangTools$patternsEqual, _p406._0._1, _p406._1._1);
															},
															bValPairs) ? _elm_lang$core$Maybe$Just(
															childDiffs(
																{ctor: '_Tuple0'})) : _elm_lang$core$Maybe$Nothing;
													},
													A2(_user$project$Utils$maybeZip, _p402._0._2, _p402._1._2)));
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EColonType':
									switch (_p402._1.ctor) {
										case 'EColonType':
											if (A2(_user$project$Types$equal, _p402._0._3, _p402._1._3)) {
												var _v200 = _p402._0._1,
													_v201 = _p402._1._1;
												baseExp = _v200;
												otherExp = _v201;
												continue extraExpsDiff;
											} else {
												return {
													ctor: '::',
													_0: otherExp,
													_1: {ctor: '[]'}
												};
											}
										case 'EParens':
											break _v195_15;
										default:
											break _v195_19;
									}
								case 'EParens':
									if (_p402._1.ctor === 'EParens') {
										var _v202 = _p402._0._1,
											_v203 = _p402._1._1;
										baseExp = _v202;
										otherExp = _v203;
										continue extraExpsDiff;
									} else {
										var _v204 = _p402._0._1,
											_v205 = otherExp;
										baseExp = _v204;
										otherExp = _v205;
										continue extraExpsDiff;
									}
								case 'ERecord':
									switch (_p402._1.ctor) {
										case 'EParens':
											break _v195_15;
										case 'ERecord':
											if (_p402._0._1.ctor === 'Nothing') {
												if (_p402._1._1.ctor === 'Nothing') {
													return A2(_user$project$LangTools$patternDeclsEqual, _p402._0._2, _p402._1._2) ? childDiffs(
														{ctor: '_Tuple0'}) : {
														ctor: '::',
														_0: otherExp,
														_1: {ctor: '[]'}
													};
												} else {
													break _v195_18;
												}
											} else {
												if (_p402._1._1.ctor === 'Just') {
													return A2(_user$project$LangTools$patternDeclsEqual, _p402._0._2, _p402._1._2) ? childDiffs(
														{ctor: '_Tuple0'}) : {
														ctor: '::',
														_0: otherExp,
														_1: {ctor: '[]'}
													};
												} else {
													break _v195_18;
												}
											}
										default:
											break _v195_19;
									}
								default:
									if (_p402._1.ctor === 'EParens') {
										break _v195_15;
									} else {
										break _v195_19;
									}
							}
						} while(false);
						return {
							ctor: '::',
							_0: otherExp,
							_1: {ctor: '[]'}
						};
					} while(false);
					var _v206 = baseExp,
						_v207 = _p402._1._1;
					baseExp = _v206;
					otherExp = _v207;
					continue extraExpsDiff;
				} while(false);
				return {
					ctor: '::',
					_0: otherExp,
					_1: {ctor: '[]'}
				};
			} while(false);
			return {
				ctor: '::',
				_0: otherExp,
				_1: {ctor: '[]'}
			};
		}
	});
var _user$project$LangTools$countNodes = F2(
	function (pred, exp) {
		return A2(
			_user$project$Utils$count,
			pred,
			_user$project$Lang$flattenExpTree(exp));
	});
var _user$project$LangTools$typeNodeCount = function (tipe) {
	var _p407 = tipe.val.t__;
	switch (_p407.ctor) {
		case 'TNum':
			return 1;
		case 'TBool':
			return 1;
		case 'TString':
			return 1;
		case 'TNull':
			return 1;
		case 'TList':
			return 1 + _user$project$LangTools$typeNodeCount(_p407._1);
		case 'TDict':
			return (1 + _user$project$LangTools$typeNodeCount(_p407._1)) + _user$project$LangTools$typeNodeCount(_p407._2);
		case 'TTuple':
			if (_p407._3.ctor === 'Nothing') {
				return 1 + _user$project$LangTools$typesNodeCount(_p407._1);
			} else {
				return (1 + _user$project$LangTools$typesNodeCount(_p407._1)) + _user$project$LangTools$typeNodeCount(_p407._3._0);
			}
		case 'TRecord':
			if (_p407._1.ctor === 'Nothing') {
				return 1 + _user$project$LangTools$typesNodeCount(
					_user$project$Utils$recordValues(_p407._2));
			} else {
				return 2 + _user$project$LangTools$typesNodeCount(
					_user$project$Utils$recordValues(_p407._2));
			}
		case 'TArrow':
			return 1 + _user$project$LangTools$typesNodeCount(_p407._1);
		case 'TUnion':
			return 1 + _user$project$LangTools$typesNodeCount(_p407._1);
		case 'TApp':
			return 1 + _user$project$LangTools$typesNodeCount(_p407._2);
		case 'TVar':
			return 1;
		case 'TForall':
			return (1 + _elm_lang$core$List$length(_p407._1)) + _user$project$LangTools$typeNodeCount(_p407._2);
		case 'TWildcard':
			return 1;
		default:
			return 1 + _user$project$LangTools$typeNodeCount(_p407._1);
	}
};
var _user$project$LangTools$typesNodeCount = function (types) {
	return _elm_lang$core$List$sum(
		A2(_elm_lang$core$List$map, _user$project$LangTools$typeNodeCount, types));
};
var _user$project$LangTools$patNodeCount = function (pat) {
	var _p408 = pat.val.p__;
	switch (_p408.ctor) {
		case 'PWildcard':
			return 1;
		case 'PVar':
			return 1;
		case 'PConst':
			return 1;
		case 'PBase':
			return 1;
		case 'PList':
			if (_p408._3.ctor === 'Just') {
				return (1 + _user$project$LangTools$patsNodeCount(_p408._1)) + _user$project$LangTools$patNodeCount(_p408._3._0);
			} else {
				return 1 + _user$project$LangTools$patsNodeCount(_p408._1);
			}
		case 'PRecord':
			return 1 + _user$project$LangTools$patsNodeCount(
				_user$project$Utils$recordValues(_p408._1));
		case 'PAs':
			return (1 + _user$project$LangTools$patNodeCount(_p408._1)) + _user$project$LangTools$patNodeCount(_p408._3);
		case 'PParens':
			return 1 + _user$project$LangTools$patNodeCount(_p408._1);
		default:
			return (1 + _user$project$LangTools$patNodeCount(_p408._1)) + _user$project$LangTools$typeNodeCount(_p408._3);
	}
};
var _user$project$LangTools$patsNodeCount = function (pats) {
	return _elm_lang$core$List$sum(
		A2(_elm_lang$core$List$map, _user$project$LangTools$patNodeCount, pats));
};
var _user$project$LangTools$declCount_ = F5(
	function (withChildren, patNodeCount, typeNodeCount, nodeCount, _p409) {
		var _p410 = _p409;
		return (_elm_lang$core$List$sum(
			A2(
				_elm_lang$core$List$map,
				function (_p411) {
					var _p412 = _p411;
					return (1 + patNodeCount(_p412._3)) + typeNodeCount(_p412._6);
				},
				_user$project$Lang$elemsOf(_p410._1))) + _elm_lang$core$List$sum(
			A2(
				_elm_lang$core$List$map,
				function (_p413) {
					var _p414 = _p413;
					return (1 + patNodeCount(_p414._2)) + typeNodeCount(_p414._5);
				},
				_p410._2))) + _elm_lang$core$List$sum(
			A2(
				_elm_lang$core$List$map,
				function (_p415) {
					var _p416 = _p415;
					return (1 + patNodeCount(_p416._2)) + (withChildren ? nodeCount(_p416._5) : 0);
				},
				_user$project$Lang$elemsOf(_p410._3)));
	});
var _user$project$LangTools$nodeCount = function (exp) {
	var expsNodeCount = function (exps) {
		return _elm_lang$core$List$sum(
			A2(_elm_lang$core$List$map, _user$project$LangTools$nodeCount, exps));
	};
	var _p417 = _user$project$Lang$unwrapExp(exp);
	switch (_p417.ctor) {
		case 'EConst':
			return 1;
		case 'EBase':
			return 1;
		case 'EVar':
			return 1;
		case 'EFun':
			return (1 + _user$project$LangTools$patsNodeCount(_p417._1)) + _user$project$LangTools$nodeCount(_p417._2);
		case 'EOp':
			return 1 + expsNodeCount(_p417._3);
		case 'EList':
			return (1 + expsNodeCount(
				_user$project$Utils$listValues(_p417._1))) + A2(
				_elm_lang$core$Maybe$withDefault,
				0,
				A2(
					_elm_lang$core$Maybe$map,
					function (e) {
						return _user$project$LangTools$nodeCount(e);
					},
					_p417._3));
		case 'ERecord':
			return (1 + _user$project$LangTools$declCount(_p417._2)) + A2(
				_elm_lang$core$Maybe$withDefault,
				0,
				A2(
					_elm_lang$core$Maybe$map,
					function (_p418) {
						var _p419 = _p418;
						return _user$project$LangTools$nodeCount(_p419._0);
					},
					_p417._1));
		case 'ESelect':
			return 1 + _user$project$LangTools$nodeCount(_p417._1);
		case 'EIf':
			return 1 + expsNodeCount(
				{
					ctor: '::',
					_0: _p417._1,
					_1: {
						ctor: '::',
						_0: _p417._3,
						_1: {
							ctor: '::',
							_0: _p417._5,
							_1: {ctor: '[]'}
						}
					}
				});
		case 'ECase':
			var _p420 = _p417._2;
			return (((1 + _elm_lang$core$List$length(_p420)) + _user$project$LangTools$nodeCount(_p417._1)) + _user$project$LangTools$patsNodeCount(
				_user$project$Lang$branchPats(_p420))) + expsNodeCount(
				_user$project$Lang$branchExps(_p420));
		case 'EApp':
			return (1 + _user$project$LangTools$nodeCount(_p417._1)) + expsNodeCount(_p417._2);
		case 'ELet':
			return (1 + _user$project$LangTools$declCount(_p417._2)) + _user$project$LangTools$nodeCount(_p417._4);
		case 'EColonType':
			return (1 + _user$project$LangTools$typeNodeCount(_p417._3)) + _user$project$LangTools$nodeCount(_p417._1);
		case 'EParens':
			return 1 + _user$project$LangTools$nodeCount(_p417._1);
		default:
			return 1;
	}
};
var _user$project$LangTools$declCount = A4(_user$project$LangTools$declCount_, true, _user$project$LangTools$patNodeCount, _user$project$LangTools$typeNodeCount, _user$project$LangTools$nodeCount);
var _user$project$LangTools$declCountWithoutChildren = A4(_user$project$LangTools$declCount_, false, _user$project$LangTools$patNodeCount, _user$project$LangTools$typeNodeCount, _user$project$LangTools$nodeCount);
var _user$project$LangTools$subExpsOfSizeAtLeast_ = F2(
	function (min, exp) {
		var _p421 = function (_p422) {
			var _p423 = _p422;
			return {
				ctor: '_Tuple2',
				_0: _elm_lang$core$List$sum(_p423._0),
				_1: _elm_lang$core$List$concat(_p423._1)
			};
		}(
			_elm_lang$core$List$unzip(
				A2(
					_elm_lang$core$List$map,
					_user$project$LangTools$subExpsOfSizeAtLeast_(min),
					_user$project$Lang$childExps(exp))));
		var childrenTotal = _p421._0;
		var largeSubExps = _p421._1;
		if (_elm_lang$core$Native_Utils.cmp(childrenTotal, min) > -1) {
			return {
				ctor: '_Tuple2',
				_0: childrenTotal,
				_1: {ctor: '::', _0: exp, _1: largeSubExps}
			};
		} else {
			var thisSizeWithoutChildren = function () {
				var _p424 = _user$project$Lang$unwrapExp(exp);
				switch (_p424.ctor) {
					case 'EConst':
						return 1;
					case 'EBase':
						return 1;
					case 'EVar':
						return 1;
					case 'EFun':
						return 1 + _user$project$LangTools$patsNodeCount(_p424._1);
					case 'EOp':
						return 1;
					case 'EList':
						if (_p424._3.ctor === 'Just') {
							return 1;
						} else {
							return 1;
						}
					case 'ERecord':
						return 1 + _user$project$LangTools$declCountWithoutChildren(_p424._2);
					case 'ESelect':
						return 1;
					case 'EIf':
						return 1;
					case 'ECase':
						var _p425 = _p424._2;
						return (1 + _elm_lang$core$List$length(_p425)) + _user$project$LangTools$patsNodeCount(
							_user$project$Lang$branchPats(_p425));
					case 'EApp':
						return 1;
					case 'ELet':
						return 1 + _user$project$LangTools$declCountWithoutChildren(_p424._2);
					case 'EColonType':
						return 1 + _user$project$LangTools$typeNodeCount(_p424._3);
					case 'EParens':
						return 1;
					default:
						return 1;
				}
			}();
			if (!_elm_lang$core$Native_Utils.eq(
				largeSubExps,
				{ctor: '[]'})) {
				return _elm_lang$core$Native_Utils.crash(
					'LangTools',
					{
						start: {line: 102, column: 7},
						end: {line: 102, column: 18}
					})('LangTools.thisSizeWithoutChildren bug');
			} else {
				var thisSize = thisSizeWithoutChildren + childrenTotal;
				return {
					ctor: '_Tuple2',
					_0: thisSize,
					_1: (_elm_lang$core$Native_Utils.cmp(thisSize, min) > -1) ? {
						ctor: '::',
						_0: exp,
						_1: {ctor: '[]'}
					} : {ctor: '[]'}
				};
			}
		}
	});
var _user$project$LangTools$subExpsOfSizeAtLeast = F2(
	function (min, exp) {
		var _p426 = A2(_user$project$LangTools$subExpsOfSizeAtLeast_, min, exp);
		var exps = _p426._1;
		return exps;
	});
var _user$project$LangTools$CannotCompare = {ctor: 'CannotCompare'};
var _user$project$LangTools$NoMatch = {ctor: 'NoMatch'};
var _user$project$LangTools$Match = function (a) {
	return {ctor: 'Match', _0: a};
};
var _user$project$LangTools$tryMatchExp = F2(
	function (pat, exp) {
		tryMatchExp:
		while (true) {
			var matchMap = F2(
				function (f, matchResult) {
					var _p427 = matchResult;
					if (_p427.ctor === 'Match') {
						return _user$project$LangTools$Match(
							f(_p427._0));
					} else {
						return matchResult;
					}
				});
			var matchAndThen = F2(
				function (f, matchResult) {
					var _p428 = matchResult;
					if (_p428.ctor === 'Match') {
						return f(_p428._0);
					} else {
						return matchResult;
					}
				});
			var projMatches = function (resultList) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (matchResult, acc) {
							var _p429 = {ctor: '_Tuple2', _0: matchResult, _1: acc};
							_v220_1:
							do {
								if (_p429._0.ctor === 'Match') {
									switch (_p429._1.ctor) {
										case 'Match':
											return _user$project$LangTools$Match(
												A2(_elm_lang$core$Basics_ops['++'], _p429._0._0, _p429._1._0));
										case 'CannotCompare':
											break _v220_1;
										default:
											break _v220_1;
									}
								} else {
									if (_p429._1.ctor === 'CannotCompare') {
										return _user$project$LangTools$CannotCompare;
									} else {
										return _p429._0;
									}
								}
							} while(false);
							return _p429._1;
						}),
					_user$project$LangTools$Match(
						{ctor: '[]'}),
					resultList);
			};
			var _p430 = _user$project$Lang$unwrapExp(exp);
			if (_p430.ctor === 'EColonType') {
				var _v222 = pat,
					_v223 = _p430._1;
				pat = _v222;
				exp = _v223;
				continue tryMatchExp;
			} else {
				var _p431 = pat.val.p__;
				switch (_p431.ctor) {
					case 'PWildcard':
						return _user$project$LangTools$Match(
							{ctor: '[]'});
					case 'PVar':
						return _user$project$LangTools$Match(
							{
								ctor: '::',
								_0: {ctor: '_Tuple2', _0: _p431._1, _1: exp},
								_1: {ctor: '[]'}
							});
					case 'PAs':
						return A2(
							matchAndThen,
							function (env) {
								return A2(
									matchMap,
									function (env2) {
										return A2(_elm_lang$core$Basics_ops['++'], env2, env);
									},
									A2(_user$project$LangTools$tryMatchExp, _p431._3, exp));
							},
							A2(_user$project$LangTools$tryMatchExp, _p431._1, exp));
					case 'PList':
						if (_p431._3.ctor === 'Nothing') {
							var _p432 = _user$project$Lang$unwrapExp(exp);
							if ((_p432.ctor === 'EList') && (_p432._3.ctor === 'Nothing')) {
								var _p433 = A2(
									_user$project$Utils$maybeZip,
									_p431._1,
									_user$project$Utils$listValues(_p432._1));
								if (_p433.ctor === 'Nothing') {
									return _user$project$LangTools$NoMatch;
								} else {
									return projMatches(
										A2(
											_elm_lang$core$List$map,
											function (_p434) {
												var _p435 = _p434;
												return A2(_user$project$LangTools$tryMatchExp, _p435._0, _p435._1);
											},
											_p433._0));
								}
							} else {
								return _user$project$LangTools$CannotCompare;
							}
						} else {
							var _p445 = _p431._3._0;
							var _p444 = _p431._1;
							var _p436 = _user$project$Lang$unwrapExp(exp);
							if (_p436.ctor === 'EList') {
								if (_p436._3.ctor === 'Nothing') {
									var _p440 = _p436._1;
									if (_elm_lang$core$Native_Utils.cmp(
										_elm_lang$core$List$length(_p440),
										_elm_lang$core$List$length(_p444)) < 0) {
										return _user$project$LangTools$NoMatch;
									} else {
										var _p437 = A2(
											_user$project$Utils$split,
											_elm_lang$core$List$length(_p444),
											_user$project$Utils$listValues(_p440));
										var headExps = _p437._0;
										var tailExps = _p437._1;
										var tryHeadMatch = projMatches(
											A2(
												_elm_lang$core$List$map,
												function (_p438) {
													var _p439 = _p438;
													return A2(_user$project$LangTools$tryMatchExp, _p439._0, _p439._1);
												},
												A2(_user$project$Utils$zip, _p444, headExps)));
										var tryTailMatch = A2(
											_user$project$LangTools$tryMatchExp,
											_p445,
											A2(_user$project$Lang$eList, tailExps, _elm_lang$core$Maybe$Nothing));
										return projMatches(
											{
												ctor: '::',
												_0: tryHeadMatch,
												_1: {
													ctor: '::',
													_0: tryTailMatch,
													_1: {ctor: '[]'}
												}
											});
									}
								} else {
									var _p443 = _p436._1;
									if (_elm_lang$core$Native_Utils.cmp(
										_elm_lang$core$List$length(_p443),
										_elm_lang$core$List$length(_p444)) < 0) {
										return _user$project$LangTools$NoMatch;
									} else {
										if (!_elm_lang$core$Native_Utils.eq(
											_elm_lang$core$List$length(_p443),
											_elm_lang$core$List$length(_p444))) {
											return _user$project$LangTools$CannotCompare;
										} else {
											var tryHeadMatch = projMatches(
												A2(
													_elm_lang$core$List$map,
													function (_p441) {
														var _p442 = _p441;
														return A2(_user$project$LangTools$tryMatchExp, _p442._0, _p442._1);
													},
													A2(
														_user$project$Utils$zip,
														_p444,
														_user$project$Utils$listValues(_p443))));
											var tryTailMatch = A2(_user$project$LangTools$tryMatchExp, _p445, _p436._3._0);
											return projMatches(
												{
													ctor: '::',
													_0: tryHeadMatch,
													_1: {
														ctor: '::',
														_0: tryTailMatch,
														_1: {ctor: '[]'}
													}
												});
										}
									}
								}
							} else {
								return _user$project$LangTools$CannotCompare;
							}
						}
					case 'PRecord':
						var _p446 = _user$project$Lang$unwrapExp(exp);
						if ((_p446.ctor === 'ERecord') && (_p446._1.ctor === 'Nothing')) {
							var _p447 = _user$project$Lang$recordEntriesFromDeclarations(_p446._2);
							if (_p447.ctor === 'Just') {
								var psEsMaybe = A4(_user$project$Record$getPatternMatch, _user$project$Utils$recordKey, _user$project$Utils$recordKey, _p431._1, _p447._0);
								var _p448 = psEsMaybe;
								if (_p448.ctor === 'Nothing') {
									return _user$project$LangTools$NoMatch;
								} else {
									return projMatches(
										A2(
											_elm_lang$core$List$map,
											function (_p449) {
												var _p450 = _p449;
												return A2(
													_user$project$LangTools$tryMatchExp,
													_user$project$Utils$recordValue(_p450._0),
													_user$project$Utils$recordValue(_p450._1));
											},
											_p448._0));
								}
							} else {
								return _user$project$LangTools$CannotCompare;
							}
						} else {
							return _user$project$LangTools$CannotCompare;
						}
					case 'PConst':
						var _p451 = _user$project$Lang$unwrapExp(exp);
						if (_p451.ctor === 'EConst') {
							return _elm_lang$core$Native_Utils.eq(_p431._1, _p451._1) ? _user$project$LangTools$Match(
								{ctor: '[]'}) : _user$project$LangTools$NoMatch;
						} else {
							return _user$project$LangTools$CannotCompare;
						}
					case 'PBase':
						var _p452 = _user$project$Lang$unwrapExp(exp);
						if (_p452.ctor === 'EBase') {
							return A2(_user$project$Lang$eBaseValsEqual, _p431._1, _p452._1) ? _user$project$LangTools$Match(
								{ctor: '[]'}) : _user$project$LangTools$NoMatch;
						} else {
							return _user$project$LangTools$CannotCompare;
						}
					case 'PParens':
						var _v237 = _p431._1,
							_v238 = exp;
						pat = _v237;
						exp = _v238;
						continue tryMatchExp;
					default:
						var _v239 = _p431._1,
							_v240 = exp;
						pat = _v239;
						exp = _v240;
						continue tryMatchExp;
				}
			}
		}
	});
var _user$project$LangTools$tryMatchExpReturningList = F2(
	function (pat, exp) {
		var _p453 = A2(_user$project$LangTools$tryMatchExp, pat, exp);
		if (_p453.ctor === 'Match') {
			return _p453._0;
		} else {
			return {ctor: '[]'};
		}
	});
var _user$project$LangTools$findPatAndBoundExpByPId = F2(
	function (targetPId, exp) {
		return A3(
			_elm_lang$core$Basics$flip,
			_elm_lang$core$Maybe$andThen,
			A2(_user$project$Lang$findScopeExpAndPatByPId, exp, targetPId),
			function (_p454) {
				var _p455 = _p454;
				var _p457 = _p455._1;
				return A3(
					_elm_lang$core$Basics$flip,
					_elm_lang$core$Maybe$andThen,
					_user$project$LangTools$patToMaybeIdent(_p457),
					function (ident) {
						return A3(
							_elm_lang$core$Basics$flip,
							_elm_lang$core$Maybe$andThen,
							_user$project$LangTools$declarationsOf(_p455._0._0),
							function (decls) {
								return A3(
									_elm_lang$core$Basics$flip,
									_elm_lang$core$Maybe$andThen,
									_elm_lang$core$Result$toMaybe(
										A2(
											_user$project$Utils$nth,
											_user$project$Lang$getDeclarationsInOrder(decls),
											_p455._0._1)),
									function (decl) {
										var _p456 = decl;
										if (_p456.ctor === 'DeclExp') {
											return A2(
												_elm_lang$core$Maybe$map,
												function (boundExp) {
													return {ctor: '_Tuple2', _0: _p457, _1: boundExp};
												},
												A2(
													_user$project$Utils$maybeFind,
													ident,
													A2(_user$project$LangTools$tryMatchExpReturningList, _p456._0._2, _p456._0._5)));
										} else {
											return _elm_lang$core$Maybe$Nothing;
										}
									});
							});
					});
			});
	});
var _user$project$LangTools$findBoundExpByPId = F2(
	function (targetPId, exp) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_p458) {
				var _p459 = _p458;
				return _p459._1;
			},
			A2(_user$project$LangTools$findPatAndBoundExpByPId, targetPId, exp));
	});
var _user$project$LangTools$findLetAndIdentBindingExp = F2(
	function (targetEId, program) {
		return A2(
			_user$project$Lang$mapFirstSuccessNode,
			function (exp) {
				var _p460 = _user$project$Lang$unwrapExp(exp);
				if (_p460.ctor === 'ELet') {
					return A2(
						_user$project$Utils$mapFirstSuccess,
						function (_p461) {
							var _p462 = _p461;
							return A2(
								_user$project$Utils$mapFirstSuccess,
								function (_p463) {
									var _p464 = _p463;
									return _elm_lang$core$Native_Utils.eq(
										_user$project$Lang$expEId(_p464._1),
										targetEId) ? _elm_lang$core$Maybe$Just(
										{ctor: '_Tuple2', _0: exp, _1: _p464._0}) : _elm_lang$core$Maybe$Nothing;
								},
								A2(_user$project$LangTools$tryMatchExpReturningList, _p462._2, _p462._5));
						},
						_user$project$Lang$elemsOf(_p460._2._3));
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			program);
	});
var _user$project$LangTools$allSimplyResolvableLetBindings = _user$project$LangTools$allSimplyResolvableThings(_user$project$LangTools$tryMatchExpReturningList);
var _user$project$LangTools$numericLetBoundIdentifiers = function (program) {
	var isSurelyNumeric = F2(
		function (numericIdents, exp) {
			var recurse = function (e) {
				return A2(isSurelyNumeric, numericIdents, e);
			};
			var _p465 = _user$project$Lang$unwrapExp(exp);
			switch (_p465.ctor) {
				case 'EConst':
					return true;
				case 'EBase':
					return false;
				case 'EVar':
					return A2(_elm_lang$core$Set$member, _p465._1, numericIdents);
				case 'EFun':
					return false;
				case 'EApp':
					return false;
				case 'EOp':
					var _p467 = _p465._3;
					var _p466 = _p465._2.val;
					switch (_p466.ctor) {
						case 'Pi':
							return true;
						case 'DictEmpty':
							return false;
						case 'CurrentEnv':
							return false;
						case 'DictFromList':
							return false;
						case 'Cos':
							return true;
						case 'Sin':
							return true;
						case 'ArcCos':
							return true;
						case 'ArcSin':
							return true;
						case 'Floor':
							return true;
						case 'Ceil':
							return true;
						case 'Round':
							return true;
						case 'ToStr':
							return false;
						case 'Sqrt':
							return true;
						case 'Explode':
							return false;
						case 'DebugLog':
							return A2(_elm_lang$core$List$any, recurse, _p467);
						case 'NoWidgets':
							return A2(_elm_lang$core$List$any, recurse, _p467);
						case 'Plus':
							return A2(_elm_lang$core$List$any, recurse, _p467);
						case 'Minus':
							return true;
						case 'Mult':
							return true;
						case 'Div':
							return true;
						case 'Lt':
							return false;
						case 'Eq':
							return false;
						case 'Mod':
							return true;
						case 'Pow':
							return true;
						case 'ArcTan2':
							return true;
						case 'DictGet':
							return false;
						case 'DictRemove':
							return false;
						case 'DictInsert':
							return false;
						case 'ToStrExceptStr':
							return A2(_elm_lang$core$List$any, recurse, _p467);
						case 'RegexExtractFirstIn':
							return false;
						default:
							return false;
					}
				case 'EList':
					return false;
				case 'ERecord':
					return false;
				case 'ESelect':
					return false;
				case 'EIf':
					return recurse(_p465._3) && recurse(_p465._5);
				case 'ECase':
					return A2(
						_elm_lang$core$List$all,
						recurse,
						_user$project$Lang$branchExps(_p465._2));
				case 'ELet':
					return recurse(_p465._4);
				case 'EColonType':
					return recurse(_p465._1);
				case 'EParens':
					return recurse(_p465._1);
				default:
					if (_p465._1.ctor === 'EEmptyHole') {
						return false;
					} else {
						return _user$project$Lang$valIsNum(_p465._1._0);
					}
			}
		});
	var expBindings = _user$project$LangTools$allSimplyResolvableLetBindings(program);
	var findAllNumericIdents = function (numericIdents) {
		findAllNumericIdents:
		while (true) {
			var moreNumericIdents = A2(
				_elm_lang$core$List$map,
				_elm_lang$core$Tuple$first,
				A2(
					_elm_lang$core$List$filter,
					function (_p468) {
						var _p469 = _p468;
						return A2(isSurelyNumeric, numericIdents, _p469._1);
					},
					expBindings));
			if (_elm_lang$core$Native_Utils.eq(
				_elm_lang$core$List$length(moreNumericIdents),
				_elm_lang$core$Set$size(numericIdents))) {
				return numericIdents;
			} else {
				var _v251 = _elm_lang$core$Set$fromList(moreNumericIdents);
				numericIdents = _v251;
				continue findAllNumericIdents;
			}
		}
	};
	return findAllNumericIdents(_elm_lang$core$Set$empty);
};
var _user$project$LangTools$BoundUnknown = {ctor: 'BoundUnknown'};
var _user$project$LangTools$Bound = function (a) {
	return {ctor: 'Bound', _0: a};
};
var _user$project$LangTools$expEnvAt_ = F2(
	function (exp, targetEId) {
		var recurse = function (e) {
			return A2(_user$project$LangTools$expEnvAt_, e, targetEId);
		};
		var recurseAllChildren = function (_p470) {
			var _p471 = _p470;
			return A2(
				_user$project$Utils$mapFirstSuccess,
				recurse,
				_user$project$Lang$childExps(exp));
		};
		var addShallowerIdentifiers = F2(
			function (newIdents, deeperBindings) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (ident, bindings) {
							return A2(_elm_lang$core$Dict$member, ident, bindings) ? bindings : A3(_elm_lang$core$Dict$insert, ident, _user$project$LangTools$BoundUnknown, bindings);
						}),
					deeperBindings,
					newIdents);
			});
		var addShallowerBoundExps = F2(
			function (expEnv, deeperBindings) {
				return A3(
					_elm_lang$core$List$foldl,
					F2(
						function (_p472, bindings) {
							var _p473 = _p472;
							var _p474 = _p473._0;
							return A2(_elm_lang$core$Dict$member, _p474, bindings) ? bindings : A3(
								_elm_lang$core$Dict$insert,
								_p474,
								_user$project$LangTools$Bound(_p473._1),
								bindings);
						}),
					deeperBindings,
					expEnv);
			});
		var addBindingsFrom = F3(
			function (pat, e, deeperBindings) {
				var _p475 = A2(_user$project$LangTools$tryMatchExp, pat, e);
				if (_p475.ctor === 'Match') {
					return A2(addShallowerBoundExps, _p475._0, deeperBindings);
				} else {
					return A2(
						addShallowerIdentifiers,
						_user$project$Lang$identifiersListInPat(pat),
						deeperBindings);
				}
			});
		var addBindingsFrom2 = F2(
			function (listLetExp, deeperBindings) {
				return A3(
					_user$project$Utils$foldLeft,
					deeperBindings,
					listLetExp,
					F2(
						function (acc, _p476) {
							var _p477 = _p476;
							return A3(addBindingsFrom, _p477._2, _p477._5, acc);
						}));
			});
		if (_elm_lang$core$Native_Utils.eq(
			_user$project$Lang$expEId(exp),
			targetEId)) {
			return _elm_lang$core$Maybe$Just(_elm_lang$core$Dict$empty);
		} else {
			var _p478 = _user$project$Lang$unwrapExp(exp);
			switch (_p478.ctor) {
				case 'EConst':
					return _elm_lang$core$Maybe$Nothing;
				case 'EBase':
					return _elm_lang$core$Maybe$Nothing;
				case 'EVar':
					return _elm_lang$core$Maybe$Nothing;
				case 'EFun':
					return A2(
						_elm_lang$core$Maybe$map,
						addShallowerIdentifiers(
							_user$project$Lang$identifiersListInPats(_p478._1)),
						recurse(_p478._2));
				case 'EOp':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'EList':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'ERecord':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'ESelect':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'EIf':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'ECase':
					var _p479 = recurse(_p478._1);
					if (_p479.ctor === 'Just') {
						return _elm_lang$core$Maybe$Just(_p479._0);
					} else {
						return A2(
							_user$project$Utils$mapFirstSuccess,
							function (_p480) {
								var _p481 = _p480;
								var _p482 = _p481._2;
								return A2(
									_elm_lang$core$Maybe$map,
									A2(addBindingsFrom, _p481._1, _p482),
									recurse(_p482));
							},
							A2(
								_elm_lang$core$List$map,
								function (_) {
									return _.val;
								},
								_p478._2));
					}
				case 'EApp':
					return recurseAllChildren(
						{ctor: '_Tuple0'});
				case 'ELet':
					var aux = F2(
						function (accAdder, letexpsGroups) {
							aux:
							while (true) {
								var _p483 = letexpsGroups;
								if (_p483.ctor === '[]') {
									return A2(
										_elm_lang$core$Maybe$map,
										accAdder,
										recurse(_p478._4));
								} else {
									var _p487 = _p483._0._1;
									var _p484 = A2(
										_user$project$Utils$mapFirstSuccess,
										recurse,
										_user$project$Lang$groupBoundExps(_p487));
									if (_p484.ctor === 'Nothing') {
										var _v261 = A2(
											F2(
												function (group, accAdder) {
													return function (_p485) {
														return A2(
															addBindingsFrom2,
															group,
															accAdder(_p485));
													};
												}),
											_p487,
											accAdder),
											_v262 = _p483._1;
										accAdder = _v261;
										letexpsGroups = _v262;
										continue aux;
									} else {
										var _p486 = _p484._0;
										return _elm_lang$core$Maybe$Just(
											_p483._0._0 ? accAdder(
												A2(addBindingsFrom2, _p487, _p486)) : _p486);
									}
								}
							}
						});
					return A2(aux, _elm_lang$core$Basics$identity, _p478._2._3);
				case 'EColonType':
					return recurse(_p478._1);
				case 'EParens':
					return recurse(_p478._1);
				default:
					return _elm_lang$core$Maybe$Nothing;
			}
		}
	});
var _user$project$LangTools$preludeExpEnv = A2(
	_user$project$Utils$fromJust_,
	'LangTools.preludeExpEnv',
	A2(
		_user$project$LangTools$expEnvAt_,
		_user$project$LeoParser$prelude,
		_user$project$Lang$expEId(
			_user$project$LangTools$lastTopLevelExp(_user$project$LeoParser$prelude))));
var _user$project$LangTools$expEnvAt = F2(
	function (exp, targetEId) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (bindings) {
				return A2(_elm_lang$core$Dict$union, bindings, _user$project$LangTools$preludeExpEnv);
			},
			A2(_user$project$LangTools$expEnvAt_, exp, targetEId));
	});
var _user$project$LangTools$resolveIdentifierToExp = F3(
	function (ident, viewerEId, program) {
		return A2(
			_elm_lang$core$Maybe$andThen,
			_elm_lang$core$Dict$get(ident),
			A2(_user$project$LangTools$expEnvAt, program, viewerEId));
	});
var _user$project$LangTools$expDescriptionParts_ = F3(
	function (program, exp, targetEId) {
		var recurse = function (e) {
			return A3(_user$project$LangTools$expDescriptionParts_, program, e, targetEId);
		};
		var varIdentOrDefault = F2(
			function (e, $default) {
				return A2(
					_elm_lang$core$Maybe$withDefault,
					$default,
					_user$project$Lang$expToMaybeIdent(e));
			});
		var searchChildren = function (_p488) {
			var _p489 = _p488;
			return A2(
				_elm_lang$core$Maybe$withDefault,
				{ctor: '[]'},
				A2(
					_user$project$Utils$mapFirstSuccess,
					function (child) {
						var _p490 = recurse(child);
						if (_p490.ctor === '[]') {
							return _elm_lang$core$Maybe$Nothing;
						} else {
							return _elm_lang$core$Maybe$Just(_p490);
						}
					},
					_user$project$Lang$childExps(exp)));
		};
		if (_elm_lang$core$Native_Utils.eq(
			_user$project$Lang$expEId(exp),
			targetEId)) {
			return {
				ctor: '::',
				_0: _user$project$LangTools$simpleExpName(exp),
				_1: {ctor: '[]'}
			};
		} else {
			var _p491 = _user$project$Lang$unwrapExp(exp);
			_v265_2:
			do {
				switch (_p491.ctor) {
					case 'ELet':
						if ((((((_p491._2._2.ctor === '[]') && (_p491._2._3.ctor === '::')) && (_p491._2._3._0.ctor === '_Tuple2')) && (_p491._2._3._0._1.ctor === '::')) && (_p491._2._3._0._1._1.ctor === '[]')) && (_p491._2._3._1.ctor === '[]')) {
							var _p505 = _p491._2._3._0._1._0._2;
							var _p504 = _p491._2._3._0._1._0._5;
							var namedAssigns = A2(_user$project$LangTools$tryMatchExpReturningList, _p505, _p504);
							var _p494 = A2(
								_elm_lang$core$List$filter,
								function (_p492) {
									var _p493 = _p492;
									return !_elm_lang$core$Native_Utils.eq(
										A2(_user$project$Lang$findExpByEId, _p493._1, targetEId),
										_elm_lang$core$Maybe$Nothing);
								},
								namedAssigns);
							if (_p494.ctor === '[]') {
								if (_elm_lang$core$Native_Utils.eq(
									_user$project$Lang$expEId(_p504),
									targetEId)) {
									var _p495 = _user$project$Lang$identifiersListInPat(_p505);
									if (_p495.ctor === '[]') {
										return {
											ctor: '::',
											_0: _user$project$LangTools$simpleExpName(_p504),
											_1: {ctor: '[]'}
										};
									} else {
										return {
											ctor: '::',
											_0: A2(
												varIdentOrDefault,
												_p504,
												A2(_elm_lang$core$String$join, '', _p495)),
											_1: {ctor: '[]'}
										};
									}
								} else {
									var scopeNames = function () {
										var _p496 = _p505.val.p__;
										if (_p496.ctor === 'PVar') {
											return {
												ctor: '::',
												_0: _p496._1,
												_1: {ctor: '[]'}
											};
										} else {
											var _p497 = _user$project$Lang$identifiersListInPat(_p505);
											if (_p497.ctor === '[]') {
												return {ctor: '[]'};
											} else {
												return {
													ctor: '::',
													_0: A2(_elm_lang$core$String$join, '', _p497),
													_1: {ctor: '[]'}
												};
											}
										}
									}();
									var _p498 = recurse(_p504);
									if (_p498.ctor === '[]') {
										return recurse(_p491._4);
									} else {
										return A2(_elm_lang$core$Basics_ops['++'], scopeNames, _p498);
									}
								}
							} else {
								var _p503 = _p494;
								var _p499 = A2(_user$project$Utils$last, 'LangTools.expDescriptionParts', _p503);
								var ident = _p499._0;
								var matchingExp = _p499._1;
								var _p500 = _elm_lang$core$List$unzip(_p503);
								var idents = _p500._0;
								if (_elm_lang$core$Native_Utils.eq(
									_user$project$Lang$expEId(matchingExp),
									targetEId)) {
									return A2(
										_elm_lang$core$Basics_ops['++'],
										A2(_user$project$Utils$dropLast, 1, idents),
										{
											ctor: '::',
											_0: A2(varIdentOrDefault, matchingExp, ident),
											_1: {ctor: '[]'}
										});
								} else {
									var _p501 = recurse(matchingExp);
									if (_p501.ctor === '[]') {
										return _elm_lang$core$Native_Utils.crashCase(
											'LangTools',
											{
												start: {line: 811, column: 15},
												end: {line: 813, column: 53}
											},
											_p501)(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'LangTools.expDescriptionParts expected to find targetEId in\n',
												A2(
													_elm_lang$core$Basics_ops['++'],
													_user$project$LangUnparser$unparseWithIds(matchingExp),
													A2(
														_elm_lang$core$Basics_ops['++'],
														'\nin\n',
														_user$project$LangUnparser$unparseWithIds(_p504)))));
									} else {
										return A2(_elm_lang$core$Basics_ops['++'], idents, _p501);
									}
								}
							}
						} else {
							break _v265_2;
						}
					case 'EApp':
						var _p506 = searchChildren(
							{ctor: '_Tuple0'});
						if (_p506.ctor === '[]') {
							return {ctor: '[]'};
						} else {
							return A2(
								_elm_lang$core$Maybe$withDefault,
								_p506,
								A2(
									_elm_lang$core$Maybe$andThen,
									function (funcName) {
										var _p507 = A3(_user$project$LangTools$resolveIdentifierToExp, funcName, targetEId, program);
										if ((_p507.ctor === 'Just') && (_p507._0.ctor === 'Bound')) {
											var _p508 = _user$project$Lang$unwrapExp(_p507._0._0);
											if (_p508.ctor === 'EFun') {
												return A2(
													_user$project$Utils$mapFirstSuccess,
													function (_p509) {
														var _p510 = _p509;
														var _p511 = A2(_user$project$LangTools$tryMatchExp, _p510._0, _p510._1);
														if (_p511.ctor === 'Match') {
															return A2(
																_elm_lang$core$Maybe$map,
																function (_p512) {
																	var _p513 = _p512;
																	return {
																		ctor: '::',
																		_0: A2(varIdentOrDefault, _p513._1, _p513._0),
																		_1: {ctor: '[]'}
																	};
																},
																A2(
																	_user$project$Utils$findFirst,
																	function (_p514) {
																		var _p515 = _p514;
																		return _elm_lang$core$Native_Utils.eq(
																			_user$project$Lang$expEId(_p515._1),
																			targetEId);
																	},
																	_p511._0));
														} else {
															return _elm_lang$core$Maybe$Nothing;
														}
													},
													A2(_user$project$Utils$zip, _p508._1, _p491._2));
											} else {
												return _elm_lang$core$Maybe$Nothing;
											}
										} else {
											return _elm_lang$core$Maybe$Nothing;
										}
									},
									_user$project$Lang$expToMaybeIdent(_p491._1)));
						}
					default:
						break _v265_2;
				}
			} while(false);
			return searchChildren(
				{ctor: '_Tuple0'});
		}
	});
var _user$project$LangTools$expDescriptionParts = F2(
	function (program, targetEId) {
		return A3(_user$project$LangTools$expDescriptionParts_, program, program, targetEId);
	});
var _user$project$LangTools$expNameForEIdWithDefault = F3(
	function ($default, program, targetEId) {
		var getParent = function (eId) {
			return A2(
				_elm_lang$core$Maybe$withDefault,
				_elm_lang$core$Maybe$Nothing,
				A2(_user$project$Lang$parentByEId, program, eId));
		};
		return A2(
			_elm_lang$core$Maybe$withDefault,
			function () {
				var _p516 = A2(
					_user$project$Utils$takeLast,
					1,
					A2(_user$project$LangTools$expDescriptionParts, program, targetEId));
				if ((_p516.ctor === '::') && (_p516._1.ctor === '[]')) {
					return _p516._0;
				} else {
					return A2(
						_elm_lang$core$Maybe$withDefault,
						$default,
						A2(
							_elm_lang$core$Maybe$map,
							_user$project$LangTools$simpleExpNameWithDefault($default),
							A2(_user$project$Lang$findExpByEId, program, targetEId)));
				}
			}(),
			A2(
				_elm_lang$core$Maybe$andThen,
				function (parentExp) {
					return function (parentEId) {
						return A2(
							_elm_lang$core$Maybe$andThen,
							function (_p517) {
								var _p518 = _p517;
								return A2(
									_elm_lang$core$Maybe$andThen,
									function (grandParentExp) {
										return A2(
											_elm_lang$core$Maybe$andThen,
											function (_p519) {
												var _p520 = _p519;
												return A2(
													_elm_lang$core$Maybe$andThen,
													function (letExp) {
														return A2(
															_elm_lang$core$Maybe$andThen,
															function (_p521) {
																var _p522 = _p521;
																return A2(
																	_elm_lang$core$Maybe$andThen,
																	function (patsWithExps) {
																		return A2(
																			_elm_lang$core$Maybe$andThen,
																			function (_p523) {
																				var _p524 = _p523;
																				return _user$project$Lang$pVarUnapply(_p524._0);
																			},
																			A2(
																				_user$project$Utils$findFirst,
																				function (_p525) {
																					return A2(
																						_user$project$Lang$eidIs,
																						targetEId,
																						_elm_lang$core$Tuple$second(_p525));
																				},
																				patsWithExps));
																	},
																	A2(
																		_user$project$Utils$maybeZip,
																		A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$second, _p522._1),
																		A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$second, _p518._1)));
															},
															_user$project$Lang$pTupleUnapply(
																_user$project$Lang$patOfLetExp(letExp)));
													},
													A2(
														_user$project$Utils$findFirst,
														function (_p526) {
															return A2(
																_user$project$Lang$eidIs,
																parentEId,
																_user$project$Lang$bindingOfLetExp(_p526));
														},
														_user$project$Lang$elemsOf(_p520._2._3)));
											},
											_user$project$Lang$eLetUnapply(grandParentExp));
									},
									getParent(parentEId));
							},
							_user$project$Lang$eTupleUnapply(parentExp));
					}(
						_user$project$Lang$expEId(parentExp));
				},
				getParent(targetEId)));
	});
var _user$project$LangTools$expNameForEId = F2(
	function (program, targetEId) {
		return A3(_user$project$LangTools$expNameForEIdWithDefault, _user$project$LangTools$defaultExpName, program, targetEId);
	});
var _user$project$LangTools$commonNameForEIdsWithDefault = F3(
	function (defaultName, program, eids) {
		var expNames = A2(
			_elm_lang$core$List$map,
			_user$project$LangTools$expNameForEId(program),
			eids);
		var prefixCandidate = _user$project$LangTools$removeLeadingDigits(
			_user$project$Utils$commonPrefixString(expNames));
		var suffixCandidate = _user$project$LangTools$removeLeadingDigits(
			_user$project$Utils$commonSuffixString(expNames));
		var candidate = function () {
			var candidate = _elm_lang$core$Native_Utils.eq(prefixCandidate, '') ? suffixCandidate : (_elm_lang$core$Native_Utils.eq(suffixCandidate, '') ? prefixCandidate : (_elm_lang$core$Native_Utils.eq(prefixCandidate, _user$project$LangTools$defaultExpName) ? suffixCandidate : (_elm_lang$core$Native_Utils.eq(suffixCandidate, _user$project$LangTools$defaultExpName) ? prefixCandidate : (_elm_lang$core$Native_Utils.eq(prefixCandidate, 'num') ? suffixCandidate : (_elm_lang$core$Native_Utils.eq(suffixCandidate, 'num') ? prefixCandidate : ((_elm_lang$core$Native_Utils.cmp(
				_elm_lang$core$String$length(prefixCandidate),
				_elm_lang$core$String$length(suffixCandidate)) < 0) ? suffixCandidate : prefixCandidate))))));
			return _user$project$LangTools$downcaseLeadingCapitals(candidate);
		}();
		return (_elm_lang$core$Native_Utils.eq(candidate, '') || (_elm_lang$core$Native_Utils.eq(candidate, 'num') || _elm_lang$core$Native_Utils.eq(candidate, _user$project$LangTools$defaultExpName))) ? A2(
			_elm_lang$core$Maybe$withDefault,
			_elm_lang$core$Native_Utils.eq(candidate, '') ? defaultName : candidate,
			A2(
				_elm_lang$core$Maybe$map,
				function (nums) {
					return (_elm_lang$core$Native_Utils.eq(
						A2(
							_elm_lang$core$List$map,
							function (_p527) {
								return _elm_lang$core$Basics$toFloat(
									_elm_lang$core$Basics$round(_p527));
							},
							nums),
						nums) && (_elm_lang$core$Native_Utils.eq(
						_user$project$Utils$dedup(nums),
						nums) && ((A2(_elm_lang$core$List$member, 0, nums) || A2(_elm_lang$core$List$member, 1, nums)) && A2(
						_elm_lang$core$List$all,
						function (n) {
							return (_elm_lang$core$Native_Utils.cmp(0, n) < 1) && (_elm_lang$core$Native_Utils.cmp(n, 10) < 0);
						},
						nums)))) ? 'i' : 'num';
				},
				_user$project$Utils$projJusts(
					A2(
						_elm_lang$core$List$map,
						function (eid) {
							return A2(
								_elm_lang$core$Maybe$andThen,
								_user$project$LangTools$expToMaybeNum,
								A2(_user$project$Lang$findExpByEId, program, eid));
						},
						eids)))) : candidate;
	});
var _user$project$LangTools$commonNameForEIds = F2(
	function (program, eids) {
		return A3(_user$project$LangTools$commonNameForEIdsWithDefault, _user$project$LangTools$defaultExpName, program, eids);
	});
var _user$project$LangTools$expNameForExpWithDefault = F3(
	function ($default, program, exp) {
		var _p528 = A2(
			_user$project$Utils$takeLast,
			1,
			A2(
				_user$project$LangTools$expDescriptionParts,
				program,
				_user$project$Lang$expEId(exp)));
		if ((_p528.ctor === '::') && (_p528._1.ctor === '[]')) {
			return _p528._0;
		} else {
			return A2(_user$project$LangTools$simpleExpNameWithDefault, $default, exp);
		}
	});
var _user$project$LangTools$expNameForExp = F2(
	function (program, exp) {
		return A3(_user$project$LangTools$expNameForExpWithDefault, _user$project$LangTools$defaultExpName, program, exp);
	});
var _user$project$LangTools$maybeResolveIdentifierToExp = F3(
	function (ident, viewerEId, program) {
		var _p529 = A3(_user$project$LangTools$resolveIdentifierToExp, ident, viewerEId, program);
		if ((_p529.ctor === 'Just') && (_p529._0.ctor === 'Bound')) {
			return _elm_lang$core$Maybe$Just(_p529._0._0);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$LangTools$eidToMaybeCorrespondingArgumentPathedPatId = F2(
	function (program, targetEId) {
		return A2(
			_user$project$Utils$mapFirstSuccess,
			function (exp) {
				var _p530 = _user$project$Lang$unwrapExp(exp);
				if (_p530.ctor === 'EApp') {
					var _p537 = _p530._1;
					var _p531 = _user$project$Lang$unwrapExp(_p537);
					if (_p531.ctor === 'EVar') {
						var _p532 = A3(
							_user$project$LangTools$resolveIdentifierToExp,
							_p531._1,
							_user$project$Lang$expEId(_p537),
							program);
						if ((_p532.ctor === 'Just') && (_p532._0.ctor === 'Bound')) {
							var _p536 = _p532._0._0;
							var _p533 = {
								ctor: '_Tuple2',
								_0: _user$project$Lang$unwrapExp(_p536),
								_1: _user$project$LeoParser$isPreludeEId(
									_user$project$Lang$expEId(_p536))
							};
							if (((_p533.ctor === '_Tuple2') && (_p533._0.ctor === 'EFun')) && (_p533._1 === false)) {
								return A2(
									_user$project$Utils$mapFirstSuccess,
									function (_p534) {
										var _p535 = _p534;
										return _elm_lang$core$Native_Utils.eq(
											_user$project$Lang$expEId(_p535._2),
											targetEId) ? _elm_lang$core$Maybe$Just(
											{
												ctor: '_Tuple2',
												_0: {
													ctor: '_Tuple2',
													_0: _user$project$Lang$expEId(_p536),
													_1: _p535._0
												},
												_1: _p535._1
											}) : _elm_lang$core$Maybe$Nothing;
									},
									A2(_user$project$LangTools$tryMatchExpsPatsToPathsAtFunctionCall, _p533._0._1, _p530._2));
							} else {
								return _elm_lang$core$Maybe$Nothing;
							}
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					} else {
						return _elm_lang$core$Maybe$Nothing;
					}
				} else {
					return _elm_lang$core$Maybe$Nothing;
				}
			},
			A2(
				_elm_lang$core$Maybe$withDefault,
				{ctor: '[]'},
				A2(_user$project$Lang$findWithAncestorsByEId, program, targetEId)));
	});

var _user$project$EvalUpdate$mdOf = function (_p0) {
	return _user$project$ImpureGoodies$whitespaceToMetadata(
		function (_) {
			return _.val;
		}(_p0));
};
var _user$project$EvalUpdate$toArray = _user$project$ImpureGoodies$toNativeArray;
var _user$project$EvalUpdate$fromArray = _user$project$ImpureGoodies$fromNativeArray;
var _user$project$EvalUpdate$wsMetadata = F2(
	function (callback, metadata) {
		var wsb = _user$project$Lang$ws(
			_user$project$ImpureGoodies$whitespaceFromMetadata(metadata));
		return callback(wsb);
	});
var _user$project$EvalUpdate$lang = {
	eBase: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, value) {
				return _user$project$Lang$withDummyExpInfo(
					A2(
						_user$project$Utils$fromOk,
						'EvalUpdate',
						A4(
							_user$project$ImpureGoodies$matchBaseValue,
							value,
							function (_p1) {
								return A2(
									_user$project$Lang$EBase,
									wsb,
									_user$project$Lang$EBool(_p1));
							},
							function (_p2) {
								return A2(
									_user$project$Lang$EBase,
									wsb,
									A2(_user$project$Lang$EString, '\"', _p2));
							},
							function (n) {
								return A4(_user$project$Lang$EConst, wsb, n, _user$project$Lang$dummyLoc, _user$project$Lang$noWidgetDecl);
							})));
			})),
	eVar: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, name) {
				return _user$project$Lang$withDummyExpInfo(
					A2(_user$project$Lang$EVar, wsb, name));
			})),
	eFun: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, arraypats, body) {
				return _user$project$Lang$withDummyExpInfo(
					A4(
						_user$project$Lang$EFun,
						wsb,
						_user$project$EvalUpdate$fromArray(arraypats),
						body,
						_user$project$Lang$space0));
			})),
	eApp: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, e1, e2s) {
				return _user$project$Lang$withDummyExpInfo(
					A5(
						_user$project$Lang$EApp,
						wsb,
						e1,
						_user$project$EvalUpdate$fromArray(e2s),
						_user$project$Lang$SpaceApp,
						_user$project$Lang$space0));
			})),
	eOp: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, opStr, e2s) {
				var op = _user$project$Lang$withDummyRange(
					A2(
						_user$project$Utils$fromJust_,
						A2(
							_elm_lang$core$Basics_ops['++'],
							'The operator ',
							A2(_elm_lang$core$Basics_ops['++'], opStr, ' is not supported')),
						_user$project$LeoParser$opFromIdentifier(opStr)));
				return _user$project$Lang$withDummyExpInfo(
					A5(
						_user$project$Lang$EOp,
						wsb,
						_user$project$Lang$space1,
						op,
						_user$project$EvalUpdate$fromArray(e2s),
						_user$project$Lang$space0));
			})),
	eList: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, wsExps) {
				return _user$project$Lang$withDummyExpInfo(
					A5(
						_user$project$Lang$EList,
						wsb,
						A2(
							_elm_lang$core$List$map,
							F2(
								function (v0, v1) {
									return {ctor: '_Tuple2', _0: v0, _1: v1};
								})(_user$project$Lang$space0),
							_user$project$EvalUpdate$fromArray(wsExps)),
						_user$project$Lang$space0,
						_elm_lang$core$Maybe$Nothing,
						_user$project$Lang$space0));
			})),
	eCons: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, head, tail) {
				return _user$project$Lang$withDummyExpInfo(
					A5(
						_user$project$Lang$EList,
						wsb,
						{
							ctor: '::',
							_0: {ctor: '_Tuple2', _0: _user$project$Lang$space0, _1: head},
							_1: {ctor: '[]'}
						},
						_user$project$Lang$space1,
						_elm_lang$core$Maybe$Just(tail),
						_user$project$Lang$space0));
			})),
	eIf: _user$project$EvalUpdate$wsMetadata(
		F4(
			function (wsb, cond, thn, els) {
				return _user$project$Lang$withDummyExpInfo(
					A7(_user$project$Lang$EIf, wsb, cond, _user$project$Lang$space1, thn, _user$project$Lang$space1, els, _user$project$Lang$space0));
			})),
	eCase: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, input, branches) {
				return _user$project$Lang$withDummyExpInfo(
					A4(
						_user$project$Lang$ECase,
						wsb,
						input,
						_user$project$EvalUpdate$fromArray(branches),
						_user$project$Lang$space0));
			})),
	eLet: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, declarations, body) {
				return _user$project$Lang$withDummyExpInfo(
					A5(_user$project$Lang$ELet, wsb, _user$project$Lang$Let, declarations, _user$project$Lang$space1, body));
			})),
	eParens: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, exp, style) {
				return _user$project$Lang$withDummyExpInfo(
					A4(
						_user$project$Lang$EParens,
						wsb,
						exp,
						_elm_lang$core$Native_Utils.eq(style, '') ? _user$project$Lang$Parens : _user$project$Lang$CustomSyntax(style),
						_user$project$Lang$space0));
			})),
	eRecord: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, declarations) {
				return _user$project$Lang$withDummyExpInfo(
					A4(_user$project$Lang$ERecord, wsb, _elm_lang$core$Maybe$Nothing, declarations, _user$project$Lang$space0));
			})),
	eRecordExtend: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, previous, declarations) {
				return _user$project$Lang$withDummyExpInfo(
					A4(
						_user$project$Lang$ERecord,
						wsb,
						_elm_lang$core$Maybe$Just(
							{ctor: '_Tuple2', _0: previous, _1: _user$project$Lang$space1}),
						declarations,
						_user$project$Lang$space0));
			})),
	eSelect: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, expr, name) {
				return _user$project$Lang$withDummyExpInfo(
					A5(_user$project$Lang$ESelect, wsb, expr, _user$project$Lang$space0, _user$project$Lang$space0, name));
			})),
	letTypeAlias: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat, t) {
				return A7(_user$project$Lang$LetType, _elm_lang$core$Maybe$Nothing, wsb, _elm_lang$core$Maybe$Nothing, pat, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, t);
			})),
	letTypeData: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat, t) {
				return A7(
					_user$project$Lang$LetType,
					_elm_lang$core$Maybe$Nothing,
					wsb,
					_elm_lang$core$Maybe$Just(_user$project$Lang$space1),
					pat,
					_user$project$Lang$FunArgAsPats,
					_user$project$Lang$space1,
					t);
			})),
	letAnnotation: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat, t) {
				return A6(_user$project$Lang$LetAnnotation, _elm_lang$core$Maybe$Nothing, wsb, pat, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, t);
			})),
	letExp: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat, exp) {
				return A6(_user$project$Lang$LetExp, _elm_lang$core$Maybe$Nothing, wsb, pat, _user$project$Lang$FunArgAsPats, _user$project$Lang$space1, exp);
			})),
	declType: _user$project$Lang$DeclType,
	declExp: _user$project$Lang$DeclExp,
	declAnnotation: _user$project$Lang$DeclAnnotation,
	declarations: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, declarationList) {
				var _p3 = _user$project$LeoParser$reorderDeclarations(
					_user$project$EvalUpdate$fromArray(declarationList));
				if (_p3.ctor === 'Err') {
					return _elm_lang$core$Native_Utils.crashCase(
						'EvalUpdate',
						{
							start: {line: 1365, column: 9},
							end: {line: 1367, column: 42}
						},
						_p3)(_p3._0);
				} else {
					return _p3._0;
				}
			})),
	branch: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat, exp) {
				return _user$project$Lang$withDummyRange(
					A4(_user$project$Lang$Branch_, wsb, pat, exp, _user$project$Lang$space1));
			})),
	pVar: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, name) {
				return _user$project$Lang$withDummyPatInfo(
					A3(_user$project$Lang$PVar, wsb, name, _user$project$Lang$noWidgetDecl));
			})),
	pBase: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, value) {
				return _user$project$Lang$withDummyPatInfo(
					A2(
						_user$project$Utils$fromOk,
						'EvalUpdate',
						A4(
							_user$project$ImpureGoodies$matchBaseValue,
							value,
							function (_p5) {
								return A2(
									_user$project$Lang$PBase,
									wsb,
									_user$project$Lang$EBool(_p5));
							},
							function (_p6) {
								return A2(
									_user$project$Lang$PBase,
									wsb,
									A2(_user$project$Lang$EString, '\"', _p6));
							},
							function (n) {
								return A2(_user$project$Lang$PConst, wsb, n);
							})));
			})),
	pWildcard: _user$project$EvalUpdate$wsMetadata(
		function (_p7) {
			return _user$project$Lang$withDummyPatInfo(
				_user$project$Lang$PWildcard(_p7));
		}),
	pList: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, wsPats) {
				return _user$project$Lang$withDummyPatInfo(
					A5(
						_user$project$Lang$PList,
						wsb,
						_user$project$EvalUpdate$fromArray(wsPats),
						_user$project$Lang$space0,
						_elm_lang$core$Maybe$Nothing,
						_user$project$Lang$space0));
			})),
	pCons: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, head, tail) {
				return _user$project$Lang$withDummyPatInfo(
					A5(
						_user$project$Lang$PList,
						wsb,
						{
							ctor: '::',
							_0: head,
							_1: {ctor: '[]'}
						},
						_user$project$Lang$space1,
						_elm_lang$core$Maybe$Just(tail),
						_user$project$Lang$space0));
			})),
	pRecord: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, pats) {
				return _user$project$Lang$withDummyPatInfo(
					A3(
						_user$project$Lang$PRecord,
						wsb,
						A2(
							_elm_lang$core$List$map,
							function (_p8) {
								var _p9 = _p8;
								return {
									ctor: '_Tuple5',
									_0: _elm_lang$core$Maybe$Just(_user$project$Lang$space0),
									_1: _user$project$Lang$ws(
										_user$project$ImpureGoodies$whitespaceFromMetadata(_p9.metadata)),
									_2: _p9.name,
									_3: _user$project$Lang$space1,
									_4: _p9.pat
								};
							},
							_user$project$EvalUpdate$fromArray(pats)),
						_user$project$Lang$space0));
			})),
	pParens: _user$project$EvalUpdate$wsMetadata(
		F2(
			function (wsb, pat) {
				return _user$project$Lang$withDummyPatInfo(
					A3(_user$project$Lang$PParens, wsb, pat, _user$project$Lang$space0));
			})),
	pAs: _user$project$EvalUpdate$wsMetadata(
		F3(
			function (wsb, pat1, pat2) {
				return _user$project$Lang$withDummyPatInfo(
					A4(_user$project$Lang$PAs, wsb, pat1, _user$project$Lang$space1, pat2));
			})),
	unapply: {
		eBase: function (exp) {
			var _p10 = _user$project$Lang$unwrapExp(exp);
			_v2_3:
			do {
				switch (_p10.ctor) {
					case 'EConst':
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: _user$project$EvalUpdate$mdOf(_p10._0),
								_1: _user$project$ImpureGoodies$hideType(_p10._1)
							});
					case 'EBase':
						switch (_p10._1.ctor) {
							case 'EBool':
								return _elm_lang$core$Maybe$Just(
									{
										ctor: '_Tuple2',
										_0: _user$project$EvalUpdate$mdOf(_p10._0),
										_1: _user$project$ImpureGoodies$hideType(_p10._1._0)
									});
							case 'EString':
								return _elm_lang$core$Maybe$Just(
									{
										ctor: '_Tuple2',
										_0: _user$project$EvalUpdate$mdOf(_p10._0),
										_1: _user$project$ImpureGoodies$hideType(_p10._1._1)
									});
							default:
								break _v2_3;
						}
					default:
						break _v2_3;
				}
			} while(false);
			return _elm_lang$core$Maybe$Nothing;
		},
		eVar: function (exp) {
			var _p11 = _user$project$Lang$unwrapExp(exp);
			if (_p11.ctor === 'EVar') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p11._0),
						_1: _p11._1
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eFun: function (exp) {
			var _p12 = _user$project$Lang$unwrapExp(exp);
			if (_p12.ctor === 'EFun') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p12._0),
						_1: _user$project$EvalUpdate$toArray(_p12._1),
						_2: _p12._2
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eApp: function (exp) {
			var _p13 = _user$project$Lang$unwrapExp(exp);
			if (_p13.ctor === 'EApp') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p13._0),
						_1: _p13._1,
						_2: _user$project$EvalUpdate$toArray(_p13._2)
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eOp: function (exp) {
			var _p14 = _user$project$Lang$unwrapExp(exp);
			if (_p14.ctor === 'EOp') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p14._0),
						_1: _user$project$LeoUnparser$unparseOp(_p14._2),
						_2: _user$project$EvalUpdate$toArray(_p14._3)
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eList: function (exp) {
			var _p15 = _user$project$Lang$unwrapExp(exp);
			if ((_p15.ctor === 'EList') && (_p15._3.ctor === 'Nothing')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p15._0),
						_1: _user$project$EvalUpdate$toArray(
							A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$second, _p15._1))
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eCons: function (exp) {
			var _p16 = _user$project$Lang$unwrapExp(exp);
			if (((((_p16.ctor === 'EList') && (_p16._1.ctor === '::')) && (_p16._1._0.ctor === '_Tuple2')) && (_p16._1._1.ctor === '[]')) && (_p16._3.ctor === 'Just')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p16._0),
						_1: _p16._1._0._1,
						_2: _p16._3._0
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eIf: function (exp) {
			var _p17 = _user$project$Lang$unwrapExp(exp);
			if (_p17.ctor === 'EIf') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple4',
						_0: _user$project$EvalUpdate$mdOf(_p17._0),
						_1: _p17._1,
						_2: _p17._3,
						_3: _p17._5
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eCase: function (exp) {
			var _p18 = _user$project$Lang$unwrapExp(exp);
			if (_p18.ctor === 'ECase') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p18._0),
						_1: _p18._1,
						_2: _user$project$EvalUpdate$toArray(_p18._2)
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eLet: function (exp) {
			var _p19 = _user$project$Lang$unwrapExp(exp);
			if (_p19.ctor === 'ELet') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p19._0),
						_1: _p19._2,
						_2: _p19._4
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eParens: function (exp) {
			var _p20 = _user$project$Lang$unwrapExp(exp);
			if (_p20.ctor === 'EParens') {
				if (_p20._2.ctor === 'CustomSyntax') {
					return _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple3',
							_0: _user$project$EvalUpdate$mdOf(_p20._0),
							_1: _p20._1,
							_2: _p20._2._0
						});
				} else {
					return _elm_lang$core$Maybe$Just(
						{
							ctor: '_Tuple3',
							_0: _user$project$EvalUpdate$mdOf(_p20._0),
							_1: _p20._1,
							_2: ''
						});
				}
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eRecord: function (exp) {
			var _p21 = _user$project$Lang$unwrapExp(exp);
			if ((_p21.ctor === 'ERecord') && (_p21._1.ctor === 'Nothing')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p21._0),
						_1: _p21._2
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eRecordExtend: function (exp) {
			var _p22 = _user$project$Lang$unwrapExp(exp);
			if (((_p22.ctor === 'ERecord') && (_p22._1.ctor === 'Just')) && (_p22._1._0.ctor === '_Tuple2')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p22._0),
						_1: _p22._1._0._0,
						_2: _p22._2
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		eSelect: function (exp) {
			var _p23 = _user$project$Lang$unwrapExp(exp);
			if (_p23.ctor === 'ESelect') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p23._0),
						_1: exp,
						_2: _p23._4
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		letTypeAlias: function (letType) {
			var _p24 = letType;
			if ((_p24._0.ctor === 'Nothing') && (_p24._2.ctor === 'Nothing')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p24._1),
						_1: _p24._3,
						_2: _p24._6
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		letTypeData: function (letType) {
			var _p25 = letType;
			if ((_p25._0.ctor === 'Nothing') && (_p25._2.ctor === 'Just')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p25._1),
						_1: _p25._3,
						_2: _p25._6
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		letAnnotation: function (_p26) {
			var _p27 = _p26;
			return {
				ctor: '_Tuple3',
				_0: _user$project$EvalUpdate$mdOf(_p27._1),
				_1: _p27._2,
				_2: _p27._5
			};
		},
		letExp: function (_p28) {
			var _p29 = _p28;
			return {
				ctor: '_Tuple3',
				_0: _user$project$EvalUpdate$mdOf(_p29._1),
				_1: _p29._2,
				_2: _p29._5
			};
		},
		declType: function (d) {
			var _p30 = d;
			if (_p30.ctor === 'DeclType') {
				return _elm_lang$core$Maybe$Just(_p30._0);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		declAnnotation: function (d) {
			var _p31 = d;
			if (_p31.ctor === 'DeclAnnotation') {
				return _elm_lang$core$Maybe$Just(_p31._0);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		declExp: function (d) {
			var _p32 = d;
			if (_p32.ctor === 'DeclExp') {
				return _elm_lang$core$Maybe$Just(_p32._0);
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		declarations: function (declarations) {
			return _user$project$EvalUpdate$toArray(
				_user$project$Lang$getDeclarationsInOrder(declarations));
		},
		branch: function (b) {
			var _p33 = b.val;
			return {
				ctor: '_Tuple3',
				_0: _user$project$EvalUpdate$mdOf(_p33._0),
				_1: _p33._1,
				_2: _p33._2
			};
		},
		pVar: function (p) {
			var _p34 = p.val.p__;
			if (_p34.ctor === 'PVar') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p34._0),
						_1: _p34._1
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pBase: function (p) {
			var _p35 = p.val.p__;
			_v25_3:
			do {
				switch (_p35.ctor) {
					case 'PBase':
						switch (_p35._1.ctor) {
							case 'EBool':
								return _elm_lang$core$Maybe$Just(
									{
										ctor: '_Tuple2',
										_0: _user$project$EvalUpdate$mdOf(_p35._0),
										_1: _user$project$ImpureGoodies$hideType(_p35._1._0)
									});
							case 'EString':
								return _elm_lang$core$Maybe$Just(
									{
										ctor: '_Tuple2',
										_0: _user$project$EvalUpdate$mdOf(_p35._0),
										_1: _user$project$ImpureGoodies$hideType(_p35._1._1)
									});
							default:
								break _v25_3;
						}
					case 'PConst':
						return _elm_lang$core$Maybe$Just(
							{
								ctor: '_Tuple2',
								_0: _user$project$EvalUpdate$mdOf(_p35._0),
								_1: _user$project$ImpureGoodies$hideType(_p35._1)
							});
					default:
						break _v25_3;
				}
			} while(false);
			return _elm_lang$core$Maybe$Nothing;
		},
		pWildcard: function (p) {
			var _p36 = p.val.p__;
			if (_p36.ctor === 'PWildcard') {
				return _elm_lang$core$Maybe$Just(
					_user$project$EvalUpdate$mdOf(_p36._0));
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pList: function (p) {
			var _p37 = p.val.p__;
			if ((_p37.ctor === 'PList') && (_p37._3.ctor === 'Nothing')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p37._0),
						_1: _user$project$EvalUpdate$toArray(_p37._1)
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pCons: function (p) {
			var _p38 = p.val.p__;
			if ((((_p38.ctor === 'PList') && (_p38._1.ctor === '::')) && (_p38._1._1.ctor === '[]')) && (_p38._3.ctor === 'Just')) {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p38._0),
						_1: _p38._1._0,
						_2: _p38._3._0
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pRecord: function (p) {
			var _p39 = p.val.p__;
			if (_p39.ctor === 'PRecord') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p39._0),
						_1: _user$project$EvalUpdate$toArray(
							A2(
								_elm_lang$core$List$map,
								function (_p40) {
									var _p41 = _p40;
									return {
										metadata: _user$project$EvalUpdate$mdOf(_p41._1),
										name: _p41._2,
										pat: _p41._4
									};
								},
								_p39._1))
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pParens: function (p) {
			var _p42 = p.val.p__;
			if (_p42.ctor === 'PParens') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple2',
						_0: _user$project$EvalUpdate$mdOf(_p42._0),
						_1: _p42._1
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		},
		pAs: function (p) {
			var _p43 = p.val.p__;
			if (_p43.ctor === 'PAs') {
				return _elm_lang$core$Maybe$Just(
					{
						ctor: '_Tuple3',
						_0: _user$project$EvalUpdate$mdOf(_p43._0),
						_1: _p43._1,
						_2: _p43._3
					});
			} else {
				return _elm_lang$core$Maybe$Nothing;
			}
		}
	}
};
var _user$project$EvalUpdate$lazyList = {
	nonEmpty: function (l) {
		var _p44 = l;
		if (_p44.ctor === 'Nil') {
			return false;
		} else {
			return true;
		}
	},
	isEmpty: function (l) {
		var _p45 = l;
		if (_p45.ctor === 'Nil') {
			return true;
		} else {
			return false;
		}
	},
	head: function (l) {
		var _p46 = l;
		if (_p46.ctor === 'Nil') {
			return _elm_lang$core$Native_Utils.crashCase(
				'EvalUpdate',
				{
					start: {line: 1224, column: 16},
					end: {line: 1226, column: 28}
				},
				_p46)('Head of empty lazy list');
		} else {
			return _p46._0;
		}
	},
	tail: function (l) {
		var _p48 = l;
		if (_p48.ctor === 'Nil') {
			return _elm_lang$core$Native_Utils.crashCase(
				'EvalUpdate',
				{
					start: {line: 1227, column: 16},
					end: {line: 1229, column: 40}
				},
				_p48)('Tail of empty lazy list');
		} else {
			return _elm_lang$lazy$Lazy$force(_p48._1);
		}
	}
};
var _user$project$EvalUpdate$unparse = function (e) {
	return A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, e);
};
var _user$project$EvalUpdate$parse = function (s) {
	return A2(
		_elm_lang$core$Result$mapError,
		_user$project$ParserUtils$showError,
		A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, s));
};
var _user$project$EvalUpdate$compile = function (e) {
	return _elm_lang$core$Native_Utils.crash(
		'EvalUpdate',
		{
			start: {line: 972, column: 13},
			end: {line: 972, column: 24}
		})('not implemented compile yet');
};
var _user$project$EvalUpdate$compileEnv = function (e) {
	return _elm_lang$core$Native_Utils.crash(
		'EvalUpdate',
		{
			start: {line: 969, column: 16},
			end: {line: 969, column: 27}
		})('not implemented compile yet');
};
var _user$project$EvalUpdate$compileVal = function (e) {
	return _elm_lang$core$Native_Utils.crash(
		'EvalUpdate',
		{
			start: {line: 966, column: 16},
			end: {line: 966, column: 27}
		})('not implemented compile yet');
};
var _user$project$EvalUpdate$update = function (updateStack) {
	return A3(_user$project$Update$update, _user$project$LazyList$Nil, _user$project$LazyList$Nil, updateStack);
};
var _user$project$EvalUpdate$eval = F2(
	function (env, e) {
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			A4(_user$project$Eval$doEval, _user$project$Eval$withoutParentsProvenanceWidgets, _user$project$Syntax$Leo, env, e));
	});
var _user$project$EvalUpdate$twoArgsUpdate = F6(
	function (msg, fun, args, a, b, c) {
		var _p50 = args;
		if (((_p50.ctor === '::') && (_p50._1.ctor === '::')) && (_p50._1._1.ctor === '[]')) {
			return A5(fun, _p50._0, _p50._1._0, a, b, c);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					msg,
					A2(
						_elm_lang$core$Basics_ops['++'],
						' takes 2 arguments, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args)))));
		}
	});
var _user$project$EvalUpdate$oneArgUpdate = F6(
	function (msg, fun, args, a, b, c) {
		var _p51 = args;
		if ((_p51.ctor === '::') && (_p51._1.ctor === '[]')) {
			return A4(fun, _p51._0, a, b, c);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					msg,
					A2(
						_elm_lang$core$Basics_ops['++'],
						' takes 1 argument, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args)))));
		}
	});
var _user$project$EvalUpdate$twoArgs = F3(
	function (msg, fun, args) {
		var _p52 = args;
		if (((_p52.ctor === '::') && (_p52._1.ctor === '::')) && (_p52._1._1.ctor === '[]')) {
			return A2(fun, _p52._0, _p52._1._0);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					msg,
					A2(
						_elm_lang$core$Basics_ops['++'],
						' takes 2 arguments, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args)))));
		}
	});
var _user$project$EvalUpdate$oneArg = F3(
	function (msg, fun, args) {
		var _p53 = args;
		if ((_p53.ctor === '::') && (_p53._1.ctor === '[]')) {
			return fun(_p53._0);
		} else {
			return _elm_lang$core$Result$Err(
				A2(
					_elm_lang$core$Basics_ops['++'],
					msg,
					A2(
						_elm_lang$core$Basics_ops['++'],
						' takes 1 argument, got ',
						_elm_lang$core$Basics$toString(
							_elm_lang$core$List$length(args)))));
		}
	});
var _user$project$EvalUpdate$builtinEnv = {
	ctor: '::',
	_0: {
		ctor: '_Tuple2',
		_0: 'error',
		_1: A2(
			_user$project$Lang$builtinVal,
			'EvalUpdate.error',
			A4(
				_user$project$Lang$VFun,
				'error',
				{
					ctor: '::',
					_0: 'msg',
					_1: {ctor: '[]'}
				},
				A2(
					_user$project$EvalUpdate$oneArg,
					'error',
					function (arg) {
						var _p54 = arg.v_;
						if ((_p54.ctor === 'VBase') && (_p54._0.ctor === 'VString')) {
							return _elm_lang$core$Result$Err(_p54._0._0);
						} else {
							return _elm_lang$core$Result$Err(
								_user$project$LangUtils$valToString(arg));
						}
					}),
				_elm_lang$core$Maybe$Nothing))
	},
	_1: {
		ctor: '::',
		_0: {ctor: '_Tuple2', _0: 'parseHTML', _1: _user$project$HTMLValParser$htmlValParser},
		_1: {
			ctor: '::',
			_0: {
				ctor: '_Tuple2',
				_0: '&&',
				_1: A2(
					_user$project$Lang$builtinVal,
					'EvalUpdate.&&',
					A4(
						_user$project$Lang$VFun,
						'&&',
						{
							ctor: '::',
							_0: 'left',
							_1: {
								ctor: '::',
								_0: 'right',
								_1: {ctor: '[]'}
							}
						},
						A2(
							_user$project$EvalUpdate$twoArgs,
							'&&',
							F2(
								function (left, right) {
									var _p55 = left.v_;
									if ((_p55.ctor === 'VBase') && (_p55._0.ctor === 'VBool')) {
										if (_p55._0._0 === true) {
											return _elm_lang$core$Result$Ok(
												{
													ctor: '_Tuple2',
													_0: right,
													_1: {ctor: '[]'}
												});
										} else {
											return _elm_lang$core$Result$Ok(
												{
													ctor: '_Tuple2',
													_0: left,
													_1: {ctor: '[]'}
												});
										}
									} else {
										return _elm_lang$core$Result$Err(
											A2(
												_elm_lang$core$Basics_ops['++'],
												'&& expects two booleans, got ',
												_user$project$LangUtils$valToString(left)));
									}
								})),
						_elm_lang$core$Maybe$Just(
							A2(
								_user$project$EvalUpdate$twoArgsUpdate,
								'&&',
								F5(
									function (left, right, oldVal, newVal, diffs) {
										var _p56 = {ctor: '_Tuple2', _0: oldVal.v_, _1: newVal.v_};
										_v43_2:
										do {
											if (((_p56.ctor === '_Tuple2') && (_p56._0.ctor === 'VBase')) && (_p56._0._0.ctor === 'VBool')) {
												if (_p56._0._0._0 === true) {
													if (((_p56._1.ctor === 'VBase') && (_p56._1._0.ctor === 'VBool')) && (_p56._1._0._0 === false)) {
														return _user$project$Results$oks(
															{
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: {
																		ctor: '::',
																		_0: newVal,
																		_1: {
																			ctor: '::',
																			_0: oldVal,
																			_1: {ctor: '[]'}
																		}
																	},
																	_1: {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																		_1: {ctor: '[]'}
																	}
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: {
																			ctor: '::',
																			_0: oldVal,
																			_1: {
																				ctor: '::',
																				_0: newVal,
																				_1: {ctor: '[]'}
																			}
																		},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																			_1: {ctor: '[]'}
																		}
																	},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: {
																				ctor: '::',
																				_0: newVal,
																				_1: {
																					ctor: '::',
																					_0: newVal,
																					_1: {ctor: '[]'}
																				}
																			},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																					_1: {ctor: '[]'}
																				}
																			}
																		},
																		_1: {ctor: '[]'}
																	}
																}
															});
													} else {
														break _v43_2;
													}
												} else {
													if (((_p56._1.ctor === 'VBase') && (_p56._1._0.ctor === 'VBool')) && (_p56._1._0._0 === true)) {
														var leftDiff = function () {
															var _p57 = left.v_;
															if (((_p57.ctor === 'VBase') && (_p57._0.ctor === 'VBool')) && (_p57._0._0 === true)) {
																return {ctor: '[]'};
															} else {
																return {
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																	_1: {ctor: '[]'}
																};
															}
														}();
														var rightDiff = function () {
															var _p58 = right.v_;
															if (((_p58.ctor === 'VBase') && (_p58._0.ctor === 'VBool')) && (_p58._0._0 === true)) {
																return {ctor: '[]'};
															} else {
																return {
																	ctor: '::',
																	_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																	_1: {ctor: '[]'}
																};
															}
														}();
														return _user$project$Results$ok1(
															{
																ctor: '_Tuple2',
																_0: {
																	ctor: '::',
																	_0: newVal,
																	_1: {
																		ctor: '::',
																		_0: newVal,
																		_1: {ctor: '[]'}
																	}
																},
																_1: A2(_elm_lang$core$Basics_ops['++'], leftDiff, rightDiff)
															});
													} else {
														break _v43_2;
													}
												}
											} else {
												break _v43_2;
											}
										} while(false);
										return _user$project$Results$ok1(
											{
												ctor: '_Tuple2',
												_0: {
													ctor: '::',
													_0: left,
													_1: {
														ctor: '::',
														_0: right,
														_1: {ctor: '[]'}
													}
												},
												_1: {ctor: '[]'}
											});
									})))))
			},
			_1: {
				ctor: '::',
				_0: {
					ctor: '_Tuple2',
					_0: '||',
					_1: A2(
						_user$project$Lang$builtinVal,
						'EvalUpdate.||',
						A4(
							_user$project$Lang$VFun,
							'||',
							{
								ctor: '::',
								_0: 'left',
								_1: {
									ctor: '::',
									_0: 'right',
									_1: {ctor: '[]'}
								}
							},
							A2(
								_user$project$EvalUpdate$twoArgs,
								'||',
								F2(
									function (left, right) {
										var _p59 = left.v_;
										if ((_p59.ctor === 'VBase') && (_p59._0.ctor === 'VBool')) {
											if (_p59._0._0 === true) {
												return _elm_lang$core$Result$Ok(
													{
														ctor: '_Tuple2',
														_0: left,
														_1: {ctor: '[]'}
													});
											} else {
												return _elm_lang$core$Result$Ok(
													{
														ctor: '_Tuple2',
														_0: right,
														_1: {ctor: '[]'}
													});
											}
										} else {
											return _elm_lang$core$Result$Err(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'|| expects two booleans, got ',
													_user$project$LangUtils$valToString(left)));
										}
									})),
							_elm_lang$core$Maybe$Just(
								A2(
									_user$project$EvalUpdate$twoArgsUpdate,
									'&&',
									F5(
										function (left, right, oldVal, newVal, diffs) {
											var _p60 = {ctor: '_Tuple2', _0: oldVal.v_, _1: newVal.v_};
											_v47_2:
											do {
												if (((_p60.ctor === '_Tuple2') && (_p60._0.ctor === 'VBase')) && (_p60._0._0.ctor === 'VBool')) {
													if (_p60._0._0._0 === false) {
														if (((_p60._1.ctor === 'VBase') && (_p60._1._0.ctor === 'VBool')) && (_p60._1._0._0 === true)) {
															return _user$project$Results$oks(
																{
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: {
																			ctor: '::',
																			_0: newVal,
																			_1: {
																				ctor: '::',
																				_0: oldVal,
																				_1: {ctor: '[]'}
																			}
																		},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																			_1: {ctor: '[]'}
																		}
																	},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: {
																				ctor: '::',
																				_0: oldVal,
																				_1: {
																					ctor: '::',
																					_0: newVal,
																					_1: {ctor: '[]'}
																				}
																			},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																				_1: {ctor: '[]'}
																			}
																		},
																		_1: {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: {
																					ctor: '::',
																					_0: newVal,
																					_1: {
																						ctor: '::',
																						_0: newVal,
																						_1: {ctor: '[]'}
																					}
																				},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																						_1: {ctor: '[]'}
																					}
																				}
																			},
																			_1: {ctor: '[]'}
																		}
																	}
																});
														} else {
															break _v47_2;
														}
													} else {
														if (((_p60._1.ctor === 'VBase') && (_p60._1._0.ctor === 'VBool')) && (_p60._1._0._0 === false)) {
															var leftDiff = function () {
																var _p61 = left.v_;
																if (((_p61.ctor === 'VBase') && (_p61._0.ctor === 'VBool')) && (_p61._0._0 === false)) {
																	return {ctor: '[]'};
																} else {
																	return {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																		_1: {ctor: '[]'}
																	};
																}
															}();
															var rightDiff = function () {
																var _p62 = right.v_;
																if (((_p62.ctor === 'VBase') && (_p62._0.ctor === 'VBool')) && (_p62._0._0 === false)) {
																	return {ctor: '[]'};
																} else {
																	return {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: 1, _1: _user$project$Lang$VConstDiffs},
																		_1: {ctor: '[]'}
																	};
																}
															}();
															return _user$project$Results$ok1(
																{
																	ctor: '_Tuple2',
																	_0: {
																		ctor: '::',
																		_0: newVal,
																		_1: {
																			ctor: '::',
																			_0: newVal,
																			_1: {ctor: '[]'}
																		}
																	},
																	_1: A2(_elm_lang$core$Basics_ops['++'], leftDiff, rightDiff)
																});
														} else {
															break _v47_2;
														}
													}
												} else {
													break _v47_2;
												}
											} while(false);
											return _user$project$Results$ok1(
												{
													ctor: '_Tuple2',
													_0: {
														ctor: '::',
														_0: left,
														_1: {
															ctor: '::',
															_0: right,
															_1: {ctor: '[]'}
														}
													},
													_1: {ctor: '[]'}
												});
										})))))
				},
				_1: {
					ctor: '::',
					_0: {
						ctor: '_Tuple2',
						_0: '<=',
						_1: A2(
							_user$project$Lang$builtinVal,
							'EvalUpdate.<=',
							A4(
								_user$project$Lang$VFun,
								'<=',
								{
									ctor: '::',
									_0: 'left',
									_1: {
										ctor: '::',
										_0: 'right',
										_1: {ctor: '[]'}
									}
								},
								A2(
									_user$project$EvalUpdate$twoArgs,
									'<=',
									F2(
										function (left, right) {
											var _p63 = {ctor: '_Tuple2', _0: left.v_, _1: right.v_};
											_v50_2:
											do {
												if (_p63.ctor === '_Tuple2') {
													switch (_p63._0.ctor) {
														case 'VConst':
															if (((_p63._0._1.ctor === '_Tuple2') && (_p63._1.ctor === 'VConst')) && (_p63._1._1.ctor === '_Tuple2')) {
																return _elm_lang$core$Result$Ok(
																	{
																		ctor: '_Tuple2',
																		_0: A2(
																			_user$project$Lang$replaceV_,
																			left,
																			_user$project$Lang$VBase(
																				_user$project$Lang$VBool(
																					_elm_lang$core$Native_Utils.cmp(_p63._0._1._0, _p63._1._1._0) < 1))),
																		_1: {ctor: '[]'}
																	});
															} else {
																break _v50_2;
															}
														case 'VBase':
															if (((_p63._0._0.ctor === 'VString') && (_p63._1.ctor === 'VBase')) && (_p63._1._0.ctor === 'VString')) {
																return _elm_lang$core$Result$Ok(
																	{
																		ctor: '_Tuple2',
																		_0: A2(
																			_user$project$Lang$replaceV_,
																			left,
																			_user$project$Lang$VBase(
																				_user$project$Lang$VBool(
																					_elm_lang$core$Native_Utils.cmp(_p63._0._0._0, _p63._1._0._0) < 1))),
																		_1: {ctor: '[]'}
																	});
															} else {
																break _v50_2;
															}
														default:
															break _v50_2;
													}
												} else {
													break _v50_2;
												}
											} while(false);
											return _elm_lang$core$Result$Err(
												A2(
													_elm_lang$core$Basics_ops['++'],
													'<= expects two numbers, got ',
													A2(
														_elm_lang$core$Basics_ops['++'],
														_user$project$LangUtils$valToString(left),
														A2(
															_elm_lang$core$Basics_ops['++'],
															' and ',
															_user$project$LangUtils$valToString(right)))));
										})),
								_elm_lang$core$Maybe$Nothing))
					},
					_1: {
						ctor: '::',
						_0: {
							ctor: '_Tuple2',
							_0: '>=',
							_1: A2(
								_user$project$Lang$builtinVal,
								'EvalUpdate.>=',
								A4(
									_user$project$Lang$VFun,
									'>=',
									{
										ctor: '::',
										_0: 'left',
										_1: {
											ctor: '::',
											_0: 'right',
											_1: {ctor: '[]'}
										}
									},
									A2(
										_user$project$EvalUpdate$twoArgs,
										'>=',
										F2(
											function (left, right) {
												var _p64 = {ctor: '_Tuple2', _0: left.v_, _1: right.v_};
												_v51_2:
												do {
													if (_p64.ctor === '_Tuple2') {
														switch (_p64._0.ctor) {
															case 'VConst':
																if (((_p64._0._1.ctor === '_Tuple2') && (_p64._1.ctor === 'VConst')) && (_p64._1._1.ctor === '_Tuple2')) {
																	return _elm_lang$core$Result$Ok(
																		{
																			ctor: '_Tuple2',
																			_0: A2(
																				_user$project$Lang$replaceV_,
																				left,
																				_user$project$Lang$VBase(
																					_user$project$Lang$VBool(
																						_elm_lang$core$Native_Utils.cmp(_p64._0._1._0, _p64._1._1._0) > -1))),
																			_1: {ctor: '[]'}
																		});
																} else {
																	break _v51_2;
																}
															case 'VBase':
																if (((_p64._0._0.ctor === 'VString') && (_p64._1.ctor === 'VBase')) && (_p64._1._0.ctor === 'VString')) {
																	return _elm_lang$core$Result$Ok(
																		{
																			ctor: '_Tuple2',
																			_0: A2(
																				_user$project$Lang$replaceV_,
																				left,
																				_user$project$Lang$VBase(
																					_user$project$Lang$VBool(
																						_elm_lang$core$Native_Utils.cmp(_p64._0._0._0, _p64._1._0._0) > -1))),
																			_1: {ctor: '[]'}
																		});
																} else {
																	break _v51_2;
																}
															default:
																break _v51_2;
														}
													} else {
														break _v51_2;
													}
												} while(false);
												return _elm_lang$core$Result$Err(
													A2(
														_elm_lang$core$Basics_ops['++'],
														'>= expects two numbers, got ',
														A2(
															_elm_lang$core$Basics_ops['++'],
															_user$project$LangUtils$valToString(left),
															A2(
																_elm_lang$core$Basics_ops['++'],
																' and ',
																_user$project$LangUtils$valToString(right)))));
											})),
									_elm_lang$core$Maybe$Nothing))
						},
						_1: {
							ctor: '::',
							_0: {
								ctor: '_Tuple2',
								_0: '>',
								_1: A2(
									_user$project$Lang$builtinVal,
									'EvalUpdate.>',
									A4(
										_user$project$Lang$VFun,
										'>',
										{
											ctor: '::',
											_0: 'left',
											_1: {
												ctor: '::',
												_0: 'right',
												_1: {ctor: '[]'}
											}
										},
										A2(
											_user$project$EvalUpdate$twoArgs,
											'>',
											F2(
												function (left, right) {
													var _p65 = {ctor: '_Tuple2', _0: left.v_, _1: right.v_};
													_v52_2:
													do {
														if (_p65.ctor === '_Tuple2') {
															switch (_p65._0.ctor) {
																case 'VConst':
																	if (((_p65._0._1.ctor === '_Tuple2') && (_p65._1.ctor === 'VConst')) && (_p65._1._1.ctor === '_Tuple2')) {
																		return _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple2',
																				_0: A2(
																					_user$project$Lang$replaceV_,
																					left,
																					_user$project$Lang$VBase(
																						_user$project$Lang$VBool(
																							_elm_lang$core$Native_Utils.cmp(_p65._0._1._0, _p65._1._1._0) > 0))),
																				_1: {ctor: '[]'}
																			});
																	} else {
																		break _v52_2;
																	}
																case 'VBase':
																	if (((_p65._0._0.ctor === 'VString') && (_p65._1.ctor === 'VBase')) && (_p65._1._0.ctor === 'VString')) {
																		return _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple2',
																				_0: A2(
																					_user$project$Lang$replaceV_,
																					left,
																					_user$project$Lang$VBase(
																						_user$project$Lang$VBool(
																							_elm_lang$core$Native_Utils.cmp(_p65._0._0._0, _p65._1._0._0) > 0))),
																				_1: {ctor: '[]'}
																			});
																	} else {
																		break _v52_2;
																	}
																default:
																	break _v52_2;
															}
														} else {
															break _v52_2;
														}
													} while(false);
													return _elm_lang$core$Result$Err(
														A2(
															_elm_lang$core$Basics_ops['++'],
															'> expects two numbers, got ',
															A2(
																_elm_lang$core$Basics_ops['++'],
																_user$project$LangUtils$valToString(left),
																A2(
																	_elm_lang$core$Basics_ops['++'],
																	' and ',
																	_user$project$LangUtils$valToString(right)))));
												})),
										_elm_lang$core$Maybe$Nothing))
							},
							_1: {
								ctor: '::',
								_0: {
									ctor: '_Tuple2',
									_0: '/=',
									_1: A2(
										_user$project$Lang$builtinVal,
										'EvalUpdate./=',
										A4(
											_user$project$Lang$VFun,
											'/=',
											{
												ctor: '::',
												_0: 'left',
												_1: {
													ctor: '::',
													_0: 'right',
													_1: {ctor: '[]'}
												}
											},
											A2(
												_user$project$EvalUpdate$twoArgs,
												'/=',
												F2(
													function (left, right) {
														var _p66 = {ctor: '_Tuple2', _0: left.v_, _1: right.v_};
														_v53_2:
														do {
															switch (_p66._0.ctor) {
																case 'VConst':
																	if (((_p66._0._1.ctor === '_Tuple2') && (_p66._1.ctor === 'VConst')) && (_p66._1._1.ctor === '_Tuple2')) {
																		return _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple2',
																				_0: A2(
																					_user$project$Lang$replaceV_,
																					left,
																					_user$project$Lang$VBase(
																						_user$project$Lang$VBool(
																							!_elm_lang$core$Native_Utils.eq(_p66._0._1._0, _p66._1._1._0)))),
																				_1: {ctor: '[]'}
																			});
																	} else {
																		break _v53_2;
																	}
																case 'VBase':
																	if (((_p66._0._0.ctor === 'VString') && (_p66._1.ctor === 'VBase')) && (_p66._1._0.ctor === 'VString')) {
																		return _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple2',
																				_0: A2(
																					_user$project$Lang$replaceV_,
																					left,
																					_user$project$Lang$VBase(
																						_user$project$Lang$VBool(
																							!_elm_lang$core$Native_Utils.eq(_p66._0._0._0, _p66._1._0._0)))),
																				_1: {ctor: '[]'}
																			});
																	} else {
																		break _v53_2;
																	}
																default:
																	break _v53_2;
															}
														} while(false);
														return _elm_lang$core$Result$Ok(
															{
																ctor: '_Tuple2',
																_0: A2(
																	_user$project$Lang$replaceV_,
																	left,
																	_user$project$Lang$VBase(
																		_user$project$Lang$VBool(
																			!_elm_lang$core$Native_Utils.eq(
																				_user$project$LangUtils$valToString(left),
																				_user$project$LangUtils$valToString(right))))),
																_1: {ctor: '[]'}
															});
													})),
											_elm_lang$core$Maybe$Nothing))
								},
								_1: {
									ctor: '::',
									_0: {
										ctor: '_Tuple2',
										_0: 'getCurrentTime',
										_1: A2(
											_user$project$Lang$builtinVal,
											'EvalUpdate.getCurrentTime',
											A4(
												_user$project$Lang$VFun,
												'getCurrentTime',
												{
													ctor: '::',
													_0: 'unit',
													_1: {ctor: '[]'}
												},
												function (_p67) {
													var n = _user$project$ImpureGoodies$getCurrentTime(
														{ctor: '_Tuple0'});
													var v_ = A2(
														_user$project$Lang$VConst,
														_elm_lang$core$Maybe$Nothing,
														{ctor: '_Tuple2', _0: n, _1: _user$project$Lang$dummyTrace});
													return _elm_lang$core$Result$Ok(
														{
															ctor: '_Tuple2',
															_0: A2(_user$project$Lang$builtinVal, 'EvalUpdate.getCurrentTime.RESULT', v_),
															_1: {ctor: '[]'}
														});
												},
												_elm_lang$core$Maybe$Nothing))
									},
									_1: {
										ctor: '::',
										_0: {
											ctor: '_Tuple2',
											_0: 'toggleGlobalBool',
											_1: A2(
												_user$project$Lang$builtinVal,
												'EvalUpdate.toggleGlobalBool',
												A4(
													_user$project$Lang$VFun,
													'toggleGlobalBool',
													{
														ctor: '::',
														_0: 'unit',
														_1: {ctor: '[]'}
													},
													function (_p68) {
														var v = _user$project$Lang$VBase(
															_user$project$Lang$VBool(
																_user$project$ImpureGoodies$toggleGlobalBool(
																	{ctor: '_Tuple0'})));
														return _elm_lang$core$Result$Ok(
															{
																ctor: '_Tuple2',
																_0: A2(_user$project$Lang$builtinVal, 'EvalUpdate.toggleGlobalBool.RESULT', v),
																_1: {ctor: '[]'}
															});
													},
													_elm_lang$core$Maybe$Nothing))
										},
										_1: {
											ctor: '::',
											_0: {
												ctor: '_Tuple2',
												_0: '%',
												_1: A2(
													_user$project$Lang$builtinVal,
													'EvalUpdate.%',
													A4(
														_user$project$Lang$VFun,
														'%',
														{
															ctor: '::',
															_0: 'left',
															_1: {
																ctor: '::',
																_0: 'right',
																_1: {ctor: '[]'}
															}
														},
														A2(
															_user$project$EvalUpdate$twoArgs,
															'%',
															F2(
																function (left, right) {
																	var _p69 = {ctor: '_Tuple2', _0: left.v_, _1: right.v_};
																	if (((((_p69.ctor === '_Tuple2') && (_p69._0.ctor === 'VConst')) && (_p69._0._1.ctor === '_Tuple2')) && (_p69._1.ctor === 'VConst')) && (_p69._1._1.ctor === '_Tuple2')) {
																		var _p70 = _p69._1._1._0;
																		return _elm_lang$core$Native_Utils.eq(_p70, 0) ? _elm_lang$core$Result$Err('Modulo by zero') : _elm_lang$core$Result$Ok(
																			{
																				ctor: '_Tuple2',
																				_0: A2(
																					_user$project$Lang$replaceV_,
																					left,
																					A2(
																						_user$project$Lang$VConst,
																						_p69._0._0,
																						{
																							ctor: '_Tuple2',
																							_0: _elm_lang$core$Basics$toFloat(
																								A2(
																									_elm_lang$core$Basics_ops['%'],
																									_elm_lang$core$Basics$truncate(_p69._0._1._0),
																									_elm_lang$core$Basics$truncate(_p70))),
																							_1: _p69._0._1._1
																						})),
																				_1: {ctor: '[]'}
																			});
																	} else {
																		return _elm_lang$core$Result$Err(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'% expects two numbers, got ',
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					_user$project$LangUtils$valToString(left),
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						' and ',
																						_user$project$LangUtils$valToString(right)))));
																	}
																})),
														_elm_lang$core$Maybe$Nothing))
											},
											_1: {
												ctor: '::',
												_0: {
													ctor: '_Tuple2',
													_0: '>>',
													_1: A2(
														_user$project$Lang$builtinVal,
														'EvalUpdate.>>',
														A4(
															_user$project$Lang$VFun,
															'>>',
															{
																ctor: '::',
																_0: 'left',
																_1: {
																	ctor: '::',
																	_0: 'right',
																	_1: {
																		ctor: '::',
																		_0: 'x',
																		_1: {ctor: '[]'}
																	}
																}
															},
															function (args) {
																var _p71 = args;
																if ((((_p71.ctor === '::') && (_p71._1.ctor === '::')) && (_p71._1._1.ctor === '::')) && (_p71._1._1._1.ctor === '[]')) {
																	var env = {
																		ctor: '::',
																		_0: {ctor: '_Tuple2', _0: 'x', _1: _p71._1._1._0},
																		_1: {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 'left', _1: _p71._0},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'right', _1: _p71._1._0},
																				_1: {ctor: '[]'}
																			}
																		}
																	};
																	return A2(
																		_elm_lang$core$Result$map,
																		_elm_lang$core$Tuple$first,
																		A4(
																			_user$project$Eval$doEval,
																			_user$project$Eval$withoutParentsProvenanceWidgets,
																			_user$project$Syntax$Leo,
																			env,
																			A2(
																				_user$project$Lang$eApp,
																				_user$project$Lang$eVar('right'),
																				{
																					ctor: '::',
																					_0: A2(
																						_user$project$Lang$eApp,
																						_user$project$Lang$eVar('left'),
																						{
																							ctor: '::',
																							_0: _user$project$Lang$eVar('x'),
																							_1: {ctor: '[]'}
																						}),
																					_1: {ctor: '[]'}
																				})));
																} else {
																	return _elm_lang$core$Result$Err(
																		A2(
																			_elm_lang$core$Basics_ops['++'],
																			'>> expects 3 arguments, got ',
																			_elm_lang$core$Basics$toString(
																				_elm_lang$core$List$length(args))));
																}
															},
															_elm_lang$core$Maybe$Just(
																F4(
																	function (args, oldVal, newVal, d) {
																		var _p72 = args;
																		if ((((_p72.ctor === '::') && (_p72._1.ctor === '::')) && (_p72._1._1.ctor === '::')) && (_p72._1._1._1.ctor === '[]')) {
																			var env = {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'left', _1: _p72._0},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 'right', _1: _p72._1._0},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: 'x', _1: _p72._1._1._0},
																						_1: {ctor: '[]'}
																					}
																				}
																			};
																			return A2(
																				_user$project$Results$map,
																				function (_p73) {
																					var _p74 = _p73;
																					var _p77 = _p74._0;
																					var _p75 = _p77.val;
																					if (((((((_p75.ctor === '::') && (_p75._0.ctor === '_Tuple2')) && (_p75._1.ctor === '::')) && (_p75._1._0.ctor === '_Tuple2')) && (_p75._1._1.ctor === '::')) && (_p75._1._1._0.ctor === '_Tuple2')) && (_p75._1._1._1.ctor === '[]')) {
																						return {
																							ctor: '_Tuple2',
																							_0: {
																								ctor: '::',
																								_0: _p75._0._1,
																								_1: {
																									ctor: '::',
																									_0: _p75._1._0._1,
																									_1: {
																										ctor: '::',
																										_0: _p75._1._1._0._1,
																										_1: {ctor: '[]'}
																									}
																								}
																							},
																							_1: _p77.changes
																						};
																					} else {
																						return _elm_lang$core$Native_Utils.crashCase(
																							'EvalUpdate',
																							{
																								start: {line: 146, column: 13},
																								end: {line: 149, column: 78}
																							},
																							_p75)('[internal error] >> Environment is empty !!!');
																					}
																				},
																				A2(
																					_user$project$Results$filter,
																					function (_p78) {
																						var _p79 = _p78;
																						return _elm_lang$core$Native_Utils.eq(_p79._1.changes, _elm_lang$core$Maybe$Nothing);
																					},
																					_user$project$EvalUpdate$update(
																						A7(
																							_user$project$UpdateStack$updateContext,
																							'>>',
																							env,
																							A2(
																								_user$project$Lang$eApp,
																								_user$project$Lang$eVar('right'),
																								{
																									ctor: '::',
																									_0: A2(
																										_user$project$Lang$eApp,
																										_user$project$Lang$eVar('left'),
																										{
																											ctor: '::',
																											_0: _user$project$Lang$eVar('x'),
																											_1: {ctor: '[]'}
																										}),
																									_1: {ctor: '[]'}
																								}),
																							{ctor: '[]'},
																							oldVal,
																							newVal,
																							d))));
																		} else {
																			return _elm_lang$core$Result$Err(
																				A2(
																					_elm_lang$core$Basics_ops['++'],
																					'>> expects 3 arguments, got ',
																					_elm_lang$core$Basics$toString(
																						_elm_lang$core$List$length(args))));
																		}
																	}))))
												},
												_1: {
													ctor: '::',
													_0: {
														ctor: '_Tuple2',
														_0: '<<',
														_1: A2(
															_user$project$Lang$builtinVal,
															'EvalUpdate.<<',
															A4(
																_user$project$Lang$VFun,
																'<<',
																{
																	ctor: '::',
																	_0: 'left',
																	_1: {
																		ctor: '::',
																		_0: 'right',
																		_1: {
																			ctor: '::',
																			_0: 'x',
																			_1: {ctor: '[]'}
																		}
																	}
																},
																function (args) {
																	var _p80 = args;
																	if ((((_p80.ctor === '::') && (_p80._1.ctor === '::')) && (_p80._1._1.ctor === '::')) && (_p80._1._1._1.ctor === '[]')) {
																		var env = {
																			ctor: '::',
																			_0: {ctor: '_Tuple2', _0: 'x', _1: _p80._1._1._0},
																			_1: {
																				ctor: '::',
																				_0: {ctor: '_Tuple2', _0: 'left', _1: _p80._0},
																				_1: {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 'right', _1: _p80._1._0},
																					_1: {ctor: '[]'}
																				}
																			}
																		};
																		return A2(
																			_elm_lang$core$Result$map,
																			_elm_lang$core$Tuple$first,
																			A4(
																				_user$project$Eval$doEval,
																				_user$project$Eval$withoutParentsProvenanceWidgets,
																				_user$project$Syntax$Leo,
																				env,
																				A2(
																					_user$project$Lang$eApp,
																					_user$project$Lang$eVar('left'),
																					{
																						ctor: '::',
																						_0: A2(
																							_user$project$Lang$eApp,
																							_user$project$Lang$eVar('right'),
																							{
																								ctor: '::',
																								_0: _user$project$Lang$eVar('x'),
																								_1: {ctor: '[]'}
																							}),
																						_1: {ctor: '[]'}
																					})));
																	} else {
																		return _elm_lang$core$Result$Err(
																			A2(
																				_elm_lang$core$Basics_ops['++'],
																				'>> expects 2 arguments, got ',
																				_elm_lang$core$Basics$toString(
																					_elm_lang$core$List$length(args))));
																	}
																},
																_elm_lang$core$Maybe$Just(
																	F4(
																		function (args, oldVal, newVal, d) {
																			var _p81 = args;
																			if ((((_p81.ctor === '::') && (_p81._1.ctor === '::')) && (_p81._1._1.ctor === '::')) && (_p81._1._1._1.ctor === '[]')) {
																				var env = {
																					ctor: '::',
																					_0: {ctor: '_Tuple2', _0: 'left', _1: _p81._0},
																					_1: {
																						ctor: '::',
																						_0: {ctor: '_Tuple2', _0: 'right', _1: _p81._1._0},
																						_1: {
																							ctor: '::',
																							_0: {ctor: '_Tuple2', _0: 'x', _1: _p81._1._1._0},
																							_1: {ctor: '[]'}
																						}
																					}
																				};
																				return A2(
																					_user$project$Results$map,
																					function (_p82) {
																						var _p83 = _p82;
																						var _p86 = _p83._0;
																						var _p84 = _p86.val;
																						if (((((((_p84.ctor === '::') && (_p84._0.ctor === '_Tuple2')) && (_p84._1.ctor === '::')) && (_p84._1._0.ctor === '_Tuple2')) && (_p84._1._1.ctor === '::')) && (_p84._1._1._0.ctor === '_Tuple2')) && (_p84._1._1._1.ctor === '[]')) {
																							return {
																								ctor: '_Tuple2',
																								_0: {
																									ctor: '::',
																									_0: _p84._0._1,
																									_1: {
																										ctor: '::',
																										_0: _p84._1._0._1,
																										_1: {
																											ctor: '::',
																											_0: _p84._1._1._0._1,
																											_1: {ctor: '[]'}
																										}
																									}
																								},
																								_1: _p86.changes
																							};
																						} else {
																							return _elm_lang$core$Native_Utils.crashCase(
																								'EvalUpdate',
																								{
																									start: {line: 166, column: 11},
																									end: {line: 168, column: 76}
																								},
																								_p84)('[internal error] << Environment is empty !!!');
																						}
																					},
																					A2(
																						_user$project$Results$filter,
																						function (_p87) {
																							var _p88 = _p87;
																							return _elm_lang$core$Native_Utils.eq(_p88._1.changes, _elm_lang$core$Maybe$Nothing);
																						},
																						_user$project$EvalUpdate$update(
																							A7(
																								_user$project$UpdateStack$updateContext,
																								'>>',
																								env,
																								A2(
																									_user$project$Lang$eApp,
																									_user$project$Lang$eVar('left'),
																									{
																										ctor: '::',
																										_0: A2(
																											_user$project$Lang$eApp,
																											_user$project$Lang$eVar('right'),
																											{
																												ctor: '::',
																												_0: _user$project$Lang$eVar('x'),
																												_1: {ctor: '[]'}
																											}),
																										_1: {ctor: '[]'}
																									}),
																								{ctor: '[]'},
																								oldVal,
																								newVal,
																								d))));
																			} else {
																				return _elm_lang$core$Result$Err(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'<< expects 3 arguments, got ',
																						_elm_lang$core$Basics$toString(
																							_elm_lang$core$List$length(args))));
																			}
																		}))))
													},
													_1: {
														ctor: '::',
														_0: {
															ctor: '_Tuple2',
															_0: '__jsEval__',
															_1: A2(
																_user$project$Lang$builtinVal,
																'EvalUpdate.__jsEval__',
																A4(
																	_user$project$Lang$VFun,
																	'__jsEval__',
																	{
																		ctor: '::',
																		_0: 'jsprogram',
																		_1: {ctor: '[]'}
																	},
																	A2(
																		_user$project$EvalUpdate$oneArg,
																		'__jsEval__',
																		function (program) {
																			var _p89 = _user$project$ValUnbuilder$string(program);
																			if (_p89.ctor === 'Ok') {
																				return _elm_lang$core$Result$Ok(
																					{
																						ctor: '_Tuple2',
																						_0: A2(
																							_user$project$EvalUpdate$nativeToVal,
																							_user$project$ValBuilder$fromVal(program),
																							_user$project$ImpureGoodies$evaluate(_p89._0)),
																						_1: {ctor: '[]'}
																					});
																			} else {
																				return _elm_lang$core$Result$Err(
																					A2(
																						_elm_lang$core$Basics_ops['++'],
																						'__jsEval__ expects a javascript program as a string, got ',
																						_user$project$LangUtils$valToString(program)));
																			}
																		}),
																	_elm_lang$core$Maybe$Nothing))
														},
														_1: {
															ctor: '::',
															_0: {
																ctor: '_Tuple2',
																_0: '__evaluate__',
																_1: A2(
																	_user$project$Lang$builtinVal,
																	'EvalUpdate.__evaluate__',
																	A4(
																		_user$project$Lang$VFun,
																		'__evaluate__',
																		{
																			ctor: '::',
																			_0: 'environment',
																			_1: {
																				ctor: '::',
																				_0: 'program',
																				_1: {ctor: '[]'}
																			}
																		},
																		A2(
																			_user$project$EvalUpdate$twoArgs,
																			'__evaluate__',
																			F2(
																				function (penv, program) {
																					var _p90 = {
																						ctor: '_Tuple2',
																						_0: A2(
																							_user$project$ValUnbuilder$list,
																							A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity),
																							penv),
																						_1: program.v_
																					};
																					if ((((_p90.ctor === '_Tuple2') && (_p90._0.ctor === 'Ok')) && (_p90._1.ctor === 'VBase')) && (_p90._1._0.ctor === 'VString')) {
																						return function (x) {
																							return _elm_lang$core$Result$Ok(
																								{
																									ctor: '_Tuple2',
																									_0: x,
																									_1: {ctor: '[]'}
																								});
																						}(
																							A3(
																								_user$project$ValBuilder$result,
																								_user$project$ValBuilder$identity,
																								_user$project$ValBuilder$fromVal(program),
																								A2(
																									_elm_lang$core$Result$map,
																									function (_p91) {
																										var _p92 = _p91;
																										return _p92._0._0;
																									},
																									A2(
																										_elm_lang$core$Result$andThen,
																										function (prog) {
																											return A4(
																												_user$project$Eval$doEval,
																												_user$project$Eval$withoutParentsProvenanceWidgets,
																												_user$project$Syntax$Leo,
																												A2(_elm_lang$core$Basics_ops['++'], _p90._0._0, _user$project$EvalUpdate$builtinEnv),
																												prog);
																										},
																										A2(
																											_elm_lang$core$Result$mapError,
																											_user$project$ParserUtils$showError,
																											A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p90._1._0._0))))));
																					} else {
																						return _elm_lang$core$Result$Err(
																							A2(
																								_elm_lang$core$Basics_ops['++'],
																								'evaluate expects a List (String, values) and a program as a string, got ',
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									_user$project$LangUtils$valToString(penv),
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										' and ',
																										_user$project$LangUtils$valToString(program)))));
																					}
																				})),
																		_elm_lang$core$Maybe$Just(
																			A2(
																				_user$project$EvalUpdate$twoArgsUpdate,
																				'__evaluate__',
																				F5(
																					function (oldpEnv, oldProgram, oldValr, newValr, d) {
																						var _p93 = {
																							ctor: '_Tuple2',
																							_0: A2(
																								_user$project$ValUnbuilder$list,
																								A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity),
																								oldpEnv),
																							_1: oldProgram.v_
																						};
																						if ((((_p93.ctor === '_Tuple2') && (_p93._0.ctor === 'Ok')) && (_p93._1.ctor === 'VBase')) && (_p93._1._0.ctor === 'VString')) {
																							var _p111 = _p93._0._0;
																							var parsed = A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p93._1._0._0);
																							var _p94 = parsed;
																							if (_p94.ctor === 'Err') {
																								var _p95 = _user$project$ParserUtils$showErrorReversible(_p94._0);
																								var error = _p95._0;
																								var reverser = _p95._1;
																								var _p96 = A2(_user$project$ValUnbuilder$result, _user$project$ValUnbuilder$identity, newValr);
																								if (_p96.ctor === 'Err') {
																									return _elm_lang$core$Result$Err(_p96._0);
																								} else {
																									if (_p96._0.ctor === 'Err') {
																										var _p98 = _p96._0._0;
																										var _p97 = reverser(_p98);
																										if (_p97.ctor === 'Just') {
																											var newProgramV = A2(
																												_user$project$ValBuilder$string,
																												_user$project$ValBuilder$fromVal(oldProgram),
																												_p97._0);
																											var newProgramDiffs = A2(_user$project$UpdateUtils$defaultVDiffs, oldProgram, newProgramV);
																											return A3(
																												_elm_lang$core$Basics$flip,
																												_user$project$Results$map,
																												newProgramDiffs,
																												function (pd) {
																													return {
																														ctor: '_Tuple2',
																														_0: {
																															ctor: '::',
																															_0: oldpEnv,
																															_1: {
																																ctor: '::',
																																_0: newProgramV,
																																_1: {ctor: '[]'}
																															}
																														},
																														_1: A2(
																															_elm_lang$core$Maybe$withDefault,
																															{ctor: '[]'},
																															A2(
																																_elm_lang$core$Maybe$map,
																																function (d) {
																																	return {
																																		ctor: '::',
																																		_0: {ctor: '_Tuple2', _0: 1, _1: d},
																																		_1: {ctor: '[]'}
																																	};
																																},
																																pd))
																													};
																												});
																										} else {
																											return _elm_lang$core$Result$Err(
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'No way to change the outpur of __evaluate__ from error to ',
																													A2(_elm_lang$core$Basics_ops['++'], _p98, '\'')));
																										}
																									} else {
																										return _elm_lang$core$Result$Err(
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												'Cannot change the outpur of __evaluate__ from error to ',
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													_user$project$LangUtils$valToString(_p96._0._0),
																													'\'')));
																									}
																								}
																							} else {
																								return A2(
																									_user$project$Results$andThen,
																									function (prog) {
																										var _p99 = {
																											ctor: '_Tuple3',
																											_0: A2(_user$project$ValUnbuilder$result, _user$project$ValUnbuilder$identity, oldValr),
																											_1: A2(_user$project$ValUnbuilder$result, _user$project$ValUnbuilder$identity, newValr),
																											_2: A2(_user$project$Lang$vDatatypeDiffsGet, '_1', d)
																										};
																										_v72_2:
																										do {
																											_v72_1:
																											do {
																												if (_p99._1.ctor === 'Err') {
																													if (_p99._2.ctor === 'Nothing') {
																														break _v72_1;
																													} else {
																														if (_p99._0.ctor === 'Err') {
																															break _v72_2;
																														} else {
																															return _elm_lang$core$Result$Err(_p99._1._0);
																														}
																													}
																												} else {
																													if (_p99._0.ctor === 'Err') {
																														if (_p99._2.ctor === 'Nothing') {
																															break _v72_1;
																														} else {
																															break _v72_2;
																														}
																													} else {
																														if (_p99._1._0.ctor === 'Ok') {
																															if (_p99._0._0.ctor === 'Ok') {
																																if (_p99._2.ctor === 'Just') {
																																	return A2(
																																		_user$project$Results$andThen,
																																		function (_p100) {
																																			var _p101 = _p100;
																																			var _p105 = _p101._0;
																																			var x = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p101._1.val);
																																			var newProgram = A2(
																																				_user$project$Lang$replaceV_,
																																				oldProgram,
																																				_user$project$Lang$VBase(
																																					_user$project$Lang$VString(x)));
																																			var newEnvValue = A3(
																																				_user$project$ValBuilder$list,
																																				A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$identity),
																																				_user$project$ValBuilder$fromVal(oldpEnv),
																																				_p105.val);
																																			var newEnvDiffs = function (d) {
																																				return {
																																					ctor: '::',
																																					_0: {
																																						ctor: '_Tuple2',
																																						_0: 0,
																																						_1: _user$project$Lang$VListDiffs(d)
																																					},
																																					_1: {ctor: '[]'}
																																				};
																																			}(
																																				A2(
																																					_elm_lang$core$List$map,
																																					function (_p102) {
																																						var _p103 = _p102;
																																						return {
																																							ctor: '_Tuple2',
																																							_0: _p103._0,
																																							_1: _user$project$Lang$ListElemUpdate(
																																								_user$project$Lang$VRecordDiffs(
																																									_elm_lang$core$Dict$fromList(
																																										{
																																											ctor: '::',
																																											_0: {ctor: '_Tuple2', _0: '_2', _1: _p103._1},
																																											_1: {ctor: '[]'}
																																										})))
																																						};
																																					},
																																					_p105.changes));
																																			return A2(
																																				_user$project$Results$map,
																																				function (mbd) {
																																					var _p104 = mbd;
																																					if (_p104.ctor === 'Nothing') {
																																						return {
																																							ctor: '_Tuple2',
																																							_0: {
																																								ctor: '::',
																																								_0: newEnvValue,
																																								_1: {
																																									ctor: '::',
																																									_0: newProgram,
																																									_1: {ctor: '[]'}
																																								}
																																							},
																																							_1: newEnvDiffs
																																						};
																																					} else {
																																						return {
																																							ctor: '_Tuple2',
																																							_0: {
																																								ctor: '::',
																																								_0: newEnvValue,
																																								_1: {
																																									ctor: '::',
																																									_0: newProgram,
																																									_1: {ctor: '[]'}
																																								}
																																							},
																																							_1: A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								newEnvDiffs,
																																								{
																																									ctor: '::',
																																									_0: {ctor: '_Tuple2', _0: 1, _1: _p104._0},
																																									_1: {ctor: '[]'}
																																								})
																																						};
																																					}
																																				},
																																				A2(_user$project$UpdateUtils$defaultVDiffs, oldProgram, newProgram));
																																		},
																																		A2(
																																			_user$project$Results$filter,
																																			function (_p106) {
																																				var _p107 = _p106;
																																				var envLength = _elm_lang$core$List$length(_p111);
																																				return _user$project$Utils$maybeIsEmpty(
																																					A2(
																																						_user$project$Utils$findFirst,
																																						function (_p108) {
																																							var _p109 = _p108;
																																							return _elm_lang$core$Native_Utils.cmp(_p109._0, envLength) > -1;
																																						},
																																						_p107._0.changes));
																																			},
																																			_user$project$EvalUpdate$update(
																																				A7(
																																					_user$project$UpdateStack$updateContext,
																																					'Eval.__evaluate__',
																																					A2(_elm_lang$core$Basics_ops['++'], _p111, _user$project$EvalUpdate$builtinEnv),
																																					prog,
																																					{ctor: '[]'},
																																					_p99._0._0._0,
																																					_p99._1._0._0,
																																					_p99._2._0))));
																																} else {
																																	break _v72_1;
																																}
																															} else {
																																if (_p99._2.ctor === 'Nothing') {
																																	break _v72_1;
																																} else {
																																	return _elm_lang$core$Result$Err(
																																		A2(
																																			_elm_lang$core$Basics_ops['++'],
																																			'Cannot change the outpur of __evaluate__ from error \'',
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				_p99._0._0._0,
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					'\' to ',
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						_user$project$LangUtils$valToString(_p99._1._0._0),
																																						'\'')))));
																																}
																															}
																														} else {
																															if (_p99._2.ctor === 'Nothing') {
																																break _v72_1;
																															} else {
																																if (_p99._0._0.ctor === 'Err') {
																																	var _p110 = _p99._1._0._0;
																																	return _elm_lang$core$Native_Utils.eq(_p99._0._0._0, _p110) ? _user$project$Results$ok1(
																																		{
																																			ctor: '_Tuple2',
																																			_0: {
																																				ctor: '::',
																																				_0: oldpEnv,
																																				_1: {
																																					ctor: '::',
																																					_0: oldProgram,
																																					_1: {ctor: '[]'}
																																				}
																																			},
																																			_1: {ctor: '[]'}
																																		}) : _elm_lang$core$Result$Err(
																																		A2(_elm_lang$core$Basics_ops['++'], 'Cannot change the error message of __evaluate__ to ', _p110));
																																} else {
																																	return _elm_lang$core$Result$Err(
																																		A2(
																																			_elm_lang$core$Basics_ops['++'],
																																			'Don\'t know how to update the result of a correct __evaluate__ by an error \'',
																																			A2(_elm_lang$core$Basics_ops['++'], _p99._1._0._0, '\'')));
																																}
																															}
																														}
																													}
																												}
																											} while(false);
																											return _elm_lang$core$Result$Err(
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'Expected VRecordDiffs with 1 element, got ',
																													_elm_lang$core$Basics$toString(d)));
																										} while(false);
																										return _elm_lang$core$Result$Err(_p99._0._0);
																									},
																									_user$project$Results$ok1(_p94._0));
																							}
																						} else {
																							return _elm_lang$core$Result$Err(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'evaluate expects a List (String, values) and a program as a string, got ',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_user$project$LangUtils$valToString(oldpEnv),
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											' and ',
																											_user$project$LangUtils$valToString(oldProgram)))));
																						}
																					})))))
															},
															_1: {
																ctor: '::',
																_0: {
																	ctor: '_Tuple2',
																	_0: '__evaluateWithCache__',
																	_1: A2(
																		_user$project$Lang$builtinVal,
																		'EvalUpdate.__evaluateWithCache__',
																		A4(
																			_user$project$Lang$VFun,
																			'__evaluateWithCache__',
																			{
																				ctor: '::',
																				_0: 'environment',
																				_1: {
																					ctor: '::',
																					_0: 'program',
																					_1: {ctor: '[]'}
																				}
																			},
																			A2(
																				_user$project$EvalUpdate$twoArgs,
																				'__evaluate__',
																				F2(
																					function (penv, program) {
																						var _p112 = {
																							ctor: '_Tuple2',
																							_0: A2(
																								_user$project$ValUnbuilder$list,
																								A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity),
																								penv),
																							_1: program.v_
																						};
																						if ((((_p112.ctor === '_Tuple2') && (_p112._0.ctor === 'Ok')) && (_p112._1.ctor === 'VBase')) && (_p112._1._0.ctor === 'VString')) {
																							return function (x) {
																								return _elm_lang$core$Result$Ok(
																									{
																										ctor: '_Tuple2',
																										_0: x,
																										_1: {ctor: '[]'}
																									});
																							}(
																								A3(
																									_user$project$ValBuilder$result,
																									A2(
																										_user$project$ValBuilder$tuple2,
																										_user$project$ValBuilder$identity,
																										_user$project$ValBuilder$list(
																											A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$identity))),
																									_user$project$ValBuilder$fromVal(program),
																									A2(
																										_elm_lang$core$Result$map,
																										function (_p113) {
																											var _p114 = _p113;
																											return {ctor: '_Tuple2', _0: _p114._0._0, _1: _p114._1};
																										},
																										A2(
																											_elm_lang$core$Result$andThen,
																											function (prog) {
																												return A4(
																													_user$project$Eval$doEval,
																													_user$project$Eval$withoutParentsProvenanceWidgets,
																													_user$project$Syntax$Leo,
																													A2(_elm_lang$core$Basics_ops['++'], _p112._0._0, _user$project$EvalUpdate$builtinEnv),
																													prog);
																											},
																											A2(
																												_elm_lang$core$Result$mapError,
																												_user$project$ParserUtils$showError,
																												A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p112._1._0._0))))));
																						} else {
																							return _elm_lang$core$Result$Err(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'evaluate expects a List (String, values) and a program as a string, got ',
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										_user$project$LangUtils$valToString(penv),
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											' and ',
																											_user$project$LangUtils$valToString(program)))));
																						}
																					})),
																			_elm_lang$core$Maybe$Just(
																				A2(
																					_user$project$EvalUpdate$twoArgsUpdate,
																					'__evaluateWithCache__',
																					F5(
																						function (oldpEnv, oldProgram, oldValr, newValr, d) {
																							var _p115 = {
																								ctor: '_Tuple2',
																								_0: A2(
																									_user$project$ValUnbuilder$list,
																									A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity),
																									oldpEnv),
																								_1: oldProgram.v_
																							};
																							if ((((_p115.ctor === '_Tuple2') && (_p115._0.ctor === 'Ok')) && (_p115._1.ctor === 'VBase')) && (_p115._1._0.ctor === 'VString')) {
																								var _p137 = _p115._0._0;
																								var parsed = A2(_user$project$Syntax$parser, _user$project$Syntax$Leo, _p115._1._0._0);
																								var _p116 = parsed;
																								if (_p116.ctor === 'Err') {
																									var _p117 = _user$project$ParserUtils$showErrorReversible(_p116._0);
																									var error = _p117._0;
																									var reverser = _p117._1;
																									var _p118 = A2(_user$project$ValUnbuilder$result, _user$project$ValUnbuilder$identity, newValr);
																									if (_p118.ctor === 'Err') {
																										return _elm_lang$core$Result$Err(_p118._0);
																									} else {
																										if (_p118._0.ctor === 'Err') {
																											var _p120 = _p118._0._0;
																											var _p119 = reverser(_p120);
																											if (_p119.ctor === 'Just') {
																												var newProgramV = A2(
																													_user$project$ValBuilder$string,
																													_user$project$ValBuilder$fromVal(oldProgram),
																													_p119._0);
																												var newProgramDiffs = A2(_user$project$UpdateUtils$defaultVDiffs, oldProgram, newProgramV);
																												return A3(
																													_elm_lang$core$Basics$flip,
																													_user$project$Results$map,
																													newProgramDiffs,
																													function (pd) {
																														return {
																															ctor: '_Tuple2',
																															_0: {
																																ctor: '::',
																																_0: oldpEnv,
																																_1: {
																																	ctor: '::',
																																	_0: newProgramV,
																																	_1: {ctor: '[]'}
																																}
																															},
																															_1: A2(
																																_elm_lang$core$Maybe$withDefault,
																																{ctor: '[]'},
																																A2(
																																	_elm_lang$core$Maybe$map,
																																	function (d) {
																																		return {
																																			ctor: '::',
																																			_0: {ctor: '_Tuple2', _0: 1, _1: d},
																																			_1: {ctor: '[]'}
																																		};
																																	},
																																	pd))
																														};
																													});
																											} else {
																												return _elm_lang$core$Result$Err(
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														'No way to change the outpur of __evaluate__ from error to ',
																														A2(_elm_lang$core$Basics_ops['++'], _p120, '\'')));
																											}
																										} else {
																											return _elm_lang$core$Result$Err(
																												A2(
																													_elm_lang$core$Basics_ops['++'],
																													'Cannot change the outpur of __evaluate__ from error to ',
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														_user$project$LangUtils$valToString(_p118._0._0),
																														'\'')));
																										}
																									}
																								} else {
																									return A2(
																										_user$project$Results$andThen,
																										function (prog) {
																											var _p121 = {
																												ctor: '_Tuple3',
																												_0: A2(
																													_user$project$ValUnbuilder$result,
																													A2(
																														_user$project$ValUnbuilder$tuple2,
																														_user$project$ValUnbuilder$identity,
																														_user$project$ValUnbuilder$list(
																															A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity))),
																													oldValr),
																												_1: A2(
																													_user$project$ValUnbuilder$result,
																													A2(
																														_user$project$ValUnbuilder$tuple2,
																														_user$project$ValUnbuilder$identity,
																														_user$project$ValUnbuilder$list(
																															A2(_user$project$ValUnbuilder$tuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$identity))),
																													newValr),
																												_2: A2(_user$project$Lang$vDatatypeDiffsGet, '_1', d)
																											};
																											_v84_2:
																											do {
																												_v84_1:
																												do {
																													if (_p121._1.ctor === 'Err') {
																														if (_p121._2.ctor === 'Nothing') {
																															break _v84_1;
																														} else {
																															if (_p121._0.ctor === 'Err') {
																																break _v84_2;
																															} else {
																																return _elm_lang$core$Result$Err(_p121._1._0);
																															}
																														}
																													} else {
																														if (_p121._0.ctor === 'Err') {
																															if (_p121._2.ctor === 'Nothing') {
																																break _v84_1;
																															} else {
																																break _v84_2;
																															}
																														} else {
																															if (_p121._1._0.ctor === 'Ok') {
																																if (_p121._0._0.ctor === 'Ok') {
																																	if (_p121._2.ctor === 'Just') {
																																		var _p135 = _p121._2._0;
																																		var _p122 = _p135;
																																		if (_p122.ctor === 'VRecordDiffs') {
																																			var _p134 = _p122._0;
																																			var _p123 = {
																																				ctor: '_Tuple2',
																																				_0: A2(_elm_lang$core$Dict$get, '_1', _p134),
																																				_1: A2(_elm_lang$core$Dict$get, '_2', _p134)
																																			};
																																			_v86_0:
																																			do {
																																				if (_p123._0.ctor === 'Nothing') {
																																					if (_p123._1.ctor === 'Just') {
																																						break _v86_0;
																																					} else {
																																						return _elm_lang$core$Result$Err(
																																							A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								'Expected VRecordDiffs with 1 element, got ',
																																								_elm_lang$core$Basics$toString(_p135)));
																																					}
																																				} else {
																																					if (_p123._1.ctor === 'Just') {
																																						break _v86_0;
																																					} else {
																																						var initEnv = A2(_elm_lang$core$Basics_ops['++'], _p137, _user$project$EvalUpdate$builtinEnv);
																																						var previousLets = A2(_user$project$UpdateStack$keepLets, initEnv, _p121._0._0._0._1);
																																						return A2(
																																							_user$project$Results$andThen,
																																							function (_p124) {
																																								var _p125 = _p124;
																																								var _p129 = _p125._0;
																																								var x = A2(_user$project$Syntax$unparser, _user$project$Syntax$Leo, _p125._1.val);
																																								var newProgram = A2(
																																									_user$project$Lang$replaceV_,
																																									oldProgram,
																																									_user$project$Lang$VBase(
																																										_user$project$Lang$VString(x)));
																																								var newEnvValue = A3(
																																									_user$project$ValBuilder$list,
																																									A2(_user$project$ValBuilder$tuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$identity),
																																									_user$project$ValBuilder$fromVal(oldpEnv),
																																									_p129.val);
																																								var newEnvDiffs = function (d) {
																																									return {
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: 0,
																																											_1: _user$project$Lang$VListDiffs(d)
																																										},
																																										_1: {ctor: '[]'}
																																									};
																																								}(
																																									A2(
																																										_elm_lang$core$List$map,
																																										function (_p126) {
																																											var _p127 = _p126;
																																											return {
																																												ctor: '_Tuple2',
																																												_0: _p127._0,
																																												_1: _user$project$Lang$ListElemUpdate(
																																													_user$project$Lang$VRecordDiffs(
																																														_elm_lang$core$Dict$fromList(
																																															{
																																																ctor: '::',
																																																_0: {ctor: '_Tuple2', _0: '_2', _1: _p127._1},
																																																_1: {ctor: '[]'}
																																															})))
																																											};
																																										},
																																										_p129.changes));
																																								return A2(
																																									_user$project$Results$map,
																																									function (mbd) {
																																										var _p128 = mbd;
																																										if (_p128.ctor === 'Nothing') {
																																											return {
																																												ctor: '_Tuple2',
																																												_0: {
																																													ctor: '::',
																																													_0: newEnvValue,
																																													_1: {
																																														ctor: '::',
																																														_0: newProgram,
																																														_1: {ctor: '[]'}
																																													}
																																												},
																																												_1: newEnvDiffs
																																											};
																																										} else {
																																											return {
																																												ctor: '_Tuple2',
																																												_0: {
																																													ctor: '::',
																																													_0: newEnvValue,
																																													_1: {
																																														ctor: '::',
																																														_0: newProgram,
																																														_1: {ctor: '[]'}
																																													}
																																												},
																																												_1: A2(
																																													_elm_lang$core$Basics_ops['++'],
																																													newEnvDiffs,
																																													{
																																														ctor: '::',
																																														_0: {ctor: '_Tuple2', _0: 1, _1: _p128._0},
																																														_1: {ctor: '[]'}
																																													})
																																											};
																																										}
																																									},
																																									A2(_user$project$UpdateUtils$defaultVDiffs, oldProgram, newProgram));
																																							},
																																							A2(
																																								_user$project$Results$filter,
																																								function (_p130) {
																																									var _p131 = _p130;
																																									var envLength = _elm_lang$core$List$length(_p137);
																																									return _user$project$Utils$maybeIsEmpty(
																																										A2(
																																											_user$project$Utils$findFirst,
																																											function (_p132) {
																																												var _p133 = _p132;
																																												return _elm_lang$core$Native_Utils.cmp(_p133._0, envLength) > -1;
																																											},
																																											_p131._0.changes));
																																								},
																																								_user$project$EvalUpdate$update(
																																									A7(_user$project$UpdateStack$updateContext, 'Eval.__evaluateWithCache__', initEnv, prog, previousLets, _p121._0._0._0._0, _p121._1._0._0._0, _p123._0._0))));
																																					}
																																				}
																																			} while(false);
																																			return _elm_lang$core$Result$Err('Cannot modify the cache of __evaluateWithCache');
																																		} else {
																																			return _elm_lang$core$Result$Err(
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					'Expected VRecordDiffs with diff on variable only, got ',
																																					_elm_lang$core$Basics$toString(_p135)));
																																		}
																																	} else {
																																		break _v84_1;
																																	}
																																} else {
																																	if (_p121._2.ctor === 'Nothing') {
																																		break _v84_1;
																																	} else {
																																		return _elm_lang$core$Result$Err(
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				'Cannot change the outpur of __evaluateWithCache__ from error \'',
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					_p121._0._0._0,
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						'\' to ',
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							_user$project$LangUtils$valToString(_p121._1._0._0._0),
																																							'\'')))));
																																	}
																																}
																															} else {
																																if (_p121._2.ctor === 'Nothing') {
																																	break _v84_1;
																																} else {
																																	if (_p121._0._0.ctor === 'Err') {
																																		var _p136 = _p121._1._0._0;
																																		return _elm_lang$core$Native_Utils.eq(_p121._0._0._0, _p136) ? _user$project$Results$ok1(
																																			{
																																				ctor: '_Tuple2',
																																				_0: {
																																					ctor: '::',
																																					_0: oldpEnv,
																																					_1: {
																																						ctor: '::',
																																						_0: oldProgram,
																																						_1: {ctor: '[]'}
																																					}
																																				},
																																				_1: {ctor: '[]'}
																																			}) : _elm_lang$core$Result$Err(
																																			A2(_elm_lang$core$Basics_ops['++'], 'Cannot change the error message of __evaluate__ to ', _p136));
																																	} else {
																																		return _elm_lang$core$Result$Err(
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				'Don\'t know how to update the result of a correct __evaluateWithCache__ by an error \'',
																																				A2(_elm_lang$core$Basics_ops['++'], _p121._1._0._0, '\'')));
																																	}
																																}
																															}
																														}
																													}
																												} while(false);
																												return _elm_lang$core$Result$Err(
																													A2(
																														_elm_lang$core$Basics_ops['++'],
																														'Expected VRecordDiffs with 1 element, got ',
																														_elm_lang$core$Basics$toString(d)));
																											} while(false);
																											return _elm_lang$core$Result$Err(_p121._0._0);
																										},
																										_user$project$Results$ok1(_p116._0));
																								}
																							} else {
																								return _elm_lang$core$Result$Err(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'evaluate expects a List (String, values) and a program as a string, got ',
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											_user$project$LangUtils$valToString(oldpEnv),
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												' and ',
																												_user$project$LangUtils$valToString(oldProgram)))));
																							}
																						})))))
																},
																_1: {
																	ctor: '::',
																	_0: {
																		ctor: '_Tuple2',
																		_0: '__updateApp__',
																		_1: A2(
																			_user$project$Lang$builtinVal,
																			'EvalUpdate.updateApp',
																			A4(
																				_user$project$Lang$VFun,
																				'__updateApp__',
																				{
																					ctor: '::',
																					_0: '{fun,input[,oldOutput],output[,outputDiff]}',
																					_1: {ctor: '[]'}
																				},
																				A2(
																					_user$project$EvalUpdate$oneArg,
																					'__updateApp__',
																					function (arg) {
																						var vb = _user$project$ValBuilder$fromVal(arg);
																						var _p138 = arg.v_;
																						if (_p138.ctor === 'VRecord') {
																							var _p165 = _p138._0;
																							var _p139 = {
																								ctor: '_Tuple3',
																								_0: A2(
																									_user$project$Utils$dictGetFirst,
																									{
																										ctor: '::',
																										_0: 'fun',
																										_1: {
																											ctor: '::',
																											_0: 'function',
																											_1: {ctor: '[]'}
																										}
																									},
																									_p165),
																								_1: A2(
																									_user$project$Utils$dictGetFirst,
																									{
																										ctor: '::',
																										_0: 'input',
																										_1: {
																											ctor: '::',
																											_0: 'oldInput',
																											_1: {
																												ctor: '::',
																												_0: 'inputOld',
																												_1: {ctor: '[]'}
																											}
																										}
																									},
																									_p165),
																								_2: A2(
																									_user$project$Utils$dictGetFirst,
																									{
																										ctor: '::',
																										_0: 'output',
																										_1: {
																											ctor: '::',
																											_0: 'newOutput',
																											_1: {
																												ctor: '::',
																												_0: 'outputNew',
																												_1: {ctor: '[]'}
																											}
																										}
																									},
																									_p165)
																							};
																							if (((_p139._0.ctor === 'Just') && (_p139._1.ctor === 'Just')) && (_p139._2.ctor === 'Just')) {
																								var _p161 = _p139._2._0;
																								var _p160 = _p139._1._0;
																								var xyEnv = {
																									ctor: '::',
																									_0: {ctor: '_Tuple2', _0: 'x', _1: _p139._0._0},
																									_1: {
																										ctor: '::',
																										_0: {ctor: '_Tuple2', _0: 'y', _1: _p160},
																										_1: {ctor: '[]'}
																									}
																								};
																								var xyExp = _user$project$Lang$withDummyExpInfo(
																									A5(
																										_user$project$Lang$EApp,
																										_user$project$Lang$space0,
																										_user$project$Lang$eVar('x'),
																										{
																											ctor: '::',
																											_0: _user$project$Lang$eVar('y'),
																											_1: {ctor: '[]'}
																										},
																										_user$project$Lang$SpaceApp,
																										_user$project$Lang$space0));
																								var oldOut = function () {
																									var _p140 = A2(
																										_user$project$Utils$dictGetFirst,
																										{
																											ctor: '::',
																											_0: 'oldOutput',
																											_1: {
																												ctor: '::',
																												_0: 'oldOut',
																												_1: {
																													ctor: '::',
																													_0: 'outputOld',
																													_1: {ctor: '[]'}
																												}
																											}
																										},
																										_p165);
																									if (_p140.ctor === 'Nothing') {
																										return A2(
																											_elm_lang$core$Result$map,
																											function (_p141) {
																												var _p142 = _p141;
																												return _p142._0._0;
																											},
																											A4(_user$project$Eval$doEval, _user$project$Eval$withoutParentsProvenanceWidgets, _user$project$Syntax$Leo, xyEnv, xyExp));
																									} else {
																										return _elm_lang$core$Result$Ok(_p140._0);
																									}
																								}();
																								var _p143 = oldOut;
																								if (_p143.ctor === 'Err') {
																									return _elm_lang$core$Result$Err(
																										A2(_elm_lang$core$Basics_ops['++'], 'while evaluating updateApp and trying to compute the old value, ', _p143._0));
																								} else {
																									var _p159 = _p143._0;
																									var outputDiff = function () {
																										var _p144 = A2(
																											_user$project$Utils$dictGetFirst,
																											{
																												ctor: '::',
																												_0: 'outputDiff',
																												_1: {
																													ctor: '::',
																													_0: 'diffOutput',
																													_1: {
																														ctor: '::',
																														_0: 'diffOut',
																														_1: {
																															ctor: '::',
																															_0: 'outDiff',
																															_1: {
																																ctor: '::',
																																_0: 'diffs',
																																_1: {ctor: '[]'}
																															}
																														}
																													}
																												}
																											},
																											_p165);
																										if (_p144.ctor === 'Nothing') {
																											return _user$project$Results$firstResult(
																												A2(_user$project$UpdateUtils$defaultVDiffs, _p159, _p161));
																										} else {
																											return A2(
																												_elm_lang$core$Result$map,
																												_elm_lang$core$Maybe$Just,
																												_user$project$UpdateUtils$valToVDiffs(_p144._0));
																										}
																									}();
																									var _p145 = outputDiff;
																									if (_p145.ctor === 'Err') {
																										return _elm_lang$core$Result$Err(
																											A2(_elm_lang$core$Basics_ops['++'], 'while evaluating updateApp and trying to compute the output diff, ', _p145._0));
																									} else {
																										if (_p145._0.ctor === 'Nothing') {
																											var resultingValue = A3(
																												_user$project$ValBuilder$result,
																												_user$project$UpdateUtils$updateReturnToVal,
																												vb,
																												_elm_lang$core$Result$Ok(
																													_user$project$Lang$InputsWithDiffs(
																														{
																															ctor: '::',
																															_0: {ctor: '_Tuple2', _0: _p160, _1: _elm_lang$core$Maybe$Nothing},
																															_1: {ctor: '[]'}
																														})));
																											return _elm_lang$core$Result$Ok(
																												{
																													ctor: '_Tuple2',
																													_0: resultingValue,
																													_1: {ctor: '[]'}
																												});
																										} else {
																											var basicResult = function () {
																												var _p146 = _user$project$EvalUpdate$update(
																													A7(
																														_user$project$UpdateStack$updateContext,
																														'__updateApp__',
																														xyEnv,
																														xyExp,
																														{ctor: '[]'},
																														_p159,
																														_p161,
																														_p145._0._0));
																												if (_p146.ctor === 'Err') {
																													return _elm_lang$core$Result$Err(_p146._0);
																												} else {
																													var l = _user$project$LazyList$toList(_p146._0);
																													var lFiltered = A2(
																														_elm_lang$core$List$filter,
																														function (_p147) {
																															var _p148 = _p147;
																															var _p149 = _p148._0.changes;
																															if (_p149.ctor === '[]') {
																																return true;
																															} else {
																																if (((_p149._0.ctor === '_Tuple2') && (_p149._0._0 === 1)) && (_p149._1.ctor === '[]')) {
																																	return true;
																																} else {
																																	return false;
																																}
																															}
																														},
																														l);
																													if (_elm_lang$core$List$isEmpty(lFiltered)) {
																														return _elm_lang$core$List$isEmpty(l) ? _elm_lang$core$Result$Ok(
																															_user$project$Lang$InputsWithDiffs(
																																{ctor: '[]'})) : _elm_lang$core$Result$Err('Only solutions modifying the constant function of __updateApp__');
																													} else {
																														var _p150 = _elm_lang$core$List$unzip(
																															A2(
																																_elm_lang$core$List$map,
																																function (_p151) {
																																	var _p152 = _p151;
																																	var _p158 = _p152._0;
																																	var _p153 = _p158.val;
																																	if (((((((_p153.ctor === '::') && (_p153._0.ctor === '_Tuple2')) && (_p153._0._0 === 'x')) && (_p153._1.ctor === '::')) && (_p153._1._0.ctor === '_Tuple2')) && (_p153._1._0._0 === 'y')) && (_p153._1._1.ctor === '[]')) {
																																		var _p156 = _p153._1._0._1;
																																		var _p154 = _p158.changes;
																																		if (_p154.ctor === '[]') {
																																			return {ctor: '_Tuple2', _0: _p156, _1: _elm_lang$core$Maybe$Nothing};
																																		} else {
																																			if (((_p154._0.ctor === '_Tuple2') && (_p154._0._0 === 1)) && (_p154._1.ctor === '[]')) {
																																				return {
																																					ctor: '_Tuple2',
																																					_0: _p156,
																																					_1: _elm_lang$core$Maybe$Just(_p154._0._1)
																																				};
																																			} else {
																																				return _elm_lang$core$Native_Utils.crashCase(
																																					'EvalUpdate',
																																					{
																																						start: {line: 357, column: 39},
																																						end: {line: 360, column: 131}
																																					},
																																					_p154)('Internal error: expected not much than (1, diff) in environment changes');
																																			}
																																		}
																																	} else {
																																		return _elm_lang$core$Native_Utils.crashCase(
																																			'EvalUpdate',
																																			{
																																				start: {line: 355, column: 34},
																																				end: {line: 361, column: 103}
																																			},
																																			_p153)('Internal error: expected x and y in environment');
																																	}
																																},
																																lFiltered));
																														var results = _p150._0;
																														var diffs = _p150._1;
																														return _elm_lang$core$Result$Ok(
																															_user$project$Lang$InputsWithDiffs(
																																A2(_user$project$Utils$zip, results, diffs)));
																													}
																												}
																											}();
																											return _elm_lang$core$Result$Ok(
																												{
																													ctor: '_Tuple2',
																													_0: A3(_user$project$ValBuilder$result, _user$project$UpdateUtils$updateReturnToVal, vb, basicResult),
																													_1: {ctor: '[]'}
																												});
																										}
																									}
																								}
																							} else {
																								return _elm_lang$core$Result$Err(
																									A2(
																										_elm_lang$core$Basics_ops['++'],
																										'__updateApp__ requires a record with at least {fun,input,output}. Missing',
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											A2(
																												_elm_lang$core$Maybe$withDefault,
																												' fun',
																												A2(
																													_elm_lang$core$Maybe$map,
																													function (_p162) {
																														return '';
																													},
																													_p139._0)),
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												A2(
																													_elm_lang$core$Maybe$withDefault,
																													' input',
																													A2(
																														_elm_lang$core$Maybe$map,
																														function (_p163) {
																															return '';
																														},
																														_p139._1)),
																												A2(
																													_elm_lang$core$Maybe$withDefault,
																													' output',
																													A2(
																														_elm_lang$core$Maybe$map,
																														function (_p164) {
																															return '';
																														},
																														_p139._2))))));
																							}
																						} else {
																							return _elm_lang$core$Result$Err(
																								A2(
																									_elm_lang$core$Basics_ops['++'],
																									'__updateApp__ argument should be a record {fun,input[,oldOutput],output[,outputDiff]}, but got ',
																									_user$project$LangUtils$valToString(arg)));
																						}
																					}),
																				_elm_lang$core$Maybe$Nothing))
																	},
																	_1: {
																		ctor: '::',
																		_0: {
																			ctor: '_Tuple2',
																			_0: '__merge__',
																			_1: A2(
																				_user$project$Lang$builtinVal,
																				'EvalUpdate.merge',
																				A4(
																					_user$project$Lang$VFun,
																					'__merge__',
																					{
																						ctor: '::',
																						_0: 'original',
																						_1: {
																							ctor: '::',
																							_0: 'List (modified, Maybe diff)',
																							_1: {ctor: '[]'}
																						}
																					},
																					A2(
																						_user$project$EvalUpdate$twoArgs,
																						'__merge__',
																						F2(
																							function (original, modifications) {
																								var _p166 = A2(
																									_user$project$ValUnbuilder$list,
																									A2(
																										_user$project$ValUnbuilder$tuple2,
																										_user$project$ValUnbuilder$identity,
																										_user$project$ValUnbuilder$maybe(_user$project$UpdateUtils$valToVDiffs)),
																									modifications);
																								if (_p166.ctor === 'Ok') {
																									var _p167 = A2(_user$project$UpdateUtils$recursiveMergeVal, original, _p166._0);
																									var newVal = _p167._0;
																									var mbd = _p167._1;
																									return _elm_lang$core$Result$Ok(
																										{
																											ctor: '_Tuple2',
																											_0: A4(
																												_user$project$ValBuilder$tuple2,
																												_user$project$ValBuilder$identity,
																												_user$project$ValBuilder$maybe(_user$project$UpdateUtils$vDiffsToVal),
																												_user$project$ValBuilder$fromVal(original),
																												{ctor: '_Tuple2', _0: newVal, _1: mbd}),
																											_1: {ctor: '[]'}
																										});
																								} else {
																									return _elm_lang$core$Result$Err(
																										A2(
																											_elm_lang$core$Basics_ops['++'],
																											'__merge__ \'s second argument should be a list of (value, Maybe diff), but got ',
																											A2(
																												_elm_lang$core$Basics_ops['++'],
																												_user$project$LangUtils$valToString(modifications),
																												A2(_elm_lang$core$Basics_ops['++'], '\n', _p166._0))));
																								}
																							})),
																					_elm_lang$core$Maybe$Nothing))
																		},
																		_1: {
																			ctor: '::',
																			_0: {
																				ctor: '_Tuple2',
																				_0: '__diff__',
																				_1: A2(
																					_user$project$Lang$builtinVal,
																					'EvalUpdate.diff',
																					A4(
																						_user$project$Lang$VFun,
																						'__diff__',
																						{
																							ctor: '::',
																							_0: 'value_before',
																							_1: {
																								ctor: '::',
																								_0: 'value_after',
																								_1: {ctor: '[]'}
																							}
																						},
																						A2(
																							_user$project$EvalUpdate$twoArgs,
																							'__diff__',
																							F2(
																								function (before, after) {
																									return _elm_lang$core$Result$Ok(
																										{
																											ctor: '_Tuple2',
																											_0: A3(
																												_user$project$ValBuilder$result,
																												_user$project$ValBuilder$maybe(_user$project$UpdateUtils$vDiffsToVal),
																												_user$project$ValBuilder$fromVal(before),
																												_user$project$Results$firstResult(
																													A2(_user$project$UpdateUtils$defaultVDiffs, before, after))),
																											_1: {ctor: '[]'}
																										});
																								})),
																						_elm_lang$core$Maybe$Nothing))
																			},
																			_1: {
																				ctor: '::',
																				_0: {
																					ctor: '_Tuple2',
																					_0: 'replaceAllIn',
																					_1: A2(_user$project$UpdateRegex$replaceAllByIn, _user$project$EvalUpdate$eval, _user$project$EvalUpdate$update)
																				},
																				_1: {
																					ctor: '::',
																					_0: {
																						ctor: '_Tuple2',
																						_0: 'replaceFirstIn',
																						_1: A2(_user$project$UpdateRegex$replaceFirstByIn, _user$project$EvalUpdate$eval, _user$project$EvalUpdate$update)
																					},
																					_1: {
																						ctor: '::',
																						_0: {
																							ctor: '_Tuple2',
																							_0: 'updateReplace',
																							_1: A2(_user$project$UpdateRegex$updateReplace, _user$project$EvalUpdate$eval, _user$project$EvalUpdate$update)
																						},
																						_1: {
																							ctor: '::',
																							_0: {
																								ctor: '_Tuple2',
																								_0: 'findInterleavings',
																								_1: _user$project$UpdateRegex$findInterleavings(_user$project$EvalUpdate$update)
																							},
																							_1: {
																								ctor: '::',
																								_0: {ctor: '_Tuple2', _0: 'join__', _1: _user$project$UpdateRegex$join},
																								_1: {
																									ctor: '::',
																									_0: {
																										ctor: '_Tuple2',
																										_0: '__mergeHtmlText__',
																										_1: A2(
																											_user$project$Lang$builtinVal,
																											'Evalupdate.__mergeHtmlText__',
																											A4(
																												_user$project$Lang$VFun,
																												'__mergeHtmlText__',
																												{
																													ctor: '::',
																													_0: 'htmlnodeList',
																													_1: {ctor: '[]'}
																												},
																												A2(
																													_user$project$EvalUpdate$oneArg,
																													'htmlnodeList',
																													function (original) {
																														var mergeHtmlText = function (l) {
																															mergeHtmlText:
																															while (true) {
																																var _p168 = l;
																																if (_p168.ctor === '::') {
																																	if (_p168._1.ctor === '::') {
																																		var _p172 = _p168._1._1;
																																		var _p171 = _p168._1._0;
																																		var _p170 = _p168._0;
																																		var _p169 = {
																																			ctor: '_Tuple2',
																																			_0: _user$project$Lang$vHtmlTextUnapply(_p170),
																																			_1: _user$project$Lang$vHtmlTextUnapply(_p171)
																																		};
																																		_v107_2:
																																		do {
																																			if ((_p169.ctor === '_Tuple2') && (_p169._0.ctor === 'Just')) {
																																				if (_p169._1.ctor === 'Just') {
																																					var _v108 = {
																																						ctor: '::',
																																						_0: A2(
																																							_user$project$ValBuilder$htmlText,
																																							_user$project$ValBuilder$fromVal(original),
																																							A2(_elm_lang$core$Basics_ops['++'], _p169._0._0, _p169._1._0)),
																																						_1: _p172
																																					};
																																					l = _v108;
																																					continue mergeHtmlText;
																																				} else {
																																					if (_p169._0._0 === '') {
																																						var _v109 = {ctor: '::', _0: _p171, _1: _p172};
																																						l = _v109;
																																						continue mergeHtmlText;
																																					} else {
																																						break _v107_2;
																																					}
																																				}
																																			} else {
																																				break _v107_2;
																																			}
																																		} while(false);
																																		return {
																																			ctor: '::',
																																			_0: _p170,
																																			_1: mergeHtmlText(
																																				{ctor: '::', _0: _p171, _1: _p172})
																																		};
																																	} else {
																																		var _p173 = _user$project$Lang$vHtmlTextUnapply(_p168._0);
																																		if ((_p173.ctor === 'Just') && (_p173._0 === '')) {
																																			return {ctor: '[]'};
																																		} else {
																																			return l;
																																		}
																																	}
																																} else {
																																	return l;
																																}
																															}
																														};
																														var _p174 = _user$project$Lang$vListUnapply(original);
																														if (_p174.ctor === 'Just') {
																															return _elm_lang$core$Result$Ok(
																																{
																																	ctor: '_Tuple2',
																																	_0: A3(
																																		_user$project$ValBuilder$list,
																																		_user$project$ValBuilder$identity,
																																		_user$project$ValBuilder$fromVal(original),
																																		mergeHtmlText(_p174._0)),
																																	_1: {ctor: '[]'}
																																});
																														} else {
																															return _elm_lang$core$Result$Err(
																																A2(
																																	_elm_lang$core$Basics_ops['++'],
																																	'Expected a list, got ',
																																	_user$project$LangUtils$valToString(original)));
																														}
																													}),
																												_elm_lang$core$Maybe$Just(
																													A2(
																														_user$project$EvalUpdate$oneArgUpdate,
																														'htmlnodeList',
																														F4(
																															function (original, oldVal, newVal, diffs) {
																																var aux = F7(
																																	function (originalIndex, outputIndex, originals, oldOutputs, newOutputs, diffs, resAccRevValRevDiffs) {
																																		aux:
																																		while (true) {
																																			var skipStepAndOutput = F3(
																																				function (originalCount, outputCount, diffs) {
																																					return A7(
																																						aux,
																																						originalIndex + originalCount,
																																						outputIndex + outputCount,
																																						A2(_elm_lang$core$List$drop, originalCount, originals),
																																						A2(_elm_lang$core$List$drop, outputCount, oldOutputs),
																																						A2(_elm_lang$core$List$drop, outputCount, newOutputs),
																																						diffs,
																																						A2(
																																							_user$project$Results$map,
																																							function (_p175) {
																																								var _p176 = _p175;
																																								return {
																																									ctor: '_Tuple2',
																																									_0: A2(
																																										_user$project$Utils$reverseInsert,
																																										A2(_elm_lang$core$List$take, originalCount, originals),
																																										_p176._0),
																																									_1: _p176._1
																																								};
																																							},
																																							resAccRevValRevDiffs));
																																				});
																																			var skipStep = function (originalCount) {
																																				return A2(skipStepAndOutput, originalCount, 1);
																																			};
																																			var insertStep = F2(
																																				function (count, tailDiffs) {
																																					var _p177 = A2(_user$project$Utils$split, count, newOutputs);
																																					var inserted = _p177._0;
																																					var newOutputTail = _p177._1;
																																					return A7(
																																						aux,
																																						originalIndex,
																																						outputIndex,
																																						originals,
																																						oldOutputs,
																																						newOutputTail,
																																						tailDiffs,
																																						A2(
																																							_user$project$Results$map,
																																							function (_p178) {
																																								var _p179 = _p178;
																																								return {
																																									ctor: '_Tuple2',
																																									_0: A2(_user$project$Utils$reverseInsert, inserted, _p179._0),
																																									_1: {
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: originalIndex,
																																											_1: _user$project$Lang$ListElemInsert(count)
																																										},
																																										_1: _p179._1
																																									}
																																								};
																																							},
																																							resAccRevValRevDiffs));
																																				});
																																			var deleteStep = F3(
																																				function (count, originalCount, tailDiffs) {
																																					var newDiffs = _elm_lang$core$Native_Utils.eq(count, 1) ? tailDiffs : {
																																						ctor: '::',
																																						_0: {
																																							ctor: '_Tuple2',
																																							_0: outputIndex + 1,
																																							_1: _user$project$Lang$ListElemDelete(count - 1)
																																						},
																																						_1: tailDiffs
																																					};
																																					return A7(
																																						aux,
																																						originalIndex + originalCount,
																																						outputIndex + 1,
																																						A2(_elm_lang$core$List$drop, originalCount, originals),
																																						A2(_elm_lang$core$List$drop, 1, oldOutputs),
																																						newOutputs,
																																						newDiffs,
																																						A2(
																																							_user$project$Results$map,
																																							function (_p180) {
																																								var _p181 = _p180;
																																								return {
																																									ctor: '_Tuple2',
																																									_0: _p181._0,
																																									_1: {
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: originalIndex,
																																											_1: _user$project$Lang$ListElemDelete(originalCount)
																																										},
																																										_1: _p181._1
																																									}
																																								};
																																							},
																																							resAccRevValRevDiffs));
																																				});
																																			var defaultStep = function (_p182) {
																																				var _p183 = _p182;
																																				var _p184 = diffs;
																																				if (_p184.ctor === '[]') {
																																					var _p185 = originals;
																																					if (_p185.ctor === '[]') {
																																						return A2(
																																							_user$project$Results$map,
																																							function (_p186) {
																																								var _p187 = _p186;
																																								return {
																																									ctor: '_Tuple2',
																																									_0: _elm_lang$core$List$reverse(_p187._0),
																																									_1: _elm_lang$core$List$reverse(_p187._1)
																																								};
																																							},
																																							resAccRevValRevDiffs);
																																					} else {
																																						return A2(
																																							skipStep,
																																							1,
																																							{ctor: '[]'});
																																					}
																																				} else {
																																					var _p191 = _p184._1;
																																					if (_elm_lang$core$Native_Utils.cmp(outputIndex, _p184._0._0) < 0) {
																																						return A2(skipStep, 1, diffs);
																																					} else {
																																						var _p188 = _p184._0._1;
																																						switch (_p188.ctor) {
																																							case 'ListElemDelete':
																																								return A3(deleteStep, _p188._0, 1, _p191);
																																							case 'ListElemInsert':
																																								return A2(insertStep, _p188._0, _p191);
																																							default:
																																								return A7(
																																									aux,
																																									originalIndex + 1,
																																									outputIndex + 1,
																																									A2(_elm_lang$core$List$drop, 1, originals),
																																									A2(_elm_lang$core$List$drop, 1, oldOutputs),
																																									A2(_elm_lang$core$List$drop, 1, newOutputs),
																																									_p191,
																																									A2(
																																										_user$project$Results$map,
																																										function (_p189) {
																																											var _p190 = _p189;
																																											return {
																																												ctor: '_Tuple2',
																																												_0: A2(
																																													_user$project$Utils$reverseInsert,
																																													A2(_elm_lang$core$List$take, 1, newOutputs),
																																													_p190._0),
																																												_1: {
																																													ctor: '::',
																																													_0: {
																																														ctor: '_Tuple2',
																																														_0: originalIndex,
																																														_1: _user$project$Lang$ListElemUpdate(_p188._0)
																																													},
																																													_1: _p190._1
																																												}
																																											};
																																										},
																																										resAccRevValRevDiffs));
																																						}
																																					}
																																				}
																																			};
																																			var _p192 = A2(_user$project$Utils$splitPrefix, _user$project$Lang$vHtmlTextUnapply, originals);
																																			var manyTexts = _p192._0;
																																			var originalTail = _p192._1;
																																			var finalStep = function (_p193) {
																																				var _p194 = _p193;
																																				var _p195 = originals;
																																				if (_p195.ctor === '[]') {
																																					return A2(
																																						_user$project$Results$map,
																																						function (_p196) {
																																							var _p197 = _p196;
																																							return {
																																								ctor: '_Tuple2',
																																								_0: _elm_lang$core$List$reverse(_p197._0),
																																								_1: _elm_lang$core$List$reverse(_p197._1)
																																							};
																																						},
																																						resAccRevValRevDiffs);
																																				} else {
																																					return A2(
																																						skipStep,
																																						_elm_lang$core$List$length(manyTexts),
																																						{ctor: '[]'});
																																				}
																																			};
																																			if (_elm_lang$core$Native_Utils.eq(
																																				_elm_lang$core$List$length(manyTexts),
																																				0)) {
																																				return defaultStep(
																																					{ctor: '_Tuple0'});
																																			} else {
																																				if (A2(
																																					_elm_lang$core$List$all,
																																					F2(
																																						function (x, y) {
																																							return _elm_lang$core$Native_Utils.eq(x, y);
																																						})(''),
																																					manyTexts)) {
																																					var _p198 = diffs;
																																					if (_p198.ctor === '[]') {
																																						return finalStep(
																																							{ctor: '_Tuple0'});
																																					} else {
																																						var _p212 = _p198._1;
																																						var _p211 = _p198._0._0;
																																						if (!_elm_lang$core$Native_Utils.eq(outputIndex, _p211)) {
																																							return A2(
																																								skipStep,
																																								_elm_lang$core$List$length(manyTexts),
																																								diffs);
																																						} else {
																																							var _p199 = _p198._0._1;
																																							switch (_p199.ctor) {
																																								case 'ListElemDelete':
																																									return A3(
																																										skipStepAndOutput,
																																										_elm_lang$core$List$length(manyTexts),
																																										0,
																																										diffs);
																																								case 'ListElemUpdate':
																																									return A3(
																																										skipStepAndOutput,
																																										_elm_lang$core$List$length(manyTexts),
																																										0,
																																										diffs);
																																								default:
																																									var _p210 = _p199._0;
																																									if (_elm_lang$core$Native_Utils.eq(_p210, 0)) {
																																										return A3(skipStepAndOutput, 0, 0, _p212);
																																									} else {
																																										var _p200 = newOutputs;
																																										if (_p200.ctor === '[]') {
																																											return _elm_lang$core$Result$Err('Inconsistent diffs, says ListElemInsert but got no new output');
																																										} else {
																																											var finalTailDiffs = _elm_lang$core$Native_Utils.eq(_p210, 1) ? _p212 : {
																																												ctor: '::',
																																												_0: {
																																													ctor: '_Tuple2',
																																													_0: _p211,
																																													_1: _user$project$Lang$ListElemInsert(_p210 - 1)
																																												},
																																												_1: _p212
																																											};
																																											var _p201 = _user$project$Lang$vHtmlTextUnapply(_p200._0);
																																											if (_p201.ctor === 'Nothing') {
																																												return A2(insertStep, 1, finalTailDiffs);
																																											} else {
																																												var _p209 = _p201._0;
																																												var _v131 = originalIndex + _elm_lang$core$List$length(manyTexts),
																																													_v132 = outputIndex,
																																													_v133 = originalTail,
																																													_v134 = oldOutputs,
																																													_v135 = _p200._1,
																																													_v136 = finalTailDiffs,
																																													_v137 = A2(
																																													_user$project$Results$andThen,
																																													A2(
																																														_user$project$Utils$fixtailrec,
																																														resAccRevValRevDiffs,
																																														function (resAccRevValRevDiffs) {
																																															return A2(
																																																_user$project$Utils$fixtailrec,
																																																originalIndex,
																																																F2(
																																																	function (originalIndex, _p202) {
																																																		var _p203 = _p202;
																																																		return A2(
																																																			_user$project$Results$map,
																																																			A2(
																																																				_user$project$Utils$fixtailrec,
																																																				_p203._0,
																																																				function (newMany) {
																																																					return A2(
																																																						_user$project$Utils$fixtailrec,
																																																						_p203._1,
																																																						F2(
																																																							function (newManyDiffs, _p204) {
																																																								var _p205 = _p204;
																																																								var newRevDiffs = A2(
																																																									_user$project$Utils$reverseInsert,
																																																									A2(
																																																										_elm_lang$core$List$concatMap,
																																																										function (_p206) {
																																																											var _p207 = _p206;
																																																											var _p208 = _p207._0;
																																																											return _elm_lang$core$Native_Utils.eq(
																																																												_p208,
																																																												{ctor: '[]'}) ? {ctor: '[]'} : {
																																																												ctor: '::',
																																																												_0: {
																																																													ctor: '_Tuple2',
																																																													_0: originalIndex + _p207._1,
																																																													_1: _user$project$Lang$ListElemUpdate(
																																																														_user$project$Lang$vHtmlTextDiffs(
																																																															_user$project$Lang$VStringDiffs(_p208)))
																																																												},
																																																												_1: {ctor: '[]'}
																																																											};
																																																										},
																																																										_user$project$Utils$zipWithIndex(newManyDiffs)),
																																																									_p205._1);
																																																								var newRevVals = A2(
																																																									_user$project$Utils$reverseInsert,
																																																									A2(
																																																										_elm_lang$core$List$map,
																																																										_user$project$ValBuilder$htmlText(
																																																											_user$project$ValBuilder$fromVal(original)),
																																																										newMany),
																																																									_p205._0);
																																																								return {ctor: '_Tuple2', _0: newRevVals, _1: newRevDiffs};
																																																							}));
																																																				}),
																																																			resAccRevValRevDiffs);
																																																	}));
																																														}),
																																													A3(
																																														_user$project$UpdateUtils$reverseStringConcatenationMultiple,
																																														manyTexts,
																																														_p209,
																																														{
																																															ctor: '::',
																																															_0: A3(
																																																_user$project$Lang$StringUpdate,
																																																0,
																																																0,
																																																_elm_lang$core$String$length(_p209)),
																																															_1: {ctor: '[]'}
																																														}));
																																												originalIndex = _v131;
																																												outputIndex = _v132;
																																												originals = _v133;
																																												oldOutputs = _v134;
																																												newOutputs = _v135;
																																												diffs = _v136;
																																												resAccRevValRevDiffs = _v137;
																																												continue aux;
																																											}
																																										}
																																									}
																																							}
																																						}
																																					}
																																				} else {
																																					var _p213 = diffs;
																																					if (_p213.ctor === '[]') {
																																						return finalStep(
																																							{ctor: '_Tuple0'});
																																					} else {
																																						var _p226 = _p213._1;
																																						if (!_elm_lang$core$Native_Utils.eq(outputIndex, _p213._0._0)) {
																																							return A2(
																																								skipStep,
																																								_elm_lang$core$List$length(manyTexts),
																																								diffs);
																																						} else {
																																							var _p214 = _p213._0._1;
																																							switch (_p214.ctor) {
																																								case 'ListElemDelete':
																																									return A3(
																																										deleteStep,
																																										_p214._0,
																																										_elm_lang$core$List$length(manyTexts),
																																										_p226);
																																								case 'ListElemInsert':
																																									return A2(insertStep, _p214._0, _p226);
																																								default:
																																									var _p225 = _p214._0;
																																									var _p215 = {ctor: '_Tuple2', _0: oldOutputs, _1: newOutputs};
																																									if (_p215._1.ctor === '[]') {
																																										return _elm_lang$core$Result$Err('Inconsistent diffs, says ListElemUpdate but got no new output');
																																									} else {
																																										if (_p215._0.ctor === '[]') {
																																											return _elm_lang$core$Result$Err('Inconsistent diffs, says ListElemUpdate but got no old output');
																																										} else {
																																											var _p224 = _p215._1._0;
																																											var _p216 = {
																																												ctor: '_Tuple2',
																																												_0: _user$project$Lang$vHtmlTextUnapply(_p224),
																																												_1: _user$project$Lang$vHtmlTextDiffsUnapply(_p225)
																																											};
																																											_v141_1:
																																											do {
																																												if (_p216._0.ctor === 'Just') {
																																													if (_p216._1.ctor === 'Just') {
																																														var _v145 = originalIndex + _elm_lang$core$List$length(manyTexts),
																																															_v146 = outputIndex + 1,
																																															_v147 = originalTail,
																																															_v148 = _p215._0._1,
																																															_v149 = _p215._1._1,
																																															_v150 = _p226,
																																															_v151 = A2(
																																															_user$project$Results$andThen,
																																															A2(
																																																_user$project$Utils$fixtailrec,
																																																resAccRevValRevDiffs,
																																																function (resAccRevValRevDiffs) {
																																																	return A2(
																																																		_user$project$Utils$fixtailrec,
																																																		originalIndex,
																																																		F2(
																																																			function (originalIndex, _p217) {
																																																				var _p218 = _p217;
																																																				return A2(
																																																					_user$project$Results$map,
																																																					A2(
																																																						_user$project$Utils$fixtailrec,
																																																						_p218._0,
																																																						function (newMany) {
																																																							return A2(
																																																								_user$project$Utils$fixtailrec,
																																																								_p218._1,
																																																								F2(
																																																									function (newManyDiffs, _p219) {
																																																										var _p220 = _p219;
																																																										var newRevDiffs = A2(
																																																											_user$project$Utils$reverseInsert,
																																																											A2(
																																																												_elm_lang$core$List$concatMap,
																																																												function (_p221) {
																																																													var _p222 = _p221;
																																																													var _p223 = _p222._0;
																																																													return _elm_lang$core$Native_Utils.eq(
																																																														_p223,
																																																														{ctor: '[]'}) ? {ctor: '[]'} : {
																																																														ctor: '::',
																																																														_0: {
																																																															ctor: '_Tuple2',
																																																															_0: originalIndex + _p222._1,
																																																															_1: _user$project$Lang$ListElemUpdate(
																																																																_user$project$Lang$vHtmlTextDiffs(
																																																																	_user$project$Lang$VStringDiffs(_p223)))
																																																														},
																																																														_1: {ctor: '[]'}
																																																													};
																																																												},
																																																												_user$project$Utils$zipWithIndex(newManyDiffs)),
																																																											_p220._1);
																																																										var newRevVals = A2(
																																																											_user$project$Utils$reverseInsert,
																																																											A2(
																																																												_elm_lang$core$List$map,
																																																												_user$project$ValBuilder$htmlText(
																																																													_user$project$ValBuilder$fromVal(original)),
																																																												newMany),
																																																											_p220._0);
																																																										return {ctor: '_Tuple2', _0: newRevVals, _1: newRevDiffs};
																																																									}));
																																																						}),
																																																					resAccRevValRevDiffs);
																																																			}));
																																																}),
																																															A3(_user$project$UpdateUtils$reverseStringConcatenationMultiple, manyTexts, _p216._0._0, _p216._1._0));
																																														originalIndex = _v145;
																																														outputIndex = _v146;
																																														originals = _v147;
																																														oldOutputs = _v148;
																																														newOutputs = _v149;
																																														diffs = _v150;
																																														resAccRevValRevDiffs = _v151;
																																														continue aux;
																																													} else {
																																														break _v141_1;
																																													}
																																												} else {
																																													if (_p216._1.ctor === 'Nothing') {
																																														break _v141_1;
																																													} else {
																																														return _elm_lang$core$Result$Err(
																																															A2(
																																																_elm_lang$core$Basics_ops['++'],
																																																'In a html text node, cannot update with anything else than a text node. Got new value ',
																																																_user$project$LangUtils$valToString(_p224)));
																																													}
																																												}
																																											} while(false);
																																											return _elm_lang$core$Result$Err(
																																												A2(
																																													_elm_lang$core$Basics_ops['++'],
																																													'In a html text node, cannot update anything else than the text itself. Got ',
																																													_elm_lang$core$Basics$toString(_p225)));
																																										}
																																									}
																																							}
																																						}
																																					}
																																				}
																																			}
																																		}
																																	});
																																var _p227 = {
																																	ctor: '_Tuple4',
																																	_0: _user$project$Lang$vListUnapply(original),
																																	_1: _user$project$Lang$vListUnapply(oldVal),
																																	_2: _user$project$Lang$vListUnapply(newVal),
																																	_3: diffs
																																};
																																if (((((_p227.ctor === '_Tuple4') && (_p227._0.ctor === 'Just')) && (_p227._1.ctor === 'Just')) && (_p227._2.ctor === 'Just')) && (_p227._3.ctor === 'VListDiffs')) {
																																	return A2(
																																		_user$project$Results$map,
																																		function (_p228) {
																																			var _p229 = _p228;
																																			var _p230 = _p229._1;
																																			var finalDiffs = _elm_lang$core$Native_Utils.eq(
																																				_p230,
																																				{ctor: '[]'}) ? {ctor: '[]'} : {
																																				ctor: '::',
																																				_0: {
																																					ctor: '_Tuple2',
																																					_0: 0,
																																					_1: _user$project$Lang$VListDiffs(_p230)
																																				},
																																				_1: {ctor: '[]'}
																																			};
																																			return {
																																				ctor: '_Tuple2',
																																				_0: {
																																					ctor: '::',
																																					_0: A3(
																																						_user$project$ValBuilder$list,
																																						_user$project$ValBuilder$identity,
																																						_user$project$ValBuilder$fromVal(original),
																																						_p229._0),
																																					_1: {ctor: '[]'}
																																				},
																																				_1: finalDiffs
																																			};
																																		},
																																		A7(
																																			aux,
																																			0,
																																			0,
																																			_p227._0._0,
																																			_p227._1._0,
																																			_p227._2._0,
																																			_p227._3._0,
																																			_user$project$Results$ok1(
																																				{
																																					ctor: '_Tuple2',
																																					_0: {ctor: '[]'},
																																					_1: {ctor: '[]'}
																																				})));
																																} else {
																																	return _elm_lang$core$Result$Err(
																																		A2(
																																			_elm_lang$core$Basics_ops['++'],
																																			'Expected lists and listdiffs to update __mergeHtmlText__, got ',
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				_user$project$LangUtils$valToString(original),
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					', ',
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						_user$project$LangUtils$valToString(oldVal),
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							', ',
																																							A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								_user$project$LangUtils$valToString(newVal),
																																								A2(
																																									_elm_lang$core$Basics_ops['++'],
																																									', ',
																																									_elm_lang$core$Basics$toString(diffs)))))))));
																																}
																															})))))
																									},
																									_1: {
																										ctor: '::',
																										_0: {
																											ctor: '_Tuple2',
																											_0: '__htmlEntity__',
																											_1: A2(
																												_user$project$Lang$builtinVal,
																												'EvalUpdate.__htmlEntity__',
																												A4(
																													_user$project$Lang$VFun,
																													'__htmlEntity__',
																													{
																														ctor: '::',
																														_0: 'entityRendered',
																														_1: {
																															ctor: '::',
																															_0: 'entity',
																															_1: {ctor: '[]'}
																														}
																													},
																													A2(
																														_user$project$EvalUpdate$twoArgs,
																														'__htmlEntity__',
																														F2(
																															function (entityRendered, entity) {
																																return _elm_lang$core$Result$Ok(
																																	{
																																		ctor: '_Tuple2',
																																		_0: A3(
																																			_user$project$ValBuilder$list,
																																			A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$identity),
																																			_user$project$ValBuilder$fromVal(entityRendered),
																																			{
																																				ctor: '::',
																																				_0: {ctor: '_Tuple2', _0: 'TEXT', _1: entityRendered},
																																				_1: {ctor: '[]'}
																																			}),
																																		_1: {ctor: '[]'}
																																	});
																															})),
																													_elm_lang$core$Maybe$Just(
																														A2(
																															_user$project$EvalUpdate$twoArgsUpdate,
																															'__htmlEntity__',
																															F5(
																																function (entityRendered, entity, oldVal, newVal, diffs) {
																																	var _p231 = {
																																		ctor: '_Tuple3',
																																		_0: entityRendered.v_,
																																		_1: entity.v_,
																																		_2: A2(
																																			_user$project$ValUnbuilder$list,
																																			A2(_user$project$ValUnbuilder$viewtuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$string),
																																			newVal)
																																	};
																																	if ((((((_p231.ctor === '_Tuple3') && (_p231._0.ctor === 'VBase')) && (_p231._0._0.ctor === 'VString')) && (_p231._1.ctor === 'VBase')) && (_p231._1._0.ctor === 'VString')) && (_p231._2.ctor === 'Ok')) {
																																		var newValS = A2(
																																			_elm_lang$core$String$join,
																																			'',
																																			A2(
																																				_elm_lang$core$List$map,
																																				function (_p232) {
																																					var _p233 = _p232;
																																					return _p233._1;
																																				},
																																				_p231._2._0));
																																		var escapedNewValS = _user$project$ImpureGoodies$htmlescape(newValS);
																																		var newEntity = A2(
																																			_user$project$Lang$replaceV_,
																																			newVal,
																																			_user$project$Lang$VBase(
																																				_user$project$Lang$VString(escapedNewValS)));
																																		var newEntityRenderedS = newValS;
																																		var newEntityRendered = A2(
																																			_user$project$Lang$replaceV_,
																																			newVal,
																																			_user$project$Lang$VBase(
																																				_user$project$Lang$VString(newEntityRenderedS)));
																																		return _user$project$Results$ok1(
																																			{
																																				ctor: '_Tuple2',
																																				_0: {
																																					ctor: '::',
																																					_0: newEntityRendered,
																																					_1: {
																																						ctor: '::',
																																						_0: newEntity,
																																						_1: {ctor: '[]'}
																																					}
																																				},
																																				_1: {
																																					ctor: '::',
																																					_0: {
																																						ctor: '_Tuple2',
																																						_0: 0,
																																						_1: _user$project$Lang$VStringDiffs(
																																							{
																																								ctor: '::',
																																								_0: A3(
																																									_user$project$Lang$StringUpdate,
																																									0,
																																									_elm_lang$core$String$length(_p231._0._0._0),
																																									_elm_lang$core$String$length(newEntityRenderedS)),
																																								_1: {ctor: '[]'}
																																							})
																																					},
																																					_1: {
																																						ctor: '::',
																																						_0: {
																																							ctor: '_Tuple2',
																																							_0: 1,
																																							_1: _user$project$Lang$VStringDiffs(
																																								{
																																									ctor: '::',
																																									_0: A3(
																																										_user$project$Lang$StringUpdate,
																																										0,
																																										_elm_lang$core$String$length(_p231._1._0._0),
																																										_elm_lang$core$String$length(escapedNewValS)),
																																									_1: {ctor: '[]'}
																																								})
																																						},
																																						_1: {ctor: '[]'}
																																					}
																																				}
																																			});
																																	} else {
																																		return _elm_lang$core$Result$Err(
																																			A2(
																																				_elm_lang$core$Basics_ops['++'],
																																				'Expected strings as arguments and [[\"TEXT\", _]] as return of __htmlEntity__, got __htmlEntity__ ',
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					_user$project$LangUtils$valToString(entityRendered),
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						' ',
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							_user$project$LangUtils$valToString(entity),
																																							A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								' updated by ',
																																								_user$project$LangUtils$valToString(newVal)))))));
																																	}
																																})))))
																										},
																										_1: {
																											ctor: '::',
																											_0: {
																												ctor: '_Tuple2',
																												_0: '__htmlStrEntity__',
																												_1: A2(
																													_user$project$Lang$builtinVal,
																													'EvalUpdate.__htmlStrEntity__',
																													A4(
																														_user$project$Lang$VFun,
																														'__htmlStrEntity__',
																														{
																															ctor: '::',
																															_0: 'entityRendered',
																															_1: {
																																ctor: '::',
																																_0: 'entity',
																																_1: {ctor: '[]'}
																															}
																														},
																														A2(
																															_user$project$EvalUpdate$twoArgs,
																															'__htmlStrEntity__',
																															F2(
																																function (entityRendered, entity) {
																																	return _elm_lang$core$Result$Ok(
																																		{
																																			ctor: '_Tuple2',
																																			_0: entityRendered,
																																			_1: {ctor: '[]'}
																																		});
																																})),
																														_elm_lang$core$Maybe$Just(
																															A2(
																																_user$project$EvalUpdate$twoArgsUpdate,
																																'__htmlStrEntity__',
																																F5(
																																	function (entityRendered, entity, oldVal, newVal, diffs) {
																																		var _p234 = {ctor: '_Tuple3', _0: entityRendered.v_, _1: entity.v_, _2: newVal.v_};
																																		if (((((((_p234.ctor === '_Tuple3') && (_p234._0.ctor === 'VBase')) && (_p234._0._0.ctor === 'VString')) && (_p234._1.ctor === 'VBase')) && (_p234._1._0.ctor === 'VString')) && (_p234._2.ctor === 'VBase')) && (_p234._2._0.ctor === 'VString')) {
																																			var _p235 = _p234._2._0._0;
																																			var escapedNewValS = _p235;
																																			var newEntity = A2(
																																				_user$project$Lang$replaceV_,
																																				newVal,
																																				_user$project$Lang$VBase(
																																					_user$project$Lang$VString(escapedNewValS)));
																																			var newEntityRenderedS = _p235;
																																			var newEntityRendered = A2(
																																				_user$project$Lang$replaceV_,
																																				newVal,
																																				_user$project$Lang$VBase(
																																					_user$project$Lang$VString(newEntityRenderedS)));
																																			return _user$project$Results$ok1(
																																				{
																																					ctor: '_Tuple2',
																																					_0: {
																																						ctor: '::',
																																						_0: newEntityRendered,
																																						_1: {
																																							ctor: '::',
																																							_0: newEntity,
																																							_1: {ctor: '[]'}
																																						}
																																					},
																																					_1: {
																																						ctor: '::',
																																						_0: {
																																							ctor: '_Tuple2',
																																							_0: 0,
																																							_1: _user$project$Lang$VStringDiffs(
																																								{
																																									ctor: '::',
																																									_0: A3(
																																										_user$project$Lang$StringUpdate,
																																										0,
																																										_elm_lang$core$String$length(_p234._0._0._0),
																																										_elm_lang$core$String$length(newEntityRenderedS)),
																																									_1: {ctor: '[]'}
																																								})
																																						},
																																						_1: {
																																							ctor: '::',
																																							_0: {
																																								ctor: '_Tuple2',
																																								_0: 1,
																																								_1: _user$project$Lang$VStringDiffs(
																																									{
																																										ctor: '::',
																																										_0: A3(
																																											_user$project$Lang$StringUpdate,
																																											0,
																																											_elm_lang$core$String$length(_p234._1._0._0),
																																											_elm_lang$core$String$length(escapedNewValS)),
																																										_1: {ctor: '[]'}
																																									})
																																							},
																																							_1: {ctor: '[]'}
																																						}
																																					}
																																				});
																																		} else {
																																			return _elm_lang$core$Result$Err(
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					'Expected strings as arguments and as return of __htmlStrEntity__, got __htmlStrEntity__ ',
																																					A2(
																																						_elm_lang$core$Basics_ops['++'],
																																						_user$project$LangUtils$valToString(entityRendered),
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							', ',
																																							A2(
																																								_elm_lang$core$Basics_ops['++'],
																																								_user$project$LangUtils$valToString(entity),
																																								A2(
																																									_elm_lang$core$Basics_ops['++'],
																																									' updated by ',
																																									_user$project$LangUtils$valToString(newVal)))))));
																																		}
																																	})))))
																											},
																											_1: {
																												ctor: '::',
																												_0: {
																													ctor: '_Tuple2',
																													_0: '__htmlRawAttribute__',
																													_1: A2(
																														_user$project$Lang$builtinVal,
																														'EvalUpdate.__htmlRawAttribute__',
																														A4(
																															_user$project$Lang$VFun,
																															'__htmlRawAttribute__',
																															{
																																ctor: '::',
																																_0: 'content',
																																_1: {ctor: '[]'}
																															},
																															A2(
																																_user$project$EvalUpdate$oneArg,
																																'__htmlRawAttribute__',
																																function (arg) {
																																	return _elm_lang$core$Result$Ok(
																																		{
																																			ctor: '_Tuple2',
																																			_0: arg,
																																			_1: {ctor: '[]'}
																																		});
																																}),
																															_elm_lang$core$Maybe$Just(
																																A2(
																																	_user$project$EvalUpdate$oneArgUpdate,
																																	'__htmlRawAttribute__',
																																	F4(
																																		function (arg, oldVal, newVal, diffs) {
																																			return _user$project$Results$ok1(
																																				{
																																					ctor: '_Tuple2',
																																					_0: {
																																						ctor: '::',
																																						_0: newVal,
																																						_1: {ctor: '[]'}
																																					},
																																					_1: {
																																						ctor: '::',
																																						_0: {ctor: '_Tuple2', _0: 0, _1: diffs},
																																						_1: {ctor: '[]'}
																																					}
																																				});
																																		})))))
																												},
																												_1: {
																													ctor: '::',
																													_0: {
																														ctor: '_Tuple2',
																														_0: '__mbwraphtmlnode__',
																														_1: A2(
																															_user$project$Lang$builtinVal,
																															'EvalUpdate.__mbwraphtmlnode__',
																															A4(
																																_user$project$Lang$VFun,
																																'__mbwraphtmlnode__',
																																{
																																	ctor: '::',
																																	_0: 'string_node_listnode',
																																	_1: {ctor: '[]'}
																																},
																																A2(
																																	_user$project$EvalUpdate$oneArg,
																																	'string_node_listnode',
																																	function (original) {
																																		var _p236 = original.v_;
																																		_v157_3:
																																		do {
																																			switch (_p236.ctor) {
																																				case 'VConst':
																																					if (_p236._1.ctor === '_Tuple2') {
																																						return _elm_lang$core$Result$Ok(
																																							{
																																								ctor: '_Tuple2',
																																								_0: A3(
																																									_user$project$ValBuilder$list,
																																									A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$string),
																																									_user$project$ValBuilder$fromVal(original),
																																									{
																																										ctor: '::',
																																										_0: {
																																											ctor: '_Tuple2',
																																											_0: 'TEXT',
																																											_1: _elm_lang$core$Basics$toString(_p236._1._0)
																																										},
																																										_1: {ctor: '[]'}
																																									}),
																																								_1: {ctor: '[]'}
																																							});
																																					} else {
																																						break _v157_3;
																																					}
																																				case 'VBase':
																																					if (_p236._0.ctor === 'VString') {
																																						return _elm_lang$core$Result$Ok(
																																							{
																																								ctor: '_Tuple2',
																																								_0: A3(
																																									_user$project$ValBuilder$list,
																																									A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$string),
																																									_user$project$ValBuilder$fromVal(original),
																																									{
																																										ctor: '::',
																																										_0: {ctor: '_Tuple2', _0: 'TEXT', _1: _p236._0._0},
																																										_1: {ctor: '[]'}
																																									}),
																																								_1: {ctor: '[]'}
																																							});
																																					} else {
																																						break _v157_3;
																																					}
																																				case 'VList':
																																					if (_p236._0.ctor === '::') {
																																						var _p237 = _p236._0._0.v_;
																																						if ((_p237.ctor === 'VBase') && (_p237._0.ctor === 'VString')) {
																																							return _elm_lang$core$Result$Ok(
																																								{
																																									ctor: '_Tuple2',
																																									_0: A3(
																																										_user$project$ValBuilder$list,
																																										_user$project$ValBuilder$identity,
																																										_user$project$ValBuilder$fromVal(original),
																																										{
																																											ctor: '::',
																																											_0: original,
																																											_1: {ctor: '[]'}
																																										}),
																																									_1: {ctor: '[]'}
																																								});
																																						} else {
																																							return _elm_lang$core$Result$Ok(
																																								{
																																									ctor: '_Tuple2',
																																									_0: original,
																																									_1: {ctor: '[]'}
																																								});
																																						}
																																					} else {
																																						break _v157_3;
																																					}
																																				default:
																																					break _v157_3;
																																			}
																																		} while(false);
																																		return _elm_lang$core$Result$Ok(
																																			{
																																				ctor: '_Tuple2',
																																				_0: original,
																																				_1: {ctor: '[]'}
																																			});
																																	}),
																																_elm_lang$core$Maybe$Just(
																																	A2(
																																		_user$project$EvalUpdate$oneArgUpdate,
																																		'string_node_listnode',
																																		F4(
																																			function (original, oldVal, newVal, diffs) {
																																				var unwrapExpDiffs = F2(
																																					function (newVal, diffs) {
																																						var _p238 = {ctor: '_Tuple2', _0: newVal.v_, _1: diffs};
																																						_v159_2:
																																						do {
																																							if ((_p238.ctor === '_Tuple2') && (_p238._1.ctor === 'VListDiffs')) {
																																								if (_p238._1._0.ctor === '::') {
																																									if (((((((_p238._0.ctor === 'VList') && (_p238._0._0.ctor === '::')) && (_p238._0._0._1.ctor === '[]')) && (_p238._1._0._0.ctor === '_Tuple2')) && (_p238._1._0._0._0 === 0)) && (_p238._1._0._0._1.ctor === 'ListElemUpdate')) && (_p238._1._0._1.ctor === '[]')) {
																																										var _p239 = {
																																											ctor: '_Tuple2',
																																											_0: A3(_user$project$ValUnbuilder$viewtuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$string, _p238._0._0._0),
																																											_1: _p238._1._0._0._1._0
																																										};
																																										_v160_3:
																																										do {
																																											_v160_1:
																																											do {
																																												if (_p239._0.ctor === 'Ok') {
																																													if (_p239._1.ctor === 'VListDiffs') {
																																														if (_p239._1._0.ctor === '::') {
																																															if ((((((_p239._0._0.ctor === '_Tuple2') && (_p239._0._0._0 === 'TEXT')) && (_p239._1._0._0.ctor === '_Tuple2')) && (_p239._1._0._0._0 === 1)) && (_p239._1._0._0._1.ctor === 'ListElemUpdate')) && (_p239._1._0._1.ctor === '[]')) {
																																																return _elm_lang$core$Result$Ok(
																																																	_elm_lang$core$Maybe$Just(
																																																		_elm_lang$core$Maybe$Just(
																																																			{ctor: '_Tuple2', _0: _p239._0._0._1, _1: _p239._1._0._0._1._0})));
																																															} else {
																																																break _v160_3;
																																															}
																																														} else {
																																															break _v160_1;
																																														}
																																													} else {
																																														break _v160_3;
																																													}
																																												} else {
																																													if ((_p239._1.ctor === 'VListDiffs') && (_p239._1._0.ctor === '[]')) {
																																														break _v160_1;
																																													} else {
																																														return _elm_lang$core$Result$Err(_p239._0._0);
																																													}
																																												}
																																											} while(false);
																																											return _elm_lang$core$Result$Ok(
																																												_elm_lang$core$Maybe$Just(_elm_lang$core$Maybe$Nothing));
																																										} while(false);
																																										return _elm_lang$core$Result$Ok(_elm_lang$core$Maybe$Nothing);
																																									} else {
																																										break _v159_2;
																																									}
																																								} else {
																																									return _elm_lang$core$Result$Ok(
																																										_elm_lang$core$Maybe$Just(_elm_lang$core$Maybe$Nothing));
																																								}
																																							} else {
																																								break _v159_2;
																																							}
																																						} while(false);
																																						return _elm_lang$core$Result$Ok(_elm_lang$core$Maybe$Nothing);
																																					});
																																				var _p240 = original.v_;
																																				_v161_3:
																																				do {
																																					switch (_p240.ctor) {
																																						case 'VConst':
																																							if (_p240._1.ctor === '_Tuple2') {
																																								var _p241 = A2(unwrapExpDiffs, newVal, diffs);
																																								if (_p241.ctor === 'Err') {
																																									return _elm_lang$core$Result$Err(_p241._0);
																																								} else {
																																									if (_p241._0.ctor === 'Nothing') {
																																										return _elm_lang$core$Result$Ok(_user$project$LazyList$Nil);
																																									} else {
																																										if (_p241._0._0.ctor === 'Nothing') {
																																											return _user$project$Results$ok1(
																																												{
																																													ctor: '_Tuple2',
																																													_0: {
																																														ctor: '::',
																																														_0: original,
																																														_1: {ctor: '[]'}
																																													},
																																													_1: {ctor: '[]'}
																																												});
																																										} else {
																																											var _p242 = _elm_lang$core$String$toFloat(_p241._0._0._0._0);
																																											if (_p242.ctor === 'Err') {
																																												return _elm_lang$core$Result$Ok(_user$project$LazyList$Nil);
																																											} else {
																																												return _user$project$Results$ok1(
																																													{
																																														ctor: '_Tuple2',
																																														_0: {
																																															ctor: '::',
																																															_0: A2(
																																																_user$project$ValBuilder$const,
																																																_user$project$ValBuilder$fromVal(original),
																																																_p242._0),
																																															_1: {ctor: '[]'}
																																														},
																																														_1: {
																																															ctor: '::',
																																															_0: {ctor: '_Tuple2', _0: 0, _1: _user$project$Lang$VConstDiffs},
																																															_1: {ctor: '[]'}
																																														}
																																													});
																																											}
																																										}
																																									}
																																								}
																																							} else {
																																								break _v161_3;
																																							}
																																						case 'VBase':
																																							if (_p240._0.ctor === 'VString') {
																																								var _p243 = A2(unwrapExpDiffs, newVal, diffs);
																																								if (_p243.ctor === 'Err') {
																																									return _elm_lang$core$Result$Err(_p243._0);
																																								} else {
																																									if (_p243._0.ctor === 'Nothing') {
																																										return _elm_lang$core$Result$Ok(_user$project$LazyList$Nil);
																																									} else {
																																										if (_p243._0._0.ctor === 'Nothing') {
																																											return _user$project$Results$ok1(
																																												{
																																													ctor: '_Tuple2',
																																													_0: {
																																														ctor: '::',
																																														_0: original,
																																														_1: {ctor: '[]'}
																																													},
																																													_1: {ctor: '[]'}
																																												});
																																										} else {
																																											return _user$project$Results$ok1(
																																												{
																																													ctor: '_Tuple2',
																																													_0: {
																																														ctor: '::',
																																														_0: A2(
																																															_user$project$ValBuilder$string,
																																															_user$project$ValBuilder$fromVal(original),
																																															_p243._0._0._0._0),
																																														_1: {ctor: '[]'}
																																													},
																																													_1: {
																																														ctor: '::',
																																														_0: {ctor: '_Tuple2', _0: 0, _1: _p243._0._0._0._1},
																																														_1: {ctor: '[]'}
																																													}
																																												});
																																										}
																																									}
																																								}
																																							} else {
																																								break _v161_3;
																																							}
																																						case 'VList':
																																							if (_p240._0.ctor === '::') {
																																								var _p244 = {ctor: '_Tuple3', _0: _p240._0._0.v_, _1: newVal.v_, _2: diffs};
																																								if ((((((((((((_p244.ctor === '_Tuple3') && (_p244._0.ctor === 'VBase')) && (_p244._0._0.ctor === 'VString')) && (_p244._1.ctor === 'VList')) && (_p244._1._0.ctor === '::')) && (_p244._1._0._1.ctor === '[]')) && (_p244._2.ctor === 'VListDiffs')) && (_p244._2._0.ctor === '::')) && (_p244._2._0._0.ctor === '_Tuple2')) && (_p244._2._0._0._0 === 0)) && (_p244._2._0._0._1.ctor === 'ListElemUpdate')) && (_p244._2._0._1.ctor === '[]')) {
																																									return _user$project$Results$ok1(
																																										{
																																											ctor: '_Tuple2',
																																											_0: {
																																												ctor: '::',
																																												_0: _p244._1._0._0,
																																												_1: {ctor: '[]'}
																																											},
																																											_1: {
																																												ctor: '::',
																																												_0: {ctor: '_Tuple2', _0: 0, _1: _p244._2._0._0._1._0},
																																												_1: {ctor: '[]'}
																																											}
																																										});
																																								} else {
																																									return _user$project$Results$ok1(
																																										{
																																											ctor: '_Tuple2',
																																											_0: {
																																												ctor: '::',
																																												_0: newVal,
																																												_1: {ctor: '[]'}
																																											},
																																											_1: {
																																												ctor: '::',
																																												_0: {ctor: '_Tuple2', _0: 0, _1: diffs},
																																												_1: {ctor: '[]'}
																																											}
																																										});
																																								}
																																							} else {
																																								break _v161_3;
																																							}
																																						default:
																																							break _v161_3;
																																					}
																																				} while(false);
																																				return _user$project$Results$ok1(
																																					{
																																						ctor: '_Tuple2',
																																						_0: {
																																							ctor: '::',
																																							_0: newVal,
																																							_1: {ctor: '[]'}
																																						},
																																						_1: {
																																							ctor: '::',
																																							_0: {ctor: '_Tuple2', _0: 0, _1: diffs},
																																							_1: {ctor: '[]'}
																																						}
																																					});
																																			})))))
																													},
																													_1: {
																														ctor: '::',
																														_0: {
																															ctor: '_Tuple2',
																															_0: '__mbstylesplit__',
																															_1: A2(
																																_user$project$Lang$builtinVal,
																																'EvalUpdate.__mbstylesplit__',
																																A4(
																																	_user$project$Lang$VFun,
																																	'__mbstylesplit__',
																																	{
																																		ctor: '::',
																																		_0: 'style_str',
																																		_1: {ctor: '[]'}
																																	},
																																	A2(
																																		_user$project$EvalUpdate$oneArg,
																																		'__mbstylesplit__',
																																		function (original) {
																																			var _p245 = original.v_;
																																			_v166_2:
																																			do {
																																				switch (_p245.ctor) {
																																					case 'VList':
																																						return _elm_lang$core$Result$Ok(
																																							{
																																								ctor: '_Tuple2',
																																								_0: original,
																																								_1: {ctor: '[]'}
																																							});
																																					case 'VBase':
																																						if (_p245._0.ctor === 'VString') {
																																							var vb = _user$project$ValBuilder$fromVal(original);
																																							var finalVal = A3(
																																								_user$project$ValBuilder$list,
																																								A2(_user$project$ValBuilder$viewtuple2, _user$project$ValBuilder$string, _user$project$ValBuilder$string),
																																								vb,
																																								A2(
																																									_elm_lang$core$List$map,
																																									function (_p246) {
																																										var _p247 = _p246;
																																										return {ctor: '_Tuple2', _0: _p247._1, _1: _p247._3};
																																									},
																																									_user$project$LangParserUtils$explodeStyleValue(_p245._0._0)));
																																							return _elm_lang$core$Result$Ok(
																																								{
																																									ctor: '_Tuple2',
																																									_0: finalVal,
																																									_1: {ctor: '[]'}
																																								});
																																						} else {
																																							break _v166_2;
																																						}
																																					default:
																																						break _v166_2;
																																				}
																																			} while(false);
																																			return _elm_lang$core$Result$Err(
																																				A2(
																																					_elm_lang$core$Basics_ops['++'],
																																					'__mbstylesplit__ takes a string or a list, got ',
																																					_user$project$LangUtils$valToString(original)));
																																		}),
																																	_elm_lang$core$Maybe$Just(
																																		A2(
																																			_user$project$EvalUpdate$oneArgUpdate,
																																			'__mbstylesplit__',
																																			F4(
																																				function (original, oldVal, newVal, diffs) {
																																					var _p248 = original.v_;
																																					_v168_2:
																																					do {
																																						switch (_p248.ctor) {
																																							case 'VList':
																																								return _user$project$Results$ok1(
																																									{
																																										ctor: '_Tuple2',
																																										_0: {
																																											ctor: '::',
																																											_0: newVal,
																																											_1: {ctor: '[]'}
																																										},
																																										_1: A2(
																																											_elm_lang$core$Maybe$withDefault,
																																											{ctor: '[]'},
																																											_user$project$UpdateUtils$combineTupleDiffs(
																																												{
																																													ctor: '::',
																																													_0: {
																																														ctor: '_Tuple2',
																																														_0: 0,
																																														_1: _elm_lang$core$Maybe$Just(diffs)
																																													},
																																													_1: {ctor: '[]'}
																																												}))
																																									});
																																							case 'VBase':
																																								if (_p248._0.ctor === 'VString') {
																																									var originalStyles = _user$project$LangParserUtils$explodeStyleValue(_p248._0._0);
																																									var _p249 = {
																																										ctor: '_Tuple2',
																																										_0: diffs,
																																										_1: A2(
																																											_user$project$ValUnbuilder$list,
																																											A2(_user$project$ValUnbuilder$viewtuple2, _user$project$ValUnbuilder$string, _user$project$ValUnbuilder$string),
																																											newVal)
																																									};
																																									_v169_2:
																																									do {
																																										if (_p249.ctor === '_Tuple2') {
																																											if (_p249._1.ctor === 'Ok') {
																																												if (_p249._0.ctor === 'VListDiffs') {
																																													var combineOldString = function (_p250) {
																																														var _p251 = _p250;
																																														return A2(
																																															_elm_lang$core$Basics_ops['++'],
																																															_p251._0,
																																															A2(
																																																_elm_lang$core$Basics_ops['++'],
																																																_p251._1,
																																																A2(
																																																	_elm_lang$core$Basics_ops['++'],
																																																	_p251._2,
																																																	A2(_elm_lang$core$Basics_ops['++'], _p251._3, _p251._4))));
																																													};
																																													var aux = F5(
																																														function (i, originalStyles, updatedStyles, diffElems, _p252) {
																																															aux:
																																															while (true) {
																																																var _p253 = _p252;
																																																var _p281 = _p253._2;
																																																var _p280 = _p253._1;
																																																var _p279 = _p253._0;
																																																var _p254 = diffElems;
																																																if (_p254.ctor === '[]') {
																																																	var finalDiffs = A2(
																																																		_elm_lang$core$Debug$log,
																																																		'finalDiffs',
																																																		A2(
																																																			_elm_lang$core$Maybe$withDefault,
																																																			{ctor: '[]'},
																																																			_user$project$UpdateUtils$combineTupleDiffs(
																																																				{
																																																					ctor: '::',
																																																					_0: {
																																																						ctor: '_Tuple2',
																																																						_0: 0,
																																																						_1: _elm_lang$core$Maybe$Just(
																																																							_user$project$Lang$VStringDiffs(
																																																								_elm_lang$core$List$reverse(_p281)))
																																																					},
																																																					_1: {ctor: '[]'}
																																																				})));
																																																	var remainingAcc = A2(
																																																		_elm_lang$core$String$join,
																																																		';',
																																																		A2(_elm_lang$core$List$map, combineOldString, originalStyles));
																																																	var finalString = A2(
																																																		_user$project$Lang$replaceV_,
																																																		original,
																																																		_user$project$Lang$VBase(
																																																			_user$project$Lang$VString(
																																																				A2(
																																																					_elm_lang$core$Debug$log,
																																																					'final string:',
																																																					A2(_elm_lang$core$Basics_ops['++'], _p279, remainingAcc)))));
																																																	return _user$project$Results$ok1(
																																																		{
																																																			ctor: '_Tuple2',
																																																			_0: {
																																																				ctor: '::',
																																																				_0: finalString,
																																																				_1: {ctor: '[]'}
																																																			},
																																																			_1: finalDiffs
																																																		});
																																																} else {
																																																	var _p278 = _p254._1;
																																																	var _p277 = _p254._0._0;
																																																	if (_elm_lang$core$Native_Utils.cmp(_p277, i) > 0) {
																																																		var _p255 = A2(_user$project$Utils$split, _p277 - i, originalStyles);
																																																		var originalStylesKept = _p255._0;
																																																		var originalStylesTail = _p255._1;
																																																		var newUpdatedStyles = A2(_elm_lang$core$List$drop, _p277 - i, updatedStyles);
																																																		var newString = A2(
																																																			_elm_lang$core$String$join,
																																																			'',
																																																			A2(_elm_lang$core$List$map, combineOldString, originalStylesKept));
																																																		var newFinalString = A2(_elm_lang$core$Basics_ops['++'], _p279, newString);
																																																		var newOffset = _p280 + _elm_lang$core$String$length(newString);
																																																		var _v173 = _p277,
																																																			_v174 = originalStylesTail,
																																																			_v175 = newUpdatedStyles,
																																																			_v176 = diffElems,
																																																			_v177 = {ctor: '_Tuple3', _0: newFinalString, _1: newOffset, _2: _p281};
																																																		i = _v173;
																																																		originalStyles = _v174;
																																																		updatedStyles = _v175;
																																																		diffElems = _v176;
																																																		_p252 = _v177;
																																																		continue aux;
																																																	} else {
																																																		var _p256 = _p254._0._1;
																																																		switch (_p256.ctor) {
																																																			case 'ListElemDelete':
																																																				var _p257 = A2(_user$project$Utils$split, _p256._0, originalStyles);
																																																				var originalStylesRemoved = _p257._0;
																																																				var originalStylesTail = _p257._1;
																																																				var oldString = A2(
																																																					_elm_lang$core$String$join,
																																																					'',
																																																					A2(
																																																						_elm_lang$core$List$map,
																																																						function (_p258) {
																																																							var _p259 = _p258;
																																																							return A2(
																																																								_elm_lang$core$Basics_ops['++'],
																																																								_p259._0,
																																																								A2(
																																																									_elm_lang$core$Basics_ops['++'],
																																																									_p259._1,
																																																									A2(
																																																										_elm_lang$core$Basics_ops['++'],
																																																										_p259._2,
																																																										A2(_elm_lang$core$Basics_ops['++'], _p259._3, _p259._4))));
																																																						},
																																																						originalStylesRemoved));
																																																				var newOriginalOffset = _p280 + _elm_lang$core$String$length(
																																																					A2(
																																																						_elm_lang$core$String$join,
																																																						'',
																																																						A2(_elm_lang$core$List$map, combineOldString, originalStylesRemoved)));
																																																				var deletionPoint = _p280;
																																																				var _v180 = _p277 + 1,
																																																					_v181 = originalStylesTail,
																																																					_v182 = updatedStyles,
																																																					_v183 = _p278,
																																																					_v184 = {
																																																					ctor: '_Tuple3',
																																																					_0: _p279,
																																																					_1: newOriginalOffset,
																																																					_2: {
																																																						ctor: '::',
																																																						_0: A3(
																																																							_user$project$Lang$StringUpdate,
																																																							deletionPoint,
																																																							deletionPoint + _elm_lang$core$String$length(oldString),
																																																							0),
																																																						_1: {ctor: '[]'}
																																																					}
																																																				};
																																																				i = _v180;
																																																				originalStyles = _v181;
																																																				updatedStyles = _v182;
																																																				diffElems = _v183;
																																																				_p252 = _v184;
																																																				continue aux;
																																																			case 'ListElemInsert':
																																																				var _p264 = _p256._0;
																																																				var _p260 = A2(_user$project$Utils$split, _p264, updatedStyles);
																																																				var insertedStyles = _p260._0;
																																																				var tailUpdatedStyles = _p260._1;
																																																				var insertedString = A2(
																																																					_elm_lang$core$Basics_ops['++'],
																																																					(A2(_elm_lang$core$String$endsWith, ';', _p279) || _elm_lang$core$Native_Utils.eq(_p279, '')) ? '' : ';',
																																																					A2(
																																																						_elm_lang$core$String$join,
																																																						'',
																																																						A2(
																																																							_elm_lang$core$List$map,
																																																							function (_p261) {
																																																								var _p262 = _p261;
																																																								return A2(
																																																									_elm_lang$core$Basics_ops['++'],
																																																									_p262._0,
																																																									A2(
																																																										_elm_lang$core$Basics_ops['++'],
																																																										':',
																																																										A2(_elm_lang$core$Basics_ops['++'], _p262._1, ';')));
																																																							},
																																																							insertedStyles)));
																																																				var insertionPoint = _p280 + _elm_lang$core$String$length(_p279);
																																																				var _p263 = A2(
																																																					_elm_lang$core$Debug$log,
																																																					'inserted',
																																																					{ctor: '_Tuple4', _0: _p264, _1: _p280, _2: insertionPoint, _3: insertedString});
																																																				var _v186 = _p277,
																																																					_v187 = originalStyles,
																																																					_v188 = tailUpdatedStyles,
																																																					_v189 = _p278,
																																																					_v190 = {
																																																					ctor: '_Tuple3',
																																																					_0: A2(_elm_lang$core$Basics_ops['++'], _p279, insertedString),
																																																					_1: _p280,
																																																					_2: {
																																																						ctor: '::',
																																																						_0: A3(
																																																							_user$project$Lang$StringUpdate,
																																																							insertionPoint,
																																																							insertionPoint,
																																																							_elm_lang$core$String$length(insertedString)),
																																																						_1: {ctor: '[]'}
																																																					}
																																																				};
																																																				i = _v186;
																																																				originalStyles = _v187;
																																																				updatedStyles = _v188;
																																																				diffElems = _v189;
																																																				_p252 = _v190;
																																																				continue aux;
																																																			default:
																																																				var _p265 = {ctor: '_Tuple2', _0: originalStyles, _1: updatedStyles};
																																																				if (((((_p265.ctor === '_Tuple2') && (_p265._0.ctor === '::')) && (_p265._0._0.ctor === '_Tuple5')) && (_p265._1.ctor === '::')) && (_p265._1._0.ctor === '_Tuple2')) {
																																																					var _p276 = _p265._0._0._3;
																																																					var _p275 = _p265._0._0._0;
																																																					var _p274 = _p265._0._0._4;
																																																					var _p273 = _p265._0._0._1;
																																																					var _p272 = _p265._0._0._2;
																																																					var _p271 = _p265._1._0._1;
																																																					var _p270 = _p265._1._0._0;
																																																					var _p266 = A2(
																																																						_elm_lang$core$Maybe$andThen,
																																																						_user$project$UpdateUtils$toTupleDiffs,
																																																						_user$project$Lang$vListDiffsUnapply(_p256._0));
																																																					if (_p266.ctor === 'Nothing') {
																																																						return _elm_lang$core$Result$Err('[Cannot add an elemnt inside a style attribute definition]');
																																																					} else {
																																																						var _p269 = _p266._0;
																																																						var nameDiffs = function () {
																																																							var _p267 = A2(_user$project$UpdateUtils$diffsAt, 0, _p269);
																																																							if (_p267.ctor === 'Nothing') {
																																																								return {ctor: '[]'};
																																																							} else {
																																																								if (_p267._0.ctor === 'VStringDiffs') {
																																																									return A2(
																																																										_user$project$Lang$offsetStr,
																																																										_p280 + _elm_lang$core$String$length(_p275),
																																																										_p267._0._0);
																																																								} else {
																																																									var basepoint = _p280 + _elm_lang$core$String$length(_p275);
																																																									return {
																																																										ctor: '::',
																																																										_0: A3(
																																																											_user$project$Lang$StringUpdate,
																																																											basepoint,
																																																											basepoint + _elm_lang$core$String$length(_p273),
																																																											_elm_lang$core$String$length(_p270)),
																																																										_1: {ctor: '[]'}
																																																									};
																																																								}
																																																							}
																																																						}();
																																																						var valueDiffs = function () {
																																																							var _p268 = A2(_user$project$UpdateUtils$diffsAt, 1, _p269);
																																																							if (_p268.ctor === 'Nothing') {
																																																								return {ctor: '[]'};
																																																							} else {
																																																								if (_p268._0.ctor === 'VStringDiffs') {
																																																									return A2(
																																																										_user$project$Lang$offsetStr,
																																																										((_p280 + _elm_lang$core$String$length(_p275)) + _elm_lang$core$String$length(_p273)) + _elm_lang$core$String$length(_p272),
																																																										_p268._0._0);
																																																								} else {
																																																									var basepoint = ((_p280 + _elm_lang$core$String$length(_p275)) + _elm_lang$core$String$length(_p273)) + _elm_lang$core$String$length(_p272);
																																																									return {
																																																										ctor: '::',
																																																										_0: A3(
																																																											_user$project$Lang$StringUpdate,
																																																											basepoint,
																																																											basepoint + _elm_lang$core$String$length(_p276),
																																																											_elm_lang$core$String$length(_p271)),
																																																										_1: {ctor: '[]'}
																																																									};
																																																								}
																																																							}
																																																						}();
																																																						var newString = A2(
																																																							_elm_lang$core$Basics_ops['++'],
																																																							_p275,
																																																							A2(
																																																								_elm_lang$core$Basics_ops['++'],
																																																								_p270,
																																																								A2(
																																																									_elm_lang$core$Basics_ops['++'],
																																																									_p272,
																																																									A2(_elm_lang$core$Basics_ops['++'], _p271, _p274))));
																																																						var newOriginalOffset = ((((_p280 + _elm_lang$core$String$length(_p275)) + _elm_lang$core$String$length(_p273)) + _elm_lang$core$String$length(_p272)) + _elm_lang$core$String$length(_p276)) + _elm_lang$core$String$length(_p274);
																																																						var _v195 = i + 1,
																																																							_v196 = _p265._0._1,
																																																							_v197 = _p265._1._1,
																																																							_v198 = _p278,
																																																							_v199 = {
																																																							ctor: '_Tuple3',
																																																							_0: A2(_elm_lang$core$Basics_ops['++'], _p279, newString),
																																																							_1: newOriginalOffset,
																																																							_2: A2(
																																																								_user$project$Utils$reverseInsert,
																																																								valueDiffs,
																																																								A2(_user$project$Utils$reverseInsert, nameDiffs, _p281))
																																																						};
																																																						i = _v195;
																																																						originalStyles = _v196;
																																																						updatedStyles = _v197;
																																																						diffElems = _v198;
																																																						_p252 = _v199;
																																																						continue aux;
																																																					}
																																																				} else {
																																																					return _elm_lang$core$Result$Err(
																																																						A2(
																																																							_elm_lang$core$Basics_ops['++'],
																																																							'[Internal error]: the diff is not consistent ',
																																																							A2(
																																																								_elm_lang$core$Basics_ops['++'],
																																																								_user$project$LangUtils$valToString(oldVal),
																																																								A2(
																																																									_elm_lang$core$Basics_ops['++'],
																																																									' ',
																																																									A2(
																																																										_elm_lang$core$Basics_ops['++'],
																																																										_user$project$LangUtils$valToString(newVal),
																																																										A2(
																																																											_elm_lang$core$Basics_ops['++'],
																																																											' ',
																																																											_elm_lang$core$Basics$toString(diffs)))))));
																																																				}
																																																		}
																																																	}
																																																}
																																															}
																																														});
																																													return A5(
																																														aux,
																																														0,
																																														originalStyles,
																																														_p249._1._0,
																																														_p249._0._0,
																																														{
																																															ctor: '_Tuple3',
																																															_0: '',
																																															_1: 0,
																																															_2: {ctor: '[]'}
																																														});
																																												} else {
																																													break _v169_2;
																																												}
																																											} else {
																																												return _elm_lang$core$Result$Err(
																																													A2(_elm_lang$core$Basics_ops['++'], 'Expected VListDiffs got an error: ', _p249._1._0));
																																											}
																																										} else {
																																											break _v169_2;
																																										}
																																									} while(false);
																																									return _elm_lang$core$Result$Err(
																																										A2(
																																											_elm_lang$core$Basics_ops['++'],
																																											'Expected VListDiffs and a List, got ',
																																											A2(
																																												_elm_lang$core$Basics_ops['++'],
																																												_elm_lang$core$Basics$toString(diffs),
																																												A2(
																																													_elm_lang$core$Basics_ops['++'],
																																													' and ',
																																													_user$project$LangUtils$valToString(newVal)))));
																																								} else {
																																									break _v168_2;
																																								}
																																							default:
																																								break _v168_2;
																																						}
																																					} while(false);
																																					return _elm_lang$core$Result$Err(
																																						A2(
																																							_elm_lang$core$Basics_ops['++'],
																																							'__mbstylesplit__ takes a string or a List, got ',
																																							_user$project$LangUtils$valToString(newVal)));
																																				})))))
																														},
																														_1: {
																															ctor: '::',
																															_0: {
																																ctor: '_Tuple2',
																																_0: 'valToHTMLSource',
																																_1: A2(
																																	_user$project$Lang$builtinVal,
																																	'EvalUpdate.valToHTMLSource',
																																	A4(
																																		_user$project$Lang$VFun,
																																		'valToHTMLSource',
																																		{
																																			ctor: '::',
																																			_0: 'htmlNode',
																																			_1: {ctor: '[]'}
																																		},
																																		A2(
																																			_user$project$EvalUpdate$oneArg,
																																			'valToHTMLSource',
																																			function (original) {
																																				return A2(
																																					_elm_lang$core$Result$map,
																																					A2(
																																						_elm_lang$core$Basics$flip,
																																						F2(
																																							function (v0, v1) {
																																								return {ctor: '_Tuple2', _0: v0, _1: v1};
																																							}),
																																						{ctor: '[]'}),
																																					A2(
																																						_elm_lang$core$Result$map,
																																						function (str) {
																																							return A2(
																																								_user$project$Lang$replaceV_,
																																								original,
																																								_user$project$Lang$VBase(
																																									_user$project$Lang$VString(str)));
																																						},
																																						A2(_user$project$LangSvg$valToHTMLSource, _user$project$HTMLParser$HTML, original)));
																																			}),
																																		_elm_lang$core$Maybe$Just(
																																			A2(
																																				_user$project$EvalUpdate$oneArgUpdate,
																																				'valToHTMLSource',
																																				F4(
																																					function (original, oldOutput, newOutput, diffs) {
																																						var _p282 = A2(
																																							_elm_lang$core$Result$andThen,
																																							_user$project$LangSvg$htmlSourceToVal(_user$project$HTMLParser$HTML),
																																							_user$project$ValUnbuilder$string(newOutput));
																																						if (_p282.ctor === 'Err') {
																																							return _elm_lang$core$Result$Err(_p282._0);
																																						} else {
																																							var _p285 = _p282._0;
																																							var _p283 = A2(_user$project$UpdateUtils$defaultVDiffs, original, _p285);
																																							if (_p283.ctor === 'Err') {
																																								return _elm_lang$core$Result$Err(
																																									A2(_elm_lang$core$Basics_ops['++'], 'Error while computing the diffs for valToHTMLSource: ', _p283._0));
																																							} else {
																																								return _elm_lang$core$Result$Ok(
																																									A2(
																																										_user$project$LazyList$map,
																																										function (mbd) {
																																											var _p284 = mbd;
																																											if (_p284.ctor === 'Nothing') {
																																												return {
																																													ctor: '_Tuple2',
																																													_0: {
																																														ctor: '::',
																																														_0: _p285,
																																														_1: {ctor: '[]'}
																																													},
																																													_1: {ctor: '[]'}
																																												};
																																											} else {
																																												return {
																																													ctor: '_Tuple2',
																																													_0: {
																																														ctor: '::',
																																														_0: _p285,
																																														_1: {ctor: '[]'}
																																													},
																																													_1: {
																																														ctor: '::',
																																														_0: {ctor: '_Tuple2', _0: 0, _1: _p284._0},
																																														_1: {ctor: '[]'}
																																													}
																																												};
																																											}
																																										},
																																										_p283._0));
																																							}
																																						}
																																					})))))
																															},
																															_1: {
																																ctor: '::',
																																_0: {
																																	ctor: '_Tuple2',
																																	_0: 'typeof',
																																	_1: A2(
																																		_user$project$Lang$builtinVal,
																																		'EvalUpdate.typeof',
																																		A4(
																																			_user$project$Lang$VFun,
																																			'typeof',
																																			{
																																				ctor: '::',
																																				_0: 'value',
																																				_1: {ctor: '[]'}
																																			},
																																			A2(
																																				_user$project$EvalUpdate$oneArg,
																																				'valToHTMLSource',
																																				function (original) {
																																					var typ = function () {
																																						var _p286 = original.v_;
																																						switch (_p286.ctor) {
																																							case 'VClosure':
																																								return 'function';
																																							case 'VFun':
																																								return 'function';
																																							case 'VRecord':
																																								return 'object';
																																							case 'VDict':
																																								return 'dict';
																																							case 'VList':
																																								return 'list';
																																							case 'VConst':
																																								return 'number';
																																							default:
																																								switch (_p286._0.ctor) {
																																									case 'VBool':
																																										return 'boolean';
																																									case 'VString':
																																										return 'string';
																																									default:
																																										return 'undefined';
																																								}
																																						}
																																					}();
																																					return _elm_lang$core$Result$Ok(
																																						{
																																							ctor: '_Tuple2',
																																							_0: A2(
																																								_user$project$Lang$builtinVal,
																																								'EvalUpdate.typeof.result',
																																								_user$project$Lang$VBase(
																																									_user$project$Lang$VString(typ))),
																																							_1: {ctor: '[]'}
																																						});
																																				}),
																																			_elm_lang$core$Maybe$Nothing))
																																},
																																_1: {ctor: '[]'}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
var _user$project$EvalUpdate$nativeToVal = F2(
	function (vb, v) {
		return A7(
			_user$project$ImpureGoodies$fromNative,
			v,
			function (s) {
				return A2(_user$project$ValBuilder$string, vb, s);
			},
			function (n) {
				return A2(_user$project$ValBuilder$num, vb, n);
			},
			function (b) {
				return A2(_user$project$ValBuilder$bool, vb, b);
			},
			function (l) {
				return A3(_user$project$ValBuilder$list, _user$project$EvalUpdate$nativeToVal, vb, l);
			},
			function (r) {
				return A3(
					_user$project$ValBuilder$record,
					_user$project$EvalUpdate$nativeToVal,
					vb,
					_elm_lang$core$Dict$fromList(r));
			},
			function (f) {
				return vb(
					A4(
						_user$project$Lang$VFun,
						'anonymous',
						{
							ctor: '::',
							_0: 'anonArg',
							_1: {ctor: '[]'}
						},
						A2(
							_user$project$EvalUpdate$oneArg,
							'anonymous',
							function (v) {
								var _p287 = _user$project$EvalUpdate$valToNative(v);
								if (_p287.ctor === 'Ok') {
									return _elm_lang$core$Result$Ok(
										A3(
											_elm_lang$core$Basics$flip,
											F2(
												function (v0, v1) {
													return {ctor: '_Tuple2', _0: v0, _1: v1};
												}),
											{ctor: '[]'},
											A2(
												_user$project$EvalUpdate$nativeToVal,
												vb,
												f(_p287._0))));
								} else {
									return _elm_lang$core$Result$Err(_p287._0);
								}
							}),
						_elm_lang$core$Maybe$Nothing));
			});
	});
var _user$project$EvalUpdate$valToNative = function (v) {
	var _p288 = v.v_;
	_v205_8:
	do {
		switch (_p288.ctor) {
			case 'VConst':
				if (_p288._1.ctor === '_Tuple2') {
					return _elm_lang$core$Result$Ok(
						_user$project$ImpureGoodies$hideType(_p288._1._0));
				} else {
					break _v205_8;
				}
			case 'VBase':
				switch (_p288._0.ctor) {
					case 'VString':
						return _elm_lang$core$Result$Ok(
							_user$project$ImpureGoodies$hideType(_p288._0._0));
					case 'VBool':
						return _elm_lang$core$Result$Ok(
							_user$project$ImpureGoodies$hideType(_p288._0._0));
					default:
						return _elm_lang$core$Result$Ok(
							_user$project$ImpureGoodies$hideType(0));
				}
			case 'VList':
				return A2(
					_elm_lang$core$Result$map,
					_user$project$EvalUpdate$toArray,
					_user$project$Utils$projOk(
						A2(_elm_lang$core$List$map, _user$project$EvalUpdate$valToNative, _p288._0)));
			case 'VRecord':
				var _p291 = _user$project$Utils$projOk(
					A2(
						_elm_lang$core$List$map,
						function (_p289) {
							var _p290 = _p289;
							return A2(
								_elm_lang$core$Result$map,
								F2(
									function (v0, v1) {
										return {ctor: '_Tuple2', _0: v0, _1: v1};
									})(_p290._0),
								_user$project$EvalUpdate$valToNative(_p290._1));
						},
						_elm_lang$core$Dict$toList(_p288._0)));
				if (_p291.ctor === 'Ok') {
					return _elm_lang$core$Result$Ok(
						_user$project$ImpureGoodies$keyPairsToNativeRecord(_p291._0));
				} else {
					return _elm_lang$core$Result$Err(_p291._0);
				}
			case 'VFun':
				return _elm_lang$core$Result$Ok(
					_user$project$ImpureGoodies$hideType(
						function (x) {
							var _p293 = A2(
								_elm_lang$core$Result$andThen,
								function (_p292) {
									return _user$project$EvalUpdate$valToNative(
										_elm_lang$core$Tuple$first(_p292));
								},
								_p288._2(
									{
										ctor: '::',
										_0: A2(
											_user$project$EvalUpdate$nativeToVal,
											_user$project$ValBuilder$fromVal(v),
											x),
										_1: {ctor: '[]'}
									}));
							if (_p293.ctor === 'Ok') {
								return _user$project$ImpureGoodies$hideType(_p293._0);
							} else {
								return _elm_lang$core$Native_Utils.crashCase(
									'EvalUpdate',
									{
										start: {line: 1033, column: 7},
										end: {line: 1035, column: 101}
									},
									_p293)(
									A2(
										_elm_lang$core$Basics_ops['++'],
										'Native version of ',
										A2(
											_elm_lang$core$Basics_ops['++'],
											_p288._0,
											A2(_elm_lang$core$Basics_ops['++'], ' function crashed with : ', _p293._0))));
							}
						}));
			case 'VClosure':
				return _elm_lang$core$Result$Ok(
					_user$project$ImpureGoodies$hideType(
						function (x) {
							var arg = A2(
								_user$project$EvalUpdate$nativeToVal,
								_user$project$ValBuilder$fromVal(v),
								x);
							var _p295 = A2(
								_elm_lang$core$Result$andThen,
								_user$project$EvalUpdate$valToNative,
								A2(
									_user$project$EvalUpdate$evaluateRawWithoutCache,
									{
										ctor: '::',
										_0: {ctor: '_Tuple2', _0: 'fun', _1: v},
										_1: {
											ctor: '::',
											_0: {ctor: '_Tuple2', _0: 'arg', _1: arg},
											_1: {ctor: '[]'}
										}
									},
									A2(
										_user$project$Lang$eApp,
										_user$project$Lang$eVar('fun'),
										{
											ctor: '::',
											_0: _user$project$Lang$eVar('arg'),
											_1: {ctor: '[]'}
										})));
							if (_p295.ctor === 'Err') {
								return _elm_lang$core$Native_Utils.crashCase(
									'EvalUpdate',
									{
										start: {line: 1039, column: 7},
										end: {line: 1041, column: 28}
									},
									_p295)(
									A2(_elm_lang$core$Basics_ops['++'], 'Native version of closure crashed with : ', _p295._0));
							} else {
								return _p295._0;
							}
						}));
			default:
				break _v205_8;
		}
	} while(false);
	return _elm_lang$core$Result$Err('Don\'t know how to convert dictionaries to native values');
};
var _user$project$EvalUpdate$evaluateRawWithoutCache = F2(
	function (env, exp) {
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			A2(_user$project$EvalUpdate$evaluateRaw, env, exp));
	});
var _user$project$EvalUpdate$evaluateRaw = F2(
	function (env, exp) {
		return A2(
			_elm_lang$core$Result$map,
			function (_p297) {
				var _p298 = _p297;
				return {ctor: '_Tuple2', _0: _p298._0._0, _1: _p298._1};
			},
			A4(
				_user$project$Eval$doEval,
				_user$project$Eval$withoutParentsProvenanceWidgets,
				_user$project$Syntax$Leo,
				A2(_elm_lang$core$Basics_ops['++'], env, _user$project$EvalUpdate$preludeEnv),
				exp));
	});
var _user$project$EvalUpdate$preludeEnv = A2(
	_user$project$Utils$fromOk,
	'Eval.preludeEnv',
	A2(
		_elm_lang$core$Result$map,
		_elm_lang$core$Tuple$second,
		A2(
			_user$project$Eval$eval,
			{ctor: '[]'},
			A5(
				_user$project$Eval$evalContext,
				_user$project$Eval$withParentsProvenanceWidgets,
				_user$project$Syntax$Leo,
				_user$project$EvalUpdate$builtinEnv,
				{ctor: '[]'},
				_user$project$LeoParser$prelude))));
var _user$project$EvalUpdate$run = F2(
	function (syntax, e) {
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			A4(_user$project$Eval$doEval, _user$project$Eval$withParentsProvenanceWidgets, syntax, _user$project$EvalUpdate$preludeEnv, e));
	});
var _user$project$EvalUpdate$parseAndRun = function (_p299) {
	return _user$project$LangUtils$valToString(
		_elm_lang$core$Tuple$first(
			_user$project$Utils$fromOk_(
				A2(
					_user$project$EvalUpdate$run,
					_user$project$Syntax$Little,
					A2(
						_user$project$Utils$fromOkay,
						'parseAndRun',
						_user$project$LeoParser$parse(_p299))))));
};
var _user$project$EvalUpdate$parseAndRun_ = function (_p300) {
	return A2(
		_user$project$ValUnparser$strVal_,
		true,
		_elm_lang$core$Tuple$first(
			_user$project$Utils$fromOk_(
				A2(
					_user$project$EvalUpdate$run,
					_user$project$Syntax$Little,
					A2(
						_user$project$Utils$fromOkay,
						'parseAndRun_',
						_user$project$LeoParser$parse(_p300))))));
};
var _user$project$EvalUpdate$runWithEnv = F2(
	function (syntax, e) {
		return A4(_user$project$Eval$doEval, _user$project$Eval$withParentsProvenanceWidgets, syntax, _user$project$EvalUpdate$preludeEnv, e);
	});
var _user$project$EvalUpdate$doUpdate = F4(
	function (oldExp, oldEnv, oldVal, newValResult) {
		return A2(
			_user$project$Results$andThen,
			function (newVal) {
				var thediffs = A2(
					_user$project$ImpureGoodies$logTimedRun,
					'UpdateUtils.defaultVDiffs (doUpdate) ',
					function (_p301) {
						return A2(_user$project$UpdateUtils$defaultVDiffs, oldVal, newVal);
					});
				var _p302 = thediffs;
				if (_p302.ctor === 'Err') {
					return _elm_lang$core$Result$Err(_p302._0);
				} else {
					if (_p302._0.ctor === 'Nil') {
						return _elm_lang$core$Result$Err('[Internal error] expected a diff or an error, got Nil');
					} else {
						if (_p302._0._0.ctor === 'Nothing') {
							var _p303 = _user$project$ImpureGoodies$log('No difference observed in the output.');
							return _user$project$Results$ok1(
								{
									ctor: '_Tuple2',
									_0: _user$project$UpdatedEnv$original(_user$project$EvalUpdate$preludeEnv),
									_1: A2(_user$project$Lang$UpdatedExp, oldExp, _elm_lang$core$Maybe$Nothing)
								});
						} else {
							return A2(
								_user$project$ImpureGoodies$logTimedRun,
								'Update.update (doUpdate) ',
								function (_p304) {
									return A2(
										_user$project$Results$andThen,
										function (diffs) {
											var previousLets = A2(_user$project$UpdateStack$keepLets, _user$project$EvalUpdate$preludeEnv, oldEnv);
											return _user$project$EvalUpdate$update(
												A7(_user$project$UpdateStack$updateContext, 'initial update', _user$project$EvalUpdate$preludeEnv, oldExp, previousLets, oldVal, newVal, diffs));
										},
										_elm_lang$core$Result$Ok(
											A2(_user$project$LazyList$filterMap, _elm_lang$core$Basics$identity, _p302._0)));
								});
						}
					}
				}
			},
			_user$project$Results$fromResult(newValResult));
	});
var _user$project$EvalUpdate$doUpdateWithoutLog = F4(
	function (oldExp, oldEnv, oldVal, newVal) {
		var thediffs = A2(_user$project$UpdateUtils$defaultVDiffs, oldVal, newVal);
		var _p305 = thediffs;
		if (_p305.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p305._0);
		} else {
			if (_p305._0.ctor === 'Nil') {
				return _elm_lang$core$Result$Err('[Internal error] expected a diff or an error, got Nil');
			} else {
				if (_p305._0._0.ctor === 'Nothing') {
					return _user$project$Results$ok1(
						{
							ctor: '_Tuple2',
							_0: _user$project$UpdatedEnv$original(_user$project$EvalUpdate$preludeEnv),
							_1: A2(_user$project$Lang$UpdatedExp, oldExp, _elm_lang$core$Maybe$Nothing)
						});
				} else {
					return A2(
						_user$project$Results$andThen,
						function (diffs) {
							var previousLets = A2(_user$project$UpdateStack$keepLets, _user$project$EvalUpdate$preludeEnv, oldEnv);
							return _user$project$EvalUpdate$update(
								A7(_user$project$UpdateStack$updateContext, 'initial update', _user$project$EvalUpdate$preludeEnv, oldExp, previousLets, oldVal, newVal, diffs));
						},
						_elm_lang$core$Result$Ok(
							A2(_user$project$LazyList$filterMap, _elm_lang$core$Basics$identity, _p305._0)));
				}
			}
		}
	});
var _user$project$EvalUpdate$preludeIdentifiersList = A2(_elm_lang$core$List$map, _elm_lang$core$Tuple$first, _user$project$EvalUpdate$preludeEnv);
var _user$project$EvalUpdate$preludeIdentifiers = _elm_lang$core$Set$fromList(_user$project$EvalUpdate$preludeIdentifiersList);
var _user$project$EvalUpdate$identifiersSetPlusPrelude = function (exp) {
	return A2(
		_elm_lang$core$Set$union,
		_user$project$Lang$identifiersSet(exp),
		_user$project$EvalUpdate$preludeIdentifiers);
};
var _user$project$EvalUpdate$assignUniqueNames = function (program) {
	var initialUsedNames = _user$project$EvalUpdate$identifiersSetPlusPrelude(program);
	var _p306 = A3(_user$project$LangTools$assignUniqueNames_, program, initialUsedNames, _elm_lang$core$Dict$empty);
	var newProgram = _p306._0;
	var usedNames = _p306._1;
	var newNameToOldName = _p306._2;
	return {ctor: '_Tuple2', _0: newProgram, _1: newNameToOldName};
};
var _user$project$EvalUpdate$visibleIdentifiersAtEIds = F2(
	function (program, eids) {
		var programIdents = A2(
			_user$project$LangTools$visibleIdentifiersAtPredicateNoPrelude,
			program,
			function (exp) {
				return A2(
					_elm_lang$core$Set$member,
					_user$project$Lang$expEId(exp),
					eids);
			});
		return A2(_elm_lang$core$Set$union, programIdents, _user$project$EvalUpdate$preludeIdentifiers);
	});
var _user$project$EvalUpdate$newVariableVisibleTo = F6(
	function (insertedLetEId, suggestedName, startingNumberForNonCollidingName, boundExp, observerEIds, program) {
		var eidToWrap = _user$project$Lang$expEId(
			A2(
				_user$project$LangTools$deepestCommonAncestorWithNewlineOrELet,
				program,
				function (exp) {
					return A2(
						_elm_lang$core$List$member,
						_user$project$Lang$expEId(exp),
						observerEIds);
				}));
		var newName = A3(
			_user$project$LangTools$nonCollidingName,
			suggestedName,
			startingNumberForNonCollidingName,
			A2(
				_user$project$EvalUpdate$visibleIdentifiersAtEIds,
				program,
				_elm_lang$core$Set$fromList(observerEIds)));
		var newProgram = A3(
			_user$project$Lang$mapExpNode,
			eidToWrap,
			function (expToWrap) {
				return A6(
					_user$project$LangTools$newLetFancyWhitespace,
					insertedLetEId,
					false,
					_user$project$Lang$pVar(newName),
					boundExp,
					expToWrap,
					program);
			},
			program);
		return {ctor: '_Tuple2', _0: newName, _1: newProgram};
	});
var _user$project$EvalUpdate$identifiersVisibleAtProgramEnd = function (program) {
	var lastEId = _user$project$Lang$expEId(
		_user$project$LangTools$lastExp(program));
	return A2(
		_user$project$EvalUpdate$visibleIdentifiersAtEIds,
		program,
		_elm_lang$core$Set$singleton(lastEId));
};
var _user$project$EvalUpdate$visibleIdentifiersAtEIdBindingNum = F2(
	function (program, insertionPosition) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_user$project$LangTools$visibleIdentifiersAtEIdBindingNumNoPrelude, program, insertionPosition),
			_user$project$EvalUpdate$preludeIdentifiersList);
	});
var _user$project$EvalUpdate$updateEnvExp = F4(
	function (env, oldExp, _p307, newVal) {
		var _p308 = _p307;
		var _p315 = _p308._0;
		var thediffs = A2(_user$project$UpdateUtils$defaultVDiffs, _p315, newVal);
		var _p309 = thediffs;
		if (_p309.ctor === 'Err') {
			return _elm_lang$core$Result$Err(_p309._0);
		} else {
			if (_p309._0.ctor === 'Nil') {
				return _elm_lang$core$Result$Err('[Internal error] expected a diff or an error, got Nil');
			} else {
				if (_p309._0._0.ctor === 'Nothing') {
					return _user$project$Results$ok1(
						{ctor: '_Tuple2', _0: env, _1: oldExp});
				} else {
					return A2(
						_user$project$Results$map,
						function (_p310) {
							var _p311 = _p310;
							return {
								ctor: '_Tuple2',
								_0: A2(
									_elm_lang$core$List$take,
									_elm_lang$core$List$length(env),
									_p311._0.val),
								_1: _p311._1.val
							};
						},
						A2(
							_user$project$Results$filter,
							function (_p312) {
								var _p313 = _p312;
								var _p314 = _user$project$Utils$maybeLast(_p313._0.changes);
								if (_p314.ctor === 'Nothing') {
									return true;
								} else {
									return _elm_lang$core$Native_Utils.cmp(
										_p314._0._0,
										_elm_lang$core$List$length(env)) < 0;
								}
							},
							A2(
								_user$project$Results$andThen,
								function (diffs) {
									var initEnv = A2(_elm_lang$core$Basics_ops['++'], env, _user$project$EvalUpdate$preludeEnv);
									var previousLets = A2(_user$project$UpdateStack$keepLets, initEnv, _p308._1);
									return _user$project$EvalUpdate$update(
										A7(_user$project$UpdateStack$updateContext, 'initial update', initEnv, oldExp, previousLets, _p315, newVal, diffs));
								},
								_elm_lang$core$Result$Ok(
									A2(_user$project$LazyList$filterMap, _elm_lang$core$Basics$identity, _p309._0)))));
				}
			}
		}
	});
var _user$project$EvalUpdate$updateExp = F3(
	function (oldExp, oldValEnvCache, newVal) {
		return A2(
			_user$project$Results$map,
			_elm_lang$core$Tuple$second,
			A4(
				_user$project$EvalUpdate$updateEnvExp,
				{ctor: '[]'},
				oldExp,
				oldValEnvCache,
				newVal));
	});
var _user$project$EvalUpdate$updateStringWithOld = F3(
	function (strSource, oldValEnvCache, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (exp) {
				return A2(
					_elm_lang$core$Result$map,
					_user$project$LazyList$map(
						function (_p316) {
							var _p317 = _p316;
							return _user$project$EvalUpdate$unparse(_p317._1);
						}),
					A4(
						_user$project$EvalUpdate$updateEnvExp,
						{ctor: '[]'},
						exp,
						oldValEnvCache,
						newVal));
			},
			_user$project$EvalUpdate$parse(strSource));
	});
var _user$project$EvalUpdate$evalExp = function (exp) {
	return A2(
		_user$project$EvalUpdate$evaluateRaw,
		{ctor: '[]'},
		exp);
};
var _user$project$EvalUpdate$evalExpWithoutCache = function (exp) {
	return A2(
		_elm_lang$core$Result$map,
		_elm_lang$core$Tuple$first,
		_user$project$EvalUpdate$evalExp(exp));
};
var _user$project$EvalUpdate$updateExpWithoutCache = F2(
	function (oldExp, newVal) {
		return A2(
			_user$project$Results$andThen,
			function (oldValEnvCache) {
				return A3(_user$project$EvalUpdate$updateExp, oldExp, oldValEnvCache, newVal);
			},
			_user$project$Results$fromResult(
				A2(
					_user$project$EvalUpdate$evaluateRaw,
					{ctor: '[]'},
					oldExp)));
	});
var _user$project$EvalUpdate$objectToEnv = function (objectAsEnvOfConsts) {
	var envAsVal = A2(
		_user$project$EvalUpdate$nativeToVal,
		_user$project$Lang$builtinVal('EvalUpdate.nativeToVal'),
		objectAsEnvOfConsts);
	var _p318 = envAsVal.v_;
	if (_p318.ctor === 'VRecord') {
		return _elm_lang$core$Result$Ok(
			_elm_lang$core$Dict$toList(_p318._0));
	} else {
		return _elm_lang$core$Result$Err(
			A2(
				_elm_lang$core$Basics_ops['++'],
				'Environment not interpretable: ',
				_user$project$LangUtils$valToString(envAsVal)));
	}
};
var _user$project$EvalUpdate$envToObject = function (env) {
	return _user$project$EvalUpdate$valToNative(
		A3(
			_user$project$ValBuilder$record,
			_user$project$ValBuilder$identity,
			_user$project$Lang$builtinVal('EvalUpdate.nativeToVal'),
			_elm_lang$core$Dict$fromList(env)));
};
var _user$project$EvalUpdate$resultWithNativeEnv = _user$project$LazyList$map(
	function (_p319) {
		var _p320 = _p319;
		return {
			ctor: '_Tuple2',
			_0: A2(
				_user$project$Utils$fromOk,
				'EvalUpdate.env to native javascript',
				_user$project$EvalUpdate$envToObject(_p320._0)),
			_1: _p320._1
		};
	});
var _user$project$EvalUpdate$updateEnvWithOld = F4(
	function (objectAsEnvOfConsts, exp, oldValEnvCache, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (env) {
				return A2(
					_elm_lang$core$Result$map,
					_user$project$EvalUpdate$resultWithNativeEnv,
					A4(_user$project$EvalUpdate$updateEnvExp, env, exp, oldValEnvCache, newVal));
			},
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$resultStringWithNativeEnv = _user$project$LazyList$map(
	function (_p321) {
		var _p322 = _p321;
		return {
			ctor: '_Tuple2',
			_0: A2(
				_user$project$Utils$fromOk,
				'EvalUpdate.env to native javascript',
				_user$project$EvalUpdate$envToObject(_p322._0)),
			_1: _user$project$EvalUpdate$unparse(_p322._1)
		};
	});
var _user$project$EvalUpdate$updateEnvStringWithOld = F4(
	function (objectAsEnvOfConsts, strSource, oldValEnvCache, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (env) {
				return A2(
					_elm_lang$core$Result$andThen,
					function (exp) {
						return A2(
							_elm_lang$core$Result$map,
							_user$project$EvalUpdate$resultStringWithNativeEnv,
							A4(_user$project$EvalUpdate$updateEnvExp, env, exp, oldValEnvCache, newVal));
					},
					_user$project$EvalUpdate$parse(strSource));
			},
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$evaluateEnv = F2(
	function (objectAsEnvOfConsts, exp) {
		return A2(
			_elm_lang$core$Result$andThen,
			A2(_elm_lang$core$Basics$flip, _user$project$EvalUpdate$evaluateRaw, exp),
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$evaluateString = function (stringSource) {
	return A2(
		_elm_lang$core$Result$andThen,
		_user$project$EvalUpdate$evaluateRaw(
			{ctor: '[]'}),
		_user$project$EvalUpdate$parse(stringSource));
};
var _user$project$EvalUpdate$evaluateEnvString = F2(
	function (objectAsEnvOfConsts, stringSource) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (env) {
				return A2(
					_elm_lang$core$Result$andThen,
					_user$project$EvalUpdate$evaluateRaw(env),
					_user$project$EvalUpdate$parse(stringSource));
			},
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$updateRaw = F3(
	function (env, exp, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (oldValEnvCache) {
				return A4(_user$project$EvalUpdate$updateEnvExp, env, exp, oldValEnvCache, newVal);
			},
			A2(_user$project$EvalUpdate$evaluateRaw, env, exp));
	});
var _user$project$EvalUpdate$updateEnv = F3(
	function (objectAsEnvOfConsts, exp, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (env) {
				return A2(
					_elm_lang$core$Result$map,
					_user$project$EvalUpdate$resultWithNativeEnv,
					A3(_user$project$EvalUpdate$updateRaw, env, exp, newVal));
			},
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$updateString = F2(
	function (strSource, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (exp) {
				return A2(
					_elm_lang$core$Result$map,
					_user$project$LazyList$map(
						function (_p323) {
							var _p324 = _p323;
							return _user$project$EvalUpdate$unparse(_p324._1);
						}),
					A3(
						_user$project$EvalUpdate$updateRaw,
						{ctor: '[]'},
						exp,
						newVal));
			},
			_user$project$EvalUpdate$parse(strSource));
	});
var _user$project$EvalUpdate$updateEnvString = F3(
	function (objectAsEnvOfConsts, strSource, newVal) {
		return A2(
			_elm_lang$core$Result$andThen,
			function (env) {
				return A2(
					_elm_lang$core$Result$andThen,
					function (exp) {
						return A2(
							_elm_lang$core$Result$map,
							_user$project$EvalUpdate$resultStringWithNativeEnv,
							A3(_user$project$EvalUpdate$updateRaw, env, exp, newVal));
					},
					_user$project$EvalUpdate$parse(strSource));
			},
			_user$project$EvalUpdate$objectToEnv(objectAsEnvOfConsts));
	});
var _user$project$EvalUpdate$stringObjEnv = {
	evaluate: _user$project$EvalUpdate$evaluateEnvString,
	update: _user$project$EvalUpdate$updateEnvStringWithOld,
	evaluateWithoutCache: F2(
		function (env, source) {
			return A2(
				_elm_lang$core$Result$map,
				_elm_lang$core$Tuple$first,
				A2(_user$project$EvalUpdate$evaluateEnvString, env, source));
		}),
	updateWithoutCache: _user$project$EvalUpdate$updateEnvString
};
var _user$project$EvalUpdate$string = {
	evaluate: _user$project$EvalUpdate$evaluateString,
	evaluateWithoutCache: function (_p325) {
		return A2(
			_elm_lang$core$Result$map,
			_elm_lang$core$Tuple$first,
			_user$project$EvalUpdate$evaluateString(_p325));
	},
	update: _user$project$EvalUpdate$updateStringWithOld,
	updateWithoutCache: _user$project$EvalUpdate$updateString,
	objEnv: _user$project$EvalUpdate$stringObjEnv
};
var _user$project$EvalUpdate$objEnv = {
	evaluate: _user$project$EvalUpdate$evaluateEnv,
	update: _user$project$EvalUpdate$updateEnvWithOld,
	evaluateWithoutCache: F2(
		function (envA, exp) {
			return A2(
				_elm_lang$core$Result$map,
				_elm_lang$core$Tuple$first,
				A2(_user$project$EvalUpdate$evaluateEnv, envA, exp));
		}),
	updateWithoutCache: _user$project$EvalUpdate$updateEnv,
	string: _user$project$EvalUpdate$stringObjEnv
};
var _user$project$EvalUpdate$api = {
	parse: _user$project$EvalUpdate$parse,
	evaluate: _user$project$EvalUpdate$evalExp,
	update: _user$project$EvalUpdate$updateExp,
	lazyList: _user$project$EvalUpdate$lazyList,
	evaluateWithoutCache: _user$project$EvalUpdate$evalExpWithoutCache,
	updateWithoutCache: _user$project$EvalUpdate$updateExpWithoutCache,
	unparse: _user$project$EvalUpdate$unparse,
	process: _elm_lang$core$Basics$flip(_elm_lang$core$Result$andThen),
	valToNative: _user$project$EvalUpdate$valToNative,
	nativeToVal: _user$project$EvalUpdate$nativeToVal(
		_user$project$Lang$builtinVal('EvalUpdate.nativeToVal')),
	valToString: _user$project$LangUtils$valToString,
	valToHTMLSource: _user$project$LangSvg$valToHTMLSource(_user$project$HTMLParser$HTML),
	string: _user$project$EvalUpdate$string,
	objEnv: _user$project$EvalUpdate$objEnv,
	lang: _user$project$EvalUpdate$lang,
	fromOk: function (res) {
		var _p326 = res;
		if (_p326.ctor === 'Ok') {
			return _p326._0;
		} else {
			return _elm_lang$core$Native_Utils.crashCase(
				'EvalUpdate',
				{
					start: {line: 1558, column: 20},
					end: {line: 1560, column: 31}
				},
				_p326)(_p326._0);
		}
	},
	foldResult: F3(
		function (errHandler, okHandler, res) {
			var _p328 = res;
			if (_p328.ctor === 'Ok') {
				return okHandler(_p328._0);
			} else {
				return errHandler(_p328._0);
			}
		}),
	first: _elm_lang$core$Tuple$first,
	second: _elm_lang$core$Tuple$second
};
var _user$project$EvalUpdate$StringObjEnvType = F4(
	function (a, b, c, d) {
		return {evaluate: a, update: b, evaluateWithoutCache: c, updateWithoutCache: d};
	});
var _user$project$EvalUpdate$StringType = F5(
	function (a, b, c, d, e) {
		return {evaluate: a, update: b, evaluateWithoutCache: c, updateWithoutCache: d, objEnv: e};
	});
var _user$project$EvalUpdate$ObjEnvType = F5(
	function (a, b, c, d, e) {
		return {evaluate: a, update: b, evaluateWithoutCache: c, updateWithoutCache: d, string: e};
	});
var _user$project$EvalUpdate$LazyListType = F4(
	function (a, b, c, d) {
		return {nonEmpty: a, isEmpty: b, head: c, tail: d};
	});
var _user$project$EvalUpdate$LangApi = function (a) {
	return function (b) {
		return function (c) {
			return function (d) {
				return function (e) {
					return function (f) {
						return function (g) {
							return function (h) {
								return function (i) {
									return function (j) {
										return function (k) {
											return function (l) {
												return function (m) {
													return function (n) {
														return function (o) {
															return function (p) {
																return function (q) {
																	return function (r) {
																		return function (s) {
																			return function (t) {
																				return function (u) {
																					return function (v) {
																						return function (w) {
																							return function (x) {
																								return function (y) {
																									return function (z) {
																										return function (_1) {
																											return function (_2) {
																												return function (_3) {
																													return function (_4) {
																														return function (_5) {
																															return function (_6) {
																																return {eBase: a, eVar: b, eFun: c, eApp: d, eOp: e, eList: f, eCons: g, eIf: h, eCase: i, eLet: j, eParens: k, eRecord: l, eRecordExtend: m, eSelect: n, letTypeAlias: o, letTypeData: p, letAnnotation: q, letExp: r, declType: s, declExp: t, declAnnotation: u, declarations: v, branch: w, pVar: x, pBase: y, pWildcard: z, pList: _1, pCons: _2, pRecord: _3, pParens: _4, pAs: _5, unapply: _6};
																															};
																														};
																													};
																												};
																											};
																										};
																									};
																								};
																							};
																						};
																					};
																				};
																			};
																		};
																	};
																};
															};
														};
													};
												};
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};

var Elm = {};
Elm["EvalUpdate"] = Elm["EvalUpdate"] || {};
Elm["EvalUpdate"].api = _user$project$EvalUpdate$api;
if(typeof exports !== "undefined") { // npm package
  var keysToExport = Object.keys(_user$project$EvalUpdate$api);
  for(var i = 0; i < keysToExport.length; i++) {
    exports[keysToExport[i]] = _user$project$EvalUpdate$api[keysToExport[i]];
  }
  return;
}

Elm['EvalUpdate'] = Elm['EvalUpdate'] || {};
if (typeof _user$project$EvalUpdate$main !== 'undefined') {
    _user$project$EvalUpdate$main(Elm['EvalUpdate'], 'EvalUpdate', undefined);
}

if (typeof define === "function" && define['amd'])
{
  define([], function() { return Elm; });
  return;
}

if (typeof module === "object")
{
  module['exports'] = Elm;
  return;
}

var globalElm = this['Elm'];
if (typeof globalElm === "undefined")
{
  this['Elm'] = Elm;
  return;
}

for (var publicModule in Elm)
{
  if (publicModule in globalElm)
  {
    throw new Error('There are two Elm modules called `' + publicModule + '` on this page! Rename one of them.');
  }
  globalElm[publicModule] = Elm[publicModule];
}

}).call(this);

